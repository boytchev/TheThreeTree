export const DATA_ADDONS = ` 
^..^ FILENAME ^..^
addons|Addons.js
^..^ CONTENTS ^..^
export * from './animation/AnimationClipCreator.js'; export * from './animation/CCDIKSolver.js'; export * from './animation/MMDAnimationHelper.js'; export * from './animation/MMDPhysics.js';  export * from './cameras/CinematicCamera.js';  export { default as WebGL } from './capabilities/WebGL.js';  export * from './controls/ArcballControls.js'; export * from './controls/DragControls.js'; export * from './controls/FirstPersonControls.js'; export * from './controls/FlyControls.js'; export * from './controls/MapControls.js'; export * from './controls/OrbitControls.js'; export * from './controls/PointerLockControls.js'; export * from './controls/TrackballControls.js'; export * from './controls/TransformControls.js';  export * from './csm/CSM.js'; export * from './csm/CSMFrustum.js'; export * from './csm/CSMHelper.js'; export * from './csm/CSMShader.js';  export * as Curves from './curves/CurveExtras.js'; export * from './curves/NURBSCurve.js'; export * from './curves/NURBSSurface.js'; export * from './curves/NURBSVolume.js'; export * as NURBSUtils from './curves/NURBSUtils.js';  export * from './effects/AnaglyphEffect.js'; export * from './effects/AsciiEffect.js'; export * from './effects/OutlineEffect.js'; export * from './effects/ParallaxBarrierEffect.js'; export * from './effects/PeppersGhostEffect.js'; export * from './effects/StereoEffect.js';  export * from './environments/DebugEnvironment.js'; export * from './environments/RoomEnvironment.js';  export * from './exporters/DRACOExporter.js'; export * from './exporters/EXRExporter.js'; export * from './exporters/GLTFExporter.js'; export * from './exporters/KTX2Exporter.js'; export * from './exporters/MMDExporter.js'; export * from './exporters/OBJExporter.js'; export * from './exporters/PLYExporter.js'; export * from './exporters/STLExporter.js'; export * from './exporters/USDZExporter.js';  export * from './geometries/BoxLineGeometry.js'; export * from './geometries/ConvexGeometry.js'; export * from './geometries/DecalGeometry.js'; export * from './geometries/ParametricGeometries.js'; export * from './geometries/ParametricGeometry.js'; export * from './geometries/RoundedBoxGeometry.js'; export * from './geometries/TeapotGeometry.js'; export * from './geometries/TextGeometry.js';  export * from './helpers/LightProbeHelper.js'; export * from './helpers/OctreeHelper.js'; export * from './helpers/PositionalAudioHelper.js'; export * from './helpers/RectAreaLightHelper.js'; export * from './helpers/TextureHelper.js'; export * from './helpers/VertexNormalsHelper.js'; export * from './helpers/VertexTangentsHelper.js'; export * from './helpers/ViewHelper.js';  export * from './interactive/HTMLMesh.js'; export * from './interactive/InteractiveGroup.js'; export * from './interactive/SelectionBox.js'; export * from './interactive/SelectionHelper.js';  export * from './lights/LightProbeGenerator.js'; export * from './lights/RectAreaLightTexturesLib.js'; export * from './lights/RectAreaLightUniformsLib.js';  export * from './lines/Line2.js'; export * from './lines/LineGeometry.js'; export * from './lines/LineMaterial.js'; export * from './lines/LineSegments2.js'; export * from './lines/LineSegmentsGeometry.js'; export * from './lines/Wireframe.js'; export * from './lines/WireframeGeometry2.js';  export * from './loaders/3DMLoader.js'; export * from './loaders/3MFLoader.js'; export * from './loaders/AMFLoader.js'; export * from './loaders/BVHLoader.js'; export * from './loaders/ColladaLoader.js'; export * from './loaders/DDSLoader.js'; export * from './loaders/DRACOLoader.js'; export * from './loaders/EXRLoader.js'; export * from './loaders/FBXLoader.js'; export * from './loaders/FontLoader.js'; export * from './loaders/GCodeLoader.js'; export * from './loaders/GLTFLoader.js'; export * from './loaders/HDRCubeTextureLoader.js'; export * from './loaders/IESLoader.js'; export * from './loaders/KMZLoader.js'; export * from './loaders/KTX2Loader.js'; export * from './loaders/KTXLoader.js'; export * from './loaders/LDrawLoader.js'; export * from './loaders/LUT3dlLoader.js'; export * from './loaders/LUTCubeLoader.js'; export * from './loaders/LWOLoader.js'; export * from './loaders/LottieLoader.js'; export * from './loaders/MD2Loader.js'; export * from './loaders/MDDLoader.js'; export * from './loaders/MMDLoader.js'; export * from './loaders/MTLLoader.js'; export * from './loaders/NRRDLoader.js'; export * from './loaders/OBJLoader.js'; export * from './loaders/PCDLoader.js'; export * from './loaders/PDBLoader.js'; export * from './loaders/PLYLoader.js'; export * from './loaders/PVRLoader.js'; export * from './loaders/RGBELoader.js'; export * from './loaders/UltraHDRLoader.js'; export * from './loaders/RGBMLoader.js'; export * from './loaders/STLLoader.js'; export * from './loaders/SVGLoader.js'; export * from './loaders/TDSLoader.js'; export * from './loaders/TGALoader.js'; export * from './loaders/TIFFLoader.js'; export * from './loaders/TTFLoader.js'; export * from './loaders/USDZLoader.js'; export * from './loaders/VOXLoader.js'; export * from './loaders/VRMLLoader.js'; export * from './loaders/VTKLoader.js'; export * from './loaders/XYZLoader.js';  export * from './materials/MeshGouraudMaterial.js';  export * from './math/Capsule.js'; export * from './math/ColorConverter.js'; export * from './math/ConvexHull.js'; export * from './math/ImprovedNoise.js'; export * from './math/Lut.js'; export * from './math/MeshSurfaceSampler.js'; export * from './math/OBB.js'; export * from './math/Octree.js'; export * from './math/SimplexNoise.js';  export * from './misc/ConvexObjectBreaker.js'; export * from './misc/GPUComputationRenderer.js'; export * from './misc/Gyroscope.js'; export * from './misc/MD2Character.js'; export * from './misc/MD2CharacterComplex.js'; export * from './misc/MorphAnimMesh.js'; export * from './misc/MorphBlendMesh.js'; export * from './misc/ProgressiveLightMap.js'; export * from './misc/RollerCoaster.js'; export * from './misc/Timer.js'; export * from './misc/TubePainter.js'; export * from './misc/Volume.js'; export * from './misc/VolumeSlice.js';  export * from './modifiers/CurveModifier.js'; export * from './modifiers/EdgeSplitModifier.js'; export * from './modifiers/SimplifyModifier.js'; export * from './modifiers/TessellateModifier.js';  export * from './objects/GroundedSkybox.js'; export * from './objects/Lensflare.js'; export * from './objects/MarchingCubes.js'; export * from './objects/Reflector.js'; export * from './objects/ReflectorForSSRPass.js'; export * from './objects/Refractor.js'; export * from './objects/ShadowMesh.js'; export * from './objects/Sky.js'; export * from './objects/Water.js'; export { Water as Water2 } from './objects/Water2.js';  export * from './physics/AmmoPhysics.js'; export * from './physics/RapierPhysics.js';  export * from './postprocessing/AfterimagePass.js'; export * from './postprocessing/BloomPass.js'; export * from './postprocessing/BokehPass.js'; export * from './postprocessing/ClearPass.js'; export * from './postprocessing/CubeTexturePass.js'; export * from './postprocessing/DotScreenPass.js'; export * from './postprocessing/EffectComposer.js'; export * from './postprocessing/FilmPass.js'; export * from './postprocessing/GlitchPass.js'; export * from './postprocessing/GTAOPass.js'; export * from './postprocessing/HalftonePass.js'; export * from './postprocessing/LUTPass.js'; export * from './postprocessing/MaskPass.js'; export * from './postprocessing/OutlinePass.js'; export * from './postprocessing/OutputPass.js'; export * from './postprocessing/Pass.js'; export * from './postprocessing/RenderPass.js'; export * from './postprocessing/RenderPixelatedPass.js'; export * from './postprocessing/SAOPass.js'; export * from './postprocessing/SMAAPass.js'; export * from './postprocessing/SSAARenderPass.js'; export * from './postprocessing/SSAOPass.js'; export * from './postprocessing/SSRPass.js'; export * from './postprocessing/SavePass.js'; export * from './postprocessing/ShaderPass.js'; export * from './postprocessing/TAARenderPass.js'; export * from './postprocessing/TexturePass.js'; export * from './postprocessing/UnrealBloomPass.js';  export * from './renderers/CSS2DRenderer.js'; export * from './renderers/CSS3DRenderer.js'; export * from './renderers/Projector.js'; export * from './renderers/SVGRenderer.js';  export * from './shaders/ACESFilmicToneMappingShader.js'; export * from './shaders/AfterimageShader.js'; export * from './shaders/BasicShader.js'; export * from './shaders/BleachBypassShader.js'; export * from './shaders/BlendShader.js'; export * from './shaders/BokehShader.js'; export { BokehShader as BokehShader2 } from './shaders/BokehShader2.js'; export * from './shaders/BrightnessContrastShader.js'; export * from './shaders/ColorCorrectionShader.js'; export * from './shaders/ColorifyShader.js'; export * from './shaders/ConvolutionShader.js'; export * from './shaders/CopyShader.js'; export * from './shaders/DOFMipMapShader.js'; export * from './shaders/DepthLimitedBlurShader.js'; export * from './shaders/DigitalGlitch.js'; export * from './shaders/DotScreenShader.js'; export * from './shaders/ExposureShader.js'; export * from './shaders/FXAAShader.js'; export * from './shaders/FilmShader.js'; export * from './shaders/FocusShader.js'; export * from './shaders/FreiChenShader.js'; export * from './shaders/GammaCorrectionShader.js'; export * from './shaders/GodRaysShader.js'; export * from './shaders/GTAOShader.js'; export * from './shaders/HalftoneShader.js'; export * from './shaders/HorizontalBlurShader.js'; export * from './shaders/HorizontalTiltShiftShader.js'; export * from './shaders/HueSaturationShader.js'; export * from './shaders/KaleidoShader.js'; export * from './shaders/LuminosityHighPassShader.js'; export * from './shaders/LuminosityShader.js'; export * from './shaders/MMDToonShader.js'; export * from './shaders/MirrorShader.js'; export * from './shaders/NormalMapShader.js'; export * from './shaders/OutputShader.js'; export * from './shaders/RGBShiftShader.js'; export * from './shaders/SAOShader.js'; export * from './shaders/SMAAShader.js'; export * from './shaders/SSAOShader.js'; export * from './shaders/SSRShader.js'; export * from './shaders/SepiaShader.js'; export * from './shaders/SobelOperatorShader.js'; export * from './shaders/SubsurfaceScatteringShader.js'; export * from './shaders/TechnicolorShader.js'; export * from './shaders/ToonShader.js'; export * from './shaders/TriangleBlurShader.js'; export * from './shaders/UnpackDepthRGBAShader.js'; export * from './shaders/VelocityShader.js'; export * from './shaders/VerticalBlurShader.js'; export * from './shaders/VerticalTiltShiftShader.js'; export * from './shaders/VignetteShader.js'; export * from './shaders/VolumeShader.js'; export * from './shaders/WaterRefractionShader.js';  export * from './textures/FlakesTexture.js';  export * as BufferGeometryUtils from './utils/BufferGeometryUtils.js'; export * as CameraUtils from './utils/CameraUtils.js'; export * as GeometryCompressionUtils from './utils/GeometryCompressionUtils.js'; export * as GeometryUtils from './utils/GeometryUtils.js'; export * from './utils/LDrawUtils.js'; export * as SceneUtils from './utils/SceneUtils.js'; export * from './utils/ShadowMapViewer.js'; export * as SkeletonUtils from './utils/SkeletonUtils.js'; export * as SortUtils from './utils/SortUtils.js'; export * from './utils/TextureUtils.js'; export * from './utils/UVsDebug.js'; export * from './utils/WorkerPool.js';  export * from './webxr/ARButton.js'; export * from './webxr/OculusHandModel.js'; export * from './webxr/OculusHandPointerModel.js'; export * from './webxr/Text2D.js'; export * from './webxr/VRButton.js'; export * from './webxr/XRButton.js'; export * from './webxr/XRControllerModelFactory.js'; export * from './webxr/XREstimatedLight.js'; export * from './webxr/XRHandMeshModel.js'; export * from './webxr/XRHandModelFactory.js'; export * from './webxr/XRHandPrimitiveModel.js'; export * from './webxr/XRPlanes.js'; 
^..^ FILENAME ^..^
addons|animation|AnimationClipCreator.js
^..^ CONTENTS ^..^
import {  AnimationClip,  BooleanKeyframeTrack,  ColorKeyframeTrack,  NumberKeyframeTrack,  Vector3,  VectorKeyframeTrack } from 'three';  class AnimationClipCreator {   static CreateRotationAnimation( period, axis = 'x' ) {    const times = [ 0, period ], values = [ 0, 360 ];    const trackName = '.rotation[' + axis + ']';    const track = new NumberKeyframeTrack( trackName, times, values );    return new AnimationClip( null, period, [ track ] );   }   static CreateScaleAxisAnimation( period, axis = 'x' ) {    const times = [ 0, period ], values = [ 0, 1 ];    const trackName = '.scale[' + axis + ']';    const track = new NumberKeyframeTrack( trackName, times, values );    return new AnimationClip( null, period, [ track ] );   }   static CreateShakeAnimation( duration, shakeScale ) {    const times = [], values = [], tmp = new Vector3();    for ( let i = 0; i < duration * 10; i ++ ) {     times.push( i / 10 );     tmp.set( Math.random() * 2.0 - 1.0, Math.random() * 2.0 - 1.0, Math.random() * 2.0 - 1.0 ).     multiply( shakeScale ).     toArray( values, values.length );    }    const trackName = '.position';    const track = new VectorKeyframeTrack( trackName, times, values );    return new AnimationClip( null, duration, [ track ] );   }   static CreatePulsationAnimation( duration, pulseScale ) {    const times = [], values = [], tmp = new Vector3();    for ( let i = 0; i < duration * 10; i ++ ) {     times.push( i / 10 );     const scaleFactor = Math.random() * pulseScale;    tmp.set( scaleFactor, scaleFactor, scaleFactor ).     toArray( values, values.length );    }    const trackName = '.scale';    const track = new VectorKeyframeTrack( trackName, times, values );    return new AnimationClip( null, duration, [ track ] );   }   static CreateVisibilityAnimation( duration ) {    const times = [ 0, duration / 2, duration ], values = [ true, false, true ];    const trackName = '.visible';    const track = new BooleanKeyframeTrack( trackName, times, values );    return new AnimationClip( null, duration, [ track ] );   }   static CreateMaterialColorAnimation( duration, colors ) {    const times = [], values = [],    timeStep = ( colors.length > 1 ) ? duration / ( colors.length - 1 ) : 0;    for ( let i = 0; i < colors.length; i ++ ) {     times.push( i * timeStep );     const color = colors[ i ];    values.push( color.r, color.g, color.b );    }    const trackName = '.material.color';    const track = new ColorKeyframeTrack( trackName, times, values );    return new AnimationClip( null, duration, [ track ] );   }  }  export { AnimationClipCreator }; 
^..^ FILENAME ^..^
addons|animation|CCDIKSolver.js
^..^ CONTENTS ^..^
import {  BufferAttribute,  BufferGeometry,  Color,  Line,  LineBasicMaterial,  Matrix4,  Mesh,  MeshBasicMaterial,  Object3D,  Quaternion,  SphereGeometry,  Vector3 } from 'three';  const _q = new Quaternion(); const _targetPos = new Vector3(); const _targetVec = new Vector3(); const _effectorPos = new Vector3(); const _effectorVec = new Vector3(); const _linkPos = new Vector3(); const _invLinkQ = new Quaternion(); const _linkScale = new Vector3(); const _axis = new Vector3(); const _vector = new Vector3(); const _matrix = new Matrix4();   /**  * CCD Algorithm  *  - https://sites.google.com/site/auraliusproject/ccd-algorithm  *  * // ik parameter example  * //  * // target, effector, index in links are bone index in skeleton.bones.  * // the bones relation should be  * // <-- parent                                  child -->  * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector  * iks = [ {  * target: 1,  * effector: 2,  * links: [ { index: 5, limitation: new Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],  * iteration: 10,  * minAngle: 0.0,  * maxAngle: 1.0,  * } ];  */  class CCDIKSolver {   /**   * @param {THREE.SkinnedMesh} mesh   * @param {Array<Object>} iks   */  constructor( mesh, iks = [] ) {    this.mesh = mesh;   this.iks = iks;    this._valid();   }   /**   * Update all IK bones.   *   * @return {CCDIKSolver}   */  update() {    const iks = this.iks;    for ( let i = 0, il = iks.length; i < il; i ++ ) {     this.updateOne( iks[ i ] );    }    return this;   }   /**   * Update one IK bone   *   * @param {Object} ik parameter   * @return {CCDIKSolver}   */  updateOne( ik ) {    const bones = this.mesh.skeleton.bones;    // for reference overhead reduction in loop   const math = Math;    const effector = bones[ ik.effector ];   const target = bones[ ik.target ];    // don't use getWorldPosition() here for the performance   // because it calls updateMatrixWorld( true ) inside.   _targetPos.setFromMatrixPosition( target.matrixWorld );    const links = ik.links;   const iteration = ik.iteration !== undefined ? ik.iteration : 1;    for ( let i = 0; i < iteration; i ++ ) {     let rotated = false;     for ( let j = 0, jl = links.length; j < jl; j ++ ) {      const link = bones[ links[ j ].index ];      // skip this link and following links.     // this skip is used for MMD performance optimization.     if ( links[ j ].enabled === false ) break;      const limitation = links[ j ].limitation;     const rotationMin = links[ j ].rotationMin;     const rotationMax = links[ j ].rotationMax;      // don't use getWorldPosition/Quaternion() here for the performance     // because they call updateMatrixWorld( true ) inside.     link.matrixWorld.decompose( _linkPos, _invLinkQ, _linkScale );     _invLinkQ.invert();     _effectorPos.setFromMatrixPosition( effector.matrixWorld );      // work in link world     _effectorVec.subVectors( _effectorPos, _linkPos );     _effectorVec.applyQuaternion( _invLinkQ );     _effectorVec.normalize();      _targetVec.subVectors( _targetPos, _linkPos );     _targetVec.applyQuaternion( _invLinkQ );     _targetVec.normalize();      let angle = _targetVec.dot( _effectorVec );      if ( angle > 1.0 ) {       angle = 1.0;      } else if ( angle < - 1.0 ) {       angle = - 1.0;      }      angle = math.acos( angle );      // skip if changing angle is too small to prevent vibration of bone     if ( angle < 1e-5 ) continue;      if ( ik.minAngle !== undefined && angle < ik.minAngle ) {       angle = ik.minAngle;      }      if ( ik.maxAngle !== undefined && angle > ik.maxAngle ) {       angle = ik.maxAngle;      }      _axis.crossVectors( _effectorVec, _targetVec );     _axis.normalize();      _q.setFromAxisAngle( _axis, angle );     link.quaternion.multiply( _q );      // TODO: re-consider the limitation specification     if ( limitation !== undefined ) {       let c = link.quaternion.w;       if ( c > 1.0 ) c = 1.0;       const c2 = math.sqrt( 1 - c * c );      link.quaternion.set( limitation.x * c2,                           limitation.y * c2,                           limitation.z * c2,                           c );      }      if ( rotationMin !== undefined ) {       link.rotation.setFromVector3( _vector.setFromEuler( link.rotation ).max( rotationMin ) );      }      if ( rotationMax !== undefined ) {       link.rotation.setFromVector3( _vector.setFromEuler( link.rotation ).min( rotationMax ) );      }      link.updateMatrixWorld( true );      rotated = true;     }     if ( ! rotated ) break;    }    return this;   }   /**   * Creates Helper   *   * @param {number} sphereSize   * @return {CCDIKHelper}   */  createHelper( sphereSize ) {    return new CCDIKHelper( this.mesh, this.iks, sphereSize );   }   // private methods   _valid() {    const iks = this.iks;   const bones = this.mesh.skeleton.bones;    for ( let i = 0, il = iks.length; i < il; i ++ ) {     const ik = iks[ i ];    const effector = bones[ ik.effector ];    const links = ik.links;    let link0, link1;     link0 = effector;     for ( let j = 0, jl = links.length; j < jl; j ++ ) {      link1 = bones[ links[ j ].index ];      if ( link0.parent !== link1 ) {       console.warn( 'THREE.CCDIKSolver: bone ' + link0.name + ' is not the child of bone ' + link1.name );      }      link0 = link1;     }    }   }  }  function getPosition( bone, matrixWorldInv ) {   return _vector   .setFromMatrixPosition( bone.matrixWorld )   .applyMatrix4( matrixWorldInv );  }  function setPositionOfBoneToAttributeArray( array, index, bone, matrixWorldInv ) {   const v = getPosition( bone, matrixWorldInv );   array[ index * 3 + 0 ] = v.x;  array[ index * 3 + 1 ] = v.y;  array[ index * 3 + 2 ] = v.z;  }  /**  * Visualize IK bones  *  * @param {SkinnedMesh} mesh  * @param {Array<Object>} iks  * @param {number} sphereSize  */ class CCDIKHelper extends Object3D {   constructor( mesh, iks = [], sphereSize = 0.25 ) {    super();    this.root = mesh;   this.iks = iks;    this.matrix.copy( mesh.matrixWorld );   this.matrixAutoUpdate = false;    this.sphereGeometry = new SphereGeometry( sphereSize, 16, 8 );    this.targetSphereMaterial = new MeshBasicMaterial( {    color: new Color( 0xff8888 ),    depthTest: false,    depthWrite: false,    transparent: true   } );    this.effectorSphereMaterial = new MeshBasicMaterial( {    color: new Color( 0x88ff88 ),    depthTest: false,    depthWrite: false,    transparent: true   } );    this.linkSphereMaterial = new MeshBasicMaterial( {    color: new Color( 0x8888ff ),    depthTest: false,    depthWrite: false,    transparent: true   } );    this.lineMaterial = new LineBasicMaterial( {    color: new Color( 0xff0000 ),    depthTest: false,    depthWrite: false,    transparent: true   } );    this._init();   }   /**   * Updates IK bones visualization.   */  updateMatrixWorld( force ) {    const mesh = this.root;    if ( this.visible ) {     let offset = 0;     const iks = this.iks;    const bones = mesh.skeleton.bones;     _matrix.copy( mesh.matrixWorld ).invert();     for ( let i = 0, il = iks.length; i < il; i ++ ) {      const ik = iks[ i ];      const targetBone = bones[ ik.target ];     const effectorBone = bones[ ik.effector ];      const targetMesh = this.children[ offset ++ ];     const effectorMesh = this.children[ offset ++ ];      targetMesh.position.copy( getPosition( targetBone, _matrix ) );     effectorMesh.position.copy( getPosition( effectorBone, _matrix ) );      for ( let j = 0, jl = ik.links.length; j < jl; j ++ ) {       const link = ik.links[ j ];      const linkBone = bones[ link.index ];       const linkMesh = this.children[ offset ++ ];       linkMesh.position.copy( getPosition( linkBone, _matrix ) );      }      const line = this.children[ offset ++ ];     const array = line.geometry.attributes.position.array;      setPositionOfBoneToAttributeArray( array, 0, targetBone, _matrix );     setPositionOfBoneToAttributeArray( array, 1, effectorBone, _matrix );      for ( let j = 0, jl = ik.links.length; j < jl; j ++ ) {       const link = ik.links[ j ];      const linkBone = bones[ link.index ];      setPositionOfBoneToAttributeArray( array, j + 2, linkBone, _matrix );      }      line.geometry.attributes.position.needsUpdate = true;     }    }    this.matrix.copy( mesh.matrixWorld );    super.updateMatrixWorld( force );   }   /**   * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.   */  dispose() {    this.sphereGeometry.dispose();    this.targetSphereMaterial.dispose();   this.effectorSphereMaterial.dispose();   this.linkSphereMaterial.dispose();   this.lineMaterial.dispose();    const children = this.children;    for ( let i = 0; i < children.length; i ++ ) {     const child = children[ i ];     if ( child.isLine ) child.geometry.dispose();    }   }   // private method   _init() {    const scope = this;   const iks = this.iks;    function createLineGeometry( ik ) {     const geometry = new BufferGeometry();    const vertices = new Float32Array( ( 2 + ik.links.length ) * 3 );    geometry.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );     return geometry;    }    function createTargetMesh() {     return new Mesh( scope.sphereGeometry, scope.targetSphereMaterial );    }    function createEffectorMesh() {     return new Mesh( scope.sphereGeometry, scope.effectorSphereMaterial );    }    function createLinkMesh() {     return new Mesh( scope.sphereGeometry, scope.linkSphereMaterial );    }    function createLine( ik ) {     return new Line( createLineGeometry( ik ), scope.lineMaterial );    }    for ( let i = 0, il = iks.length; i < il; i ++ ) {     const ik = iks[ i ];     this.add( createTargetMesh() );    this.add( createEffectorMesh() );     for ( let j = 0, jl = ik.links.length; j < jl; j ++ ) {      this.add( createLinkMesh() );     }     this.add( createLine( ik ) );    }   }  }  export { CCDIKSolver, CCDIKHelper }; 
^..^ FILENAME ^..^
addons|animation|MMDAnimationHelper.js
^..^ CONTENTS ^..^
import {  AnimationMixer,  Object3D,  Quaternion,  Vector3 } from 'three'; import { CCDIKSolver } from '../animation/CCDIKSolver.js'; import { MMDPhysics } from '../animation/MMDPhysics.js';  /**  * MMDAnimationHelper handles animation of MMD assets loaded by MMDLoader  * with MMD special features as IK, Grant, and Physics.  *  * Dependencies  *  - ammo.js https://github.com/kripken/ammo.js  *  - MMDPhysics  *  - CCDIKSolver  *  * TODO  *  - more precise grant skinning support.  */ class MMDAnimationHelper {   /**   * @param {Object} params - (optional)   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.   * @param {Number} params.afterglow - Default is 0.0.   * @param {boolean} params.resetPhysicsOnLoop - Default is true.   */  constructor( params = {} ) {    this.meshes = [];    this.camera = null;   this.cameraTarget = new Object3D();   this.cameraTarget.name = 'target';    this.audio = null;   this.audioManager = null;    this.objects = new WeakMap();    this.configuration = {    sync: params.sync !== undefined ? params.sync : true,    afterglow: params.afterglow !== undefined ? params.afterglow : 0.0,    resetPhysicsOnLoop: params.resetPhysicsOnLoop !== undefined ? params.resetPhysicsOnLoop : true,    pmxAnimation: params.pmxAnimation !== undefined ? params.pmxAnimation : false   };    this.enabled = {    animation: true,    ik: true,    grant: true,    physics: true,    cameraAnimation: true   };    this.onBeforePhysics = function ( /* mesh */ ) {};    // experimental   this.sharedPhysics = false;   this.masterPhysics = null;   }   /**   * Adds an Three.js Object to helper and setups animation.   * The anmation durations of added objects are synched   * if this.configuration.sync is true.   *   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object   * @param {Object} params - (optional)   * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.   * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.   * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.   * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.   * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.   * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).   * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.   * @return {MMDAnimationHelper}   */  add( object, params = {} ) {    if ( object.isSkinnedMesh ) {     this._addMesh( object, params );    } else if ( object.isCamera ) {     this._setupCamera( object, params );    } else if ( object.type === 'Audio' ) {     this._setupAudio( object, params );    } else {     throw new Error( 'THREE.MMDAnimationHelper.add: '     + 'accepts only '     + 'THREE.SkinnedMesh or '     + 'THREE.Camera or '     + 'THREE.Audio instance.' );    }    if ( this.configuration.sync ) this._syncDuration();    return this;   }   /**   * Removes an Three.js Object from helper.   *   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object   * @return {MMDAnimationHelper}   */  remove( object ) {    if ( object.isSkinnedMesh ) {     this._removeMesh( object );    } else if ( object.isCamera ) {     this._clearCamera( object );    } else if ( object.type === 'Audio' ) {     this._clearAudio( object );    } else {     throw new Error( 'THREE.MMDAnimationHelper.remove: '     + 'accepts only '     + 'THREE.SkinnedMesh or '     + 'THREE.Camera or '     + 'THREE.Audio instance.' );    }    if ( this.configuration.sync ) this._syncDuration();    return this;   }   /**   * Updates the animation.   *   * @param {Number} delta   * @return {MMDAnimationHelper}   */  update( delta ) {    if ( this.audioManager !== null ) this.audioManager.control( delta );    for ( let i = 0; i < this.meshes.length; i ++ ) {     this._animateMesh( this.meshes[ i ], delta );    }    if ( this.sharedPhysics ) this._updateSharedPhysics( delta );    if ( this.camera !== null ) this._animateCamera( this.camera, delta );    return this;   }   /**   * Changes the pose of SkinnedMesh as VPD specifies.   *   * @param {THREE.SkinnedMesh} mesh   * @param {Object} vpd - VPD content parsed MMDParser   * @param {Object} params - (optional)   * @param {boolean} params.resetPose - Default is true.   * @param {boolean} params.ik - Default is true.   * @param {boolean} params.grant - Default is true.   * @return {MMDAnimationHelper}   */  pose( mesh, vpd, params = {} ) {    if ( params.resetPose !== false ) mesh.pose();    const bones = mesh.skeleton.bones;   const boneParams = vpd.bones;    const boneNameDictionary = {};    for ( let i = 0, il = bones.length; i < il; i ++ ) {     boneNameDictionary[ bones[ i ].name ] = i;    }    const vector = new Vector3();   const quaternion = new Quaternion();    for ( let i = 0, il = boneParams.length; i < il; i ++ ) {     const boneParam = boneParams[ i ];    const boneIndex = boneNameDictionary[ boneParam.name ];     if ( boneIndex === undefined ) continue;     const bone = bones[ boneIndex ];    bone.position.add( vector.fromArray( boneParam.translation ) );    bone.quaternion.multiply( quaternion.fromArray( boneParam.quaternion ) );    }    mesh.updateMatrixWorld( true );    // PMX animation system special path   if ( this.configuration.pmxAnimation &&    mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === 'pmx' ) {     const sortedBonesData = this._sortBoneDataArray( mesh.geometry.userData.MMD.bones.slice() );    const ikSolver = params.ik !== false ? this._createCCDIKSolver( mesh ) : null;    const grantSolver = params.grant !== false ? this.createGrantSolver( mesh ) : null;    this._animatePMXMesh( mesh, sortedBonesData, ikSolver, grantSolver );    } else {     if ( params.ik !== false ) {      this._createCCDIKSolver( mesh ).update();     }     if ( params.grant !== false ) {      this.createGrantSolver( mesh ).update();     }    }    return this;   }   /**   * Enabes/Disables an animation feature.   *   * @param {string} key   * @param {boolean} enabled   * @return {MMDAnimationHelper}   */  enable( key, enabled ) {    if ( this.enabled[ key ] === undefined ) {     throw new Error( 'THREE.MMDAnimationHelper.enable: '     + 'unknown key ' + key );    }    this.enabled[ key ] = enabled;    if ( key === 'physics' ) {     for ( let i = 0, il = this.meshes.length; i < il; i ++ ) {      this._optimizeIK( this.meshes[ i ], enabled );     }    }    return this;   }   /**   * Creates an GrantSolver instance.   *   * @param {THREE.SkinnedMesh} mesh   * @return {GrantSolver}   */  createGrantSolver( mesh ) {    return new GrantSolver( mesh, mesh.geometry.userData.MMD.grants );   }   // private methods   _addMesh( mesh, params ) {    if ( this.meshes.indexOf( mesh ) >= 0 ) {     throw new Error( 'THREE.MMDAnimationHelper._addMesh: '     + 'SkinnedMesh |'' + mesh.name + '|' has already been added.' );    }    this.meshes.push( mesh );   this.objects.set( mesh, { looped: false } );    this._setupMeshAnimation( mesh, params.animation );    if ( params.physics !== false ) {     this._setupMeshPhysics( mesh, params );    }    return this;   }   _setupCamera( camera, params ) {    if ( this.camera === camera ) {     throw new Error( 'THREE.MMDAnimationHelper._setupCamera: '     + 'Camera |'' + camera.name + '|' has already been set.' );    }    if ( this.camera ) this.clearCamera( this.camera );    this.camera = camera;    camera.add( this.cameraTarget );    this.objects.set( camera, {} );    if ( params.animation !== undefined ) {     this._setupCameraAnimation( camera, params.animation );    }    return this;   }   _setupAudio( audio, params ) {    if ( this.audio === audio ) {     throw new Error( 'THREE.MMDAnimationHelper._setupAudio: '     + 'Audio |'' + audio.name + '|' has already been set.' );    }    if ( this.audio ) this.clearAudio( this.audio );    this.audio = audio;   this.audioManager = new AudioManager( audio, params );    this.objects.set( this.audioManager, {    duration: this.audioManager.duration   } );    return this;   }   _removeMesh( mesh ) {    let found = false;   let writeIndex = 0;    for ( let i = 0, il = this.meshes.length; i < il; i ++ ) {     if ( this.meshes[ i ] === mesh ) {      this.objects.delete( mesh );     found = true;      continue;     }     this.meshes[ writeIndex ++ ] = this.meshes[ i ];    }    if ( ! found ) {     throw new Error( 'THREE.MMDAnimationHelper._removeMesh: '     + 'SkinnedMesh |'' + mesh.name + '|' has not been added yet.' );    }    this.meshes.length = writeIndex;    return this;   }   _clearCamera( camera ) {    if ( camera !== this.camera ) {     throw new Error( 'THREE.MMDAnimationHelper._clearCamera: '     + 'Camera |'' + camera.name + '|' has not been set yet.' );    }    this.camera.remove( this.cameraTarget );    this.objects.delete( this.camera );   this.camera = null;    return this;   }   _clearAudio( audio ) {    if ( audio !== this.audio ) {     throw new Error( 'THREE.MMDAnimationHelper._clearAudio: '     + 'Audio |'' + audio.name + '|' has not been set yet.' );    }    this.objects.delete( this.audioManager );    this.audio = null;   this.audioManager = null;    return this;   }   _setupMeshAnimation( mesh, animation ) {    const objects = this.objects.get( mesh );    if ( animation !== undefined ) {     const animations = Array.isArray( animation )     ? animation : [ animation ];     objects.mixer = new AnimationMixer( mesh );     for ( let i = 0, il = animations.length; i < il; i ++ ) {      objects.mixer.clipAction( animations[ i ] ).play();     }     // TODO: find a workaround not to access ._clip looking like a private property    objects.mixer.addEventListener( 'loop', function ( event ) {      const tracks = event.action._clip.tracks;      if ( tracks.length > 0 && tracks[ 0 ].name.slice( 0, 6 ) !== '.bones' ) return;      objects.looped = true;     } );    }    objects.ikSolver = this._createCCDIKSolver( mesh );   objects.grantSolver = this.createGrantSolver( mesh );    return this;   }   _setupCameraAnimation( camera, animation ) {    const animations = Array.isArray( animation )    ? animation : [ animation ];    const objects = this.objects.get( camera );    objects.mixer = new AnimationMixer( camera );    for ( let i = 0, il = animations.length; i < il; i ++ ) {     objects.mixer.clipAction( animations[ i ] ).play();    }   }   _setupMeshPhysics( mesh, params ) {    const objects = this.objects.get( mesh );    // shared physics is experimental    if ( params.world === undefined && this.sharedPhysics ) {     const masterPhysics = this._getMasterPhysics();     if ( masterPhysics !== null ) world = masterPhysics.world; // eslint-disable-line no-undef    }    objects.physics = this._createMMDPhysics( mesh, params );    if ( objects.mixer && params.animationWarmup !== false ) {     this._animateMesh( mesh, 0 );    objects.physics.reset();    }    objects.physics.warmup( params.warmup !== undefined ? params.warmup : 60 );    this._optimizeIK( mesh, true );   }   _animateMesh( mesh, delta ) {    const objects = this.objects.get( mesh );    const mixer = objects.mixer;   const ikSolver = objects.ikSolver;   const grantSolver = objects.grantSolver;   const physics = objects.physics;   const looped = objects.looped;    if ( mixer && this.enabled.animation ) {     // alternate solution to save/restore bones but less performant?    //mesh.pose();    //this._updatePropertyMixersBuffer( mesh );     this._restoreBones( mesh );     mixer.update( delta );     this._saveBones( mesh );     // PMX animation system special path    if ( this.configuration.pmxAnimation &&     mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === 'pmx' ) {      if ( ! objects.sortedBonesData ) objects.sortedBonesData = this._sortBoneDataArray( mesh.geometry.userData.MMD.bones.slice() );      this._animatePMXMesh(      mesh,      objects.sortedBonesData,      ikSolver && this.enabled.ik ? ikSolver : null,      grantSolver && this.enabled.grant ? grantSolver : null     );     } else {      if ( ikSolver && this.enabled.ik ) {       mesh.updateMatrixWorld( true );      ikSolver.update();      }      if ( grantSolver && this.enabled.grant ) {       grantSolver.update();      }     }    }    if ( looped === true && this.enabled.physics ) {     if ( physics && this.configuration.resetPhysicsOnLoop ) physics.reset();     objects.looped = false;    }    if ( physics && this.enabled.physics && ! this.sharedPhysics ) {     this.onBeforePhysics( mesh );    physics.update( delta );    }   }   // Sort bones in order by 1. transformationClass and 2. bone index.  // In PMX animation system, bone transformations should be processed  // in this order.  _sortBoneDataArray( boneDataArray ) {    return boneDataArray.sort( function ( a, b ) {     if ( a.transformationClass !== b.transformationClass ) {      return a.transformationClass - b.transformationClass;     } else {      return a.index - b.index;     }    } );   }   // PMX Animation system is a bit too complex and doesn't great match to  // Three.js Animation system. This method attempts to simulate it as much as  // possible but doesn't perfectly simulate.  // This method is more costly than the regular one so  // you are recommended to set constructor parameter "pmxAnimation: true"  // only if your PMX model animation doesn't work well.  // If you need better method you would be required to write your own.  _animatePMXMesh( mesh, sortedBonesData, ikSolver, grantSolver ) {    _quaternionIndex = 0;   _grantResultMap.clear();    for ( let i = 0, il = sortedBonesData.length; i < il; i ++ ) {     updateOne( mesh, sortedBonesData[ i ].index, ikSolver, grantSolver );    }    mesh.updateMatrixWorld( true );   return this;   }   _animateCamera( camera, delta ) {    const mixer = this.objects.get( camera ).mixer;    if ( mixer && this.enabled.cameraAnimation ) {     mixer.update( delta );     camera.updateProjectionMatrix();     camera.up.set( 0, 1, 0 );    camera.up.applyQuaternion( camera.quaternion );    camera.lookAt( this.cameraTarget.position );    }   }   _optimizeIK( mesh, physicsEnabled ) {    const iks = mesh.geometry.userData.MMD.iks;   const bones = mesh.geometry.userData.MMD.bones;    for ( let i = 0, il = iks.length; i < il; i ++ ) {     const ik = iks[ i ];    const links = ik.links;     for ( let j = 0, jl = links.length; j < jl; j ++ ) {      const link = links[ j ];      if ( physicsEnabled === true ) {       // disable IK of the bone the corresponding rigidBody type of which is 1 or 2      // because its rotation will be overriden by physics      link.enabled = bones[ link.index ].rigidBodyType > 0 ? false : true;      } else {       link.enabled = true;      }     }    }   }   _createCCDIKSolver( mesh ) {    if ( CCDIKSolver === undefined ) {     throw new Error( 'THREE.MMDAnimationHelper: Import CCDIKSolver.' );    }    return new CCDIKSolver( mesh, mesh.geometry.userData.MMD.iks );   }   _createMMDPhysics( mesh, params ) {    if ( MMDPhysics === undefined ) {     throw new Error( 'THREE.MMDPhysics: Import MMDPhysics.' );    }    return new MMDPhysics(    mesh,    mesh.geometry.userData.MMD.rigidBodies,    mesh.geometry.userData.MMD.constraints,    params );   }   /*   * Detects the longest duration and then sets it to them to sync.   * TODO: Not to access private properties ( ._actions and ._clip )   */  _syncDuration() {    let max = 0.0;    const objects = this.objects;   const meshes = this.meshes;   const camera = this.camera;   const audioManager = this.audioManager;    // get the longest duration    for ( let i = 0, il = meshes.length; i < il; i ++ ) {     const mixer = this.objects.get( meshes[ i ] ).mixer;     if ( mixer === undefined ) continue;     for ( let j = 0; j < mixer._actions.length; j ++ ) {      const clip = mixer._actions[ j ]._clip;      if ( ! objects.has( clip ) ) {       objects.set( clip, {       duration: clip.duration      } );      }      max = Math.max( max, objects.get( clip ).duration );     }    }    if ( camera !== null ) {     const mixer = this.objects.get( camera ).mixer;     if ( mixer !== undefined ) {      for ( let i = 0, il = mixer._actions.length; i < il; i ++ ) {       const clip = mixer._actions[ i ]._clip;       if ( ! objects.has( clip ) ) {        objects.set( clip, {        duration: clip.duration       } );       }       max = Math.max( max, objects.get( clip ).duration );      }     }    }    if ( audioManager !== null ) {     max = Math.max( max, objects.get( audioManager ).duration );    }    max += this.configuration.afterglow;    // update the duration    for ( let i = 0, il = this.meshes.length; i < il; i ++ ) {     const mixer = this.objects.get( this.meshes[ i ] ).mixer;     if ( mixer === undefined ) continue;     for ( let j = 0, jl = mixer._actions.length; j < jl; j ++ ) {      mixer._actions[ j ]._clip.duration = max;     }    }    if ( camera !== null ) {     const mixer = this.objects.get( camera ).mixer;     if ( mixer !== undefined ) {      for ( let i = 0, il = mixer._actions.length; i < il; i ++ ) {       mixer._actions[ i ]._clip.duration = max;      }     }    }    if ( audioManager !== null ) {     audioManager.duration = max;    }   }   // workaround   _updatePropertyMixersBuffer( mesh ) {    const mixer = this.objects.get( mesh ).mixer;    const propertyMixers = mixer._bindings;   const accuIndex = mixer._accuIndex;    for ( let i = 0, il = propertyMixers.length; i < il; i ++ ) {     const propertyMixer = propertyMixers[ i ];    const buffer = propertyMixer.buffer;    const stride = propertyMixer.valueSize;    const offset = ( accuIndex + 1 ) * stride;     propertyMixer.binding.getValue( buffer, offset );    }   }   /*   * Avoiding these two issues by restore/save bones before/after mixer animation.   *   * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.   *    Calculating IK, Grant, and Physics after mixer animation can break   *    the cache coherency.   *   * 2. Applying Grant two or more times without reset the posing breaks model.   */  _saveBones( mesh ) {    const objects = this.objects.get( mesh );    const bones = mesh.skeleton.bones;    let backupBones = objects.backupBones;    if ( backupBones === undefined ) {     backupBones = new Float32Array( bones.length * 7 );    objects.backupBones = backupBones;    }    for ( let i = 0, il = bones.length; i < il; i ++ ) {     const bone = bones[ i ];    bone.position.toArray( backupBones, i * 7 );    bone.quaternion.toArray( backupBones, i * 7 + 3 );    }   }   _restoreBones( mesh ) {    const objects = this.objects.get( mesh );    const backupBones = objects.backupBones;    if ( backupBones === undefined ) return;    const bones = mesh.skeleton.bones;    for ( let i = 0, il = bones.length; i < il; i ++ ) {     const bone = bones[ i ];    bone.position.fromArray( backupBones, i * 7 );    bone.quaternion.fromArray( backupBones, i * 7 + 3 );    }   }   // experimental   _getMasterPhysics() {    if ( this.masterPhysics !== null ) return this.masterPhysics;    for ( let i = 0, il = this.meshes.length; i < il; i ++ ) {     const physics = this.meshes[ i ].physics;     if ( physics !== undefined && physics !== null ) {      this.masterPhysics = physics;     return this.masterPhysics;     }    }    return null;   }   _updateSharedPhysics( delta ) {    if ( this.meshes.length === 0 || ! this.enabled.physics || ! this.sharedPhysics ) return;    const physics = this._getMasterPhysics();    if ( physics === null ) return;    for ( let i = 0, il = this.meshes.length; i < il; i ++ ) {     const p = this.meshes[ i ].physics;     if ( p !== null && p !== undefined ) {      p.updateRigidBodies();     }    }    physics.stepSimulation( delta );    for ( let i = 0, il = this.meshes.length; i < il; i ++ ) {     const p = this.meshes[ i ].physics;     if ( p !== null && p !== undefined ) {      p.updateBones();     }    }   }  }  // Keep working quaternions for less GC const _quaternions = []; let _quaternionIndex = 0;  function getQuaternion() {   if ( _quaternionIndex >= _quaternions.length ) {    _quaternions.push( new Quaternion() );   }   return _quaternions[ _quaternionIndex ++ ];  }  // Save rotation whose grant and IK are already applied // used by grant children const _grantResultMap = new Map();  function updateOne( mesh, boneIndex, ikSolver, grantSolver ) {   const bones = mesh.skeleton.bones;  const bonesData = mesh.geometry.userData.MMD.bones;  const boneData = bonesData[ boneIndex ];  const bone = bones[ boneIndex ];   // Return if already updated by being referred as a grant parent.  if ( _grantResultMap.has( boneIndex ) ) return;   const quaternion = getQuaternion();   // Initialize grant result here to prevent infinite loop.  // If it's referred before updating with actual result later  // result without applyting IK or grant is gotten  // but better than composing of infinite loop.  _grantResultMap.set( boneIndex, quaternion.copy( bone.quaternion ) );   // @TODO: Support global grant and grant position  if ( grantSolver && boneData.grant &&   ! boneData.grant.isLocal && boneData.grant.affectRotation ) {    const parentIndex = boneData.grant.parentIndex;   const ratio = boneData.grant.ratio;    if ( ! _grantResultMap.has( parentIndex ) ) {     updateOne( mesh, parentIndex, ikSolver, grantSolver );    }    grantSolver.addGrantRotation( bone, _grantResultMap.get( parentIndex ), ratio );   }   if ( ikSolver && boneData.ik ) {    // @TODO: Updating world matrices every time solving an IK bone is   // costly. Optimize if possible.   mesh.updateMatrixWorld( true );   ikSolver.updateOne( boneData.ik );    // No confident, but it seems the grant results with ik links should be updated?   const links = boneData.ik.links;    for ( let i = 0, il = links.length; i < il; i ++ ) {     const link = links[ i ];     if ( link.enabled === false ) continue;     const linkIndex = link.index;     if ( _grantResultMap.has( linkIndex ) ) {      _grantResultMap.set( linkIndex, _grantResultMap.get( linkIndex ).copy( bones[ linkIndex ].quaternion ) );     }    }   }   // Update with the actual result here  quaternion.copy( bone.quaternion );  }  //  class AudioManager {   /**   * @param {THREE.Audio} audio   * @param {Object} params - (optional)   * @param {Nuumber} params.delayTime   */  constructor( audio, params = {} ) {    this.audio = audio;    this.elapsedTime = 0.0;   this.currentTime = 0.0;   this.delayTime = params.delayTime !== undefined    ? params.delayTime : 0.0;    this.audioDuration = this.audio.buffer.duration;   this.duration = this.audioDuration + this.delayTime;   }   /**   * @param {Number} delta   * @return {AudioManager}   */  control( delta ) {    this.elapsed += delta;   this.currentTime += delta;    if ( this._shouldStopAudio() ) this.audio.stop();   if ( this._shouldStartAudio() ) this.audio.play();    return this;   }   // private methods   _shouldStartAudio() {    if ( this.audio.isPlaying ) return false;    while ( this.currentTime >= this.duration ) {     this.currentTime -= this.duration;    }    if ( this.currentTime < this.delayTime ) return false;    // 'duration' can be bigger than 'audioDuration + delayTime' because of sync configuration   if ( ( this.currentTime - this.delayTime ) > this.audioDuration ) return false;    return true;   }   _shouldStopAudio() {    return this.audio.isPlaying &&    this.currentTime >= this.duration;   }  }  const _q = new Quaternion();  /**  * Solver for Grant (Fuyo in Japanese. I just google translated because  * Fuyo may be MMD specific term and may not be common word in 3D CG terms.)  * Grant propagates a bone's transform to other bones transforms even if  * they are not children.  * @param {THREE.SkinnedMesh} mesh  * @param {Array<Object>} grants  */ class GrantSolver {   constructor( mesh, grants = [] ) {    this.mesh = mesh;   this.grants = grants;   }   /**   * Solve all the grant bones   * @return {GrantSolver}   */  update() {    const grants = this.grants;    for ( let i = 0, il = grants.length; i < il; i ++ ) {     this.updateOne( grants[ i ] );    }    return this;   }   /**   * Solve a grant bone   * @param {Object} grant - grant parameter   * @return {GrantSolver}   */  updateOne( grant ) {    const bones = this.mesh.skeleton.bones;   const bone = bones[ grant.index ];   const parentBone = bones[ grant.parentIndex ];    if ( grant.isLocal ) {     // TODO: implement    if ( grant.affectPosition ) {     }     // TODO: implement    if ( grant.affectRotation ) {     }    } else {     // TODO: implement    if ( grant.affectPosition ) {     }     if ( grant.affectRotation ) {      this.addGrantRotation( bone, parentBone.quaternion, grant.ratio );     }    }    return this;   }   addGrantRotation( bone, q, ratio ) {    _q.set( 0, 0, 0, 1 );   _q.slerp( q, ratio );   bone.quaternion.multiply( _q );    return this;   }  }  export { MMDAnimationHelper }; 
^..^ FILENAME ^..^
addons|animation|MMDPhysics.js
^..^ CONTENTS ^..^
import {  Bone,  BoxGeometry,  CapsuleGeometry,  Color,  Euler,  Matrix4,  Mesh,  MeshBasicMaterial,  Object3D,  Quaternion,  SphereGeometry,  Vector3 } from 'three';  /**  * Dependencies  *  - Ammo.js https://github.com/kripken/ammo.js  *  * MMDPhysics calculates physics with Ammo(Bullet based JavaScript Physics engine)  * for MMD model loaded by MMDLoader.  *  * TODO  *  - Physics in Worker  */  /* global Ammo */  class MMDPhysics {   /**   * @param {THREE.SkinnedMesh} mesh   * @param {Array<Object>} rigidBodyParams   * @param {Array<Object>} (optional) constraintParams   * @param {Object} params - (optional)   * @param {Number} params.unitStep - Default is 1 / 65.   * @param {Integer} params.maxStepNum - Default is 3.   * @param {Vector3} params.gravity - Default is ( 0, - 9.8 * 10, 0 )   */  constructor( mesh, rigidBodyParams, constraintParams = [], params = {} ) {    if ( typeof Ammo === 'undefined' ) {     throw new Error( 'THREE.MMDPhysics: Import ammo.js https://github.com/kripken/ammo.js' );    }    this.manager = new ResourceManager();    this.mesh = mesh;    /*    * I don't know why but 1/60 unitStep easily breaks models    * so I set it 1/65 so far.    * Don't set too small unitStep because    * the smaller unitStep can make the performance worse.    */   this.unitStep = ( params.unitStep !== undefined ) ? params.unitStep : 1 / 65;   this.maxStepNum = ( params.maxStepNum !== undefined ) ? params.maxStepNum : 3;   this.gravity = new Vector3( 0, - 9.8 * 10, 0 );    if ( params.gravity !== undefined ) this.gravity.copy( params.gravity );    this.world = params.world !== undefined ? params.world : null; // experimental    this.bodies = [];   this.constraints = [];    this._init( mesh, rigidBodyParams, constraintParams );   }   /**   * Advances Physics calculation and updates bones.   *   * @param {Number} delta - time in second   * @return {MMDPhysics}   */  update( delta ) {    const manager = this.manager;   const mesh = this.mesh;    // rigid bodies and constrains are for   // mesh's world scale (1, 1, 1).   // Convert to (1, 1, 1) if it isn't.    let isNonDefaultScale = false;    const position = manager.allocThreeVector3();   const quaternion = manager.allocThreeQuaternion();   const scale = manager.allocThreeVector3();    mesh.matrixWorld.decompose( position, quaternion, scale );    if ( scale.x !== 1 || scale.y !== 1 || scale.z !== 1 ) {     isNonDefaultScale = true;    }    let parent;    if ( isNonDefaultScale ) {     parent = mesh.parent;     if ( parent !== null ) mesh.parent = null;     scale.copy( this.mesh.scale );     mesh.scale.set( 1, 1, 1 );    mesh.updateMatrixWorld( true );    }    // calculate physics and update bones    this._updateRigidBodies();   this._stepSimulation( delta );   this._updateBones();    // restore mesh if converted above    if ( isNonDefaultScale ) {     if ( parent !== null ) mesh.parent = parent;     mesh.scale.copy( scale );    }    manager.freeThreeVector3( scale );   manager.freeThreeQuaternion( quaternion );   manager.freeThreeVector3( position );    return this;   }   /**   * Resets rigid bodies transorm to current bone's.   *   * @return {MMDPhysics}   */  reset() {    for ( let i = 0, il = this.bodies.length; i < il; i ++ ) {     this.bodies[ i ].reset();    }    return this;   }   /**   * Warm ups Rigid bodies. Calculates cycles steps.   *   * @param {Integer} cycles   * @return {MMDPhysics}   */  warmup( cycles ) {    for ( let i = 0; i < cycles; i ++ ) {     this.update( 1 / 60 );    }    return this;   }   /**   * Sets gravity.   *   * @param {Vector3} gravity   * @return {MMDPhysicsHelper}   */  setGravity( gravity ) {    this.world.setGravity( new Ammo.btVector3( gravity.x, gravity.y, gravity.z ) );   this.gravity.copy( gravity );    return this;   }   /**   * Creates MMDPhysicsHelper   *   * @return {MMDPhysicsHelper}   */  createHelper() {    return new MMDPhysicsHelper( this.mesh, this );   }   // private methods   _init( mesh, rigidBodyParams, constraintParams ) {    const manager = this.manager;    // rigid body/constraint parameters are for   // mesh's default world transform as position(0, 0, 0),   // quaternion(0, 0, 0, 1) and scale(0, 0, 0)    const parent = mesh.parent;    if ( parent !== null ) mesh.parent = null;    const currentPosition = manager.allocThreeVector3();   const currentQuaternion = manager.allocThreeQuaternion();   const currentScale = manager.allocThreeVector3();    currentPosition.copy( mesh.position );   currentQuaternion.copy( mesh.quaternion );   currentScale.copy( mesh.scale );    mesh.position.set( 0, 0, 0 );   mesh.quaternion.set( 0, 0, 0, 1 );   mesh.scale.set( 1, 1, 1 );    mesh.updateMatrixWorld( true );    if ( this.world === null ) {     this.world = this._createWorld();    this.setGravity( this.gravity );    }    this._initRigidBodies( rigidBodyParams );   this._initConstraints( constraintParams );    if ( parent !== null ) mesh.parent = parent;    mesh.position.copy( currentPosition );   mesh.quaternion.copy( currentQuaternion );   mesh.scale.copy( currentScale );    mesh.updateMatrixWorld( true );    this.reset();    manager.freeThreeVector3( currentPosition );   manager.freeThreeQuaternion( currentQuaternion );   manager.freeThreeVector3( currentScale );   }   _createWorld() {    const config = new Ammo.btDefaultCollisionConfiguration();   const dispatcher = new Ammo.btCollisionDispatcher( config );   const cache = new Ammo.btDbvtBroadphase();   const solver = new Ammo.btSequentialImpulseConstraintSolver();   const world = new Ammo.btDiscreteDynamicsWorld( dispatcher, cache, solver, config );   return world;   }   _initRigidBodies( rigidBodies ) {    for ( let i = 0, il = rigidBodies.length; i < il; i ++ ) {     this.bodies.push( new RigidBody(     this.mesh, this.world, rigidBodies[ i ], this.manager ) );    }   }   _initConstraints( constraints ) {    for ( let i = 0, il = constraints.length; i < il; i ++ ) {     const params = constraints[ i ];    const bodyA = this.bodies[ params.rigidBodyIndex1 ];    const bodyB = this.bodies[ params.rigidBodyIndex2 ];    this.constraints.push( new Constraint( this.mesh, this.world, bodyA, bodyB, params, this.manager ) );    }   }   _stepSimulation( delta ) {    const unitStep = this.unitStep;   let stepTime = delta;   let maxStepNum = ( ( delta / unitStep ) | 0 ) + 1;    if ( stepTime < unitStep ) {     stepTime = unitStep;    maxStepNum = 1;    }    if ( maxStepNum > this.maxStepNum ) {     maxStepNum = this.maxStepNum;    }    this.world.stepSimulation( stepTime, maxStepNum, unitStep );   }   _updateRigidBodies() {    for ( let i = 0, il = this.bodies.length; i < il; i ++ ) {     this.bodies[ i ].updateFromBone();    }   }   _updateBones() {    for ( let i = 0, il = this.bodies.length; i < il; i ++ ) {     this.bodies[ i ].updateBone();    }   }  }  /**  * This manager's responsibilies are  *  * 1. manage Ammo.js and Three.js object resources and  *    improve the performance and the memory consumption by  *    reusing objects.  *  * 2. provide simple Ammo object operations.  */ class ResourceManager {   constructor() {    // for Three.js   this.threeVector3s = [];   this.threeMatrix4s = [];   this.threeQuaternions = [];   this.threeEulers = [];    // for Ammo.js   this.transforms = [];   this.quaternions = [];   this.vector3s = [];   }   allocThreeVector3() {    return ( this.threeVector3s.length > 0 )    ? this.threeVector3s.pop()    : new Vector3();   }   freeThreeVector3( v ) {    this.threeVector3s.push( v );   }   allocThreeMatrix4() {    return ( this.threeMatrix4s.length > 0 )    ? this.threeMatrix4s.pop()    : new Matrix4();   }   freeThreeMatrix4( m ) {    this.threeMatrix4s.push( m );   }   allocThreeQuaternion() {    return ( this.threeQuaternions.length > 0 )    ? this.threeQuaternions.pop()    : new Quaternion();   }   freeThreeQuaternion( q ) {    this.threeQuaternions.push( q );   }   allocThreeEuler() {    return ( this.threeEulers.length > 0 )    ? this.threeEulers.pop()    : new Euler();   }   freeThreeEuler( e ) {    this.threeEulers.push( e );   }   allocTransform() {    return ( this.transforms.length > 0 )    ? this.transforms.pop()    : new Ammo.btTransform();   }   freeTransform( t ) {    this.transforms.push( t );   }   allocQuaternion() {    return ( this.quaternions.length > 0 )    ? this.quaternions.pop()    : new Ammo.btQuaternion();   }   freeQuaternion( q ) {    this.quaternions.push( q );   }   allocVector3() {    return ( this.vector3s.length > 0 )    ? this.vector3s.pop()    : new Ammo.btVector3();   }   freeVector3( v ) {    this.vector3s.push( v );   }   setIdentity( t ) {    t.setIdentity();   }   getBasis( t ) {    var q = this.allocQuaternion();   t.getBasis().getRotation( q );   return q;   }   getBasisAsMatrix3( t ) {    var q = this.getBasis( t );   var m = this.quaternionToMatrix3( q );   this.freeQuaternion( q );   return m;   }   getOrigin( t ) {    return t.getOrigin();   }   setOrigin( t, v ) {    t.getOrigin().setValue( v.x(), v.y(), v.z() );   }   copyOrigin( t1, t2 ) {    var o = t2.getOrigin();   this.setOrigin( t1, o );   }   setBasis( t, q ) {    t.setRotation( q );   }   setBasisFromMatrix3( t, m ) {    var q = this.matrix3ToQuaternion( m );   this.setBasis( t, q );   this.freeQuaternion( q );   }   setOriginFromArray3( t, a ) {    t.getOrigin().setValue( a[ 0 ], a[ 1 ], a[ 2 ] );   }   setOriginFromThreeVector3( t, v ) {    t.getOrigin().setValue( v.x, v.y, v.z );   }   setBasisFromArray3( t, a ) {    var thQ = this.allocThreeQuaternion();   var thE = this.allocThreeEuler();   thE.set( a[ 0 ], a[ 1 ], a[ 2 ] );   this.setBasisFromThreeQuaternion( t, thQ.setFromEuler( thE ) );    this.freeThreeEuler( thE );   this.freeThreeQuaternion( thQ );   }   setBasisFromThreeQuaternion( t, a ) {    var q = this.allocQuaternion();    q.setX( a.x );   q.setY( a.y );   q.setZ( a.z );   q.setW( a.w );   this.setBasis( t, q );    this.freeQuaternion( q );   }   multiplyTransforms( t1, t2 ) {    var t = this.allocTransform();   this.setIdentity( t );    var m1 = this.getBasisAsMatrix3( t1 );   var m2 = this.getBasisAsMatrix3( t2 );    var o1 = this.getOrigin( t1 );   var o2 = this.getOrigin( t2 );    var v1 = this.multiplyMatrix3ByVector3( m1, o2 );   var v2 = this.addVector3( v1, o1 );   this.setOrigin( t, v2 );    var m3 = this.multiplyMatrices3( m1, m2 );   this.setBasisFromMatrix3( t, m3 );    this.freeVector3( v1 );   this.freeVector3( v2 );    return t;   }   inverseTransform( t ) {    var t2 = this.allocTransform();    var m1 = this.getBasisAsMatrix3( t );   var o = this.getOrigin( t );    var m2 = this.transposeMatrix3( m1 );   var v1 = this.negativeVector3( o );   var v2 = this.multiplyMatrix3ByVector3( m2, v1 );    this.setOrigin( t2, v2 );   this.setBasisFromMatrix3( t2, m2 );    this.freeVector3( v1 );   this.freeVector3( v2 );    return t2;   }   multiplyMatrices3( m1, m2 ) {    var m3 = [];    var v10 = this.rowOfMatrix3( m1, 0 );   var v11 = this.rowOfMatrix3( m1, 1 );   var v12 = this.rowOfMatrix3( m1, 2 );    var v20 = this.columnOfMatrix3( m2, 0 );   var v21 = this.columnOfMatrix3( m2, 1 );   var v22 = this.columnOfMatrix3( m2, 2 );    m3[ 0 ] = this.dotVectors3( v10, v20 );   m3[ 1 ] = this.dotVectors3( v10, v21 );   m3[ 2 ] = this.dotVectors3( v10, v22 );   m3[ 3 ] = this.dotVectors3( v11, v20 );   m3[ 4 ] = this.dotVectors3( v11, v21 );   m3[ 5 ] = this.dotVectors3( v11, v22 );   m3[ 6 ] = this.dotVectors3( v12, v20 );   m3[ 7 ] = this.dotVectors3( v12, v21 );   m3[ 8 ] = this.dotVectors3( v12, v22 );    this.freeVector3( v10 );   this.freeVector3( v11 );   this.freeVector3( v12 );   this.freeVector3( v20 );   this.freeVector3( v21 );   this.freeVector3( v22 );    return m3;   }   addVector3( v1, v2 ) {    var v = this.allocVector3();   v.setValue( v1.x() + v2.x(), v1.y() + v2.y(), v1.z() + v2.z() );   return v;   }   dotVectors3( v1, v2 ) {    return v1.x() * v2.x() + v1.y() * v2.y() + v1.z() * v2.z();   }   rowOfMatrix3( m, i ) {    var v = this.allocVector3();   v.setValue( m[ i * 3 + 0 ], m[ i * 3 + 1 ], m[ i * 3 + 2 ] );   return v;   }   columnOfMatrix3( m, i ) {    var v = this.allocVector3();   v.setValue( m[ i + 0 ], m[ i + 3 ], m[ i + 6 ] );   return v;   }   negativeVector3( v ) {    var v2 = this.allocVector3();   v2.setValue( - v.x(), - v.y(), - v.z() );   return v2;   }   multiplyMatrix3ByVector3( m, v ) {    var v4 = this.allocVector3();    var v0 = this.rowOfMatrix3( m, 0 );   var v1 = this.rowOfMatrix3( m, 1 );   var v2 = this.rowOfMatrix3( m, 2 );   var x = this.dotVectors3( v0, v );   var y = this.dotVectors3( v1, v );   var z = this.dotVectors3( v2, v );    v4.setValue( x, y, z );    this.freeVector3( v0 );   this.freeVector3( v1 );   this.freeVector3( v2 );    return v4;   }   transposeMatrix3( m ) {    var m2 = [];   m2[ 0 ] = m[ 0 ];   m2[ 1 ] = m[ 3 ];   m2[ 2 ] = m[ 6 ];   m2[ 3 ] = m[ 1 ];   m2[ 4 ] = m[ 4 ];   m2[ 5 ] = m[ 7 ];   m2[ 6 ] = m[ 2 ];   m2[ 7 ] = m[ 5 ];   m2[ 8 ] = m[ 8 ];   return m2;   }   quaternionToMatrix3( q ) {    var m = [];    var x = q.x();   var y = q.y();   var z = q.z();   var w = q.w();    var xx = x * x;   var yy = y * y;   var zz = z * z;    var xy = x * y;   var yz = y * z;   var zx = z * x;    var xw = x * w;   var yw = y * w;   var zw = z * w;    m[ 0 ] = 1 - 2 * ( yy + zz );   m[ 1 ] = 2 * ( xy - zw );   m[ 2 ] = 2 * ( zx + yw );   m[ 3 ] = 2 * ( xy + zw );   m[ 4 ] = 1 - 2 * ( zz + xx );   m[ 5 ] = 2 * ( yz - xw );   m[ 6 ] = 2 * ( zx - yw );   m[ 7 ] = 2 * ( yz + xw );   m[ 8 ] = 1 - 2 * ( xx + yy );    return m;   }   matrix3ToQuaternion( m ) {    var t = m[ 0 ] + m[ 4 ] + m[ 8 ];   var s, x, y, z, w;    if ( t > 0 ) {     s = Math.sqrt( t + 1.0 ) * 2;    w = 0.25 * s;    x = ( m[ 7 ] - m[ 5 ] ) / s;    y = ( m[ 2 ] - m[ 6 ] ) / s;    z = ( m[ 3 ] - m[ 1 ] ) / s;    } else if ( ( m[ 0 ] > m[ 4 ] ) && ( m[ 0 ] > m[ 8 ] ) ) {     s = Math.sqrt( 1.0 + m[ 0 ] - m[ 4 ] - m[ 8 ] ) * 2;    w = ( m[ 7 ] - m[ 5 ] ) / s;    x = 0.25 * s;    y = ( m[ 1 ] + m[ 3 ] ) / s;    z = ( m[ 2 ] + m[ 6 ] ) / s;    } else if ( m[ 4 ] > m[ 8 ] ) {     s = Math.sqrt( 1.0 + m[ 4 ] - m[ 0 ] - m[ 8 ] ) * 2;    w = ( m[ 2 ] - m[ 6 ] ) / s;    x = ( m[ 1 ] + m[ 3 ] ) / s;    y = 0.25 * s;    z = ( m[ 5 ] + m[ 7 ] ) / s;    } else {     s = Math.sqrt( 1.0 + m[ 8 ] - m[ 0 ] - m[ 4 ] ) * 2;    w = ( m[ 3 ] - m[ 1 ] ) / s;    x = ( m[ 2 ] + m[ 6 ] ) / s;    y = ( m[ 5 ] + m[ 7 ] ) / s;    z = 0.25 * s;    }    var q = this.allocQuaternion();   q.setX( x );   q.setY( y );   q.setZ( z );   q.setW( w );   return q;   }  }  /**  * @param {THREE.SkinnedMesh} mesh  * @param {Ammo.btDiscreteDynamicsWorld} world  * @param {Object} params  * @param {ResourceManager} manager  */ class RigidBody {   constructor( mesh, world, params, manager ) {    this.mesh = mesh;   this.world = world;   this.params = params;   this.manager = manager;    this.body = null;   this.bone = null;   this.boneOffsetForm = null;   this.boneOffsetFormInverse = null;    this._init();   }   /**   * Resets rigid body transform to the current bone's.   *   * @return {RigidBody}   */  reset() {    this._setTransformFromBone();   return this;   }   /**   * Updates rigid body's transform from the current bone.   *   * @return {RidigBody}   */  updateFromBone() {    if ( this.params.boneIndex !== - 1 && this.params.type === 0 ) {     this._setTransformFromBone();    }    return this;   }   /**   * Updates bone from the current ridid body's transform.   *   * @return {RidigBody}   */  updateBone() {    if ( this.params.type === 0 || this.params.boneIndex === - 1 ) {     return this;    }    this._updateBoneRotation();    if ( this.params.type === 1 ) {     this._updateBonePosition();    }    this.bone.updateMatrixWorld( true );    if ( this.params.type === 2 ) {     this._setPositionFromBone();    }    return this;   }   // private methods   _init() {    function generateShape( p ) {     switch ( p.shapeType ) {      case 0:      return new Ammo.btSphereShape( p.width );      case 1:      return new Ammo.btBoxShape( new Ammo.btVector3( p.width, p.height, p.depth ) );      case 2:      return new Ammo.btCapsuleShape( p.width, p.height );      default:      throw new Error( 'unknown shape type ' + p.shapeType );     }    }    const manager = this.manager;   const params = this.params;   const bones = this.mesh.skeleton.bones;   const bone = ( params.boneIndex === - 1 )    ? new Bone()    : bones[ params.boneIndex ];    const shape = generateShape( params );   const weight = ( params.type === 0 ) ? 0 : params.weight;   const localInertia = manager.allocVector3();   localInertia.setValue( 0, 0, 0 );    if ( weight !== 0 ) {     shape.calculateLocalInertia( weight, localInertia );    }    const boneOffsetForm = manager.allocTransform();   manager.setIdentity( boneOffsetForm );   manager.setOriginFromArray3( boneOffsetForm, params.position );   manager.setBasisFromArray3( boneOffsetForm, params.rotation );    const vector = manager.allocThreeVector3();   const boneForm = manager.allocTransform();   manager.setIdentity( boneForm );   manager.setOriginFromThreeVector3( boneForm, bone.getWorldPosition( vector ) );    const form = manager.multiplyTransforms( boneForm, boneOffsetForm );   const state = new Ammo.btDefaultMotionState( form );    const info = new Ammo.btRigidBodyConstructionInfo( weight, state, shape, localInertia );   info.set_m_friction( params.friction );   info.set_m_restitution( params.restitution );    const body = new Ammo.btRigidBody( info );    if ( params.type === 0 ) {     body.setCollisionFlags( body.getCollisionFlags() | 2 );     /*     * It'd be better to comment out this line though in general I should call this method     * because I'm not sure why but physics will be more like MMD's     * if I comment out.     */    body.setActivationState( 4 );    }    body.setDamping( params.positionDamping, params.rotationDamping );   body.setSleepingThresholds( 0, 0 );    this.world.addRigidBody( body, 1 << params.groupIndex, params.groupTarget );    this.body = body;   this.bone = bone;   this.boneOffsetForm = boneOffsetForm;   this.boneOffsetFormInverse = manager.inverseTransform( boneOffsetForm );    manager.freeVector3( localInertia );   manager.freeTransform( form );   manager.freeTransform( boneForm );   manager.freeThreeVector3( vector );   }   _getBoneTransform() {    const manager = this.manager;   const p = manager.allocThreeVector3();   const q = manager.allocThreeQuaternion();   const s = manager.allocThreeVector3();    this.bone.matrixWorld.decompose( p, q, s );    const tr = manager.allocTransform();   manager.setOriginFromThreeVector3( tr, p );   manager.setBasisFromThreeQuaternion( tr, q );    const form = manager.multiplyTransforms( tr, this.boneOffsetForm );    manager.freeTransform( tr );   manager.freeThreeVector3( s );   manager.freeThreeQuaternion( q );   manager.freeThreeVector3( p );    return form;   }   _getWorldTransformForBone() {    const manager = this.manager;   const tr = this.body.getCenterOfMassTransform();   return manager.multiplyTransforms( tr, this.boneOffsetFormInverse );   }   _setTransformFromBone() {    const manager = this.manager;   const form = this._getBoneTransform();    // TODO: check the most appropriate way to set   //this.body.setWorldTransform( form );   this.body.setCenterOfMassTransform( form );   this.body.getMotionState().setWorldTransform( form );    manager.freeTransform( form );   }   _setPositionFromBone() {    const manager = this.manager;   const form = this._getBoneTransform();    const tr = manager.allocTransform();   this.body.getMotionState().getWorldTransform( tr );   manager.copyOrigin( tr, form );    // TODO: check the most appropriate way to set   //this.body.setWorldTransform( tr );   this.body.setCenterOfMassTransform( tr );   this.body.getMotionState().setWorldTransform( tr );    manager.freeTransform( tr );   manager.freeTransform( form );   }   _updateBoneRotation() {    const manager = this.manager;    const tr = this._getWorldTransformForBone();   const q = manager.getBasis( tr );    const thQ = manager.allocThreeQuaternion();   const thQ2 = manager.allocThreeQuaternion();   const thQ3 = manager.allocThreeQuaternion();    thQ.set( q.x(), q.y(), q.z(), q.w() );   thQ2.setFromRotationMatrix( this.bone.matrixWorld );   thQ2.conjugate();   thQ2.multiply( thQ );    //this.bone.quaternion.multiply( thQ2 );    thQ3.setFromRotationMatrix( this.bone.matrix );    // Renormalizing quaternion here because repeatedly transforming   // quaternion continuously accumulates floating point error and   // can end up being overflow. See #15335   this.bone.quaternion.copy( thQ2.multiply( thQ3 ).normalize() );    manager.freeThreeQuaternion( thQ );   manager.freeThreeQuaternion( thQ2 );   manager.freeThreeQuaternion( thQ3 );    manager.freeQuaternion( q );   manager.freeTransform( tr );   }   _updateBonePosition() {    const manager = this.manager;    const tr = this._getWorldTransformForBone();    const thV = manager.allocThreeVector3();    const o = manager.getOrigin( tr );   thV.set( o.x(), o.y(), o.z() );    if ( this.bone.parent ) {     this.bone.parent.worldToLocal( thV );    }    this.bone.position.copy( thV );    manager.freeThreeVector3( thV );    manager.freeTransform( tr );   }  }  //  class Constraint {   /**   * @param {THREE.SkinnedMesh} mesh   * @param {Ammo.btDiscreteDynamicsWorld} world   * @param {RigidBody} bodyA   * @param {RigidBody} bodyB   * @param {Object} params   * @param {ResourceManager} manager   */  constructor( mesh, world, bodyA, bodyB, params, manager ) {    this.mesh = mesh;   this.world = world;   this.bodyA = bodyA;   this.bodyB = bodyB;   this.params = params;   this.manager = manager;    this.constraint = null;    this._init();   }   // private method   _init() {    const manager = this.manager;   const params = this.params;   const bodyA = this.bodyA;   const bodyB = this.bodyB;    const form = manager.allocTransform();   manager.setIdentity( form );   manager.setOriginFromArray3( form, params.position );   manager.setBasisFromArray3( form, params.rotation );    const formA = manager.allocTransform();   const formB = manager.allocTransform();    bodyA.body.getMotionState().getWorldTransform( formA );   bodyB.body.getMotionState().getWorldTransform( formB );    const formInverseA = manager.inverseTransform( formA );   const formInverseB = manager.inverseTransform( formB );    const formA2 = manager.multiplyTransforms( formInverseA, form );   const formB2 = manager.multiplyTransforms( formInverseB, form );    const constraint = new Ammo.btGeneric6DofSpringConstraint( bodyA.body, bodyB.body, formA2, formB2, true );    const lll = manager.allocVector3();   const lul = manager.allocVector3();   const all = manager.allocVector3();   const aul = manager.allocVector3();    lll.setValue( params.translationLimitation1[ 0 ],                 params.translationLimitation1[ 1 ],                 params.translationLimitation1[ 2 ] );   lul.setValue( params.translationLimitation2[ 0 ],                 params.translationLimitation2[ 1 ],                 params.translationLimitation2[ 2 ] );   all.setValue( params.rotationLimitation1[ 0 ],                 params.rotationLimitation1[ 1 ],                 params.rotationLimitation1[ 2 ] );   aul.setValue( params.rotationLimitation2[ 0 ],                 params.rotationLimitation2[ 1 ],                 params.rotationLimitation2[ 2 ] );    constraint.setLinearLowerLimit( lll );   constraint.setLinearUpperLimit( lul );   constraint.setAngularLowerLimit( all );   constraint.setAngularUpperLimit( aul );    for ( let i = 0; i < 3; i ++ ) {     if ( params.springPosition[ i ] !== 0 ) {      constraint.enableSpring( i, true );     constraint.setStiffness( i, params.springPosition[ i ] );     }    }    for ( let i = 0; i < 3; i ++ ) {     if ( params.springRotation[ i ] !== 0 ) {      constraint.enableSpring( i + 3, true );     constraint.setStiffness( i + 3, params.springRotation[ i ] );     }    }    /*    * Currently(10/31/2016) official ammo.js doesn't support    * btGeneric6DofSpringConstraint.setParam method.    * You need custom ammo.js (add the method into idl) if you wanna use.    * By setting this parameter, physics will be more like MMD's    */   if ( constraint.setParam !== undefined ) {     for ( let i = 0; i < 6; i ++ ) {      constraint.setParam( 2, 0.475, i );     }    }    this.world.addConstraint( constraint, true );   this.constraint = constraint;    manager.freeTransform( form );   manager.freeTransform( formA );   manager.freeTransform( formB );   manager.freeTransform( formInverseA );   manager.freeTransform( formInverseB );   manager.freeTransform( formA2 );   manager.freeTransform( formB2 );   manager.freeVector3( lll );   manager.freeVector3( lul );   manager.freeVector3( all );   manager.freeVector3( aul );   }  }  //  const _position = new Vector3(); const _quaternion = new Quaternion(); const _scale = new Vector3(); const _matrixWorldInv = new Matrix4();  class MMDPhysicsHelper extends Object3D {   /**   * Visualize Rigid bodies   *   * @param {THREE.SkinnedMesh} mesh   * @param {Physics} physics   */  constructor( mesh, physics ) {    super();    this.root = mesh;   this.physics = physics;    this.matrix.copy( mesh.matrixWorld );   this.matrixAutoUpdate = false;    this.materials = [];    this.materials.push(    new MeshBasicMaterial( {     color: new Color( 0xff8888 ),     wireframe: true,     depthTest: false,     depthWrite: false,     opacity: 0.25,     transparent: true    } )   );    this.materials.push(    new MeshBasicMaterial( {     color: new Color( 0x88ff88 ),     wireframe: true,     depthTest: false,     depthWrite: false,     opacity: 0.25,     transparent: true    } )   );    this.materials.push(    new MeshBasicMaterial( {     color: new Color( 0x8888ff ),     wireframe: true,     depthTest: false,     depthWrite: false,     opacity: 0.25,     transparent: true    } )   );    this._init();   }    /**   * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.   */  dispose() {    const materials = this.materials;   const children = this.children;    for ( let i = 0; i < materials.length; i ++ ) {     materials[ i ].dispose();    }    for ( let i = 0; i < children.length; i ++ ) {     const child = children[ i ];     if ( child.isMesh ) child.geometry.dispose();    }   }   /**   * Updates Rigid Bodies visualization.   */  updateMatrixWorld( force ) {    var mesh = this.root;    if ( this.visible ) {     var bodies = this.physics.bodies;     _matrixWorldInv     .copy( mesh.matrixWorld )     .decompose( _position, _quaternion, _scale )     .compose( _position, _quaternion, _scale.set( 1, 1, 1 ) )     .invert();     for ( var i = 0, il = bodies.length; i < il; i ++ ) {      var body = bodies[ i ].body;     var child = this.children[ i ];      var tr = body.getCenterOfMassTransform();     var origin = tr.getOrigin();     var rotation = tr.getRotation();      child.position      .set( origin.x(), origin.y(), origin.z() )      .applyMatrix4( _matrixWorldInv );      child.quaternion      .setFromRotationMatrix( _matrixWorldInv )      .multiply(       _quaternion.set( rotation.x(), rotation.y(), rotation.z(), rotation.w() )      );     }    }    this.matrix    .copy( mesh.matrixWorld )    .decompose( _position, _quaternion, _scale )    .compose( _position, _quaternion, _scale.set( 1, 1, 1 ) );    super.updateMatrixWorld( force );   }   // private method   _init() {    var bodies = this.physics.bodies;    function createGeometry( param ) {     switch ( param.shapeType ) {      case 0:      return new SphereGeometry( param.width, 16, 8 );      case 1:      return new BoxGeometry( param.width * 2, param.height * 2, param.depth * 2, 8, 8, 8 );      case 2:      return new CapsuleGeometry( param.width, param.height, 8, 16 );      default:      return null;     }    }    for ( var i = 0, il = bodies.length; i < il; i ++ ) {     var param = bodies[ i ].params;    this.add( new Mesh( createGeometry( param ), this.materials[ param.type ] ) );    }   }  }  export { MMDPhysics }; 
^..^ FILENAME ^..^
addons|cameras|CinematicCamera.js
^..^ CONTENTS ^..^
import {  Mesh,  OrthographicCamera,  PerspectiveCamera,  PlaneGeometry,  Scene,  ShaderMaterial,  UniformsUtils,  WebGLRenderTarget } from 'three';  import { BokehShader, BokehDepthShader } from '../shaders/BokehShader2.js';  class CinematicCamera extends PerspectiveCamera {   constructor( fov, aspect, near, far ) {    super( fov, aspect, near, far );    this.type = 'CinematicCamera';    this.postprocessing = { enabled: true };   this.shaderSettings = {    rings: 3,    samples: 4   };    const depthShader = BokehDepthShader;    this.materialDepth = new ShaderMaterial( {    uniforms: depthShader.uniforms,    vertexShader: depthShader.vertexShader,    fragmentShader: depthShader.fragmentShader   } );    this.materialDepth.uniforms[ 'mNear' ].value = near;   this.materialDepth.uniforms[ 'mFar' ].value = far;    // In case of cinematicCamera, having a default lens set is important   this.setLens();    this.initPostProcessing();   }   // providing fnumber and coc(Circle of Confusion) as extra arguments  // In case of cinematicCamera, having a default lens set is important  // if fnumber and coc are not provided, cinematicCamera tries to act as a basic PerspectiveCamera  setLens( focalLength = 35, filmGauge = 35, fNumber = 8, coc = 0.019 ) {    this.filmGauge = filmGauge;    this.setFocalLength( focalLength );    this.fNumber = fNumber;   this.coc = coc;    // fNumber is focalLength by aperture   this.aperture = focalLength / this.fNumber;    // hyperFocal is required to calculate depthOfField when a lens tries to focus at a distance with given fNumber and focalLength   this.hyperFocal = ( focalLength * focalLength ) / ( this.aperture * this.coc );   }   linearize( depth ) {    const zfar = this.far;   const znear = this.near;   return - zfar * znear / ( depth * ( zfar - znear ) - zfar );   }   smoothstep( near, far, depth ) {    const x = this.saturate( ( depth - near ) / ( far - near ) );   return x * x * ( 3 - 2 * x );   }   saturate( x ) {    return Math.max( 0, Math.min( 1, x ) );   }   // function for focusing at a distance from the camera  focusAt( focusDistance = 20 ) {    const focalLength = this.getFocalLength();    // distance from the camera (normal to frustrum) to focus on   this.focus = focusDistance;    // the nearest point from the camera which is in focus (unused)   this.nearPoint = ( this.hyperFocal * this.focus ) / ( this.hyperFocal + ( this.focus - focalLength ) );    // the farthest point from the camera which is in focus (unused)   this.farPoint = ( this.hyperFocal * this.focus ) / ( this.hyperFocal - ( this.focus - focalLength ) );    // the gap or width of the space in which is everything is in focus (unused)   this.depthOfField = this.farPoint - this.nearPoint;    // Considering minimum distance of focus for a standard lens (unused)   if ( this.depthOfField < 0 ) this.depthOfField = 0;    this.sdistance = this.smoothstep( this.near, this.far, this.focus );    this.ldistance = this.linearize( 1 - this.sdistance );    this.postprocessing.bokeh_uniforms[ 'focalDepth' ].value = this.ldistance;   }   initPostProcessing() {    if ( this.postprocessing.enabled ) {     this.postprocessing.scene = new Scene();     this.postprocessing.camera = new OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 10000, 10000 );     this.postprocessing.scene.add( this.postprocessing.camera );     this.postprocessing.rtTextureDepth = new WebGLRenderTarget( window.innerWidth, window.innerHeight );    this.postprocessing.rtTextureColor = new WebGLRenderTarget( window.innerWidth, window.innerHeight );     const bokeh_shader = BokehShader;     this.postprocessing.bokeh_uniforms = UniformsUtils.clone( bokeh_shader.uniforms );     this.postprocessing.bokeh_uniforms[ 'tColor' ].value = this.postprocessing.rtTextureColor.texture;    this.postprocessing.bokeh_uniforms[ 'tDepth' ].value = this.postprocessing.rtTextureDepth.texture;     this.postprocessing.bokeh_uniforms[ 'manualdof' ].value = 0;    this.postprocessing.bokeh_uniforms[ 'shaderFocus' ].value = 0;     this.postprocessing.bokeh_uniforms[ 'fstop' ].value = 2.8;     this.postprocessing.bokeh_uniforms[ 'showFocus' ].value = 1;     this.postprocessing.bokeh_uniforms[ 'focalDepth' ].value = 0.1;     //console.log( this.postprocessing.bokeh_uniforms[ "focalDepth" ].value );     this.postprocessing.bokeh_uniforms[ 'znear' ].value = this.near;    this.postprocessing.bokeh_uniforms[ 'zfar' ].value = this.near;      this.postprocessing.bokeh_uniforms[ 'textureWidth' ].value = window.innerWidth;     this.postprocessing.bokeh_uniforms[ 'textureHeight' ].value = window.innerHeight;     this.postprocessing.materialBokeh = new ShaderMaterial( {     uniforms: this.postprocessing.bokeh_uniforms,     vertexShader: bokeh_shader.vertexShader,     fragmentShader: bokeh_shader.fragmentShader,     defines: {      RINGS: this.shaderSettings.rings,      SAMPLES: this.shaderSettings.samples,      DEPTH_PACKING: 1     }    } );     this.postprocessing.quad = new Mesh( new PlaneGeometry( window.innerWidth, window.innerHeight ), this.postprocessing.materialBokeh );    this.postprocessing.quad.position.z = - 500;    this.postprocessing.scene.add( this.postprocessing.quad );    }   }   renderCinematic( scene, renderer ) {    if ( this.postprocessing.enabled ) {     const currentRenderTarget = renderer.getRenderTarget();     renderer.clear();     // Render scene into texture     scene.overrideMaterial = null;    renderer.setRenderTarget( this.postprocessing.rtTextureColor );    renderer.clear();    renderer.render( scene, this );     // Render depth into texture     scene.overrideMaterial = this.materialDepth;    renderer.setRenderTarget( this.postprocessing.rtTextureDepth );    renderer.clear();    renderer.render( scene, this );     // Render bokeh composite     renderer.setRenderTarget( null );    renderer.render( this.postprocessing.scene, this.postprocessing.camera );     renderer.setRenderTarget( currentRenderTarget );    }   }  }  export { CinematicCamera }; 
^..^ FILENAME ^..^
addons|capabilities|WebGL.js
^..^ CONTENTS ^..^
class WebGL {   static isWebGL2Available() {    try {     const canvas = document.createElement( 'canvas' );    return !! ( window.WebGL2RenderingContext && canvas.getContext( 'webgl2' ) );    } catch ( e ) {     return false;    }   }   static isColorSpaceAvailable( colorSpace ) {    try {     const canvas = document.createElement( 'canvas' );    const ctx = window.WebGL2RenderingContext && canvas.getContext( 'webgl2' );    ctx.drawingBufferColorSpace = colorSpace;    return ctx.drawingBufferColorSpace === colorSpace; // deepscan-disable-line SAME_OPERAND_VALUE    } catch ( e ) {     return false;    }   }   static getWebGL2ErrorMessage() {    return this.getErrorMessage( 2 );   }   static getErrorMessage( version ) {    const names = {    1: 'WebGL',    2: 'WebGL 2'   };    const contexts = {    1: window.WebGLRenderingContext,    2: window.WebGL2RenderingContext   };    let message = 'Your $0 does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">$1</a>';    const element = document.createElement( 'div' );   element.id = 'webglmessage';   element.style.fontFamily = 'monospace';   element.style.fontSize = '13px';   element.style.fontWeight = 'normal';   element.style.textAlign = 'center';   element.style.background = '#fff';   element.style.color = '#000';   element.style.padding = '1.5em';   element.style.width = '400px';   element.style.margin = '5em auto 0';    if ( contexts[ version ] ) {     message = message.replace( '$0', 'graphics card' );    } else {     message = message.replace( '$0', 'browser' );    }    message = message.replace( '$1', names[ version ] );    element.innerHTML = message;    return element;   }   // @deprecated, r168   static isWebGLAvailable() {    console.warn( 'isWebGLAvailable() has been deprecated and will be removed in r178. Use isWebGL2Available() instead.' );    try {     const canvas = document.createElement( 'canvas' );    return !! ( window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) ) );    } catch ( e ) {     return false;    }   }   static getWebGLErrorMessage() {    console.warn( 'getWebGLErrorMessage() has been deprecated and will be removed in r178. Use getWebGL2ErrorMessage() instead.' );    return this.getErrorMessage( 1 );   }  }  export default WebGL; 
^..^ FILENAME ^..^
addons|capabilities|WebGPU.js
^..^ CONTENTS ^..^
if ( self.GPUShaderStage === undefined ) {   self.GPUShaderStage = { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };  }  // statics  let isAvailable = navigator.gpu !== undefined;   if ( typeof window !== 'undefined' && isAvailable ) {   isAvailable = await navigator.gpu.requestAdapter();  }  class WebGPU {   static isAvailable() {    return Boolean( isAvailable );   }   static getStaticAdapter() {    return isAvailable;   }   static getErrorMessage() {    const message = 'Your browser does not support <a href="https://gpuweb.github.io/gpuweb/" style="color:blue">WebGPU</a> yet';    const element = document.createElement( 'div' );   element.id = 'webgpumessage';   element.style.fontFamily = 'monospace';   element.style.fontSize = '13px';   element.style.fontWeight = 'normal';   element.style.textAlign = 'center';   element.style.background = '#fff';   element.style.color = '#000';   element.style.padding = '1.5em';   element.style.maxWidth = '400px';   element.style.margin = '5em auto 0';    element.innerHTML = message;    return element;   }  }   export default WebGPU; 
^..^ FILENAME ^..^
addons|controls|ArcballControls.js
^..^ CONTENTS ^..^
import {  Controls,  GridHelper,  EllipseCurve,  BufferGeometry,  Line,  LineBasicMaterial,  Raycaster,  Group,  Box3,  Sphere,  Quaternion,  Vector2,  Vector3,  Matrix4,  MathUtils } from 'three';  //trackball state const STATE = {   IDLE: Symbol(),  ROTATE: Symbol(),  PAN: Symbol(),  SCALE: Symbol(),  FOV: Symbol(),  FOCUS: Symbol(),  ZROTATE: Symbol(),  TOUCH_MULTI: Symbol(),  ANIMATION_FOCUS: Symbol(),  ANIMATION_ROTATE: Symbol()  };  const INPUT = {   NONE: Symbol(),  ONE_FINGER: Symbol(),  ONE_FINGER_SWITCHED: Symbol(),  TWO_FINGER: Symbol(),  MULT_FINGER: Symbol(),  CURSOR: Symbol()  };  //cursor center coordinates const _center = {   x: 0,  y: 0  };  //transformation matrices for gizmos and camera const _transformation = {   camera: new Matrix4(),  gizmos: new Matrix4()  };  //events const _changeEvent = { type: 'change' }; const _startEvent = { type: 'start' }; const _endEvent = { type: 'end' };  const _raycaster = new Raycaster(); const _offset = new Vector3();  const _gizmoMatrixStateTemp = new Matrix4(); const _cameraMatrixStateTemp = new Matrix4(); const _scalePointTemp = new Vector3(); /**  *  * @param {Camera} camera Virtual camera used in the scene  * @param {HTMLElement} domElement Renderer's dom element  * @param {Scene} scene The scene to be rendered  */ class ArcballControls extends Controls {   constructor( camera, domElement = null, scene = null ) {    super( camera, domElement );    this.scene = scene;   this.target = new Vector3();   this._currentTarget = new Vector3();   this.radiusFactor = 0.67;    this.mouseActions = [];   this._mouseOp = null;     //global vectors and matrices that are used in some operations to avoid creating new objects every time (e.g. every time cursor moves)   this._v2_1 = new Vector2();   this._v3_1 = new Vector3();   this._v3_2 = new Vector3();    this._m4_1 = new Matrix4();   this._m4_2 = new Matrix4();    this._quat = new Quaternion();    //transformation matrices   this._translationMatrix = new Matrix4(); //matrix for translation operation   this._rotationMatrix = new Matrix4(); //matrix for rotation operation   this._scaleMatrix = new Matrix4(); //matrix for scaling operation    this._rotationAxis = new Vector3(); //axis for rotate operation     //camera state   this._cameraMatrixState = new Matrix4();   this._cameraProjectionState = new Matrix4();    this._fovState = 1;   this._upState = new Vector3();   this._zoomState = 1;   this._nearPos = 0;   this._farPos = 0;    this._gizmoMatrixState = new Matrix4();    //initial values   this._up0 = new Vector3();   this._zoom0 = 1;   this._fov0 = 0;   this._initialNear = 0;   this._nearPos0 = 0;   this._initialFar = 0;   this._farPos0 = 0;   this._cameraMatrixState0 = new Matrix4();   this._gizmoMatrixState0 = new Matrix4();    //pointers array   this._button = - 1;   this._touchStart = [];   this._touchCurrent = [];   this._input = INPUT.NONE;    //two fingers touch interaction   this._switchSensibility = 32; //minimum movement to be performed to fire single pan start after the second finger has been released   this._startFingerDistance = 0; //distance between two fingers   this._currentFingerDistance = 0;   this._startFingerRotation = 0; //amount of rotation performed with two fingers   this._currentFingerRotation = 0;    //double tap   this._devPxRatio = 0;   this._downValid = true;   this._nclicks = 0;   this._downEvents = [];   this._downStart = 0; //pointerDown time   this._clickStart = 0; //first click time   this._maxDownTime = 250;   this._maxInterval = 300;   this._posThreshold = 24;   this._movementThreshold = 24;    //cursor positions   this._currentCursorPosition = new Vector3();   this._startCursorPosition = new Vector3();    //grid   this._grid = null; //grid to be visualized during pan operation   this._gridPosition = new Vector3();    //gizmos   this._gizmos = new Group();   this._curvePts = 128;     //animations   this._timeStart = - 1; //initial time   this._animationId = - 1;    //focus animation   this.focusAnimationTime = 500; //duration of focus animation in ms    //rotate animation   this._timePrev = 0; //time at which previous rotate operation has been detected   this._timeCurrent = 0; //time at which current rotate operation has been detected   this._anglePrev = 0; //angle of previous rotation   this._angleCurrent = 0; //angle of current rotation   this._cursorPosPrev = new Vector3(); //cursor position when previous rotate operation has been detected   this._cursorPosCurr = new Vector3();//cursor position when current rotate operation has been detected   this._wPrev = 0; //angular velocity of the previous rotate operation   this._wCurr = 0; //angular velocity of the current rotate operation     //parameters   this.adjustNearFar = false;   this.scaleFactor = 1.1; //zoom/distance multiplier   this.dampingFactor = 25;   this.wMax = 20; //maximum angular velocity allowed   this.enableAnimations = true; //if animations should be performed   this.enableGrid = false; //if grid should be showed during pan operation   this.cursorZoom = false; //if wheel zoom should be cursor centered   this.minFov = 5;   this.maxFov = 90;   this.rotateSpeed = 1;    this.enablePan = true;   this.enableRotate = true;   this.enableZoom = true;   this.enableGizmos = true;    this.minDistance = 0;   this.maxDistance = Infinity;   this.minZoom = 0;   this.maxZoom = Infinity;    //trackball parameters   this._tbRadius = 1;    //FSA   this._state = STATE.IDLE;    this.setCamera( camera );    if ( this.scene != null ) {     this.scene.add( this._gizmos );    }    this.initializeMouseActions();    // event listeners    this._onContextMenu = onContextMenu.bind( this );   this._onWheel = onWheel.bind( this );   this._onPointerUp = onPointerUp.bind( this );   this._onPointerMove = onPointerMove.bind( this );   this._onPointerDown = onPointerDown.bind( this );   this._onPointerCancel = onPointerCancel.bind( this );   this._onWindowResize = onWindowResize.bind( this );    if ( domElement !== null ) {     this.connect();    }   }   connect() {    this.domElement.style.touchAction = 'none';   this._devPxRatio = window.devicePixelRatio;    this.domElement.addEventListener( 'contextmenu', this._onContextMenu );   this.domElement.addEventListener( 'wheel', this._onWheel );   this.domElement.addEventListener( 'pointerdown', this._onPointerDown );   this.domElement.addEventListener( 'pointercancel', this._onPointerCancel );    window.addEventListener( 'resize', this._onWindowResize );   }   disconnect() {    this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );   this.domElement.removeEventListener( 'pointercancel', this._onPointerCancel );   this.domElement.removeEventListener( 'wheel', this._onWheel );   this.domElement.removeEventListener( 'contextmenu', this._onContextMenu );    window.removeEventListener( 'pointermove', this._onPointerMove );   window.removeEventListener( 'pointerup', this._onPointerUp );    window.removeEventListener( 'resize', this._onWindowResize );   }   onSinglePanStart( event, operation ) {    if ( this.enabled ) {     this.dispatchEvent( _startEvent );     this.setCenter( event.clientX, event.clientY );     switch ( operation ) {      case 'PAN':       if ( ! this.enablePan ) {        return;       }       if ( this._animationId != - 1 ) {        cancelAnimationFrame( this._animationId );       this._animationId = - 1;       this._timeStart = - 1;        this.activateGizmos( false );       this.dispatchEvent( _changeEvent );       }       this.updateTbState( STATE.PAN, true );      this._startCursorPosition.copy( this.unprojectOnTbPlane( this.object, _center.x, _center.y, this.domElement ) );      if ( this.enableGrid ) {        this.drawGrid();       this.dispatchEvent( _changeEvent );       }       break;      case 'ROTATE':       if ( ! this.enableRotate ) {        return;       }       if ( this._animationId != - 1 ) {        cancelAnimationFrame( this._animationId );       this._animationId = - 1;       this._timeStart = - 1;       }       this.updateTbState( STATE.ROTATE, true );      this._startCursorPosition.copy( this.unprojectOnTbSurface( this.object, _center.x, _center.y, this.domElement, this._tbRadius ) );      this.activateGizmos( true );      if ( this.enableAnimations ) {        this._timePrev = this._timeCurrent = performance.now();       this._angleCurrent = this._anglePrev = 0;       this._cursorPosPrev.copy( this._startCursorPosition );       this._cursorPosCurr.copy( this._cursorPosPrev );       this._wCurr = 0;       this._wPrev = this._wCurr;       }       this.dispatchEvent( _changeEvent );      break;      case 'FOV':       if ( ! this.object.isPerspectiveCamera || ! this.enableZoom ) {        return;       }       if ( this._animationId != - 1 ) {        cancelAnimationFrame( this._animationId );       this._animationId = - 1;       this._timeStart = - 1;        this.activateGizmos( false );       this.dispatchEvent( _changeEvent );       }       this.updateTbState( STATE.FOV, true );      this._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );      this._currentCursorPosition.copy( this._startCursorPosition );      break;      case 'ZOOM':       if ( ! this.enableZoom ) {        return;       }       if ( this._animationId != - 1 ) {        cancelAnimationFrame( this._animationId );       this._animationId = - 1;       this._timeStart = - 1;        this.activateGizmos( false );       this.dispatchEvent( _changeEvent );       }       this.updateTbState( STATE.SCALE, true );      this._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );      this._currentCursorPosition.copy( this._startCursorPosition );      break;     }    }   }   onSinglePanMove( event, opState ) {    if ( this.enabled ) {     const restart = opState != this._state;    this.setCenter( event.clientX, event.clientY );     switch ( opState ) {      case STATE.PAN:       if ( this.enablePan ) {        if ( restart ) {         //switch to pan operation         this.dispatchEvent( _endEvent );        this.dispatchEvent( _startEvent );         this.updateTbState( opState, true );        this._startCursorPosition.copy( this.unprojectOnTbPlane( this.object, _center.x, _center.y, this.domElement ) );        if ( this.enableGrid ) {          this.drawGrid();         }         this.activateGizmos( false );        } else {         //continue with pan operation        this._currentCursorPosition.copy( this.unprojectOnTbPlane( this.object, _center.x, _center.y, this.domElement ) );        this.applyTransformMatrix( this.pan( this._startCursorPosition, this._currentCursorPosition ) );        }       }       break;      case STATE.ROTATE:       if ( this.enableRotate ) {        if ( restart ) {         //switch to rotate operation         this.dispatchEvent( _endEvent );        this.dispatchEvent( _startEvent );         this.updateTbState( opState, true );        this._startCursorPosition.copy( this.unprojectOnTbSurface( this.object, _center.x, _center.y, this.domElement, this._tbRadius ) );         if ( this.enableGrid ) {          this.disposeGrid();         }         this.activateGizmos( true );        } else {         //continue with rotate operation        this._currentCursorPosition.copy( this.unprojectOnTbSurface( this.object, _center.x, _center.y, this.domElement, this._tbRadius ) );         const distance = this._startCursorPosition.distanceTo( this._currentCursorPosition );        const angle = this._startCursorPosition.angleTo( this._currentCursorPosition );        const amount = Math.max( distance / this._tbRadius, angle ) * this.rotateSpeed; //effective rotation angle         this.applyTransformMatrix( this.rotate( this.calculateRotationAxis( this._startCursorPosition, this._currentCursorPosition ), amount ) );         if ( this.enableAnimations ) {          this._timePrev = this._timeCurrent;         this._timeCurrent = performance.now();         this._anglePrev = this._angleCurrent;         this._angleCurrent = amount;         this._cursorPosPrev.copy( this._cursorPosCurr );         this._cursorPosCurr.copy( this._currentCursorPosition );         this._wPrev = this._wCurr;         this._wCurr = this.calculateAngularSpeed( this._anglePrev, this._angleCurrent, this._timePrev, this._timeCurrent );         }        }       }       break;      case STATE.SCALE:       if ( this.enableZoom ) {        if ( restart ) {         //switch to zoom operation         this.dispatchEvent( _endEvent );        this.dispatchEvent( _startEvent );         this.updateTbState( opState, true );        this._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );        this._currentCursorPosition.copy( this._startCursorPosition );         if ( this.enableGrid ) {          this.disposeGrid();         }         this.activateGizmos( false );        } else {         //continue with zoom operation        const screenNotches = 8; //how many wheel notches corresponds to a full screen pan        this._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );         const movement = this._currentCursorPosition.y - this._startCursorPosition.y;         let size = 1;         if ( movement < 0 ) {          size = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) );         } else if ( movement > 0 ) {          size = Math.pow( this.scaleFactor, movement * screenNotches );         }         this._v3_1.setFromMatrixPosition( this._gizmoMatrixState );         this.applyTransformMatrix( this.scale( size, this._v3_1 ) );        }       }       break;      case STATE.FOV:       if ( this.enableZoom && this.object.isPerspectiveCamera ) {        if ( restart ) {         //switch to fov operation         this.dispatchEvent( _endEvent );        this.dispatchEvent( _startEvent );         this.updateTbState( opState, true );        this._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );        this._currentCursorPosition.copy( this._startCursorPosition );         if ( this.enableGrid ) {          this.disposeGrid();         }         this.activateGizmos( false );        } else {         //continue with fov operation        const screenNotches = 8; //how many wheel notches corresponds to a full screen pan        this._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );         const movement = this._currentCursorPosition.y - this._startCursorPosition.y;         let size = 1;         if ( movement < 0 ) {          size = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) );         } else if ( movement > 0 ) {          size = Math.pow( this.scaleFactor, movement * screenNotches );         }         this._v3_1.setFromMatrixPosition( this._cameraMatrixState );        const x = this._v3_1.distanceTo( this._gizmos.position );        let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed         //check min and max distance        xNew = MathUtils.clamp( xNew, this.minDistance, this.maxDistance );         const y = x * Math.tan( MathUtils.DEG2RAD * this._fovState * 0.5 );         //calculate new fov        let newFov = MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 );         //check min and max fov        newFov = MathUtils.clamp( newFov, this.minFov, this.maxFov );         const newDistance = y / Math.tan( MathUtils.DEG2RAD * ( newFov / 2 ) );        size = x / newDistance;        this._v3_2.setFromMatrixPosition( this._gizmoMatrixState );         this.setFov( newFov );        this.applyTransformMatrix( this.scale( size, this._v3_2, false ) );         //adjusting distance        _offset.copy( this._gizmos.position ).sub( this.object.position ).normalize().multiplyScalar( newDistance / x );        this._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z );        }       }       break;     }     this.dispatchEvent( _changeEvent );    }   }   onSinglePanEnd() {    if ( this._state == STATE.ROTATE ) {      if ( ! this.enableRotate ) {      return;     }     if ( this.enableAnimations ) {      //perform rotation animation     const deltaTime = ( performance.now() - this._timeCurrent );     if ( deltaTime < 120 ) {       const w = Math.abs( ( this._wPrev + this._wCurr ) / 2 );       const self = this;      this._animationId = window.requestAnimationFrame( function ( t ) {        self.updateTbState( STATE.ANIMATION_ROTATE, true );       const rotationAxis = self.calculateRotationAxis( self._cursorPosPrev, self._cursorPosCurr );        self.onRotationAnim( t, rotationAxis, Math.min( w, self.wMax ) );       } );      } else {       //cursor has been standing still for over 120 ms since last movement      this.updateTbState( STATE.IDLE, false );      this.activateGizmos( false );      this.dispatchEvent( _changeEvent );      }     } else {      this.updateTbState( STATE.IDLE, false );     this.activateGizmos( false );     this.dispatchEvent( _changeEvent );     }    } else if ( this._state == STATE.PAN || this._state == STATE.IDLE ) {     this.updateTbState( STATE.IDLE, false );     if ( this.enableGrid ) {      this.disposeGrid();     }     this.activateGizmos( false );    this.dispatchEvent( _changeEvent );     }    this.dispatchEvent( _endEvent );   }   onDoubleTap( event ) {    if ( this.enabled && this.enablePan && this.scene != null ) {     this.dispatchEvent( _startEvent );     this.setCenter( event.clientX, event.clientY );    const hitP = this.unprojectOnObj( this.getCursorNDC( _center.x, _center.y, this.domElement ), this.object );     if ( hitP != null && this.enableAnimations ) {      const self = this;     if ( this._animationId != - 1 ) {       window.cancelAnimationFrame( this._animationId );      }      this._timeStart = - 1;     this._animationId = window.requestAnimationFrame( function ( t ) {       self.updateTbState( STATE.ANIMATION_FOCUS, true );      self.onFocusAnim( t, hitP, self._cameraMatrixState, self._gizmoMatrixState );      } );     } else if ( hitP != null && ! this.enableAnimations ) {      this.updateTbState( STATE.FOCUS, true );     this.focus( hitP, this.scaleFactor );     this.updateTbState( STATE.IDLE, false );     this.dispatchEvent( _changeEvent );     }    }    this.dispatchEvent( _endEvent );   }   onDoublePanStart() {    if ( this.enabled && this.enablePan ) {     this.dispatchEvent( _startEvent );     this.updateTbState( STATE.PAN, true );     this.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );    this._startCursorPosition.copy( this.unprojectOnTbPlane( this.object, _center.x, _center.y, this.domElement, true ) );    this._currentCursorPosition.copy( this._startCursorPosition );     this.activateGizmos( false );    }   }   onDoublePanMove() {    if ( this.enabled && this.enablePan ) {     this.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );     if ( this._state != STATE.PAN ) {      this.updateTbState( STATE.PAN, true );     this._startCursorPosition.copy( this._currentCursorPosition );     }     this._currentCursorPosition.copy( this.unprojectOnTbPlane( this.object, _center.x, _center.y, this.domElement, true ) );    this.applyTransformMatrix( this.pan( this._startCursorPosition, this._currentCursorPosition, true ) );    this.dispatchEvent( _changeEvent );    }   }   onDoublePanEnd() {    this.updateTbState( STATE.IDLE, false );   this.dispatchEvent( _endEvent );   }   onRotateStart() {    if ( this.enabled && this.enableRotate ) {     this.dispatchEvent( _startEvent );     this.updateTbState( STATE.ZROTATE, true );     //this._startFingerRotation = event.rotation;     this._startFingerRotation = this.getAngle( this._touchCurrent[ 1 ], this._touchCurrent[ 0 ] ) + this.getAngle( this._touchStart[ 1 ], this._touchStart[ 0 ] );    this._currentFingerRotation = this._startFingerRotation;     this.object.getWorldDirection( this._rotationAxis ); //rotation axis     if ( ! this.enablePan && ! this.enableZoom ) {      this.activateGizmos( true );     }    }   }   onRotateMove() {    if ( this.enabled && this.enableRotate ) {     this.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );    let rotationPoint;     if ( this._state != STATE.ZROTATE ) {      this.updateTbState( STATE.ZROTATE, true );     this._startFingerRotation = this._currentFingerRotation;     }     //this._currentFingerRotation = event.rotation;    this._currentFingerRotation = this.getAngle( this._touchCurrent[ 1 ], this._touchCurrent[ 0 ] ) + this.getAngle( this._touchStart[ 1 ], this._touchStart[ 0 ] );     if ( ! this.enablePan ) {      rotationPoint = new Vector3().setFromMatrixPosition( this._gizmoMatrixState );     } else {      this._v3_2.setFromMatrixPosition( this._gizmoMatrixState );     rotationPoint = this.unprojectOnTbPlane( this.object, _center.x, _center.y, this.domElement ).applyQuaternion( this.object.quaternion ).multiplyScalar( 1 / this.object.zoom ).add( this._v3_2 );     }     const amount = MathUtils.DEG2RAD * ( this._startFingerRotation - this._currentFingerRotation );     this.applyTransformMatrix( this.zRotate( rotationPoint, amount ) );    this.dispatchEvent( _changeEvent );    }   }   onRotateEnd() {    this.updateTbState( STATE.IDLE, false );   this.activateGizmos( false );   this.dispatchEvent( _endEvent );   }   onPinchStart() {    if ( this.enabled && this.enableZoom ) {     this.dispatchEvent( _startEvent );    this.updateTbState( STATE.SCALE, true );     this._startFingerDistance = this.calculatePointersDistance( this._touchCurrent[ 0 ], this._touchCurrent[ 1 ] );    this._currentFingerDistance = this._startFingerDistance;     this.activateGizmos( false );    }   }   onPinchMove() {    if ( this.enabled && this.enableZoom ) {     this.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );    const minDistance = 12; //minimum distance between fingers (in css pixels)     if ( this._state != STATE.SCALE ) {      this._startFingerDistance = this._currentFingerDistance;     this.updateTbState( STATE.SCALE, true );     }     this._currentFingerDistance = Math.max( this.calculatePointersDistance( this._touchCurrent[ 0 ], this._touchCurrent[ 1 ] ), minDistance * this._devPxRatio );    const amount = this._currentFingerDistance / this._startFingerDistance;     let scalePoint;     if ( ! this.enablePan ) {      scalePoint = this._gizmos.position;     } else {      if ( this.object.isOrthographicCamera ) {       scalePoint = this.unprojectOnTbPlane( this.object, _center.x, _center.y, this.domElement )       .applyQuaternion( this.object.quaternion )       .multiplyScalar( 1 / this.object.zoom )       .add( this._gizmos.position );      } else if ( this.object.isPerspectiveCamera ) {       scalePoint = this.unprojectOnTbPlane( this.object, _center.x, _center.y, this.domElement )       .applyQuaternion( this.object.quaternion )       .add( this._gizmos.position );      }     }     this.applyTransformMatrix( this.scale( amount, scalePoint ) );    this.dispatchEvent( _changeEvent );    }   }   onPinchEnd() {    this.updateTbState( STATE.IDLE, false );   this.dispatchEvent( _endEvent );   }   onTriplePanStart() {    if ( this.enabled && this.enableZoom ) {     this.dispatchEvent( _startEvent );     this.updateTbState( STATE.SCALE, true );     //const center = event.center;    let clientX = 0;    let clientY = 0;    const nFingers = this._touchCurrent.length;     for ( let i = 0; i < nFingers; i ++ ) {      clientX += this._touchCurrent[ i ].clientX;     clientY += this._touchCurrent[ i ].clientY;     }     this.setCenter( clientX / nFingers, clientY / nFingers );     this._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );    this._currentCursorPosition.copy( this._startCursorPosition );    }   }   onTriplePanMove() {    if ( this.enabled && this.enableZoom ) {     //   fov / 2    //  ||    //  | |    //  |  |    // x | |    //  |   |    //  |    |    //  | _ _ _|    //   y     //const center = event.center;    let clientX = 0;    let clientY = 0;    const nFingers = this._touchCurrent.length;     for ( let i = 0; i < nFingers; i ++ ) {      clientX += this._touchCurrent[ i ].clientX;     clientY += this._touchCurrent[ i ].clientY;     }     this.setCenter( clientX / nFingers, clientY / nFingers );     const screenNotches = 8; //how many wheel notches corresponds to a full screen pan    this._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );     const movement = this._currentCursorPosition.y - this._startCursorPosition.y;     let size = 1;     if ( movement < 0 ) {      size = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) );     } else if ( movement > 0 ) {      size = Math.pow( this.scaleFactor, movement * screenNotches );     }     this._v3_1.setFromMatrixPosition( this._cameraMatrixState );    const x = this._v3_1.distanceTo( this._gizmos.position );    let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed     //check min and max distance    xNew = MathUtils.clamp( xNew, this.minDistance, this.maxDistance );     const y = x * Math.tan( MathUtils.DEG2RAD * this._fovState * 0.5 );     //calculate new fov    let newFov = MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 );     //check min and max fov    newFov = MathUtils.clamp( newFov, this.minFov, this.maxFov );     const newDistance = y / Math.tan( MathUtils.DEG2RAD * ( newFov / 2 ) );    size = x / newDistance;    this._v3_2.setFromMatrixPosition( this._gizmoMatrixState );     this.setFov( newFov );    this.applyTransformMatrix( this.scale( size, this._v3_2, false ) );     //adjusting distance    _offset.copy( this._gizmos.position ).sub( this.object.position ).normalize().multiplyScalar( newDistance / x );    this._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z );     this.dispatchEvent( _changeEvent );    }   }   onTriplePanEnd() {    this.updateTbState( STATE.IDLE, false );   this.dispatchEvent( _endEvent );   //this.dispatchEvent( _changeEvent );   }   /**   * Set _center's x/y coordinates   * @param {Number} clientX   * @param {Number} clientY   */  setCenter( clientX, clientY ) {    _center.x = clientX;   _center.y = clientY;   }   /**   * Set default mouse actions   */  initializeMouseActions() {    this.setMouseAction( 'PAN', 0, 'CTRL' );   this.setMouseAction( 'PAN', 2 );    this.setMouseAction( 'ROTATE', 0 );    this.setMouseAction( 'ZOOM', 'WHEEL' );   this.setMouseAction( 'ZOOM', 1 );    this.setMouseAction( 'FOV', 'WHEEL', 'SHIFT' );   this.setMouseAction( 'FOV', 1, 'SHIFT' );    }   /**   * Compare two mouse actions   * @param {Object} action1   * @param {Object} action2   * @returns {Boolean} True if action1 and action 2 are the same mouse action, false otherwise   */  compareMouseAction( action1, action2 ) {    if ( action1.operation == action2.operation ) {     if ( action1.mouse == action2.mouse && action1.key == action2.key ) {      return true;     } else {      return false;     }    } else {     return false;    }   }   /**   * Set a new mouse action by specifying the operation to be performed and a mouse/key combination. In case of conflict, replaces the existing one   * @param {String} operation The operation to be performed ('PAN', 'ROTATE', 'ZOOM', 'FOV)   * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches   * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed   * @returns {Boolean} True if the mouse action has been successfully added, false otherwise   */  setMouseAction( operation, mouse, key = null ) {    const operationInput = [ 'PAN', 'ROTATE', 'ZOOM', 'FOV' ];   const mouseInput = [ 0, 1, 2, 'WHEEL' ];   const keyInput = [ 'CTRL', 'SHIFT', null ];   let state;    if ( ! operationInput.includes( operation ) || ! mouseInput.includes( mouse ) || ! keyInput.includes( key ) ) {     //invalid parameters    return false;    }    if ( mouse == 'WHEEL' ) {     if ( operation != 'ZOOM' && operation != 'FOV' ) {      //cannot associate 2D operation to 1D input     return false;     }    }    switch ( operation ) {     case 'PAN':      state = STATE.PAN;     break;     case 'ROTATE':      state = STATE.ROTATE;     break;     case 'ZOOM':      state = STATE.SCALE;     break;     case 'FOV':      state = STATE.FOV;     break;    }    const action = {     operation: operation,    mouse: mouse,    key: key,    state: state    };    for ( let i = 0; i < this.mouseActions.length; i ++ ) {     if ( this.mouseActions[ i ].mouse == action.mouse && this.mouseActions[ i ].key == action.key ) {      this.mouseActions.splice( i, 1, action );     return true;     }    }    this.mouseActions.push( action );   return true;   }   /**   * Remove a mouse action by specifying its mouse/key combination   * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches   * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed   * @returns {Boolean} True if the operation has been succesfully removed, false otherwise   */  unsetMouseAction( mouse, key = null ) {    for ( let i = 0; i < this.mouseActions.length; i ++ ) {     if ( this.mouseActions[ i ].mouse == mouse && this.mouseActions[ i ].key == key ) {      this.mouseActions.splice( i, 1 );     return true;     }    }    return false;   }   /**   * Return the operation associated to a mouse/keyboard combination   * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches   * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed   * @returns The operation if it has been found, null otherwise   */  getOpFromAction( mouse, key ) {    let action;    for ( let i = 0; i < this.mouseActions.length; i ++ ) {     action = this.mouseActions[ i ];    if ( action.mouse == mouse && action.key == key ) {      return action.operation;     }    }    if ( key != null ) {     for ( let i = 0; i < this.mouseActions.length; i ++ ) {      action = this.mouseActions[ i ];     if ( action.mouse == mouse && action.key == null ) {       return action.operation;      }     }    }    return null;   }   /**   * Get the operation associated to mouse and key combination and returns the corresponding FSA state   * @param {Number} mouse Mouse button   * @param {String} key Keyboard modifier   * @returns The FSA state obtained from the operation associated to mouse/keyboard combination   */  getOpStateFromAction( mouse, key ) {    let action;    for ( let i = 0; i < this.mouseActions.length; i ++ ) {     action = this.mouseActions[ i ];    if ( action.mouse == mouse && action.key == key ) {      return action.state;     }    }    if ( key != null ) {     for ( let i = 0; i < this.mouseActions.length; i ++ ) {      action = this.mouseActions[ i ];     if ( action.mouse == mouse && action.key == null ) {       return action.state;      }     }    }    return null;   }   /**   * Calculate the angle between two pointers   * @param {PointerEvent} p1   * @param {PointerEvent} p2   * @returns {Number} The angle between two pointers in degrees   */  getAngle( p1, p2 ) {    return Math.atan2( p2.clientY - p1.clientY, p2.clientX - p1.clientX ) * 180 / Math.PI;   }   /**   * Update a PointerEvent inside current pointerevents array   * @param {PointerEvent} event   */  updateTouchEvent( event ) {    for ( let i = 0; i < this._touchCurrent.length; i ++ ) {     if ( this._touchCurrent[ i ].pointerId == event.pointerId ) {      this._touchCurrent.splice( i, 1, event );     break;     }    }   }   /**   * Apply a transformation matrix, to the camera and gizmos   * @param {Object} transformation Object containing matrices to apply to camera and gizmos   */  applyTransformMatrix( transformation ) {    if ( transformation.camera != null ) {     this._m4_1.copy( this._cameraMatrixState ).premultiply( transformation.camera );    this._m4_1.decompose( this.object.position, this.object.quaternion, this.object.scale );    this.object.updateMatrix();     //update camera up vector    if ( this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE ) {      this.object.up.copy( this._upState ).applyQuaternion( this.object.quaternion );     }    }    if ( transformation.gizmos != null ) {     this._m4_1.copy( this._gizmoMatrixState ).premultiply( transformation.gizmos );    this._m4_1.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );    this._gizmos.updateMatrix();    }    if ( this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS ) {     this._tbRadius = this.calculateTbRadius( this.object );     if ( this.adjustNearFar ) {      const cameraDistance = this.object.position.distanceTo( this._gizmos.position );      const bb = new Box3();     bb.setFromObject( this._gizmos );     const sphere = new Sphere();     bb.getBoundingSphere( sphere );      const adjustedNearPosition = Math.max( this._nearPos0, sphere.radius + sphere.center.length() );     const regularNearPosition = cameraDistance - this._initialNear;      const minNearPos = Math.min( adjustedNearPosition, regularNearPosition );     this.object.near = cameraDistance - minNearPos;       const adjustedFarPosition = Math.min( this._farPos0, - sphere.radius + sphere.center.length() );     const regularFarPosition = cameraDistance - this._initialFar;      const minFarPos = Math.min( adjustedFarPosition, regularFarPosition );     this.object.far = cameraDistance - minFarPos;      this.object.updateProjectionMatrix();     } else {      let update = false;      if ( this.object.near != this._initialNear ) {       this.object.near = this._initialNear;      update = true;      }      if ( this.object.far != this._initialFar ) {       this.object.far = this._initialFar;      update = true;      }      if ( update ) {       this.object.updateProjectionMatrix();      }     }    }   }   /**   * Calculate the angular speed   * @param {Number} p0 Position at t0   * @param {Number} p1 Position at t1   * @param {Number} t0 Initial time in milliseconds   * @param {Number} t1 Ending time in milliseconds   */  calculateAngularSpeed( p0, p1, t0, t1 ) {    const s = p1 - p0;   const t = ( t1 - t0 ) / 1000;   if ( t == 0 ) {     return 0;    }    return s / t;   }   /**   * Calculate the distance between two pointers   * @param {PointerEvent} p0 The first pointer   * @param {PointerEvent} p1 The second pointer   * @returns {number} The distance between the two pointers   */  calculatePointersDistance( p0, p1 ) {    return Math.sqrt( Math.pow( p1.clientX - p0.clientX, 2 ) + Math.pow( p1.clientY - p0.clientY, 2 ) );   }   /**   * Calculate the rotation axis as the vector perpendicular between two vectors   * @param {Vector3} vec1 The first vector   * @param {Vector3} vec2 The second vector   * @returns {Vector3} The normalized rotation axis   */  calculateRotationAxis( vec1, vec2 ) {    this._rotationMatrix.extractRotation( this._cameraMatrixState );   this._quat.setFromRotationMatrix( this._rotationMatrix );    this._rotationAxis.crossVectors( vec1, vec2 ).applyQuaternion( this._quat );   return this._rotationAxis.normalize().clone();   }   /**   * Calculate the trackball radius so that gizmo's diamater will be 2/3 of the minimum side of the camera frustum   * @param {Camera} camera   * @returns {Number} The trackball radius   */  calculateTbRadius( camera ) {    const distance = camera.position.distanceTo( this._gizmos.position );    if ( camera.type == 'PerspectiveCamera' ) {     const halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5; //vertical fov/2 in radians    const halfFovH = Math.atan( ( camera.aspect ) * Math.tan( halfFovV ) ); //horizontal fov/2 in radians    return Math.tan( Math.min( halfFovV, halfFovH ) ) * distance * this.radiusFactor;    } else if ( camera.type == 'OrthographicCamera' ) {     return Math.min( camera.top, camera.right ) * this.radiusFactor;    }   }   /**   * Focus operation consist of positioning the point of interest in front of the camera and a slightly zoom in   * @param {Vector3} point The point of interest   * @param {Number} size Scale factor   * @param {Number} amount Amount of operation to be completed (used for focus animations, default is complete full operation)   */  focus( point, size, amount = 1 ) {    //move center of camera (along with gizmos) towards point of interest   _offset.copy( point ).sub( this._gizmos.position ).multiplyScalar( amount );   this._translationMatrix.makeTranslation( _offset.x, _offset.y, _offset.z );    _gizmoMatrixStateTemp.copy( this._gizmoMatrixState );   this._gizmoMatrixState.premultiply( this._translationMatrix );   this._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );    _cameraMatrixStateTemp.copy( this._cameraMatrixState );   this._cameraMatrixState.premultiply( this._translationMatrix );   this._cameraMatrixState.decompose( this.object.position, this.object.quaternion, this.object.scale );    //apply zoom   if ( this.enableZoom ) {     this.applyTransformMatrix( this.scale( size, this._gizmos.position ) );    }    this._gizmoMatrixState.copy( _gizmoMatrixStateTemp );   this._cameraMatrixState.copy( _cameraMatrixStateTemp );   }   /**   * Draw a grid and add it to the scene   */  drawGrid() {    if ( this.scene != null ) {     const color = 0x888888;    const multiplier = 3;    let size, divisions, maxLength, tick;     if ( this.object.isOrthographicCamera ) {      const width = this.object.right - this.object.left;     const height = this.object.bottom - this.object.top;      maxLength = Math.max( width, height );     tick = maxLength / 20;      size = maxLength / this.object.zoom * multiplier;     divisions = size / tick * this.object.zoom;     } else if ( this.object.isPerspectiveCamera ) {      const distance = this.object.position.distanceTo( this._gizmos.position );     const halfFovV = MathUtils.DEG2RAD * this.object.fov * 0.5;     const halfFovH = Math.atan( ( this.object.aspect ) * Math.tan( halfFovV ) );      maxLength = Math.tan( Math.max( halfFovV, halfFovH ) ) * distance * 2;     tick = maxLength / 20;      size = maxLength * multiplier;     divisions = size / tick;     }     if ( this._grid == null ) {      this._grid = new GridHelper( size, divisions, color, color );     this._grid.position.copy( this._gizmos.position );     this._gridPosition.copy( this._grid.position );     this._grid.quaternion.copy( this.object.quaternion );     this._grid.rotateX( Math.PI * 0.5 );      this.scene.add( this._grid );     }    }   }   /**   * Remove all listeners, stop animations and clean scene   */  dispose() {    if ( this._animationId != - 1 ) {     window.cancelAnimationFrame( this._animationId );    }    this.disconnect();    if ( this.scene !== null ) this.scene.remove( this._gizmos );   this.disposeGrid();   }   /**   * remove the grid from the scene   */  disposeGrid() {    if ( this._grid != null && this.scene != null ) {     this.scene.remove( this._grid );    this._grid = null;    }   }   /**   * Compute the easing out cubic function for ease out effect in animation   * @param {Number} t The absolute progress of the animation in the bound of 0 (beginning of the) and 1 (ending of animation)   * @returns {Number} Result of easing out cubic at time t   */  easeOutCubic( t ) {    return 1 - Math.pow( 1 - t, 3 );   }   /**   * Make rotation gizmos more or less visible   * @param {Boolean} isActive If true, make gizmos more visible   */  activateGizmos( isActive ) {    const gizmoX = this._gizmos.children[ 0 ];   const gizmoY = this._gizmos.children[ 1 ];   const gizmoZ = this._gizmos.children[ 2 ];    if ( isActive ) {     gizmoX.material.setValues( { opacity: 1 } );    gizmoY.material.setValues( { opacity: 1 } );    gizmoZ.material.setValues( { opacity: 1 } );    } else {     gizmoX.material.setValues( { opacity: 0.6 } );    gizmoY.material.setValues( { opacity: 0.6 } );    gizmoZ.material.setValues( { opacity: 0.6 } );    }   }   /**   * Calculate the cursor position in NDC   * @param {number} x Cursor horizontal coordinate within the canvas   * @param {number} y Cursor vertical coordinate within the canvas   * @param {HTMLElement} canvas The canvas where the renderer draws its output   * @returns {Vector2} Cursor normalized position inside the canvas   */  getCursorNDC( cursorX, cursorY, canvas ) {    const canvasRect = canvas.getBoundingClientRect();   this._v2_1.setX( ( ( cursorX - canvasRect.left ) / canvasRect.width ) * 2 - 1 );   this._v2_1.setY( ( ( canvasRect.bottom - cursorY ) / canvasRect.height ) * 2 - 1 );   return this._v2_1.clone();   }   /**   * Calculate the cursor position inside the canvas x/y coordinates with the origin being in the center of the canvas   * @param {Number} x Cursor horizontal coordinate within the canvas   * @param {Number} y Cursor vertical coordinate within the canvas   * @param {HTMLElement} canvas The canvas where the renderer draws its output   * @returns {Vector2} Cursor position inside the canvas   */  getCursorPosition( cursorX, cursorY, canvas ) {    this._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) );   this._v2_1.x *= ( this.object.right - this.object.left ) * 0.5;   this._v2_1.y *= ( this.object.top - this.object.bottom ) * 0.5;   return this._v2_1.clone();   }   /**   * Set the camera to be controlled   * @param {Camera} camera The virtual camera to be controlled   */  setCamera( camera ) {    camera.lookAt( this.target );   camera.updateMatrix();    //setting state   if ( camera.type == 'PerspectiveCamera' ) {     this._fov0 = camera.fov;    this._fovState = camera.fov;    }    this._cameraMatrixState0.copy( camera.matrix );   this._cameraMatrixState.copy( this._cameraMatrixState0 );   this._cameraProjectionState.copy( camera.projectionMatrix );   this._zoom0 = camera.zoom;   this._zoomState = this._zoom0;    this._initialNear = camera.near;   this._nearPos0 = camera.position.distanceTo( this.target ) - camera.near;   this._nearPos = this._initialNear;    this._initialFar = camera.far;   this._farPos0 = camera.position.distanceTo( this.target ) - camera.far;   this._farPos = this._initialFar;    this._up0.copy( camera.up );   this._upState.copy( camera.up );    this.object = camera;   this.object.updateProjectionMatrix();    //making gizmos   this._tbRadius = this.calculateTbRadius( camera );   this.makeGizmos( this.target, this._tbRadius );   }   /**   * Set gizmos visibility   * @param {Boolean} value Value of gizmos visibility   */  setGizmosVisible( value ) {    this._gizmos.visible = value;   this.dispatchEvent( _changeEvent );   }   /**   * Set gizmos radius factor and redraws gizmos   * @param {Float} value Value of radius factor   */  setTbRadius( value ) {    this.radiusFactor = value;   this._tbRadius = this.calculateTbRadius( this.object );    const curve = new EllipseCurve( 0, 0, this._tbRadius, this._tbRadius );   const points = curve.getPoints( this._curvePts );   const curveGeometry = new BufferGeometry().setFromPoints( points );     for ( const gizmo in this._gizmos.children ) {     this._gizmos.children[ gizmo ].geometry = curveGeometry;    }    this.dispatchEvent( _changeEvent );   }   /**   * Creates the rotation gizmos matching trackball center and radius   * @param {Vector3} tbCenter The trackball center   * @param {number} tbRadius The trackball radius   */  makeGizmos( tbCenter, tbRadius ) {    const curve = new EllipseCurve( 0, 0, tbRadius, tbRadius );   const points = curve.getPoints( this._curvePts );    //geometry   const curveGeometry = new BufferGeometry().setFromPoints( points );    //material   const curveMaterialX = new LineBasicMaterial( { color: 0xff8080, fog: false, transparent: true, opacity: 0.6 } );   const curveMaterialY = new LineBasicMaterial( { color: 0x80ff80, fog: false, transparent: true, opacity: 0.6 } );   const curveMaterialZ = new LineBasicMaterial( { color: 0x8080ff, fog: false, transparent: true, opacity: 0.6 } );    //line   const gizmoX = new Line( curveGeometry, curveMaterialX );   const gizmoY = new Line( curveGeometry, curveMaterialY );   const gizmoZ = new Line( curveGeometry, curveMaterialZ );    const rotation = Math.PI * 0.5;   gizmoX.rotation.x = rotation;   gizmoY.rotation.y = rotation;     //setting state   this._gizmoMatrixState0.identity().setPosition( tbCenter );   this._gizmoMatrixState.copy( this._gizmoMatrixState0 );    if ( this.object.zoom !== 1 ) {     //adapt gizmos size to camera zoom    const size = 1 / this.object.zoom;    this._scaleMatrix.makeScale( size, size, size );    this._translationMatrix.makeTranslation( - tbCenter.x, - tbCenter.y, - tbCenter.z );     this._gizmoMatrixState.premultiply( this._translationMatrix ).premultiply( this._scaleMatrix );    this._translationMatrix.makeTranslation( tbCenter.x, tbCenter.y, tbCenter.z );    this._gizmoMatrixState.premultiply( this._translationMatrix );    }    this._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );    //    this._gizmos.traverse( function ( object ) {     if ( object.isLine ) {      object.geometry.dispose();     object.material.dispose();     }    } );    this._gizmos.clear();    //    this._gizmos.add( gizmoX );   this._gizmos.add( gizmoY );   this._gizmos.add( gizmoZ );   }   /**   * Perform animation for focus operation   * @param {Number} time Instant in which this function is called as performance.now()   * @param {Vector3} point Point of interest for focus operation   * @param {Matrix4} cameraMatrix Camera matrix   * @param {Matrix4} gizmoMatrix Gizmos matrix   */  onFocusAnim( time, point, cameraMatrix, gizmoMatrix ) {    if ( this._timeStart == - 1 ) {     //animation start    this._timeStart = time;    }    if ( this._state == STATE.ANIMATION_FOCUS ) {     const deltaTime = time - this._timeStart;    const animTime = deltaTime / this.focusAnimationTime;     this._gizmoMatrixState.copy( gizmoMatrix );     if ( animTime >= 1 ) {      //animation end      this._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );      this.focus( point, this.scaleFactor );      this._timeStart = - 1;     this.updateTbState( STATE.IDLE, false );     this.activateGizmos( false );      this.dispatchEvent( _changeEvent );     } else {      const amount = this.easeOutCubic( animTime );     const size = ( ( 1 - amount ) + ( this.scaleFactor * amount ) );      this._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );     this.focus( point, size, amount );      this.dispatchEvent( _changeEvent );     const self = this;     this._animationId = window.requestAnimationFrame( function ( t ) {       self.onFocusAnim( t, point, cameraMatrix, gizmoMatrix.clone() );      } );     }    } else {     //interrupt animation     this._animationId = - 1;    this._timeStart = - 1;    }   }   /**   * Perform animation for rotation operation   * @param {Number} time Instant in which this function is called as performance.now()   * @param {Vector3} rotationAxis Rotation axis   * @param {number} w0 Initial angular velocity   */  onRotationAnim( time, rotationAxis, w0 ) {    if ( this._timeStart == - 1 ) {     //animation start    this._anglePrev = 0;    this._angleCurrent = 0;    this._timeStart = time;    }    if ( this._state == STATE.ANIMATION_ROTATE ) {     //w = w0 + alpha * t    const deltaTime = ( time - this._timeStart ) / 1000;    const w = w0 + ( ( - this.dampingFactor ) * deltaTime );     if ( w > 0 ) {      //tetha = 0.5 * alpha * t^2 + w0 * t + tetha0     this._angleCurrent = 0.5 * ( - this.dampingFactor ) * Math.pow( deltaTime, 2 ) + w0 * deltaTime + 0;     this.applyTransformMatrix( this.rotate( rotationAxis, this._angleCurrent ) );     this.dispatchEvent( _changeEvent );     const self = this;     this._animationId = window.requestAnimationFrame( function ( t ) {       self.onRotationAnim( t, rotationAxis, w0 );      } );     } else {      this._animationId = - 1;     this._timeStart = - 1;      this.updateTbState( STATE.IDLE, false );     this.activateGizmos( false );      this.dispatchEvent( _changeEvent );     }    } else {     //interrupt animation     this._animationId = - 1;    this._timeStart = - 1;     if ( this._state != STATE.ROTATE ) {      this.activateGizmos( false );     this.dispatchEvent( _changeEvent );     }    }   }    /**   * Perform pan operation moving camera between two points   * @param {Vector3} p0 Initial point   * @param {Vector3} p1 Ending point   * @param {Boolean} adjust If movement should be adjusted considering camera distance (Perspective only)   */  pan( p0, p1, adjust = false ) {    const movement = p0.clone().sub( p1 );    if ( this.object.isOrthographicCamera ) {     //adjust movement amount    movement.multiplyScalar( 1 / this.object.zoom );    } else if ( this.object.isPerspectiveCamera && adjust ) {     //adjust movement amount    this._v3_1.setFromMatrixPosition( this._cameraMatrixState0 ); //camera's initial position    this._v3_2.setFromMatrixPosition( this._gizmoMatrixState0 ); //gizmo's initial position    const distanceFactor = this._v3_1.distanceTo( this._v3_2 ) / this.object.position.distanceTo( this._gizmos.position );    movement.multiplyScalar( 1 / distanceFactor );    }    this._v3_1.set( movement.x, movement.y, 0 ).applyQuaternion( this.object.quaternion );    this._m4_1.makeTranslation( this._v3_1.x, this._v3_1.y, this._v3_1.z );    this.setTransformationMatrices( this._m4_1, this._m4_1 );   return _transformation;   }   /**   * Reset trackball   */  reset() {    this.object.zoom = this._zoom0;    if ( this.object.isPerspectiveCamera ) {     this.object.fov = this._fov0;    }    this.object.near = this._nearPos;   this.object.far = this._farPos;   this._cameraMatrixState.copy( this._cameraMatrixState0 );   this._cameraMatrixState.decompose( this.object.position, this.object.quaternion, this.object.scale );   this.object.up.copy( this._up0 );    this.object.updateMatrix();   this.object.updateProjectionMatrix();    this._gizmoMatrixState.copy( this._gizmoMatrixState0 );   this._gizmoMatrixState0.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );   this._gizmos.updateMatrix();    this._tbRadius = this.calculateTbRadius( this.object );   this.makeGizmos( this._gizmos.position, this._tbRadius );    this.object.lookAt( this._gizmos.position );    this.updateTbState( STATE.IDLE, false );    this.dispatchEvent( _changeEvent );   }   /**   * Rotate the camera around an axis passing by trackball's center   * @param {Vector3} axis Rotation axis   * @param {number} angle Angle in radians   * @returns {Object} Object with 'camera' field containing transformation matrix resulting from the operation to be applied to the camera   */  rotate( axis, angle ) {    const point = this._gizmos.position; //rotation center   this._translationMatrix.makeTranslation( - point.x, - point.y, - point.z );   this._rotationMatrix.makeRotationAxis( axis, - angle );    //rotate camera   this._m4_1.makeTranslation( point.x, point.y, point.z );   this._m4_1.multiply( this._rotationMatrix );   this._m4_1.multiply( this._translationMatrix );    this.setTransformationMatrices( this._m4_1 );    return _transformation;   }   copyState() {    let state;   if ( this.object.isOrthographicCamera ) {     state = JSON.stringify( { arcballState: {      cameraFar: this.object.far,     cameraMatrix: this.object.matrix,     cameraNear: this.object.near,     cameraUp: this.object.up,     cameraZoom: this.object.zoom,     gizmoMatrix: this._gizmos.matrix     } } );    } else if ( this.object.isPerspectiveCamera ) {     state = JSON.stringify( { arcballState: {     cameraFar: this.object.far,     cameraFov: this.object.fov,     cameraMatrix: this.object.matrix,     cameraNear: this.object.near,     cameraUp: this.object.up,     cameraZoom: this.object.zoom,     gizmoMatrix: this._gizmos.matrix     } } );    }    navigator.clipboard.writeText( state );   }   pasteState() {    const self = this;   navigator.clipboard.readText().then( function resolved( value ) {     self.setStateFromJSON( value );    } );   }   /**   * Save the current state of the control. This can later be recover with .reset   */  saveState() {    this._cameraMatrixState0.copy( this.object.matrix );   this._gizmoMatrixState0.copy( this._gizmos.matrix );   this._nearPos = this.object.near;   this._farPos = this.object.far;   this._zoom0 = this.object.zoom;   this._up0.copy( this.object.up );    if ( this.object.isPerspectiveCamera ) {     this._fov0 = this.object.fov;    }   }   /**   * Perform uniform scale operation around a given point   * @param {Number} size Scale factor   * @param {Vector3} point Point around which scale   * @param {Boolean} scaleGizmos If gizmos should be scaled (Perspective only)   * @returns {Object} Object with 'camera' and 'gizmo' fields containing transformation matrices resulting from the operation to be applied to the camera and gizmos   */  scale( size, point, scaleGizmos = true ) {    _scalePointTemp.copy( point );   let sizeInverse = 1 / size;    if ( this.object.isOrthographicCamera ) {     //camera zoom    this.object.zoom = this._zoomState;    this.object.zoom *= size;     //check min and max zoom    if ( this.object.zoom > this.maxZoom ) {      this.object.zoom = this.maxZoom;     sizeInverse = this._zoomState / this.maxZoom;     } else if ( this.object.zoom < this.minZoom ) {      this.object.zoom = this.minZoom;     sizeInverse = this._zoomState / this.minZoom;     }     this.object.updateProjectionMatrix();     this._v3_1.setFromMatrixPosition( this._gizmoMatrixState ); //gizmos position     //scale gizmos so they appear in the same spot having the same dimension    this._scaleMatrix.makeScale( sizeInverse, sizeInverse, sizeInverse );    this._translationMatrix.makeTranslation( - this._v3_1.x, - this._v3_1.y, - this._v3_1.z );     this._m4_2.makeTranslation( this._v3_1.x, this._v3_1.y, this._v3_1.z ).multiply( this._scaleMatrix );    this._m4_2.multiply( this._translationMatrix );      //move camera and gizmos to obtain pinch effect    _scalePointTemp.sub( this._v3_1 );     const amount = _scalePointTemp.clone().multiplyScalar( sizeInverse );    _scalePointTemp.sub( amount );     this._m4_1.makeTranslation( _scalePointTemp.x, _scalePointTemp.y, _scalePointTemp.z );    this._m4_2.premultiply( this._m4_1 );     this.setTransformationMatrices( this._m4_1, this._m4_2 );    return _transformation;    } else if ( this.object.isPerspectiveCamera ) {     this._v3_1.setFromMatrixPosition( this._cameraMatrixState );    this._v3_2.setFromMatrixPosition( this._gizmoMatrixState );     //move camera    let distance = this._v3_1.distanceTo( _scalePointTemp );    let amount = distance - ( distance * sizeInverse );     //check min and max distance    const newDistance = distance - amount;    if ( newDistance < this.minDistance ) {      sizeInverse = this.minDistance / distance;     amount = distance - ( distance * sizeInverse );     } else if ( newDistance > this.maxDistance ) {      sizeInverse = this.maxDistance / distance;     amount = distance - ( distance * sizeInverse );     }     _offset.copy( _scalePointTemp ).sub( this._v3_1 ).normalize().multiplyScalar( amount );     this._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z );      if ( scaleGizmos ) {      //scale gizmos so they appear in the same spot having the same dimension     const pos = this._v3_2;      distance = pos.distanceTo( _scalePointTemp );     amount = distance - ( distance * sizeInverse );     _offset.copy( _scalePointTemp ).sub( this._v3_2 ).normalize().multiplyScalar( amount );      this._translationMatrix.makeTranslation( pos.x, pos.y, pos.z );     this._scaleMatrix.makeScale( sizeInverse, sizeInverse, sizeInverse );      this._m4_2.makeTranslation( _offset.x, _offset.y, _offset.z ).multiply( this._translationMatrix );     this._m4_2.multiply( this._scaleMatrix );      this._translationMatrix.makeTranslation( - pos.x, - pos.y, - pos.z );      this._m4_2.multiply( this._translationMatrix );     this.setTransformationMatrices( this._m4_1, this._m4_2 );      } else {      this.setTransformationMatrices( this._m4_1 );     }     return _transformation;    }   }   /**   * Set camera fov   * @param {Number} value fov to be setted   */  setFov( value ) {    if ( this.object.isPerspectiveCamera ) {     this.object.fov = MathUtils.clamp( value, this.minFov, this.maxFov );    this.object.updateProjectionMatrix();    }   }   /**   * Set values in transformation object   * @param {Matrix4} camera Transformation to be applied to the camera   * @param {Matrix4} gizmos Transformation to be applied to gizmos   */   setTransformationMatrices( camera = null, gizmos = null ) {    if ( camera != null ) {     if ( _transformation.camera != null ) {      _transformation.camera.copy( camera );     } else {      _transformation.camera = camera.clone();     }    } else {     _transformation.camera = null;    }    if ( gizmos != null ) {     if ( _transformation.gizmos != null ) {      _transformation.gizmos.copy( gizmos );     } else {      _transformation.gizmos = gizmos.clone();     }    } else {     _transformation.gizmos = null;    }   }   /**   * Rotate camera around its direction axis passing by a given point by a given angle   * @param {Vector3} point The point where the rotation axis is passing trough   * @param {Number} angle Angle in radians   * @returns The computed transormation matix   */  zRotate( point, angle ) {    this._rotationMatrix.makeRotationAxis( this._rotationAxis, angle );   this._translationMatrix.makeTranslation( - point.x, - point.y, - point.z );    this._m4_1.makeTranslation( point.x, point.y, point.z );   this._m4_1.multiply( this._rotationMatrix );   this._m4_1.multiply( this._translationMatrix );    this._v3_1.setFromMatrixPosition( this._gizmoMatrixState ).sub( point ); //vector from rotation center to gizmos position   this._v3_2.copy( this._v3_1 ).applyAxisAngle( this._rotationAxis, angle ); //apply rotation   this._v3_2.sub( this._v3_1 );    this._m4_2.makeTranslation( this._v3_2.x, this._v3_2.y, this._v3_2.z );    this.setTransformationMatrices( this._m4_1, this._m4_2 );   return _transformation;   }    getRaycaster() {    return _raycaster;   }    /**   * Unproject the cursor on the 3D object surface   * @param {Vector2} cursor Cursor coordinates in NDC   * @param {Camera} camera Virtual camera   * @returns {Vector3} The point of intersection with the model, if exist, null otherwise   */  unprojectOnObj( cursor, camera ) {    const raycaster = this.getRaycaster();   raycaster.near = camera.near;   raycaster.far = camera.far;   raycaster.setFromCamera( cursor, camera );    const intersect = raycaster.intersectObjects( this.scene.children, true );    for ( let i = 0; i < intersect.length; i ++ ) {     if ( intersect[ i ].object.uuid != this._gizmos.uuid && intersect[ i ].face != null ) {      return intersect[ i ].point.clone();     }    }    return null;   }   /**   * Unproject the cursor on the trackball surface   * @param {Camera} camera The virtual camera   * @param {Number} cursorX Cursor horizontal coordinate on screen   * @param {Number} cursorY Cursor vertical coordinate on screen   * @param {HTMLElement} canvas The canvas where the renderer draws its output   * @param {number} tbRadius The trackball radius   * @returns {Vector3} The unprojected point on the trackball surface   */  unprojectOnTbSurface( camera, cursorX, cursorY, canvas, tbRadius ) {    if ( camera.type == 'OrthographicCamera' ) {     this._v2_1.copy( this.getCursorPosition( cursorX, cursorY, canvas ) );    this._v3_1.set( this._v2_1.x, this._v2_1.y, 0 );     const x2 = Math.pow( this._v2_1.x, 2 );    const y2 = Math.pow( this._v2_1.y, 2 );    const r2 = Math.pow( this._tbRadius, 2 );     if ( x2 + y2 <= r2 * 0.5 ) {      //intersection with sphere     this._v3_1.setZ( Math.sqrt( r2 - ( x2 + y2 ) ) );     } else {      //intersection with hyperboloid     this._v3_1.setZ( ( r2 * 0.5 ) / ( Math.sqrt( x2 + y2 ) ) );     }     return this._v3_1;    } else if ( camera.type == 'PerspectiveCamera' ) {     //unproject cursor on the near plane    this._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) );     this._v3_1.set( this._v2_1.x, this._v2_1.y, - 1 );    this._v3_1.applyMatrix4( camera.projectionMatrixInverse );     const rayDir = this._v3_1.clone().normalize(); //unprojected ray direction    const cameraGizmoDistance = camera.position.distanceTo( this._gizmos.position );    const radius2 = Math.pow( tbRadius, 2 );     //   camera    //  ||    //  | |    //  |  |    // h | |    //  |   |    //  |    |    // _ _ | _ _ _| _ _  near plane    //   l     const h = this._v3_1.z;    const l = Math.sqrt( Math.pow( this._v3_1.x, 2 ) + Math.pow( this._v3_1.y, 2 ) );     if ( l == 0 ) {      //ray aligned with camera     rayDir.set( this._v3_1.x, this._v3_1.y, tbRadius );     return rayDir;     }     const m = h / l;    const q = cameraGizmoDistance;     /*     * calculate intersection point between unprojected ray and trackball surface     *|y = m * x + q     *|x^2 + y^2 = r^2     *     * (m^2 + 1) * x^2 + (2 * m * q) * x + q^2 - r^2 = 0     */    let a = Math.pow( m, 2 ) + 1;    let b = 2 * m * q;    let c = Math.pow( q, 2 ) - radius2;    let delta = Math.pow( b, 2 ) - ( 4 * a * c );     if ( delta >= 0 ) {      //intersection with sphere     this._v2_1.setX( ( - b - Math.sqrt( delta ) ) / ( 2 * a ) );     this._v2_1.setY( m * this._v2_1.x + q );      const angle = MathUtils.RAD2DEG * this._v2_1.angle();      if ( angle >= 45 ) {       //if angle between intersection point and X' axis is >= 45, return that point      //otherwise, calculate intersection point with hyperboloid       const rayLength = Math.sqrt( Math.pow( this._v2_1.x, 2 ) + Math.pow( ( cameraGizmoDistance - this._v2_1.y ), 2 ) );      rayDir.multiplyScalar( rayLength );      rayDir.z += cameraGizmoDistance;      return rayDir;      }     }     //intersection with hyperboloid    /*     *|y = m * x + q     *|y = (1 / x) * (r^2 / 2)     *     * m * x^2 + q * x - r^2 / 2 = 0     */     a = m;    b = q;    c = - radius2 * 0.5;    delta = Math.pow( b, 2 ) - ( 4 * a * c );    this._v2_1.setX( ( - b - Math.sqrt( delta ) ) / ( 2 * a ) );    this._v2_1.setY( m * this._v2_1.x + q );     const rayLength = Math.sqrt( Math.pow( this._v2_1.x, 2 ) + Math.pow( ( cameraGizmoDistance - this._v2_1.y ), 2 ) );     rayDir.multiplyScalar( rayLength );    rayDir.z += cameraGizmoDistance;    return rayDir;    }   }    /**   * Unproject the cursor on the plane passing through the center of the trackball orthogonal to the camera   * @param {Camera} camera The virtual camera   * @param {Number} cursorX Cursor horizontal coordinate on screen   * @param {Number} cursorY Cursor vertical coordinate on screen   * @param {HTMLElement} canvas The canvas where the renderer draws its output   * @param {Boolean} initialDistance If initial distance between camera and gizmos should be used for calculations instead of current (Perspective only)   * @returns {Vector3} The unprojected point on the trackball plane   */  unprojectOnTbPlane( camera, cursorX, cursorY, canvas, initialDistance = false ) {    if ( camera.type == 'OrthographicCamera' ) {     this._v2_1.copy( this.getCursorPosition( cursorX, cursorY, canvas ) );    this._v3_1.set( this._v2_1.x, this._v2_1.y, 0 );     return this._v3_1.clone();    } else if ( camera.type == 'PerspectiveCamera' ) {     this._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) );     //unproject cursor on the near plane    this._v3_1.set( this._v2_1.x, this._v2_1.y, - 1 );    this._v3_1.applyMatrix4( camera.projectionMatrixInverse );     const rayDir = this._v3_1.clone().normalize(); //unprojected ray direction     //   camera    //  ||    //  | |    //  |  |    // h | |    //  |   |    //  |    |    // _ _ | _ _ _| _ _  near plane    //   l     const h = this._v3_1.z;    const l = Math.sqrt( Math.pow( this._v3_1.x, 2 ) + Math.pow( this._v3_1.y, 2 ) );    let cameraGizmoDistance;     if ( initialDistance ) {      cameraGizmoDistance = this._v3_1.setFromMatrixPosition( this._cameraMatrixState0 ).distanceTo( this._v3_2.setFromMatrixPosition( this._gizmoMatrixState0 ) );     } else {      cameraGizmoDistance = camera.position.distanceTo( this._gizmos.position );     }     /*     * calculate intersection point between unprojected ray and the plane     *|y = mx + q     *|y = 0     *     * x = -q/m    */    if ( l == 0 ) {      //ray aligned with camera     rayDir.set( 0, 0, 0 );     return rayDir;     }     const m = h / l;    const q = cameraGizmoDistance;    const x = - q / m;     const rayLength = Math.sqrt( Math.pow( q, 2 ) + Math.pow( x, 2 ) );    rayDir.multiplyScalar( rayLength );    rayDir.z = 0;    return rayDir;    }   }   /**   * Update camera and gizmos state   */  updateMatrixState() {    //update camera and gizmos state   this._cameraMatrixState.copy( this.object.matrix );   this._gizmoMatrixState.copy( this._gizmos.matrix );    if ( this.object.isOrthographicCamera ) {     this._cameraProjectionState.copy( this.object.projectionMatrix );    this.object.updateProjectionMatrix();    this._zoomState = this.object.zoom;    } else if ( this.object.isPerspectiveCamera ) {     this._fovState = this.object.fov;    }   }   /**   * Update the trackball FSA   * @param {STATE} newState New state of the FSA   * @param {Boolean} updateMatrices If matriices state should be updated   */  updateTbState( newState, updateMatrices ) {    this._state = newState;   if ( updateMatrices ) {     this.updateMatrixState();    }   }   update() {    const EPS = 0.000001;    if ( this.target.equals( this._currentTarget ) === false ) {     this._gizmos.position.copy( this.target ); //for correct radius calculation    this._tbRadius = this.calculateTbRadius( this.object );    this.makeGizmos( this.target, this._tbRadius );    this._currentTarget.copy( this.target );    }    //check min/max parameters   if ( this.object.isOrthographicCamera ) {     //check zoom    if ( this.object.zoom > this.maxZoom || this.object.zoom < this.minZoom ) {      const newZoom = MathUtils.clamp( this.object.zoom, this.minZoom, this.maxZoom );     this.applyTransformMatrix( this.scale( newZoom / this.object.zoom, this._gizmos.position, true ) );     }    } else if ( this.object.isPerspectiveCamera ) {     //check distance    const distance = this.object.position.distanceTo( this._gizmos.position );     if ( distance > this.maxDistance + EPS || distance < this.minDistance - EPS ) {      const newDistance = MathUtils.clamp( distance, this.minDistance, this.maxDistance );     this.applyTransformMatrix( this.scale( newDistance / distance, this._gizmos.position ) );     this.updateMatrixState();      }     //check fov    if ( this.object.fov < this.minFov || this.object.fov > this.maxFov ) {      this.object.fov = MathUtils.clamp( this.object.fov, this.minFov, this.maxFov );     this.object.updateProjectionMatrix();     }     const oldRadius = this._tbRadius;    this._tbRadius = this.calculateTbRadius( this.object );     if ( oldRadius < this._tbRadius - EPS || oldRadius > this._tbRadius + EPS ) {      const scale = ( this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z ) / 3;     const newRadius = this._tbRadius / scale;     const curve = new EllipseCurve( 0, 0, newRadius, newRadius );     const points = curve.getPoints( this._curvePts );     const curveGeometry = new BufferGeometry().setFromPoints( points );      for ( const gizmo in this._gizmos.children ) {       this._gizmos.children[ gizmo ].geometry = curveGeometry;      }     }    }    this.object.lookAt( this._gizmos.position );   }   setStateFromJSON( json ) {    const state = JSON.parse( json );    if ( state.arcballState != undefined ) {     this._cameraMatrixState.fromArray( state.arcballState.cameraMatrix.elements );    this._cameraMatrixState.decompose( this.object.position, this.object.quaternion, this.object.scale );     this.object.up.copy( state.arcballState.cameraUp );    this.object.near = state.arcballState.cameraNear;    this.object.far = state.arcballState.cameraFar;     this.object.zoom = state.arcballState.cameraZoom;     if ( this.object.isPerspectiveCamera ) {      this.object.fov = state.arcballState.cameraFov;     }     this._gizmoMatrixState.fromArray( state.arcballState.gizmoMatrix.elements );    this._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );     this.object.updateMatrix();    this.object.updateProjectionMatrix();     this._gizmos.updateMatrix();     this._tbRadius = this.calculateTbRadius( this.object );    const gizmoTmp = new Matrix4().copy( this._gizmoMatrixState0 );    this.makeGizmos( this._gizmos.position, this._tbRadius );    this._gizmoMatrixState0.copy( gizmoTmp );     this.object.lookAt( this._gizmos.position );    this.updateTbState( STATE.IDLE, false );     this.dispatchEvent( _changeEvent );    }   }  }  //listeners  function onWindowResize() {   const scale = ( this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z ) / 3;  this._tbRadius = this.calculateTbRadius( this.object );   const newRadius = this._tbRadius / scale;  const curve = new EllipseCurve( 0, 0, newRadius, newRadius );  const points = curve.getPoints( this._curvePts );  const curveGeometry = new BufferGeometry().setFromPoints( points );    for ( const gizmo in this._gizmos.children ) {    this._gizmos.children[ gizmo ].geometry = curveGeometry;   }   this.dispatchEvent( _changeEvent );  }  function onContextMenu( event ) {   if ( ! this.enabled ) {    return;   }   for ( let i = 0; i < this.mouseActions.length; i ++ ) {    if ( this.mouseActions[ i ].mouse == 2 ) {     //prevent only if button 2 is actually used    event.preventDefault();    break;    }   }  }  function onPointerCancel() {   this._touchStart.splice( 0, this._touchStart.length );  this._touchCurrent.splice( 0, this._touchCurrent.length );  this._input = INPUT.NONE;  }  function onPointerDown( event ) {   if ( event.button == 0 && event.isPrimary ) {    this._downValid = true;   this._downEvents.push( event );   this._downStart = performance.now();   } else {    this._downValid = false;   }   if ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) {    this._touchStart.push( event );   this._touchCurrent.push( event );    switch ( this._input ) {     case INPUT.NONE:      //singleStart     this._input = INPUT.ONE_FINGER;     this.onSinglePanStart( event, 'ROTATE' );      window.addEventListener( 'pointermove', this._onPointerMove );     window.addEventListener( 'pointerup', this._onPointerUp );      break;     case INPUT.ONE_FINGER:    case INPUT.ONE_FINGER_SWITCHED:      //doubleStart     this._input = INPUT.TWO_FINGER;      this.onRotateStart();     this.onPinchStart();     this.onDoublePanStart();      break;     case INPUT.TWO_FINGER:      //multipleStart     this._input = INPUT.MULT_FINGER;     this.onTriplePanStart( event );     break;    }   } else if ( event.pointerType != 'touch' && this._input == INPUT.NONE ) {    let modifier = null;    if ( event.ctrlKey || event.metaKey ) {     modifier = 'CTRL';    } else if ( event.shiftKey ) {     modifier = 'SHIFT';    }    this._mouseOp = this.getOpFromAction( event.button, modifier );   if ( this._mouseOp != null ) {     window.addEventListener( 'pointermove', this._onPointerMove );    window.addEventListener( 'pointerup', this._onPointerUp );     //singleStart    this._input = INPUT.CURSOR;    this._button = event.button;    this.onSinglePanStart( event, this._mouseOp );    }   }  }  function onPointerMove( event ) {   if ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) {    switch ( this._input ) {     case INPUT.ONE_FINGER:      //singleMove     this.updateTouchEvent( event );      this.onSinglePanMove( event, STATE.ROTATE );     break;     case INPUT.ONE_FINGER_SWITCHED:      const movement = this.calculatePointersDistance( this._touchCurrent[ 0 ], event ) * this._devPxRatio;      if ( movement >= this._switchSensibility ) {       //singleMove      this._input = INPUT.ONE_FINGER;      this.updateTouchEvent( event );       this.onSinglePanStart( event, 'ROTATE' );      break;      }      break;     case INPUT.TWO_FINGER:      //rotate/pan/pinchMove     this.updateTouchEvent( event );      this.onRotateMove();     this.onPinchMove();     this.onDoublePanMove();      break;     case INPUT.MULT_FINGER:      //multMove     this.updateTouchEvent( event );      this.onTriplePanMove( event );     break;    }   } else if ( event.pointerType != 'touch' && this._input == INPUT.CURSOR ) {    let modifier = null;    if ( event.ctrlKey || event.metaKey ) {     modifier = 'CTRL';    } else if ( event.shiftKey ) {     modifier = 'SHIFT';    }    const mouseOpState = this.getOpStateFromAction( this._button, modifier );    if ( mouseOpState != null ) {     this.onSinglePanMove( event, mouseOpState );    }   }   //checkDistance  if ( this._downValid ) {    const movement = this.calculatePointersDistance( this._downEvents[ this._downEvents.length - 1 ], event ) * this._devPxRatio;   if ( movement > this._movementThreshold ) {     this._downValid = false;    }   }  }  function onPointerUp( event ) {   if ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) {    const nTouch = this._touchCurrent.length;    for ( let i = 0; i < nTouch; i ++ ) {     if ( this._touchCurrent[ i ].pointerId == event.pointerId ) {      this._touchCurrent.splice( i, 1 );     this._touchStart.splice( i, 1 );     break;     }    }    switch ( this._input ) {     case INPUT.ONE_FINGER:    case INPUT.ONE_FINGER_SWITCHED:      //singleEnd     window.removeEventListener( 'pointermove', this._onPointerMove );     window.removeEventListener( 'pointerup', this._onPointerUp );      this._input = INPUT.NONE;     this.onSinglePanEnd();      break;     case INPUT.TWO_FINGER:      //doubleEnd     this.onDoublePanEnd( event );     this.onPinchEnd( event );     this.onRotateEnd( event );      //switching to singleStart     this._input = INPUT.ONE_FINGER_SWITCHED;      break;     case INPUT.MULT_FINGER:      if ( this._touchCurrent.length == 0 ) {       window.removeEventListener( 'pointermove', this._onPointerMove );      window.removeEventListener( 'pointerup', this._onPointerUp );       //multCancel      this._input = INPUT.NONE;      this.onTriplePanEnd();      }      break;    }   } else if ( event.pointerType != 'touch' && this._input == INPUT.CURSOR ) {    window.removeEventListener( 'pointermove', this._onPointerMove );   window.removeEventListener( 'pointerup', this._onPointerUp );    this._input = INPUT.NONE;   this.onSinglePanEnd();   this._button = - 1;   }   if ( event.isPrimary ) {    if ( this._downValid ) {     const downTime = event.timeStamp - this._downEvents[ this._downEvents.length - 1 ].timeStamp;     if ( downTime <= this._maxDownTime ) {      if ( this._nclicks == 0 ) {       //first valid click detected      this._nclicks = 1;      this._clickStart = performance.now();      } else {       const clickInterval = event.timeStamp - this._clickStart;      const movement = this.calculatePointersDistance( this._downEvents[ 1 ], this._downEvents[ 0 ] ) * this._devPxRatio;       if ( clickInterval <= this._maxInterval && movement <= this._posThreshold ) {        //second valid click detected       //fire double tap and reset values       this._nclicks = 0;       this._downEvents.splice( 0, this._downEvents.length );       this.onDoubleTap( event );       } else {        //new 'first click'       this._nclicks = 1;       this._downEvents.shift();       this._clickStart = performance.now();       }      }     } else {      this._downValid = false;     this._nclicks = 0;     this._downEvents.splice( 0, this._downEvents.length );     }    } else {     this._nclicks = 0;    this._downEvents.splice( 0, this._downEvents.length );    }   }  }  function onWheel( event ) {   if ( this.enabled && this.enableZoom ) {    let modifier = null;    if ( event.ctrlKey || event.metaKey ) {     modifier = 'CTRL';    } else if ( event.shiftKey ) {     modifier = 'SHIFT';    }    const mouseOp = this.getOpFromAction( 'WHEEL', modifier );    if ( mouseOp != null ) {     event.preventDefault();    this.dispatchEvent( _startEvent );     const notchDeltaY = 125; //distance of one notch of mouse wheel    let sgn = event.deltaY / notchDeltaY;     let size = 1;     if ( sgn > 0 ) {      size = 1 / this.scaleFactor;     } else if ( sgn < 0 ) {      size = this.scaleFactor;     }     switch ( mouseOp ) {      case 'ZOOM':       this.updateTbState( STATE.SCALE, true );       if ( sgn > 0 ) {        size = 1 / ( Math.pow( this.scaleFactor, sgn ) );       } else if ( sgn < 0 ) {        size = Math.pow( this.scaleFactor, - sgn );       }       if ( this.cursorZoom && this.enablePan ) {        let scalePoint;        if ( this.object.isOrthographicCamera ) {         scalePoint = this.unprojectOnTbPlane( this.object, event.clientX, event.clientY, this.domElement ).applyQuaternion( this.object.quaternion ).multiplyScalar( 1 / this.object.zoom ).add( this._gizmos.position );        } else if ( this.object.isPerspectiveCamera ) {         scalePoint = this.unprojectOnTbPlane( this.object, event.clientX, event.clientY, this.domElement ).applyQuaternion( this.object.quaternion ).add( this._gizmos.position );        }        this.applyTransformMatrix( this.scale( size, scalePoint ) );       } else {        this.applyTransformMatrix( this.scale( size, this._gizmos.position ) );       }       if ( this._grid != null ) {        this.disposeGrid();       this.drawGrid();       }       this.updateTbState( STATE.IDLE, false );       this.dispatchEvent( _changeEvent );      this.dispatchEvent( _endEvent );       break;      case 'FOV':       if ( this.object.isPerspectiveCamera ) {        this.updateTbState( STATE.FOV, true );         //Vertigo effect        //   fov / 2       //  ||       //  | |       //  |  |       // x | |       //  |   |       //  |    |       //  | _ _ _|       //   y        //check for iOs shift shortcut       if ( event.deltaX != 0 ) {         sgn = event.deltaX / notchDeltaY;         size = 1;         if ( sgn > 0 ) {          size = 1 / ( Math.pow( this.scaleFactor, sgn ) );         } else if ( sgn < 0 ) {          size = Math.pow( this.scaleFactor, - sgn );         }        }        this._v3_1.setFromMatrixPosition( this._cameraMatrixState );       const x = this._v3_1.distanceTo( this._gizmos.position );       let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed        //check min and max distance       xNew = MathUtils.clamp( xNew, this.minDistance, this.maxDistance );        const y = x * Math.tan( MathUtils.DEG2RAD * this.object.fov * 0.5 );        //calculate new fov       let newFov = MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 );        //check min and max fov       if ( newFov > this.maxFov ) {         newFov = this.maxFov;        } else if ( newFov < this.minFov ) {         newFov = this.minFov;        }        const newDistance = y / Math.tan( MathUtils.DEG2RAD * ( newFov / 2 ) );       size = x / newDistance;        this.setFov( newFov );       this.applyTransformMatrix( this.scale( size, this._gizmos.position, false ) );       }       if ( this._grid != null ) {        this.disposeGrid();       this.drawGrid();       }       this.updateTbState( STATE.IDLE, false );       this.dispatchEvent( _changeEvent );      this.dispatchEvent( _endEvent );       break;     }    }   }  }  export { ArcballControls }; 
^..^ FILENAME ^..^
addons|controls|DragControls.js
^..^ CONTENTS ^..^
import {  Controls,  Matrix4,  Plane,  Raycaster,  Vector2,  Vector3,  MOUSE,  TOUCH } from 'three';  const _plane = new Plane();  const _pointer = new Vector2(); const _offset = new Vector3(); const _diff = new Vector2(); const _previousPointer = new Vector2(); const _intersection = new Vector3(); const _worldPosition = new Vector3(); const _inverseMatrix = new Matrix4();  const _up = new Vector3(); const _right = new Vector3();  let _selected = null, _hovered = null; const _intersections = [];  const STATE = {  NONE: - 1,  PAN: 0,  ROTATE: 1 };  class DragControls extends Controls {   constructor( objects, camera, domElement = null ) {    super( camera, domElement );    this.objects = objects;    this.recursive = true;   this.transformGroup = false;   this.rotateSpeed = 1;    this.raycaster = new Raycaster();    // interaction    this.mouseButtons = { LEFT: MOUSE.PAN, MIDDLE: MOUSE.PAN, RIGHT: MOUSE.ROTATE };   this.touches = { ONE: TOUCH.PAN };    // event listeners    this._onPointerMove = onPointerMove.bind( this );   this._onPointerDown = onPointerDown.bind( this );   this._onPointerCancel = onPointerCancel.bind( this );   this._onContextMenu = onContextMenu.bind( this );    //    if ( domElement !== null ) {     this.connect();    }   }   connect() {    this.domElement.addEventListener( 'pointermove', this._onPointerMove );   this.domElement.addEventListener( 'pointerdown', this._onPointerDown );   this.domElement.addEventListener( 'pointerup', this._onPointerCancel );   this.domElement.addEventListener( 'pointerleave', this._onPointerCancel );   this.domElement.addEventListener( 'contextmenu', this._onContextMenu );    this.domElement.style.touchAction = 'none'; // disable touch scroll   }   disconnect() {    this.domElement.removeEventListener( 'pointermove', this._onPointerMove );   this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );   this.domElement.removeEventListener( 'pointerup', this._onPointerCancel );   this.domElement.removeEventListener( 'pointerleave', this._onPointerCancel );   this.domElement.removeEventListener( 'contextmenu', this._onContextMenu );    this.domElement.style.touchAction = 'auto';   this.domElement.style.cursor = '';   }   dispose() {    this.disconnect();   }   _updatePointer( event ) {    const rect = this.domElement.getBoundingClientRect();    _pointer.x = ( event.clientX - rect.left ) / rect.width * 2 - 1;   _pointer.y = - ( event.clientY - rect.top ) / rect.height * 2 + 1;   }   _updateState( event ) {    // determine action    let action;    if ( event.pointerType === 'touch' ) {     action = this.touches.ONE;    } else {     switch ( event.button ) {      case 0:       action = this.mouseButtons.LEFT;      break;      case 1:       action = this.mouseButtons.MIDDLE;      break;      case 2:       action = this.mouseButtons.RIGHT;      break;      default:       action = null;     }    }    // determine state    switch ( action ) {     case MOUSE.PAN:    case TOUCH.PAN:      this.state = STATE.PAN;      break;     case MOUSE.ROTATE:    case TOUCH.ROTATE:      this.state = STATE.ROTATE;      break;     default:      this.state = STATE.NONE;    }   }   getRaycaster() {    console.warn( 'THREE.DragControls: getRaycaster() has been deprecated. Use controls.raycaster instead.' ); // @deprecated r169    return this.raycaster;   }   setObjects( objects ) {    console.warn( 'THREE.DragControls: setObjects() has been deprecated. Use controls.objects instead.' ); // @deprecated r169    this.objects = objects;   }   getObjects() {    console.warn( 'THREE.DragControls: getObjects() has been deprecated. Use controls.objects instead.' ); // @deprecated r169    return this.objects;   }   activate() {    console.warn( 'THREE.DragControls: activate() has been renamed to connect().' ); // @deprecated r169   this.connect();   }   deactivate() {    console.warn( 'THREE.DragControls: deactivate() has been renamed to disconnect().' ); // @deprecated r169   this.disconnect();   }   set mode( value ) {    console.warn( 'THREE.DragControls: The .mode property has been removed. Define the type of transformation via the .mouseButtons or .touches properties.' ); // @deprecated r169   }   get mode() {    console.warn( 'THREE.DragControls: The .mode property has been removed. Define the type of transformation via the .mouseButtons or .touches properties.' ); // @deprecated r169   }  }  function onPointerMove( event ) {   const camera = this.object;  const domElement = this.domElement;  const raycaster = this.raycaster;   if ( this.enabled === false ) return;   this._updatePointer( event );   raycaster.setFromCamera( _pointer, camera );   if ( _selected ) {    if ( this.state === STATE.PAN ) {     if ( raycaster.ray.intersectPlane( _plane, _intersection ) ) {      _selected.position.copy( _intersection.sub( _offset ).applyMatrix4( _inverseMatrix ) );     }    } else if ( this.state === STATE.ROTATE ) {     _diff.subVectors( _pointer, _previousPointer ).multiplyScalar( this.rotateSpeed );    _selected.rotateOnWorldAxis( _up, _diff.x );    _selected.rotateOnWorldAxis( _right.normalize(), - _diff.y );    }    this.dispatchEvent( { type: 'drag', object: _selected } );    _previousPointer.copy( _pointer );   } else {    // hover support    if ( event.pointerType === 'mouse' || event.pointerType === 'pen' ) {     _intersections.length = 0;     raycaster.setFromCamera( _pointer, camera );    raycaster.intersectObjects( this.objects, this.recursive, _intersections );     if ( _intersections.length > 0 ) {      const object = _intersections[ 0 ].object;      _plane.setFromNormalAndCoplanarPoint( camera.getWorldDirection( _plane.normal ), _worldPosition.setFromMatrixPosition( object.matrixWorld ) );      if ( _hovered !== object && _hovered !== null ) {       this.dispatchEvent( { type: 'hoveroff', object: _hovered } );       domElement.style.cursor = 'auto';      _hovered = null;      }      if ( _hovered !== object ) {       this.dispatchEvent( { type: 'hoveron', object: object } );       domElement.style.cursor = 'pointer';      _hovered = object;      }     } else {      if ( _hovered !== null ) {       this.dispatchEvent( { type: 'hoveroff', object: _hovered } );       domElement.style.cursor = 'auto';      _hovered = null;      }     }    }   }   _previousPointer.copy( _pointer );  }  function onPointerDown( event ) {   const camera = this.object;  const domElement = this.domElement;  const raycaster = this.raycaster;   if ( this.enabled === false ) return;   this._updatePointer( event );  this._updateState( event );   _intersections.length = 0;   raycaster.setFromCamera( _pointer, camera );  raycaster.intersectObjects( this.objects, this.recursive, _intersections );   if ( _intersections.length > 0 ) {    if ( this.transformGroup === true ) {     // look for the outermost group in the object's upper hierarchy     _selected = findGroup( _intersections[ 0 ].object );    } else {     _selected = _intersections[ 0 ].object;    }    _plane.setFromNormalAndCoplanarPoint( camera.getWorldDirection( _plane.normal ), _worldPosition.setFromMatrixPosition( _selected.matrixWorld ) );    if ( raycaster.ray.intersectPlane( _plane, _intersection ) ) {     if ( this.state === STATE.PAN ) {      _inverseMatrix.copy( _selected.parent.matrixWorld ).invert();     _offset.copy( _intersection ).sub( _worldPosition.setFromMatrixPosition( _selected.matrixWorld ) );     } else if ( this.state === STATE.ROTATE ) {      // the controls only support Y+ up     _up.set( 0, 1, 0 ).applyQuaternion( camera.quaternion ).normalize();     _right.set( 1, 0, 0 ).applyQuaternion( camera.quaternion ).normalize();     }    }    domElement.style.cursor = 'move';    this.dispatchEvent( { type: 'dragstart', object: _selected } );   }   _previousPointer.copy( _pointer );  }  function onPointerCancel() {   if ( this.enabled === false ) return;   if ( _selected ) {    this.dispatchEvent( { type: 'dragend', object: _selected } );    _selected = null;   }   this.domElement.style.cursor = _hovered ? 'pointer' : 'auto';   this.state = STATE.NONE;  }  function onContextMenu( event ) {   if ( this.enabled === false ) return;   event.preventDefault();  }  function findGroup( obj, group = null ) {   if ( obj.isGroup ) group = obj;   if ( obj.parent === null ) return group;   return findGroup( obj.parent, group );  }  export { DragControls }; 
^..^ FILENAME ^..^
addons|controls|FirstPersonControls.js
^..^ CONTENTS ^..^
import {  Controls,  MathUtils,  Spherical,  Vector3 } from 'three';  const _lookDirection = new Vector3(); const _spherical = new Spherical(); const _target = new Vector3(); const _targetPosition = new Vector3();  class FirstPersonControls extends Controls {   constructor( object, domElement = null ) {    super( object, domElement );    // API    this.movementSpeed = 1.0;   this.lookSpeed = 0.005;    this.lookVertical = true;   this.autoForward = false;    this.activeLook = true;    this.heightSpeed = false;   this.heightCoef = 1.0;   this.heightMin = 0.0;   this.heightMax = 1.0;    this.constrainVertical = false;   this.verticalMin = 0;   this.verticalMax = Math.PI;    this.mouseDragOn = false;    // internals    this._autoSpeedFactor = 0.0;    this._pointerX = 0;   this._pointerY = 0;    this._moveForward = false;   this._moveBackward = false;   this._moveLeft = false;   this._moveRight = false;    this._viewHalfX = 0;   this._viewHalfY = 0;    this._lat = 0;   this._lon = 0;    // event listeners    this._onPointerMove = onPointerMove.bind( this );   this._onPointerDown = onPointerDown.bind( this );   this._onPointerUp = onPointerUp.bind( this );   this._onContextMenu = onContextMenu.bind( this );   this._onKeyDown = onKeyDown.bind( this );   this._onKeyUp = onKeyUp.bind( this );    //    if ( domElement !== null ) {     this.connect();     this.handleResize();    }    this._setOrientation();   }   connect() {    window.addEventListener( 'keydown', this._onKeyDown );   window.addEventListener( 'keyup', this._onKeyUp );    this.domElement.addEventListener( 'pointermove', this._onPointerMove );   this.domElement.addEventListener( 'pointerdown', this._onPointerDown );   this.domElement.addEventListener( 'pointerup', this._onPointerUp );   this.domElement.addEventListener( 'contextmenu', this._onContextMenu );   }   disconnect() {    window.removeEventListener( 'keydown', this._onKeyDown );   window.removeEventListener( 'keyup', this._onKeyUp );    this.domElement.removeEventListener( 'pointerdown', this._onPointerMove );   this.domElement.removeEventListener( 'pointermove', this._onPointerDown );   this.domElement.removeEventListener( 'pointerup', this._onPointerUp );   this.domElement.removeEventListener( 'contextmenu', this._onContextMenu );   }   dispose() {    this.disconnect();   }   handleResize() {    if ( this.domElement === document ) {     this._viewHalfX = window.innerWidth / 2;    this._viewHalfY = window.innerHeight / 2;    } else {     this._viewHalfX = this.domElement.offsetWidth / 2;    this._viewHalfY = this.domElement.offsetHeight / 2;    }   }   lookAt( x, y, z ) {    if ( x.isVector3 ) {     _target.copy( x );    } else {     _target.set( x, y, z );    }    this.object.lookAt( _target );    this._setOrientation();    return this;   }   update( delta ) {    if ( this.enabled === false ) return;    if ( this.heightSpeed ) {     const y = MathUtils.clamp( this.object.position.y, this.heightMin, this.heightMax );    const heightDelta = y - this.heightMin;     this._autoSpeedFactor = delta * ( heightDelta * this.heightCoef );    } else {     this._autoSpeedFactor = 0.0;    }    const actualMoveSpeed = delta * this.movementSpeed;    if ( this._moveForward || ( this.autoForward && ! this._moveBackward ) ) this.object.translateZ( - ( actualMoveSpeed + this._autoSpeedFactor ) );   if ( this._moveBackward ) this.object.translateZ( actualMoveSpeed );    if ( this._moveLeft ) this.object.translateX( - actualMoveSpeed );   if ( this._moveRight ) this.object.translateX( actualMoveSpeed );    if ( this._moveUp ) this.object.translateY( actualMoveSpeed );   if ( this._moveDown ) this.object.translateY( - actualMoveSpeed );    let actualLookSpeed = delta * this.lookSpeed;    if ( ! this.activeLook ) {     actualLookSpeed = 0;    }    let verticalLookRatio = 1;    if ( this.constrainVertical ) {     verticalLookRatio = Math.PI / ( this.verticalMax - this.verticalMin );    }    this._lon -= this._pointerX * actualLookSpeed;   if ( this.lookVertical ) this._lat -= this._pointerY * actualLookSpeed * verticalLookRatio;    this._lat = Math.max( - 85, Math.min( 85, this._lat ) );    let phi = MathUtils.degToRad( 90 - this._lat );   const theta = MathUtils.degToRad( this._lon );    if ( this.constrainVertical ) {     phi = MathUtils.mapLinear( phi, 0, Math.PI, this.verticalMin, this.verticalMax );    }    const position = this.object.position;    _targetPosition.setFromSphericalCoords( 1, phi, theta ).add( position );    this.object.lookAt( _targetPosition );   }   _setOrientation() {    const quaternion = this.object.quaternion;    _lookDirection.set( 0, 0, - 1 ).applyQuaternion( quaternion );   _spherical.setFromVector3( _lookDirection );    this._lat = 90 - MathUtils.radToDeg( _spherical.phi );   this._lon = MathUtils.radToDeg( _spherical.theta );   }  }  function onPointerDown( event ) {   if ( this.domElement !== document ) {    this.domElement.focus();   }   if ( this.activeLook ) {    switch ( event.button ) {     case 0: this._moveForward = true; break;    case 2: this._moveBackward = true; break;    }   }   this.mouseDragOn = true;  }  function onPointerUp( event ) {   if ( this.activeLook ) {    switch ( event.button ) {     case 0: this._moveForward = false; break;    case 2: this._moveBackward = false; break;    }   }   this.mouseDragOn = false;  }  function onPointerMove( event ) {   if ( this.domElement === document ) {    this._pointerX = event.pageX - this._viewHalfX;   this._pointerY = event.pageY - this._viewHalfY;   } else {    this._pointerX = event.pageX - this.domElement.offsetLeft - this._viewHalfX;   this._pointerY = event.pageY - this.domElement.offsetTop - this._viewHalfY;   }  }  function onKeyDown( event ) {   switch ( event.code ) {    case 'ArrowUp':   case 'KeyW': this._moveForward = true; break;    case 'ArrowLeft':   case 'KeyA': this._moveLeft = true; break;    case 'ArrowDown':   case 'KeyS': this._moveBackward = true; break;    case 'ArrowRight':   case 'KeyD': this._moveRight = true; break;    case 'KeyR': this._moveUp = true; break;   case 'KeyF': this._moveDown = true; break;   }  }  function onKeyUp( event ) {   switch ( event.code ) {    case 'ArrowUp':   case 'KeyW': this._moveForward = false; break;    case 'ArrowLeft':   case 'KeyA': this._moveLeft = false; break;    case 'ArrowDown':   case 'KeyS': this._moveBackward = false; break;    case 'ArrowRight':   case 'KeyD': this._moveRight = false; break;    case 'KeyR': this._moveUp = false; break;   case 'KeyF': this._moveDown = false; break;   }  }  function onContextMenu( event ) {   if ( this.enabled === false ) return;   event.preventDefault();  }  export { FirstPersonControls }; 
^..^ FILENAME ^..^
addons|controls|FlyControls.js
^..^ CONTENTS ^..^
import {  Controls,  Quaternion,  Vector3 } from 'three';  const _changeEvent = { type: 'change' };  const _EPS = 0.000001; const _tmpQuaternion = new Quaternion();  class FlyControls extends Controls {   constructor( object, domElement = null ) {    super( object, domElement );    this.movementSpeed = 1.0;   this.rollSpeed = 0.005;    this.dragToLook = false;   this.autoForward = false;    // internals    this._moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };   this._moveVector = new Vector3( 0, 0, 0 );   this._rotationVector = new Vector3( 0, 0, 0 );   this._lastQuaternion = new Quaternion();   this._lastPosition = new Vector3();   this._status = 0;    // event listeners    this._onKeyDown = onKeyDown.bind( this );   this._onKeyUp = onKeyUp.bind( this );   this._onPointerMove = onPointerMove.bind( this );   this._onPointerDown = onPointerDown.bind( this );   this._onPointerUp = onPointerUp.bind( this );   this._onPointerCancel = onPointerCancel.bind( this );   this._onContextMenu = onContextMenu.bind( this );    //    if ( domElement !== null ) {     this.connect();    }   }   connect() {    window.addEventListener( 'keydown', this._onKeyDown );   window.addEventListener( 'keyup', this._onKeyUp );    this.domElement.addEventListener( 'pointermove', this._onPointerMove );   this.domElement.addEventListener( 'pointerdown', this._onPointerDown );   this.domElement.addEventListener( 'pointerup', this._onPointerUp );   this.domElement.addEventListener( 'pointercancel', this._onPointerCancel );   this.domElement.addEventListener( 'contextmenu', this._onContextMenu );   }   disconnect() {    window.removeEventListener( 'keydown', this._onKeyDown );   window.removeEventListener( 'keyup', this._onKeyUp );    this.domElement.removeEventListener( 'pointermove', this._onPointerMove );   this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );   this.domElement.removeEventListener( 'pointerup', this._onPointerUp );   this.domElement.removeEventListener( 'pointercancel', this._onPointerCancel );   this.domElement.removeEventListener( 'contextmenu', this._onContextMenu );   }   dispose() {    this.disconnect();   }   update( delta ) {    if ( this.enabled === false ) return;    const object = this.object;    const moveMult = delta * this.movementSpeed;   const rotMult = delta * this.rollSpeed;    object.translateX( this._moveVector.x * moveMult );   object.translateY( this._moveVector.y * moveMult );   object.translateZ( this._moveVector.z * moveMult );    _tmpQuaternion.set( this._rotationVector.x * rotMult, this._rotationVector.y * rotMult, this._rotationVector.z * rotMult, 1 ).normalize();   object.quaternion.multiply( _tmpQuaternion );    if (    this._lastPosition.distanceToSquared( object.position ) > _EPS ||    8 * ( 1 - this._lastQuaternion.dot( object.quaternion ) ) > _EPS   ) {     this.dispatchEvent( _changeEvent );    this._lastQuaternion.copy( object.quaternion );    this._lastPosition.copy( object.position );    }   }   // private   _updateMovementVector() {    const forward = ( this._moveState.forward || ( this.autoForward && ! this._moveState.back ) ) ? 1 : 0;    this._moveVector.x = ( - this._moveState.left + this._moveState.right );   this._moveVector.y = ( - this._moveState.down + this._moveState.up );   this._moveVector.z = ( - forward + this._moveState.back );    //console.log( 'move:', [ this._moveVector.x, this._moveVector.y, this._moveVector.z ] );   }   _updateRotationVector() {    this._rotationVector.x = ( - this._moveState.pitchDown + this._moveState.pitchUp );   this._rotationVector.y = ( - this._moveState.yawRight + this._moveState.yawLeft );   this._rotationVector.z = ( - this._moveState.rollRight + this._moveState.rollLeft );    //console.log( 'rotate:', [ this._rotationVector.x, this._rotationVector.y, this._rotationVector.z ] );   }   _getContainerDimensions() {    if ( this.domElement != document ) {     return {     size: [ this.domElement.offsetWidth, this.domElement.offsetHeight ],     offset: [ this.domElement.offsetLeft, this.domElement.offsetTop ]    };    } else {     return {     size: [ window.innerWidth, window.innerHeight ],     offset: [ 0, 0 ]    };    }   }  }  function onKeyDown( event ) {   if ( event.altKey || this.enabled === false ) {    return;   }   switch ( event.code ) {    case 'ShiftLeft':   case 'ShiftRight': this.movementSpeedMultiplier = .1; break;    case 'KeyW': this._moveState.forward = 1; break;   case 'KeyS': this._moveState.back = 1; break;    case 'KeyA': this._moveState.left = 1; break;   case 'KeyD': this._moveState.right = 1; break;    case 'KeyR': this._moveState.up = 1; break;   case 'KeyF': this._moveState.down = 1; break;    case 'ArrowUp': this._moveState.pitchUp = 1; break;   case 'ArrowDown': this._moveState.pitchDown = 1; break;    case 'ArrowLeft': this._moveState.yawLeft = 1; break;   case 'ArrowRight': this._moveState.yawRight = 1; break;    case 'KeyQ': this._moveState.rollLeft = 1; break;   case 'KeyE': this._moveState.rollRight = 1; break;   }   this._updateMovementVector();  this._updateRotationVector();  }  function onKeyUp( event ) {   if ( this.enabled === false ) return;   switch ( event.code ) {    case 'ShiftLeft':   case 'ShiftRight': this.movementSpeedMultiplier = 1; break;    case 'KeyW': this._moveState.forward = 0; break;   case 'KeyS': this._moveState.back = 0; break;    case 'KeyA': this._moveState.left = 0; break;   case 'KeyD': this._moveState.right = 0; break;    case 'KeyR': this._moveState.up = 0; break;   case 'KeyF': this._moveState.down = 0; break;    case 'ArrowUp': this._moveState.pitchUp = 0; break;   case 'ArrowDown': this._moveState.pitchDown = 0; break;    case 'ArrowLeft': this._moveState.yawLeft = 0; break;   case 'ArrowRight': this._moveState.yawRight = 0; break;    case 'KeyQ': this._moveState.rollLeft = 0; break;   case 'KeyE': this._moveState.rollRight = 0; break;   }   this._updateMovementVector();  this._updateRotationVector();  }  function onPointerDown( event ) {   if ( this.enabled === false ) return;   if ( this.dragToLook ) {    this._status ++;   } else {    switch ( event.button ) {     case 0: this._moveState.forward = 1; break;    case 2: this._moveState.back = 1; break;    }    this._updateMovementVector();   }  }  function onPointerMove( event ) {   if ( this.enabled === false ) return;   if ( ! this.dragToLook || this._status > 0 ) {    const container = this._getContainerDimensions();   const halfWidth = container.size[ 0 ] / 2;   const halfHeight = container.size[ 1 ] / 2;    this._moveState.yawLeft = - ( ( event.pageX - container.offset[ 0 ] ) - halfWidth ) / halfWidth;   this._moveState.pitchDown = ( ( event.pageY - container.offset[ 1 ] ) - halfHeight ) / halfHeight;    this._updateRotationVector();   }  }  function onPointerUp( event ) {   if ( this.enabled === false ) return;   if ( this.dragToLook ) {    this._status --;    this._moveState.yawLeft = this._moveState.pitchDown = 0;   } else {    switch ( event.button ) {     case 0: this._moveState.forward = 0; break;    case 2: this._moveState.back = 0; break;    }    this._updateMovementVector();   }   this._updateRotationVector();  }  function onPointerCancel() {   if ( this.enabled === false ) return;   if ( this.dragToLook ) {    this._status = 0;    this._moveState.yawLeft = this._moveState.pitchDown = 0;   } else {    this._moveState.forward = 0;   this._moveState.back = 0;    this._updateMovementVector();   }   this._updateRotationVector();  }  function onContextMenu( event ) {   if ( this.enabled === false ) return;   event.preventDefault();  }  export { FlyControls }; 
^..^ FILENAME ^..^
addons|controls|MapControls.js
^..^ CONTENTS ^..^
import { MOUSE, TOUCH } from 'three';  import { OrbitControls } from './OrbitControls.js';  // MapControls performs orbiting, dollying (zooming), and panning. // Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default). // //    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate //    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish //    Pan - left mouse, or arrow keys / touch: one-finger move  class MapControls extends OrbitControls {   constructor( object, domElement ) {    super( object, domElement );    this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up    this.mouseButtons = { LEFT: MOUSE.PAN, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.ROTATE };    this.touches = { ONE: TOUCH.PAN, TWO: TOUCH.DOLLY_ROTATE };   }  }  export { MapControls }; 
^..^ FILENAME ^..^
addons|controls|OrbitControls.js
^..^ CONTENTS ^..^
import {  Controls,  MOUSE,  Quaternion,  Spherical,  TOUCH,  Vector2,  Vector3,  Plane,  Ray,  MathUtils } from 'three';  // OrbitControls performs orbiting, dollying (zooming), and panning. // Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default). // //    Orbit - left mouse / touch: one-finger move //    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish //    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move  const _changeEvent = { type: 'change' }; const _startEvent = { type: 'start' }; const _endEvent = { type: 'end' }; const _ray = new Ray(); const _plane = new Plane(); const _TILT_LIMIT = Math.cos( 70 * MathUtils.DEG2RAD );  const _v = new Vector3(); const _twoPI = 2 * Math.PI;  const _STATE = {  NONE: - 1,  ROTATE: 0,  DOLLY: 1,  PAN: 2,  TOUCH_ROTATE: 3,  TOUCH_PAN: 4,  TOUCH_DOLLY_PAN: 5,  TOUCH_DOLLY_ROTATE: 6 }; const _EPS = 0.000001;  class OrbitControls extends Controls {   constructor( object, domElement = null ) {    super( object, domElement );    this.state = _STATE.NONE;    // Set to false to disable this control   this.enabled = true;    // "target" sets the location of focus, where the object orbits around   this.target = new Vector3();    // Sets the 3D cursor (similar to Blender), from which the maxTargetRadius takes effect   this.cursor = new Vector3();    // How far you can dolly in and out ( PerspectiveCamera only )   this.minDistance = 0;   this.maxDistance = Infinity;    // How far you can zoom in and out ( OrthographicCamera only )   this.minZoom = 0;   this.maxZoom = Infinity;    // Limit camera target within a spherical area around the cursor   this.minTargetRadius = 0;   this.maxTargetRadius = Infinity;    // How far you can orbit vertically, upper and lower limits.   // Range is 0 to Math.PI radians.   this.minPolarAngle = 0; // radians   this.maxPolarAngle = Math.PI; // radians    // How far you can orbit horizontally, upper and lower limits.   // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )   this.minAzimuthAngle = - Infinity; // radians   this.maxAzimuthAngle = Infinity; // radians    // Set to true to enable damping (inertia)   // If damping is enabled, you must call controls.update() in your animation loop   this.enableDamping = false;   this.dampingFactor = 0.05;    // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.   // Set to false to disable zooming   this.enableZoom = true;   this.zoomSpeed = 1.0;    // Set to false to disable rotating   this.enableRotate = true;   this.rotateSpeed = 1.0;    // Set to false to disable panning   this.enablePan = true;   this.panSpeed = 1.0;   this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up   this.keyPanSpeed = 7.0; // pixels moved per arrow key push   this.zoomToCursor = false;    // Set to true to automatically rotate around the target   // If auto-rotate is enabled, you must call controls.update() in your animation loop   this.autoRotate = false;   this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60    // The four arrow keys   this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };    // Mouse buttons   this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };    // Touch fingers   this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };    // for reset   this.target0 = this.target.clone();   this.position0 = this.object.position.clone();   this.zoom0 = this.object.zoom;    // the target DOM element for key events   this._domElementKeyEvents = null;    // internals    this._lastPosition = new Vector3();   this._lastQuaternion = new Quaternion();   this._lastTargetPosition = new Vector3();    // so camera.up is the orbit axis   this._quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );   this._quatInverse = this._quat.clone().invert();    // current position in spherical coordinates   this._spherical = new Spherical();   this._sphericalDelta = new Spherical();    this._scale = 1;   this._panOffset = new Vector3();    this._rotateStart = new Vector2();   this._rotateEnd = new Vector2();   this._rotateDelta = new Vector2();    this._panStart = new Vector2();   this._panEnd = new Vector2();   this._panDelta = new Vector2();    this._dollyStart = new Vector2();   this._dollyEnd = new Vector2();   this._dollyDelta = new Vector2();    this._dollyDirection = new Vector3();   this._mouse = new Vector2();   this._performCursorZoom = false;    this._pointers = [];   this._pointerPositions = {};    this._controlActive = false;    // event listeners    this._onPointerMove = onPointerMove.bind( this );   this._onPointerDown = onPointerDown.bind( this );   this._onPointerUp = onPointerUp.bind( this );   this._onContextMenu = onContextMenu.bind( this );   this._onMouseWheel = onMouseWheel.bind( this );   this._onKeyDown = onKeyDown.bind( this );    this._onTouchStart = onTouchStart.bind( this );   this._onTouchMove = onTouchMove.bind( this );    this._onMouseDown = onMouseDown.bind( this );   this._onMouseMove = onMouseMove.bind( this );    this._interceptControlDown = interceptControlDown.bind( this );   this._interceptControlUp = interceptControlUp.bind( this );    //    if ( this.domElement !== null ) {     this.connect();    }    this.update();   }   connect() {    this.domElement.addEventListener( 'pointerdown', this._onPointerDown );   this.domElement.addEventListener( 'pointercancel', this._onPointerUp );    this.domElement.addEventListener( 'contextmenu', this._onContextMenu );   this.domElement.addEventListener( 'wheel', this._onMouseWheel, { passive: false } );    const document = this.domElement.getRootNode(); // offscreen canvas compatibility   document.addEventListener( 'keydown', this._interceptControlDown, { passive: true, capture: true } );    this.domElement.style.touchAction = 'none'; // disable touch scroll   }   disconnect() {    this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );   this.domElement.removeEventListener( 'pointermove', this._onPointerMove );   this.domElement.removeEventListener( 'pointerup', this._onPointerUp );   this.domElement.removeEventListener( 'pointercancel', this._onPointerUp );    this.domElement.removeEventListener( 'wheel', this._onMouseWheel );   this.domElement.removeEventListener( 'contextmenu', this._onContextMenu );    this.stopListenToKeyEvents();    const document = this.domElement.getRootNode(); // offscreen canvas compatibility   document.removeEventListener( 'keydown', this._interceptControlDown, { capture: true } );    this.domElement.style.touchAction = 'auto';   }   dispose() {    this.disconnect();   }   getPolarAngle() {    return this._spherical.phi;   }   getAzimuthalAngle() {    return this._spherical.theta;   }   getDistance() {    return this.object.position.distanceTo( this.target );   }   listenToKeyEvents( domElement ) {    domElement.addEventListener( 'keydown', this._onKeyDown );   this._domElementKeyEvents = domElement;   }   stopListenToKeyEvents() {    if ( this._domElementKeyEvents !== null ) {     this._domElementKeyEvents.removeEventListener( 'keydown', this._onKeyDown );    this._domElementKeyEvents = null;    }   }   saveState() {    this.target0.copy( this.target );   this.position0.copy( this.object.position );   this.zoom0 = this.object.zoom;   }   reset() {    this.target.copy( this.target0 );   this.object.position.copy( this.position0 );   this.object.zoom = this.zoom0;    this.object.updateProjectionMatrix();   this.dispatchEvent( _changeEvent );    this.update();    this.state = _STATE.NONE;   }   update( deltaTime = null ) {    const position = this.object.position;    _v.copy( position ).sub( this.target );    // rotate offset to "y-axis-is-up" space   _v.applyQuaternion( this._quat );    // angle from z-axis around y-axis   this._spherical.setFromVector3( _v );    if ( this.autoRotate && this.state === _STATE.NONE ) {     this._rotateLeft( this._getAutoRotationAngle( deltaTime ) );    }    if ( this.enableDamping ) {     this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;    this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;    } else {     this._spherical.theta += this._sphericalDelta.theta;    this._spherical.phi += this._sphericalDelta.phi;    }    // restrict theta to be between desired limits    let min = this.minAzimuthAngle;   let max = this.maxAzimuthAngle;    if ( isFinite( min ) && isFinite( max ) ) {     if ( min < - Math.PI ) min += _twoPI; else if ( min > Math.PI ) min -= _twoPI;     if ( max < - Math.PI ) max += _twoPI; else if ( max > Math.PI ) max -= _twoPI;     if ( min <= max ) {      this._spherical.theta = Math.max( min, Math.min( max, this._spherical.theta ) );     } else {      this._spherical.theta = ( this._spherical.theta > ( min + max ) / 2 ) ?      Math.max( min, this._spherical.theta ) :      Math.min( max, this._spherical.theta );     }    }    // restrict phi to be between desired limits   this._spherical.phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, this._spherical.phi ) );    this._spherical.makeSafe();     // move target to panned location    if ( this.enableDamping === true ) {     this.target.addScaledVector( this._panOffset, this.dampingFactor );    } else {     this.target.add( this._panOffset );    }    // Limit the target distance from the cursor to create a sphere around the center of interest   this.target.sub( this.cursor );   this.target.clampLength( this.minTargetRadius, this.maxTargetRadius );   this.target.add( this.cursor );    let zoomChanged = false;   // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera   // we adjust zoom later in these cases   if ( this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera ) {     this._spherical.radius = this._clampDistance( this._spherical.radius );    } else {     const prevRadius = this._spherical.radius;    this._spherical.radius = this._clampDistance( this._spherical.radius * this._scale );    zoomChanged = prevRadius != this._spherical.radius;    }    _v.setFromSpherical( this._spherical );    // rotate offset back to "camera-up-vector-is-up" space   _v.applyQuaternion( this._quatInverse );    position.copy( this.target ).add( _v );    this.object.lookAt( this.target );    if ( this.enableDamping === true ) {     this._sphericalDelta.theta *= ( 1 - this.dampingFactor );    this._sphericalDelta.phi *= ( 1 - this.dampingFactor );     this._panOffset.multiplyScalar( 1 - this.dampingFactor );    } else {     this._sphericalDelta.set( 0, 0, 0 );     this._panOffset.set( 0, 0, 0 );    }    // adjust camera position   if ( this.zoomToCursor && this._performCursorZoom ) {     let newRadius = null;    if ( this.object.isPerspectiveCamera ) {      // move the camera down the pointer ray     // this method avoids floating point error     const prevRadius = _v.length();     newRadius = this._clampDistance( prevRadius * this._scale );      const radiusDelta = prevRadius - newRadius;     this.object.position.addScaledVector( this._dollyDirection, radiusDelta );     this.object.updateMatrixWorld();      zoomChanged = !! radiusDelta;     } else if ( this.object.isOrthographicCamera ) {      // adjust the ortho camera position based on zoom changes     const mouseBefore = new Vector3( this._mouse.x, this._mouse.y, 0 );     mouseBefore.unproject( this.object );      const prevZoom = this.object.zoom;     this.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / this._scale ) );     this.object.updateProjectionMatrix();      zoomChanged = prevZoom !== this.object.zoom;      const mouseAfter = new Vector3( this._mouse.x, this._mouse.y, 0 );     mouseAfter.unproject( this.object );      this.object.position.sub( mouseAfter ).add( mouseBefore );     this.object.updateMatrixWorld();      newRadius = _v.length();     } else {      console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );     this.zoomToCursor = false;     }     // handle the placement of the target    if ( newRadius !== null ) {      if ( this.screenSpacePanning ) {       // position the orbit target in front of the new camera position      this.target.set( 0, 0, - 1 )       .transformDirection( this.object.matrix )       .multiplyScalar( newRadius )       .add( this.object.position );      } else {       // get the ray and translation plane to compute target      _ray.origin.copy( this.object.position );      _ray.direction.set( 0, 0, - 1 ).transformDirection( this.object.matrix );       // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid      // extremely large values      if ( Math.abs( this.object.up.dot( _ray.direction ) ) < _TILT_LIMIT ) {        this.object.lookAt( this.target );       } else {        _plane.setFromNormalAndCoplanarPoint( this.object.up, this.target );       _ray.intersectPlane( _plane, this.target );       }      }     }    } else if ( this.object.isOrthographicCamera ) {     const prevZoom = this.object.zoom;    this.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / this._scale ) );     if ( prevZoom !== this.object.zoom ) {      this.object.updateProjectionMatrix();     zoomChanged = true;     }    }    this._scale = 1;   this._performCursorZoom = false;    // update condition is:   // min(camera displacement, camera rotation in radians)^2 > EPS   // using small-angle approximation cos(x/2) = 1 - x^2 / 8    if ( zoomChanged ||    this._lastPosition.distanceToSquared( this.object.position ) > _EPS ||    8 * ( 1 - this._lastQuaternion.dot( this.object.quaternion ) ) > _EPS ||    this._lastTargetPosition.distanceToSquared( this.target ) > _EPS ) {     this.dispatchEvent( _changeEvent );     this._lastPosition.copy( this.object.position );    this._lastQuaternion.copy( this.object.quaternion );    this._lastTargetPosition.copy( this.target );     return true;    }    return false;   }   _getAutoRotationAngle( deltaTime ) {    if ( deltaTime !== null ) {     return ( _twoPI / 60 * this.autoRotateSpeed ) * deltaTime;    } else {     return _twoPI / 60 / 60 * this.autoRotateSpeed;    }   }   _getZoomScale( delta ) {    const normalizedDelta = Math.abs( delta * 0.01 );   return Math.pow( 0.95, this.zoomSpeed * normalizedDelta );   }   _rotateLeft( angle ) {    this._sphericalDelta.theta -= angle;   }   _rotateUp( angle ) {    this._sphericalDelta.phi -= angle;   }   _panLeft( distance, objectMatrix ) {    _v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix   _v.multiplyScalar( - distance );    this._panOffset.add( _v );   }   _panUp( distance, objectMatrix ) {    if ( this.screenSpacePanning === true ) {     _v.setFromMatrixColumn( objectMatrix, 1 );    } else {     _v.setFromMatrixColumn( objectMatrix, 0 );    _v.crossVectors( this.object.up, _v );    }    _v.multiplyScalar( distance );    this._panOffset.add( _v );   }   // deltaX and deltaY are in pixels; right and down are positive  _pan( deltaX, deltaY ) {    const element = this.domElement;    if ( this.object.isPerspectiveCamera ) {     // perspective    const position = this.object.position;    _v.copy( position ).sub( this.target );    let targetDistance = _v.length();     // half of the fov is center to top of screen    targetDistance *= Math.tan( ( this.object.fov / 2 ) * Math.PI / 180.0 );     // we use only clientHeight here so aspect ratio does not distort speed    this._panLeft( 2 * deltaX * targetDistance / element.clientHeight, this.object.matrix );    this._panUp( 2 * deltaY * targetDistance / element.clientHeight, this.object.matrix );    } else if ( this.object.isOrthographicCamera ) {     // orthographic    this._panLeft( deltaX * ( this.object.right - this.object.left ) / this.object.zoom / element.clientWidth, this.object.matrix );    this._panUp( deltaY * ( this.object.top - this.object.bottom ) / this.object.zoom / element.clientHeight, this.object.matrix );    } else {     // camera neither orthographic nor perspective    console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );    this.enablePan = false;    }   }   _dollyOut( dollyScale ) {    if ( this.object.isPerspectiveCamera || this.object.isOrthographicCamera ) {     this._scale /= dollyScale;    } else {     console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );    this.enableZoom = false;    }   }   _dollyIn( dollyScale ) {    if ( this.object.isPerspectiveCamera || this.object.isOrthographicCamera ) {     this._scale *= dollyScale;    } else {     console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );    this.enableZoom = false;    }   }   _updateZoomParameters( x, y ) {    if ( ! this.zoomToCursor ) {     return;    }    this._performCursorZoom = true;    const rect = this.domElement.getBoundingClientRect();   const dx = x - rect.left;   const dy = y - rect.top;   const w = rect.width;   const h = rect.height;    this._mouse.x = ( dx / w ) * 2 - 1;   this._mouse.y = - ( dy / h ) * 2 + 1;    this._dollyDirection.set( this._mouse.x, this._mouse.y, 1 ).unproject( this.object ).sub( this.object.position ).normalize();   }   _clampDistance( dist ) {    return Math.max( this.minDistance, Math.min( this.maxDistance, dist ) );   }   //  // event callbacks - update the object state  //   _handleMouseDownRotate( event ) {    this._rotateStart.set( event.clientX, event.clientY );   }   _handleMouseDownDolly( event ) {    this._updateZoomParameters( event.clientX, event.clientX );   this._dollyStart.set( event.clientX, event.clientY );   }   _handleMouseDownPan( event ) {    this._panStart.set( event.clientX, event.clientY );   }   _handleMouseMoveRotate( event ) {    this._rotateEnd.set( event.clientX, event.clientY );    this._rotateDelta.subVectors( this._rotateEnd, this._rotateStart ).multiplyScalar( this.rotateSpeed );    const element = this.domElement;    this._rotateLeft( _twoPI * this._rotateDelta.x / element.clientHeight ); // yes, height    this._rotateUp( _twoPI * this._rotateDelta.y / element.clientHeight );    this._rotateStart.copy( this._rotateEnd );    this.update();   }   _handleMouseMoveDolly( event ) {    this._dollyEnd.set( event.clientX, event.clientY );    this._dollyDelta.subVectors( this._dollyEnd, this._dollyStart );    if ( this._dollyDelta.y > 0 ) {     this._dollyOut( this._getZoomScale( this._dollyDelta.y ) );    } else if ( this._dollyDelta.y < 0 ) {     this._dollyIn( this._getZoomScale( this._dollyDelta.y ) );    }    this._dollyStart.copy( this._dollyEnd );    this.update();   }   _handleMouseMovePan( event ) {    this._panEnd.set( event.clientX, event.clientY );    this._panDelta.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.panSpeed );    this._pan( this._panDelta.x, this._panDelta.y );    this._panStart.copy( this._panEnd );    this.update();   }   _handleMouseWheel( event ) {    this._updateZoomParameters( event.clientX, event.clientY );    if ( event.deltaY < 0 ) {     this._dollyIn( this._getZoomScale( event.deltaY ) );    } else if ( event.deltaY > 0 ) {     this._dollyOut( this._getZoomScale( event.deltaY ) );    }    this.update();   }   _handleKeyDown( event ) {    let needsUpdate = false;    switch ( event.code ) {     case this.keys.UP:      if ( event.ctrlKey || event.metaKey || event.shiftKey ) {       this._rotateUp( _twoPI * this.rotateSpeed / this.domElement.clientHeight );      } else {       this._pan( 0, this.keyPanSpeed );      }      needsUpdate = true;     break;     case this.keys.BOTTOM:      if ( event.ctrlKey || event.metaKey || event.shiftKey ) {       this._rotateUp( - _twoPI * this.rotateSpeed / this.domElement.clientHeight );      } else {       this._pan( 0, - this.keyPanSpeed );      }      needsUpdate = true;     break;     case this.keys.LEFT:      if ( event.ctrlKey || event.metaKey || event.shiftKey ) {       this._rotateLeft( _twoPI * this.rotateSpeed / this.domElement.clientHeight );      } else {       this._pan( this.keyPanSpeed, 0 );      }      needsUpdate = true;     break;     case this.keys.RIGHT:      if ( event.ctrlKey || event.metaKey || event.shiftKey ) {       this._rotateLeft( - _twoPI * this.rotateSpeed / this.domElement.clientHeight );      } else {       this._pan( - this.keyPanSpeed, 0 );      }      needsUpdate = true;     break;    }    if ( needsUpdate ) {     // prevent the browser from scrolling on cursor keys    event.preventDefault();     this.update();    }    }   _handleTouchStartRotate( event ) {    if ( this._pointers.length === 1 ) {     this._rotateStart.set( event.pageX, event.pageY );    } else {     const position = this._getSecondPointerPosition( event );     const x = 0.5 * ( event.pageX + position.x );    const y = 0.5 * ( event.pageY + position.y );     this._rotateStart.set( x, y );    }   }   _handleTouchStartPan( event ) {    if ( this._pointers.length === 1 ) {     this._panStart.set( event.pageX, event.pageY );    } else {     const position = this._getSecondPointerPosition( event );     const x = 0.5 * ( event.pageX + position.x );    const y = 0.5 * ( event.pageY + position.y );     this._panStart.set( x, y );    }   }   _handleTouchStartDolly( event ) {    const position = this._getSecondPointerPosition( event );    const dx = event.pageX - position.x;   const dy = event.pageY - position.y;    const distance = Math.sqrt( dx * dx + dy * dy );    this._dollyStart.set( 0, distance );   }   _handleTouchStartDollyPan( event ) {    if ( this.enableZoom ) this._handleTouchStartDolly( event );    if ( this.enablePan ) this._handleTouchStartPan( event );   }   _handleTouchStartDollyRotate( event ) {    if ( this.enableZoom ) this._handleTouchStartDolly( event );    if ( this.enableRotate ) this._handleTouchStartRotate( event );   }   _handleTouchMoveRotate( event ) {    if ( this._pointers.length == 1 ) {     this._rotateEnd.set( event.pageX, event.pageY );    } else {     const position = this._getSecondPointerPosition( event );     const x = 0.5 * ( event.pageX + position.x );    const y = 0.5 * ( event.pageY + position.y );     this._rotateEnd.set( x, y );    }    this._rotateDelta.subVectors( this._rotateEnd, this._rotateStart ).multiplyScalar( this.rotateSpeed );    const element = this.domElement;    this._rotateLeft( _twoPI * this._rotateDelta.x / element.clientHeight ); // yes, height    this._rotateUp( _twoPI * this._rotateDelta.y / element.clientHeight );    this._rotateStart.copy( this._rotateEnd );   }   _handleTouchMovePan( event ) {    if ( this._pointers.length === 1 ) {     this._panEnd.set( event.pageX, event.pageY );    } else {     const position = this._getSecondPointerPosition( event );     const x = 0.5 * ( event.pageX + position.x );    const y = 0.5 * ( event.pageY + position.y );     this._panEnd.set( x, y );    }    this._panDelta.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.panSpeed );    this._pan( this._panDelta.x, this._panDelta.y );    this._panStart.copy( this._panEnd );   }   _handleTouchMoveDolly( event ) {    const position = this._getSecondPointerPosition( event );    const dx = event.pageX - position.x;   const dy = event.pageY - position.y;    const distance = Math.sqrt( dx * dx + dy * dy );    this._dollyEnd.set( 0, distance );    this._dollyDelta.set( 0, Math.pow( this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed ) );    this._dollyOut( this._dollyDelta.y );    this._dollyStart.copy( this._dollyEnd );    const centerX = ( event.pageX + position.x ) * 0.5;   const centerY = ( event.pageY + position.y ) * 0.5;    this._updateZoomParameters( centerX, centerY );   }   _handleTouchMoveDollyPan( event ) {    if ( this.enableZoom ) this._handleTouchMoveDolly( event );    if ( this.enablePan ) this._handleTouchMovePan( event );   }   _handleTouchMoveDollyRotate( event ) {    if ( this.enableZoom ) this._handleTouchMoveDolly( event );    if ( this.enableRotate ) this._handleTouchMoveRotate( event );   }   // pointers   _addPointer( event ) {    this._pointers.push( event.pointerId );   }   _removePointer( event ) {    delete this._pointerPositions[ event.pointerId ];    for ( let i = 0; i < this._pointers.length; i ++ ) {     if ( this._pointers[ i ] == event.pointerId ) {      this._pointers.splice( i, 1 );     return;     }    }   }   _isTrackingPointer( event ) {    for ( let i = 0; i < this._pointers.length; i ++ ) {     if ( this._pointers[ i ] == event.pointerId ) return true;    }    return false;   }   _trackPointer( event ) {    let position = this._pointerPositions[ event.pointerId ];    if ( position === undefined ) {     position = new Vector2();    this._pointerPositions[ event.pointerId ] = position;    }    position.set( event.pageX, event.pageY );   }   _getSecondPointerPosition( event ) {    const pointerId = ( event.pointerId === this._pointers[ 0 ] ) ? this._pointers[ 1 ] : this._pointers[ 0 ];    return this._pointerPositions[ pointerId ];   }   //   _customWheelEvent( event ) {    const mode = event.deltaMode;    // minimal wheel event altered to meet delta-zoom demand   const newEvent = {    clientX: event.clientX,    clientY: event.clientY,    deltaY: event.deltaY,   };    switch ( mode ) {     case 1: // LINE_MODE     newEvent.deltaY *= 16;     break;     case 2: // PAGE_MODE     newEvent.deltaY *= 100;     break;    }    // detect if event was triggered by pinching   if ( event.ctrlKey && ! this._controlActive ) {     newEvent.deltaY *= 10;    }    return newEvent;   }  }  function onPointerDown( event ) {   if ( this.enabled === false ) return;   if ( this._pointers.length === 0 ) {    this.domElement.setPointerCapture( event.pointerId );    this.domElement.addEventListener( 'pointermove', this._onPointerMove );   this.domElement.addEventListener( 'pointerup', this._onPointerUp );   }   //   if ( this._isTrackingPointer( event ) ) return;   //   this._addPointer( event );   if ( event.pointerType === 'touch' ) {    this._onTouchStart( event );   } else {    this._onMouseDown( event );   }  }  function onPointerMove( event ) {   if ( this.enabled === false ) return;   if ( event.pointerType === 'touch' ) {    this._onTouchMove( event );   } else {    this._onMouseMove( event );   }  }  function onPointerUp( event ) {   this._removePointer( event );   switch ( this._pointers.length ) {    case 0:     this.domElement.releasePointerCapture( event.pointerId );     this.domElement.removeEventListener( 'pointermove', this._onPointerMove );    this.domElement.removeEventListener( 'pointerup', this._onPointerUp );     this.dispatchEvent( _endEvent );     this.state = _STATE.NONE;     break;    case 1:     const pointerId = this._pointers[ 0 ];    const position = this._pointerPositions[ pointerId ];     // minimal placeholder event - allows state correction on pointer-up    this._onTouchStart( { pointerId: pointerId, pageX: position.x, pageY: position.y } );     break;   }  }  function onMouseDown( event ) {   let mouseAction;   switch ( event.button ) {    case 0:     mouseAction = this.mouseButtons.LEFT;    break;    case 1:     mouseAction = this.mouseButtons.MIDDLE;    break;    case 2:     mouseAction = this.mouseButtons.RIGHT;    break;    default:     mouseAction = - 1;   }   switch ( mouseAction ) {    case MOUSE.DOLLY:     if ( this.enableZoom === false ) return;     this._handleMouseDownDolly( event );     this.state = _STATE.DOLLY;     break;    case MOUSE.ROTATE:     if ( event.ctrlKey || event.metaKey || event.shiftKey ) {      if ( this.enablePan === false ) return;      this._handleMouseDownPan( event );      this.state = _STATE.PAN;     } else {      if ( this.enableRotate === false ) return;      this._handleMouseDownRotate( event );      this.state = _STATE.ROTATE;     }     break;    case MOUSE.PAN:     if ( event.ctrlKey || event.metaKey || event.shiftKey ) {      if ( this.enableRotate === false ) return;      this._handleMouseDownRotate( event );      this.state = _STATE.ROTATE;     } else {      if ( this.enablePan === false ) return;      this._handleMouseDownPan( event );      this.state = _STATE.PAN;     }     break;    default:     this.state = _STATE.NONE;   }   if ( this.state !== _STATE.NONE ) {    this.dispatchEvent( _startEvent );   }  }  function onMouseMove( event ) {   switch ( this.state ) {    case _STATE.ROTATE:     if ( this.enableRotate === false ) return;     this._handleMouseMoveRotate( event );     break;    case _STATE.DOLLY:     if ( this.enableZoom === false ) return;     this._handleMouseMoveDolly( event );     break;    case _STATE.PAN:     if ( this.enablePan === false ) return;     this._handleMouseMovePan( event );     break;   }  }  function onMouseWheel( event ) {   if ( this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE ) return;   event.preventDefault();   this.dispatchEvent( _startEvent );   this._handleMouseWheel( this._customWheelEvent( event ) );   this.dispatchEvent( _endEvent );  }  function onKeyDown( event ) {   if ( this.enabled === false || this.enablePan === false ) return;   this._handleKeyDown( event );  }  function onTouchStart( event ) {   this._trackPointer( event );   switch ( this._pointers.length ) {    case 1:     switch ( this.touches.ONE ) {      case TOUCH.ROTATE:       if ( this.enableRotate === false ) return;       this._handleTouchStartRotate( event );       this.state = _STATE.TOUCH_ROTATE;       break;      case TOUCH.PAN:       if ( this.enablePan === false ) return;       this._handleTouchStartPan( event );       this.state = _STATE.TOUCH_PAN;       break;      default:       this.state = _STATE.NONE;     }     break;    case 2:     switch ( this.touches.TWO ) {      case TOUCH.DOLLY_PAN:       if ( this.enableZoom === false && this.enablePan === false ) return;       this._handleTouchStartDollyPan( event );       this.state = _STATE.TOUCH_DOLLY_PAN;       break;      case TOUCH.DOLLY_ROTATE:       if ( this.enableZoom === false && this.enableRotate === false ) return;       this._handleTouchStartDollyRotate( event );       this.state = _STATE.TOUCH_DOLLY_ROTATE;       break;      default:       this.state = _STATE.NONE;     }     break;    default:     this.state = _STATE.NONE;   }   if ( this.state !== _STATE.NONE ) {    this.dispatchEvent( _startEvent );   }  }  function onTouchMove( event ) {   this._trackPointer( event );   switch ( this.state ) {    case _STATE.TOUCH_ROTATE:     if ( this.enableRotate === false ) return;     this._handleTouchMoveRotate( event );     this.update();     break;    case _STATE.TOUCH_PAN:     if ( this.enablePan === false ) return;     this._handleTouchMovePan( event );     this.update();     break;    case _STATE.TOUCH_DOLLY_PAN:     if ( this.enableZoom === false && this.enablePan === false ) return;     this._handleTouchMoveDollyPan( event );     this.update();     break;    case _STATE.TOUCH_DOLLY_ROTATE:     if ( this.enableZoom === false && this.enableRotate === false ) return;     this._handleTouchMoveDollyRotate( event );     this.update();     break;    default:     this.state = _STATE.NONE;   }  }  function onContextMenu( event ) {   if ( this.enabled === false ) return;   event.preventDefault();  }  function interceptControlDown( event ) {   if ( event.key === 'Control' ) {    this._controlActive = true;    const document = this.domElement.getRootNode(); // offscreen canvas compatibility    document.addEventListener( 'keyup', this._interceptControlUp, { passive: true, capture: true } );   }  }  function interceptControlUp( event ) {   if ( event.key === 'Control' ) {    this._controlActive = false;    const document = this.domElement.getRootNode(); // offscreen canvas compatibility    document.removeEventListener( 'keyup', this._interceptControlUp, { passive: true, capture: true } );   }  }  export { OrbitControls }; 
^..^ FILENAME ^..^
addons|controls|PointerLockControls.js
^..^ CONTENTS ^..^
import {  Controls,  Euler,  Vector3 } from 'three';  const _euler = new Euler( 0, 0, 0, 'YXZ' ); const _vector = new Vector3();  const _changeEvent = { type: 'change' }; const _lockEvent = { type: 'lock' }; const _unlockEvent = { type: 'unlock' };  const _PI_2 = Math.PI / 2;  class PointerLockControls extends Controls {   constructor( camera, domElement = null ) {    super( camera, domElement );    this.isLocked = false;    // Set to constrain the pitch of the camera   // Range is 0 to Math.PI radians   this.minPolarAngle = 0; // radians   this.maxPolarAngle = Math.PI; // radians    this.pointerSpeed = 1.0;    // event listeners    this._onMouseMove = onMouseMove.bind( this );   this._onPointerlockChange = onPointerlockChange.bind( this );   this._onPointerlockError = onPointerlockError.bind( this );    if ( this.domElement !== null ) {     this.connect();    }   }   connect() {    this.domElement.ownerDocument.addEventListener( 'mousemove', this._onMouseMove );   this.domElement.ownerDocument.addEventListener( 'pointerlockchange', this._onPointerlockChange );   this.domElement.ownerDocument.addEventListener( 'pointerlockerror', this._onPointerlockError );   }   disconnect() {    this.domElement.ownerDocument.removeEventListener( 'mousemove', this._onMouseMove );   this.domElement.ownerDocument.removeEventListener( 'pointerlockchange', this._onPointerlockChange );   this.domElement.ownerDocument.removeEventListener( 'pointerlockerror', this._onPointerlockError );   }   dispose() {    this.disconnect();   }   getObject() {    console.warn( 'THREE.PointerLockControls: getObject() has been deprecated. Use controls.object instead.' ); // @deprecated r169    return this.object;   }   getDirection( v ) {    return v.set( 0, 0, - 1 ).applyQuaternion( this.object.quaternion );   }   moveForward( distance ) {    if ( this.enabled === false ) return;    // move forward parallel to the xz-plane   // assumes camera.up is y-up    const camera = this.object;    _vector.setFromMatrixColumn( camera.matrix, 0 );    _vector.crossVectors( camera.up, _vector );    camera.position.addScaledVector( _vector, distance );   }   moveRight( distance ) {    if ( this.enabled === false ) return;    const camera = this.object;    _vector.setFromMatrixColumn( camera.matrix, 0 );    camera.position.addScaledVector( _vector, distance );   }   lock() {    this.domElement.requestPointerLock();   }   unlock() {    this.domElement.ownerDocument.exitPointerLock();   }  }  // event listeners  function onMouseMove( event ) {   if ( this.enabled === false || this.isLocked === false ) return;   const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;  const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;   const camera = this.object;  _euler.setFromQuaternion( camera.quaternion );   _euler.y -= movementX * 0.002 * this.pointerSpeed;  _euler.x -= movementY * 0.002 * this.pointerSpeed;   _euler.x = Math.max( _PI_2 - this.maxPolarAngle, Math.min( _PI_2 - this.minPolarAngle, _euler.x ) );   camera.quaternion.setFromEuler( _euler );   this.dispatchEvent( _changeEvent );  }  function onPointerlockChange() {   if ( this.domElement.ownerDocument.pointerLockElement === this.domElement ) {    this.dispatchEvent( _lockEvent );    this.isLocked = true;   } else {    this.dispatchEvent( _unlockEvent );    this.isLocked = false;   }  }  function onPointerlockError() {   console.error( 'THREE.PointerLockControls: Unable to use Pointer Lock API' );  }  export { PointerLockControls }; 
^..^ FILENAME ^..^
addons|controls|TrackballControls.js
^..^ CONTENTS ^..^
import {  Controls,  MathUtils,  MOUSE,  Quaternion,  Vector2,  Vector3 } from 'three';  const _changeEvent = { type: 'change' }; const _startEvent = { type: 'start' }; const _endEvent = { type: 'end' };  const _EPS = 0.000001; const _STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };  const _v2 = new Vector2(); const _mouseChange = new Vector2(); const _objectUp = new Vector3(); const _pan = new Vector3(); const _axis = new Vector3(); const _quaternion = new Quaternion(); const _eyeDirection = new Vector3(); const _objectUpDirection = new Vector3(); const _objectSidewaysDirection = new Vector3(); const _moveDirection = new Vector3();  class TrackballControls extends Controls {   constructor( object, domElement = null ) {    super( object, domElement );    // API    this.enabled = true;    this.screen = { left: 0, top: 0, width: 0, height: 0 };    this.rotateSpeed = 1.0;   this.zoomSpeed = 1.2;   this.panSpeed = 0.3;    this.noRotate = false;   this.noZoom = false;   this.noPan = false;    this.staticMoving = false;   this.dynamicDampingFactor = 0.2;    this.minDistance = 0;   this.maxDistance = Infinity;    this.minZoom = 0;   this.maxZoom = Infinity;    this.keys = [ 'KeyA' /*A*/, 'KeyS' /*S*/, 'KeyD' /*D*/ ];    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };   this.state = _STATE.NONE;   this.keyState = _STATE.NONE;    this.target = new Vector3();    // internals    this._lastPosition = new Vector3();   this._lastZoom = 1;   this._touchZoomDistanceStart = 0;   this._touchZoomDistanceEnd = 0;   this._lastAngle = 0;    this._eye = new Vector3();    this._movePrev = new Vector2();   this._moveCurr = new Vector2();    this._lastAxis = new Vector3();    this._zoomStart = new Vector2();   this._zoomEnd = new Vector2();    this._panStart = new Vector2();   this._panEnd = new Vector2();    this._pointers = [];   this._pointerPositions = {};    // event listeners    this._onPointerMove = onPointerMove.bind( this );   this._onPointerDown = onPointerDown.bind( this );   this._onPointerUp = onPointerUp.bind( this );   this._onPointerCancel = onPointerCancel.bind( this );   this._onContextMenu = onContextMenu.bind( this );   this._onMouseWheel = onMouseWheel.bind( this );   this._onKeyDown = onKeyDown.bind( this );   this._onKeyUp = onKeyUp.bind( this );    this._onTouchStart = onTouchStart.bind( this );   this._onTouchMove = onTouchMove.bind( this );   this._onTouchEnd = onTouchEnd.bind( this );    this._onMouseDown = onMouseDown.bind( this );   this._onMouseMove = onMouseMove.bind( this );   this._onMouseUp = onMouseUp.bind( this );    // for reset    this._target0 = this.target.clone();   this._position0 = this.object.position.clone();   this._up0 = this.object.up.clone();   this._zoom0 = this.object.zoom;    if ( domElement !== null ) {     this.connect();     this.handleResize();    }    // force an update at start   this.update();   }   connect() {    window.addEventListener( 'keydown', this._onKeyDown );   window.addEventListener( 'keyup', this._onKeyUp );    this.domElement.addEventListener( 'pointerdown', this._onPointerDown );   this.domElement.addEventListener( 'pointercancel', this._onPointerCancel );   this.domElement.addEventListener( 'wheel', this._onMouseWheel, { passive: false } );   this.domElement.addEventListener( 'contextmenu', this._onContextMenu );    this.domElement.style.touchAction = 'none'; // disable touch scroll   }   disconnect() {    window.removeEventListener( 'keydown', this._onKeyDown );   window.removeEventListener( 'keyup', this._onKeyUp );    this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );   this.domElement.removeEventListener( 'pointermove', this._onPointerMove );   this.domElement.removeEventListener( 'pointerup', this._onPointerUp );   this.domElement.removeEventListener( 'pointercancel', this._onPointerCancel );   this.domElement.removeEventListener( 'wheel', this._onMouseWheel );   this.domElement.removeEventListener( 'contextmenu', this._onContextMenu );    this.domElement.style.touchAction = 'auto'; // disable touch scroll   }   dispose() {    this.disconnect();   }   handleResize() {    const box = this.domElement.getBoundingClientRect();   // adjustments come from similar code in the jquery offset() function   const d = this.domElement.ownerDocument.documentElement;    this.screen.left = box.left + window.pageXOffset - d.clientLeft;   this.screen.top = box.top + window.pageYOffset - d.clientTop;   this.screen.width = box.width;   this.screen.height = box.height;   }   update() {    this._eye.subVectors( this.object.position, this.target );    if ( ! this.noRotate ) {     this._rotateCamera();    }    if ( ! this.noZoom ) {     this._zoomCamera();    }    if ( ! this.noPan ) {     this._panCamera();    }    this.object.position.addVectors( this.target, this._eye );    if ( this.object.isPerspectiveCamera ) {     this._checkDistances();     this.object.lookAt( this.target );     if ( this._lastPosition.distanceToSquared( this.object.position ) > _EPS ) {      this.dispatchEvent( _changeEvent );      this._lastPosition.copy( this.object.position );     }    } else if ( this.object.isOrthographicCamera ) {     this.object.lookAt( this.target );     if ( this._lastPosition.distanceToSquared( this.object.position ) > _EPS || this._lastZoom !== this.object.zoom ) {      this.dispatchEvent( _changeEvent );      this._lastPosition.copy( this.object.position );     this._lastZoom = this.object.zoom;     }    } else {     console.warn( 'THREE.TrackballControls: Unsupported camera type.' );    }   }   reset() {    this.state = _STATE.NONE;   this.keyState = _STATE.NONE;    this.target.copy( this._target0 );   this.object.position.copy( this._position0 );   this.object.up.copy( this._up0 );   this.object.zoom = this._zoom0;    this.object.updateProjectionMatrix();    this._eye.subVectors( this.object.position, this.target );    this.object.lookAt( this.target );    this.dispatchEvent( _changeEvent );    this._lastPosition.copy( this.object.position );   this._lastZoom = this.object.zoom;   }   _panCamera() {    _mouseChange.copy( this._panEnd ).sub( this._panStart );    if ( _mouseChange.lengthSq() ) {     if ( this.object.isOrthographicCamera ) {      const scale_x = ( this.object.right - this.object.left ) / this.object.zoom / this.domElement.clientWidth;     const scale_y = ( this.object.top - this.object.bottom ) / this.object.zoom / this.domElement.clientWidth;      _mouseChange.x *= scale_x;     _mouseChange.y *= scale_y;     }     _mouseChange.multiplyScalar( this._eye.length() * this.panSpeed );     _pan.copy( this._eye ).cross( this.object.up ).setLength( _mouseChange.x );    _pan.add( _objectUp.copy( this.object.up ).setLength( _mouseChange.y ) );     this.object.position.add( _pan );    this.target.add( _pan );     if ( this.staticMoving ) {      this._panStart.copy( this._panEnd );     } else {      this._panStart.add( _mouseChange.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.dynamicDampingFactor ) );     }    }   }   _rotateCamera() {    _moveDirection.set( this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0 );   let angle = _moveDirection.length();    if ( angle ) {     this._eye.copy( this.object.position ).sub( this.target );     _eyeDirection.copy( this._eye ).normalize();    _objectUpDirection.copy( this.object.up ).normalize();    _objectSidewaysDirection.crossVectors( _objectUpDirection, _eyeDirection ).normalize();     _objectUpDirection.setLength( this._moveCurr.y - this._movePrev.y );    _objectSidewaysDirection.setLength( this._moveCurr.x - this._movePrev.x );     _moveDirection.copy( _objectUpDirection.add( _objectSidewaysDirection ) );     _axis.crossVectors( _moveDirection, this._eye ).normalize();     angle *= this.rotateSpeed;    _quaternion.setFromAxisAngle( _axis, angle );     this._eye.applyQuaternion( _quaternion );    this.object.up.applyQuaternion( _quaternion );     this._lastAxis.copy( _axis );    this._lastAngle = angle;    } else if ( ! this.staticMoving && this._lastAngle ) {     this._lastAngle *= Math.sqrt( 1.0 - this.dynamicDampingFactor );    this._eye.copy( this.object.position ).sub( this.target );    _quaternion.setFromAxisAngle( this._lastAxis, this._lastAngle );    this._eye.applyQuaternion( _quaternion );    this.object.up.applyQuaternion( _quaternion );    }    this._movePrev.copy( this._moveCurr );   }   _zoomCamera() {    let factor;    if ( this.state === _STATE.TOUCH_ZOOM_PAN ) {     factor = this._touchZoomDistanceStart / this._touchZoomDistanceEnd;    this._touchZoomDistanceStart = this._touchZoomDistanceEnd;     if ( this.object.isPerspectiveCamera ) {      this._eye.multiplyScalar( factor );     } else if ( this.object.isOrthographicCamera ) {      this.object.zoom = MathUtils.clamp( this.object.zoom / factor, this.minZoom, this.maxZoom );      if ( this._lastZoom !== this.object.zoom ) {       this.object.updateProjectionMatrix();      }     } else {      console.warn( 'THREE.TrackballControls: Unsupported camera type' );     }    } else {     factor = 1.0 + ( this._zoomEnd.y - this._zoomStart.y ) * this.zoomSpeed;     if ( factor !== 1.0 && factor > 0.0 ) {      if ( this.object.isPerspectiveCamera ) {       this._eye.multiplyScalar( factor );      } else if ( this.object.isOrthographicCamera ) {       this.object.zoom = MathUtils.clamp( this.object.zoom / factor, this.minZoom, this.maxZoom );       if ( this._lastZoom !== this.object.zoom ) {        this.object.updateProjectionMatrix();       }      } else {       console.warn( 'THREE.TrackballControls: Unsupported camera type' );      }     }     if ( this.staticMoving ) {      this._zoomStart.copy( this._zoomEnd );     } else {      this._zoomStart.y += ( this._zoomEnd.y - this._zoomStart.y ) * this.dynamicDampingFactor;     }    }   }   _getMouseOnScreen( pageX, pageY ) {    _v2.set(    ( pageX - this.screen.left ) / this.screen.width,    ( pageY - this.screen.top ) / this.screen.height   );    return _v2;   }   _getMouseOnCircle( pageX, pageY ) {    _v2.set(    ( ( pageX - this.screen.width * 0.5 - this.screen.left ) / ( this.screen.width * 0.5 ) ),    ( ( this.screen.height + 2 * ( this.screen.top - pageY ) ) / this.screen.width ) // screen.width intentional   );    return _v2;   }   _addPointer( event ) {    this._pointers.push( event );   }   _removePointer( event ) {    delete this._pointerPositions[ event.pointerId ];    for ( let i = 0; i < this._pointers.length; i ++ ) {     if ( this._pointers[ i ].pointerId == event.pointerId ) {      this._pointers.splice( i, 1 );     return;     }    }   }   _trackPointer( event ) {    let position = this._pointerPositions[ event.pointerId ];    if ( position === undefined ) {     position = new Vector2();    this._pointerPositions[ event.pointerId ] = position;    }    position.set( event.pageX, event.pageY );   }   _getSecondPointerPosition( event ) {    const pointer = ( event.pointerId === this._pointers[ 0 ].pointerId ) ? this._pointers[ 1 ] : this._pointers[ 0 ];    return this._pointerPositions[ pointer.pointerId ];   }   _checkDistances() {    if ( ! this.noZoom || ! this.noPan ) {     if ( this._eye.lengthSq() > this.maxDistance * this.maxDistance ) {      this.object.position.addVectors( this.target, this._eye.setLength( this.maxDistance ) );     this._zoomStart.copy( this._zoomEnd );     }     if ( this._eye.lengthSq() < this.minDistance * this.minDistance ) {      this.object.position.addVectors( this.target, this._eye.setLength( this.minDistance ) );     this._zoomStart.copy( this._zoomEnd );     }    }   }  }  function onPointerDown( event ) {   if ( this.enabled === false ) return;   if ( this._pointers.length === 0 ) {    this.domElement.setPointerCapture( event.pointerId );    this.domElement.addEventListener( 'pointermove', this._onPointerMove );   this.domElement.addEventListener( 'pointerup', this._onPointerUp );   }   //   this._addPointer( event );   if ( event.pointerType === 'touch' ) {    this._onTouchStart( event );   } else {    this._onMouseDown( event );   }  }  function onPointerMove( event ) {   if ( this.enabled === false ) return;   if ( event.pointerType === 'touch' ) {    this._onTouchMove( event );   } else {    this._onMouseMove( event );   }  }  function onPointerUp( event ) {   if ( this.enabled === false ) return;   if ( event.pointerType === 'touch' ) {    this._onTouchEnd( event );   } else {    this._onMouseUp();   }   //   this._removePointer( event );   if ( this._pointers.length === 0 ) {    this.domElement.releasePointerCapture( event.pointerId );    this.domElement.removeEventListener( 'pointermove', this._onPointerMove );   this.domElement.removeEventListener( 'pointerup', this._onPointerUp );   }  }  function onPointerCancel( event ) {   this._removePointer( event );  }  function onKeyUp() {   if ( this.enabled === false ) return;   this.keyState = _STATE.NONE;   window.addEventListener( 'keydown', this._onKeyDown );  }  function onKeyDown( event ) {   if ( this.enabled === false ) return;   window.removeEventListener( 'keydown', this._onKeyDown );   if ( this.keyState !== _STATE.NONE ) {    return;   } else if ( event.code === this.keys[ _STATE.ROTATE ] && ! this.noRotate ) {    this.keyState = _STATE.ROTATE;   } else if ( event.code === this.keys[ _STATE.ZOOM ] && ! this.noZoom ) {    this.keyState = _STATE.ZOOM;   } else if ( event.code === this.keys[ _STATE.PAN ] && ! this.noPan ) {    this.keyState = _STATE.PAN;   }  }  function onMouseDown( event ) {   let mouseAction;   switch ( event.button ) {    case 0:    mouseAction = this.mouseButtons.LEFT;    break;    case 1:    mouseAction = this.mouseButtons.MIDDLE;    break;    case 2:    mouseAction = this.mouseButtons.RIGHT;    break;    default:    mouseAction = - 1;   }   switch ( mouseAction ) {    case MOUSE.DOLLY:    this.state = _STATE.ZOOM;    break;    case MOUSE.ROTATE:    this.state = _STATE.ROTATE;    break;    case MOUSE.PAN:    this.state = _STATE.PAN;    break;    default:    this.state = _STATE.NONE;   }   const state = ( this.keyState !== _STATE.NONE ) ? this.keyState : this.state;   if ( state === _STATE.ROTATE && ! this.noRotate ) {    this._moveCurr.copy( this._getMouseOnCircle( event.pageX, event.pageY ) );   this._movePrev.copy( this._moveCurr );   } else if ( state === _STATE.ZOOM && ! this.noZoom ) {    this._zoomStart.copy( this._getMouseOnScreen( event.pageX, event.pageY ) );   this._zoomEnd.copy( this._zoomStart );   } else if ( state === _STATE.PAN && ! this.noPan ) {    this._panStart.copy( this._getMouseOnScreen( event.pageX, event.pageY ) );   this._panEnd.copy( this._panStart );   }   this.dispatchEvent( _startEvent );  }  function onMouseMove( event ) {   const state = ( this.keyState !== _STATE.NONE ) ? this.keyState : this.state;   if ( state === _STATE.ROTATE && ! this.noRotate ) {    this._movePrev.copy( this._moveCurr );   this._moveCurr.copy( this._getMouseOnCircle( event.pageX, event.pageY ) );   } else if ( state === _STATE.ZOOM && ! this.noZoom ) {    this._zoomEnd.copy( this._getMouseOnScreen( event.pageX, event.pageY ) );   } else if ( state === _STATE.PAN && ! this.noPan ) {    this._panEnd.copy( this._getMouseOnScreen( event.pageX, event.pageY ) );   }  }  function onMouseUp() {   this.state = _STATE.NONE;   this.dispatchEvent( _endEvent );  }  function onMouseWheel( event ) {   if ( this.enabled === false ) return;   if ( this.noZoom === true ) return;   event.preventDefault();   switch ( event.deltaMode ) {    case 2:    // Zoom in pages    this._zoomStart.y -= event.deltaY * 0.025;    break;    case 1:    // Zoom in lines    this._zoomStart.y -= event.deltaY * 0.01;    break;    default:    // undefined, 0, assume pixels    this._zoomStart.y -= event.deltaY * 0.00025;    break;   }   this.dispatchEvent( _startEvent );  this.dispatchEvent( _endEvent );  }  function onContextMenu( event ) {   if ( this.enabled === false ) return;   event.preventDefault();  }  function onTouchStart( event ) {   this._trackPointer( event );   switch ( this._pointers.length ) {    case 1:    this.state = _STATE.TOUCH_ROTATE;    this._moveCurr.copy( this._getMouseOnCircle( this._pointers[ 0 ].pageX, this._pointers[ 0 ].pageY ) );    this._movePrev.copy( this._moveCurr );    break;    default: // 2 or more    this.state = _STATE.TOUCH_ZOOM_PAN;    const dx = this._pointers[ 0 ].pageX - this._pointers[ 1 ].pageX;    const dy = this._pointers[ 0 ].pageY - this._pointers[ 1 ].pageY;    this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );     const x = ( this._pointers[ 0 ].pageX + this._pointers[ 1 ].pageX ) / 2;    const y = ( this._pointers[ 0 ].pageY + this._pointers[ 1 ].pageY ) / 2;    this._panStart.copy( this._getMouseOnScreen( x, y ) );    this._panEnd.copy( this._panStart );    break;   }   this.dispatchEvent( _startEvent );  }  function onTouchMove( event ) {   this._trackPointer( event );   switch ( this._pointers.length ) {    case 1:    this._movePrev.copy( this._moveCurr );    this._moveCurr.copy( this._getMouseOnCircle( event.pageX, event.pageY ) );    break;    default: // 2 or more     const position = this._getSecondPointerPosition( event );     const dx = event.pageX - position.x;    const dy = event.pageY - position.y;    this._touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );     const x = ( event.pageX + position.x ) / 2;    const y = ( event.pageY + position.y ) / 2;    this._panEnd.copy( this._getMouseOnScreen( x, y ) );    break;   }  }  function onTouchEnd( event ) {   switch ( this._pointers.length ) {    case 0:    this.state = _STATE.NONE;    break;    case 1:    this.state = _STATE.TOUCH_ROTATE;    this._moveCurr.copy( this._getMouseOnCircle( event.pageX, event.pageY ) );    this._movePrev.copy( this._moveCurr );    break;    case 2:    this.state = _STATE.TOUCH_ZOOM_PAN;     for ( let i = 0; i < this._pointers.length; i ++ ) {      if ( this._pointers[ i ].pointerId !== event.pointerId ) {       const position = this._pointerPositions[ this._pointers[ i ].pointerId ];      this._moveCurr.copy( this._getMouseOnCircle( position.x, position.y ) );      this._movePrev.copy( this._moveCurr );      break;      }     }     break;   }   this.dispatchEvent( _endEvent );  }  export { TrackballControls }; 
^..^ FILENAME ^..^
addons|controls|TransformControls.js
^..^ CONTENTS ^..^
import {  BoxGeometry,  BufferGeometry,  Controls,  CylinderGeometry,  DoubleSide,  Euler,  Float32BufferAttribute,  Line,  LineBasicMaterial,  Matrix4,  Mesh,  MeshBasicMaterial,  Object3D,  OctahedronGeometry,  PlaneGeometry,  Quaternion,  Raycaster,  SphereGeometry,  TorusGeometry,  Vector3 } from 'three';  const _raycaster = new Raycaster();  const _tempVector = new Vector3(); const _tempVector2 = new Vector3(); const _tempQuaternion = new Quaternion(); const _unit = {  X: new Vector3( 1, 0, 0 ),  Y: new Vector3( 0, 1, 0 ),  Z: new Vector3( 0, 0, 1 ) };  const _changeEvent = { type: 'change' }; const _mouseDownEvent = { type: 'mouseDown', mode: null }; const _mouseUpEvent = { type: 'mouseUp', mode: null }; const _objectChangeEvent = { type: 'objectChange' };  class TransformControls extends Controls {   constructor( camera, domElement = null ) {    super( undefined, domElement );    const root = new TransformControlsRoot( this );   this._root = root;    const gizmo = new TransformControlsGizmo();   this._gizmo = gizmo;   root.add( gizmo );    const plane = new TransformControlsPlane();   this._plane = plane;   root.add( plane );    const scope = this;    // Defined getter, setter and store for a property   function defineProperty( propName, defaultValue ) {     let propValue = defaultValue;     Object.defineProperty( scope, propName, {      get: function () {       return propValue !== undefined ? propValue : defaultValue;      },      set: function ( value ) {       if ( propValue !== value ) {        propValue = value;       plane[ propName ] = value;       gizmo[ propName ] = value;        scope.dispatchEvent( { type: propName + '-changed', value: value } );       scope.dispatchEvent( _changeEvent );       }      }     } );     scope[ propName ] = defaultValue;    plane[ propName ] = defaultValue;    gizmo[ propName ] = defaultValue;    }    // Define properties with getters/setter   // Setting the defined property will automatically trigger change event   // Defined properties are passed down to gizmo and plane    defineProperty( 'camera', camera );   defineProperty( 'object', undefined );   defineProperty( 'enabled', true );   defineProperty( 'axis', null );   defineProperty( 'mode', 'translate' );   defineProperty( 'translationSnap', null );   defineProperty( 'rotationSnap', null );   defineProperty( 'scaleSnap', null );   defineProperty( 'space', 'world' );   defineProperty( 'size', 1 );   defineProperty( 'dragging', false );   defineProperty( 'showX', true );   defineProperty( 'showY', true );   defineProperty( 'showZ', true );    // Reusable utility variables    const worldPosition = new Vector3();   const worldPositionStart = new Vector3();   const worldQuaternion = new Quaternion();   const worldQuaternionStart = new Quaternion();   const cameraPosition = new Vector3();   const cameraQuaternion = new Quaternion();   const pointStart = new Vector3();   const pointEnd = new Vector3();   const rotationAxis = new Vector3();   const rotationAngle = 0;   const eye = new Vector3();    // TODO: remove properties unused in plane and gizmo    defineProperty( 'worldPosition', worldPosition );   defineProperty( 'worldPositionStart', worldPositionStart );   defineProperty( 'worldQuaternion', worldQuaternion );   defineProperty( 'worldQuaternionStart', worldQuaternionStart );   defineProperty( 'cameraPosition', cameraPosition );   defineProperty( 'cameraQuaternion', cameraQuaternion );   defineProperty( 'pointStart', pointStart );   defineProperty( 'pointEnd', pointEnd );   defineProperty( 'rotationAxis', rotationAxis );   defineProperty( 'rotationAngle', rotationAngle );   defineProperty( 'eye', eye );    this._offset = new Vector3();   this._startNorm = new Vector3();   this._endNorm = new Vector3();   this._cameraScale = new Vector3();    this._parentPosition = new Vector3();   this._parentQuaternion = new Quaternion();   this._parentQuaternionInv = new Quaternion();   this._parentScale = new Vector3();    this._worldScaleStart = new Vector3();   this._worldQuaternionInv = new Quaternion();   this._worldScale = new Vector3();    this._positionStart = new Vector3();   this._quaternionStart = new Quaternion();   this._scaleStart = new Vector3();    this._getPointer = getPointer.bind( this );   this._onPointerDown = onPointerDown.bind( this );   this._onPointerHover = onPointerHover.bind( this );   this._onPointerMove = onPointerMove.bind( this );   this._onPointerUp = onPointerUp.bind( this );    if ( domElement !== null ) {     this.connect();    }   }   connect() {    this.domElement.addEventListener( 'pointerdown', this._onPointerDown );   this.domElement.addEventListener( 'pointermove', this._onPointerHover );   this.domElement.addEventListener( 'pointerup', this._onPointerUp );    this.domElement.style.touchAction = 'none'; // disable touch scroll   }   disconnect() {    this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );   this.domElement.removeEventListener( 'pointermove', this._onPointerHover );   this.domElement.removeEventListener( 'pointermove', this._onPointerMove );   this.domElement.removeEventListener( 'pointerup', this._onPointerUp );    this.domElement.style.touchAction = 'auto';   }   getHelper() {    return this._root;   }   pointerHover( pointer ) {    if ( this.object === undefined || this.dragging === true ) return;    if ( pointer !== null ) _raycaster.setFromCamera( pointer, this.camera );    const intersect = intersectObjectWithRay( this._gizmo.picker[ this.mode ], _raycaster );    if ( intersect ) {     this.axis = intersect.object.name;    } else {     this.axis = null;    }   }   pointerDown( pointer ) {    if ( this.object === undefined || this.dragging === true || ( pointer != null && pointer.button !== 0 ) ) return;    if ( this.axis !== null ) {     if ( pointer !== null ) _raycaster.setFromCamera( pointer, this.camera );     const planeIntersect = intersectObjectWithRay( this._plane, _raycaster, true );     if ( planeIntersect ) {      this.object.updateMatrixWorld();     this.object.parent.updateMatrixWorld();      this._positionStart.copy( this.object.position );     this._quaternionStart.copy( this.object.quaternion );     this._scaleStart.copy( this.object.scale );      this.object.matrixWorld.decompose( this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart );      this.pointStart.copy( planeIntersect.point ).sub( this.worldPositionStart );     }     this.dragging = true;    _mouseDownEvent.mode = this.mode;    this.dispatchEvent( _mouseDownEvent );    }   }   pointerMove( pointer ) {    const axis = this.axis;   const mode = this.mode;   const object = this.object;   let space = this.space;    if ( mode === 'scale' ) {     space = 'local';    } else if ( axis === 'E' || axis === 'XYZE' || axis === 'XYZ' ) {     space = 'world';    }    if ( object === undefined || axis === null || this.dragging === false || ( pointer !== null && pointer.button !== - 1 ) ) return;    if ( pointer !== null ) _raycaster.setFromCamera( pointer, this.camera );    const planeIntersect = intersectObjectWithRay( this._plane, _raycaster, true );    if ( ! planeIntersect ) return;    this.pointEnd.copy( planeIntersect.point ).sub( this.worldPositionStart );    if ( mode === 'translate' ) {     // Apply translate     this._offset.copy( this.pointEnd ).sub( this.pointStart );     if ( space === 'local' && axis !== 'XYZ' ) {      this._offset.applyQuaternion( this._worldQuaternionInv );     }     if ( axis.indexOf( 'X' ) === - 1 ) this._offset.x = 0;    if ( axis.indexOf( 'Y' ) === - 1 ) this._offset.y = 0;    if ( axis.indexOf( 'Z' ) === - 1 ) this._offset.z = 0;     if ( space === 'local' && axis !== 'XYZ' ) {      this._offset.applyQuaternion( this._quaternionStart ).divide( this._parentScale );     } else {      this._offset.applyQuaternion( this._parentQuaternionInv ).divide( this._parentScale );     }     object.position.copy( this._offset ).add( this._positionStart );     // Apply translation snap     if ( this.translationSnap ) {      if ( space === 'local' ) {       object.position.applyQuaternion( _tempQuaternion.copy( this._quaternionStart ).invert() );       if ( axis.search( 'X' ) !== - 1 ) {        object.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;       }       if ( axis.search( 'Y' ) !== - 1 ) {        object.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;       }       if ( axis.search( 'Z' ) !== - 1 ) {        object.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;       }       object.position.applyQuaternion( this._quaternionStart );      }      if ( space === 'world' ) {       if ( object.parent ) {        object.position.add( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );       }       if ( axis.search( 'X' ) !== - 1 ) {        object.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;       }       if ( axis.search( 'Y' ) !== - 1 ) {        object.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;       }       if ( axis.search( 'Z' ) !== - 1 ) {        object.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;       }       if ( object.parent ) {        object.position.sub( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );       }      }     }    } else if ( mode === 'scale' ) {     if ( axis.search( 'XYZ' ) !== - 1 ) {      let d = this.pointEnd.length() / this.pointStart.length();      if ( this.pointEnd.dot( this.pointStart ) < 0 ) d *= - 1;      _tempVector2.set( d, d, d );     } else {      _tempVector.copy( this.pointStart );     _tempVector2.copy( this.pointEnd );      _tempVector.applyQuaternion( this._worldQuaternionInv );     _tempVector2.applyQuaternion( this._worldQuaternionInv );      _tempVector2.divide( _tempVector );      if ( axis.search( 'X' ) === - 1 ) {       _tempVector2.x = 1;      }      if ( axis.search( 'Y' ) === - 1 ) {       _tempVector2.y = 1;      }      if ( axis.search( 'Z' ) === - 1 ) {       _tempVector2.z = 1;      }     }     // Apply scale     object.scale.copy( this._scaleStart ).multiply( _tempVector2 );     if ( this.scaleSnap ) {      if ( axis.search( 'X' ) !== - 1 ) {       object.scale.x = Math.round( object.scale.x / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;      }      if ( axis.search( 'Y' ) !== - 1 ) {       object.scale.y = Math.round( object.scale.y / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;      }      if ( axis.search( 'Z' ) !== - 1 ) {       object.scale.z = Math.round( object.scale.z / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;      }     }    } else if ( mode === 'rotate' ) {     this._offset.copy( this.pointEnd ).sub( this.pointStart );     const ROTATION_SPEED = 20 / this.worldPosition.distanceTo( _tempVector.setFromMatrixPosition( this.camera.matrixWorld ) );     let _inPlaneRotation = false;     if ( axis === 'XYZE' ) {      this.rotationAxis.copy( this._offset ).cross( this.eye ).normalize();     this.rotationAngle = this._offset.dot( _tempVector.copy( this.rotationAxis ).cross( this.eye ) ) * ROTATION_SPEED;     } else if ( axis === 'X' || axis === 'Y' || axis === 'Z' ) {      this.rotationAxis.copy( _unit[ axis ] );      _tempVector.copy( _unit[ axis ] );      if ( space === 'local' ) {       _tempVector.applyQuaternion( this.worldQuaternion );      }      _tempVector.cross( this.eye );      // When _tempVector is 0 after cross with this.eye the vectors are parallel and should use in-plane rotation logic.     if ( _tempVector.length() === 0 ) {       _inPlaneRotation = true;      } else {       this.rotationAngle = this._offset.dot( _tempVector.normalize() ) * ROTATION_SPEED;      }      }     if ( axis === 'E' || _inPlaneRotation ) {      this.rotationAxis.copy( this.eye );     this.rotationAngle = this.pointEnd.angleTo( this.pointStart );      this._startNorm.copy( this.pointStart ).normalize();     this._endNorm.copy( this.pointEnd ).normalize();      this.rotationAngle *= ( this._endNorm.cross( this._startNorm ).dot( this.eye ) < 0 ? 1 : - 1 );     }     // Apply rotation snap     if ( this.rotationSnap ) this.rotationAngle = Math.round( this.rotationAngle / this.rotationSnap ) * this.rotationSnap;     // Apply rotate    if ( space === 'local' && axis !== 'E' && axis !== 'XYZE' ) {      object.quaternion.copy( this._quaternionStart );     object.quaternion.multiply( _tempQuaternion.setFromAxisAngle( this.rotationAxis, this.rotationAngle ) ).normalize();     } else {      this.rotationAxis.applyQuaternion( this._parentQuaternionInv );     object.quaternion.copy( _tempQuaternion.setFromAxisAngle( this.rotationAxis, this.rotationAngle ) );     object.quaternion.multiply( this._quaternionStart ).normalize();     }    }    this.dispatchEvent( _changeEvent );   this.dispatchEvent( _objectChangeEvent );   }   pointerUp( pointer ) {    if ( pointer !== null && pointer.button !== 0 ) return;    if ( this.dragging && ( this.axis !== null ) ) {     _mouseUpEvent.mode = this.mode;    this.dispatchEvent( _mouseUpEvent );    }    this.dragging = false;   this.axis = null;   }   dispose() {    this.disconnect();    this.traverse( function ( child ) {     if ( child.geometry ) child.geometry.dispose();    if ( child.material ) child.material.dispose();    } );   }   // Set current object  attach( object ) {    this.object = object;   this._root.visible = true;    return this;   }   // Detach from object  detach() {    this.object = undefined;   this.axis = null;    this._root.visible = false;    return this;   }   reset() {    if ( ! this.enabled ) return;    if ( this.dragging ) {     this.object.position.copy( this._positionStart );    this.object.quaternion.copy( this._quaternionStart );    this.object.scale.copy( this._scaleStart );     this.dispatchEvent( _changeEvent );    this.dispatchEvent( _objectChangeEvent );     this.pointStart.copy( this.pointEnd );    }   }   getRaycaster() {    return _raycaster;   }   // TODO: deprecate   getMode() {    return this.mode;   }   setMode( mode ) {    this.mode = mode;   }   setTranslationSnap( translationSnap ) {    this.translationSnap = translationSnap;   }   setRotationSnap( rotationSnap ) {    this.rotationSnap = rotationSnap;   }   setScaleSnap( scaleSnap ) {    this.scaleSnap = scaleSnap;   }   setSize( size ) {    this.size = size;   }   setSpace( space ) {    this.space = space;   }  }  // mouse / touch event handlers  function getPointer( event ) {   if ( this.domElement.ownerDocument.pointerLockElement ) {    return {    x: 0,    y: 0,    button: event.button   };   } else {    const rect = this.domElement.getBoundingClientRect();    return {    x: ( event.clientX - rect.left ) / rect.width * 2 - 1,    y: - ( event.clientY - rect.top ) / rect.height * 2 + 1,    button: event.button   };   }  }  function onPointerHover( event ) {   if ( ! this.enabled ) return;   switch ( event.pointerType ) {    case 'mouse':   case 'pen':    this.pointerHover( this._getPointer( event ) );    break;   }  }  function onPointerDown( event ) {   if ( ! this.enabled ) return;   if ( ! document.pointerLockElement ) {    this.domElement.setPointerCapture( event.pointerId );   }   this.domElement.addEventListener( 'pointermove', this._onPointerMove );   this.pointerHover( this._getPointer( event ) );  this.pointerDown( this._getPointer( event ) );  }  function onPointerMove( event ) {   if ( ! this.enabled ) return;   this.pointerMove( this._getPointer( event ) );  }  function onPointerUp( event ) {   if ( ! this.enabled ) return;   this.domElement.releasePointerCapture( event.pointerId );   this.domElement.removeEventListener( 'pointermove', this._onPointerMove );   this.pointerUp( this._getPointer( event ) );  }  function intersectObjectWithRay( object, raycaster, includeInvisible ) {   const allIntersections = raycaster.intersectObject( object, true );   for ( let i = 0; i < allIntersections.length; i ++ ) {    if ( allIntersections[ i ].object.visible || includeInvisible ) {     return allIntersections[ i ];    }   }   return false;  }  //  // Reusable utility variables  const _tempEuler = new Euler(); const _alignVector = new Vector3( 0, 1, 0 ); const _zeroVector = new Vector3( 0, 0, 0 ); const _lookAtMatrix = new Matrix4(); const _tempQuaternion2 = new Quaternion(); const _identityQuaternion = new Quaternion(); const _dirVector = new Vector3(); const _tempMatrix = new Matrix4();  const _unitX = new Vector3( 1, 0, 0 ); const _unitY = new Vector3( 0, 1, 0 ); const _unitZ = new Vector3( 0, 0, 1 );  const _v1 = new Vector3(); const _v2 = new Vector3(); const _v3 = new Vector3();  class TransformControlsRoot extends Object3D {   constructor( controls ) {    super();    this.isTransformControlsRoot = true;    this.controls = controls;   this.visible = false;   }   // updateMatrixWorld updates key transformation variables  updateMatrixWorld( force ) {    const controls = this.controls;    if ( controls.object !== undefined ) {     controls.object.updateMatrixWorld();     if ( controls.object.parent === null ) {      console.error( 'TransformControls: The attached 3D object must be a part of the scene graph.' );     } else {      controls.object.parent.matrixWorld.decompose( controls._parentPosition, controls._parentQuaternion, controls._parentScale );     }     controls.object.matrixWorld.decompose( controls.worldPosition, controls.worldQuaternion, controls._worldScale );     controls._parentQuaternionInv.copy( controls._parentQuaternion ).invert();    controls._worldQuaternionInv.copy( controls.worldQuaternion ).invert();    }    controls.camera.updateMatrixWorld();   controls.camera.matrixWorld.decompose( controls.cameraPosition, controls.cameraQuaternion, controls._cameraScale );    if ( controls.camera.isOrthographicCamera ) {     controls.camera.getWorldDirection( controls.eye ).negate();    } else {     controls.eye.copy( controls.cameraPosition ).sub( controls.worldPosition ).normalize();    }    super.updateMatrixWorld( force );   }  }  class TransformControlsGizmo extends Object3D {   constructor() {    super();    this.isTransformControlsGizmo = true;    this.type = 'TransformControlsGizmo';    // shared materials    const gizmoMaterial = new MeshBasicMaterial( {    depthTest: false,    depthWrite: false,    fog: false,    toneMapped: false,    transparent: true   } );    const gizmoLineMaterial = new LineBasicMaterial( {    depthTest: false,    depthWrite: false,    fog: false,    toneMapped: false,    transparent: true   } );    // Make unique material for each axis/color    const matInvisible = gizmoMaterial.clone();   matInvisible.opacity = 0.15;    const matHelper = gizmoLineMaterial.clone();   matHelper.opacity = 0.5;    const matRed = gizmoMaterial.clone();   matRed.color.setHex( 0xff0000 );    const matGreen = gizmoMaterial.clone();   matGreen.color.setHex( 0x00ff00 );    const matBlue = gizmoMaterial.clone();   matBlue.color.setHex( 0x0000ff );    const matRedTransparent = gizmoMaterial.clone();   matRedTransparent.color.setHex( 0xff0000 );   matRedTransparent.opacity = 0.5;    const matGreenTransparent = gizmoMaterial.clone();   matGreenTransparent.color.setHex( 0x00ff00 );   matGreenTransparent.opacity = 0.5;    const matBlueTransparent = gizmoMaterial.clone();   matBlueTransparent.color.setHex( 0x0000ff );   matBlueTransparent.opacity = 0.5;    const matWhiteTransparent = gizmoMaterial.clone();   matWhiteTransparent.opacity = 0.25;    const matYellowTransparent = gizmoMaterial.clone();   matYellowTransparent.color.setHex( 0xffff00 );   matYellowTransparent.opacity = 0.25;    const matYellow = gizmoMaterial.clone();   matYellow.color.setHex( 0xffff00 );    const matGray = gizmoMaterial.clone();   matGray.color.setHex( 0x787878 );    // reusable geometry    const arrowGeometry = new CylinderGeometry( 0, 0.04, 0.1, 12 );   arrowGeometry.translate( 0, 0.05, 0 );    const scaleHandleGeometry = new BoxGeometry( 0.08, 0.08, 0.08 );   scaleHandleGeometry.translate( 0, 0.04, 0 );    const lineGeometry = new BufferGeometry();   lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 1, 0, 0 ], 3 ) );    const lineGeometry2 = new CylinderGeometry( 0.0075, 0.0075, 0.5, 3 );   lineGeometry2.translate( 0, 0.25, 0 );    function CircleGeometry( radius, arc ) {     const geometry = new TorusGeometry( radius, 0.0075, 3, 64, arc * Math.PI * 2 );    geometry.rotateY( Math.PI / 2 );    geometry.rotateX( Math.PI / 2 );    return geometry;    }    // Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position    function TranslateHelperGeometry() {     const geometry = new BufferGeometry();     geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 1, 1, 1 ], 3 ) );     return geometry;    }    // Gizmo definitions - custom hierarchy definitions for setupGizmo() function    const gizmoTranslate = {    X: [     [ new Mesh( arrowGeometry, matRed ), [ 0.5, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],     [ new Mesh( arrowGeometry, matRed ), [ - 0.5, 0, 0 ], [ 0, 0, Math.PI / 2 ]],     [ new Mesh( lineGeometry2, matRed ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]]    ],    Y: [     [ new Mesh( arrowGeometry, matGreen ), [ 0, 0.5, 0 ]],     [ new Mesh( arrowGeometry, matGreen ), [ 0, - 0.5, 0 ], [ Math.PI, 0, 0 ]],     [ new Mesh( lineGeometry2, matGreen ) ]    ],    Z: [     [ new Mesh( arrowGeometry, matBlue ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ]],     [ new Mesh( arrowGeometry, matBlue ), [ 0, 0, - 0.5 ], [ - Math.PI / 2, 0, 0 ]],     [ new Mesh( lineGeometry2, matBlue ), null, [ Math.PI / 2, 0, 0 ]]    ],    XYZ: [     [ new Mesh( new OctahedronGeometry( 0.1, 0 ), matWhiteTransparent.clone() ), [ 0, 0, 0 ]]    ],    XY: [     [ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matBlueTransparent.clone() ), [ 0.15, 0.15, 0 ]]    ],    YZ: [     [ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matRedTransparent.clone() ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]]    ],    XZ: [     [ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matGreenTransparent.clone() ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]]    ]   };    const pickerTranslate = {    X: [     [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0.3, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],     [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ - 0.3, 0, 0 ], [ 0, 0, Math.PI / 2 ]]    ],    Y: [     [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0.3, 0 ]],     [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, - 0.3, 0 ], [ 0, 0, Math.PI ]]    ],    Z: [     [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, 0.3 ], [ Math.PI / 2, 0, 0 ]],     [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, - 0.3 ], [ - Math.PI / 2, 0, 0 ]]    ],    XYZ: [     [ new Mesh( new OctahedronGeometry( 0.2, 0 ), matInvisible ) ]    ],    XY: [     [ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0.15, 0 ]]    ],    YZ: [     [ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]]    ],    XZ: [     [ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]]    ]   };    const helperTranslate = {    START: [     [ new Mesh( new OctahedronGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]    ],    END: [     [ new Mesh( new OctahedronGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]    ],    DELTA: [     [ new Line( TranslateHelperGeometry(), matHelper ), null, null, null, 'helper' ]    ],    X: [     [ new Line( lineGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]    ],    Y: [     [ new Line( lineGeometry, matHelper.clone() ), [ 0, - 1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]    ],    Z: [     [ new Line( lineGeometry, matHelper.clone() ), [ 0, 0, - 1e3 ], [ 0, - Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]    ]   };    const gizmoRotate = {    XYZE: [     [ new Mesh( CircleGeometry( 0.5, 1 ), matGray ), null, [ 0, Math.PI / 2, 0 ]]    ],    X: [     [ new Mesh( CircleGeometry( 0.5, 0.5 ), matRed ) ]    ],    Y: [     [ new Mesh( CircleGeometry( 0.5, 0.5 ), matGreen ), null, [ 0, 0, - Math.PI / 2 ]]    ],    Z: [     [ new Mesh( CircleGeometry( 0.5, 0.5 ), matBlue ), null, [ 0, Math.PI / 2, 0 ]]    ],    E: [     [ new Mesh( CircleGeometry( 0.75, 1 ), matYellowTransparent ), null, [ 0, Math.PI / 2, 0 ]]    ]   };    const helperRotate = {    AXIS: [     [ new Line( lineGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]    ]   };    const pickerRotate = {    XYZE: [     [ new Mesh( new SphereGeometry( 0.25, 10, 8 ), matInvisible ) ]    ],    X: [     [ new Mesh( new TorusGeometry( 0.5, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, - Math.PI / 2, - Math.PI / 2 ]],    ],    Y: [     [ new Mesh( new TorusGeometry( 0.5, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ]],    ],    Z: [     [ new Mesh( new TorusGeometry( 0.5, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],    ],    E: [     [ new Mesh( new TorusGeometry( 0.75, 0.1, 2, 24 ), matInvisible ) ]    ]   };    const gizmoScale = {    X: [     [ new Mesh( scaleHandleGeometry, matRed ), [ 0.5, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],     [ new Mesh( lineGeometry2, matRed ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],     [ new Mesh( scaleHandleGeometry, matRed ), [ - 0.5, 0, 0 ], [ 0, 0, Math.PI / 2 ]],    ],    Y: [     [ new Mesh( scaleHandleGeometry, matGreen ), [ 0, 0.5, 0 ]],     [ new Mesh( lineGeometry2, matGreen ) ],     [ new Mesh( scaleHandleGeometry, matGreen ), [ 0, - 0.5, 0 ], [ 0, 0, Math.PI ]],    ],    Z: [     [ new Mesh( scaleHandleGeometry, matBlue ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ]],     [ new Mesh( lineGeometry2, matBlue ), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ]],     [ new Mesh( scaleHandleGeometry, matBlue ), [ 0, 0, - 0.5 ], [ - Math.PI / 2, 0, 0 ]]    ],    XY: [     [ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matBlueTransparent ), [ 0.15, 0.15, 0 ]]    ],    YZ: [     [ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matRedTransparent ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]]    ],    XZ: [     [ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matGreenTransparent ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]]    ],    XYZ: [     [ new Mesh( new BoxGeometry( 0.1, 0.1, 0.1 ), matWhiteTransparent.clone() ) ],    ]   };    const pickerScale = {    X: [     [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0.3, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],     [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ - 0.3, 0, 0 ], [ 0, 0, Math.PI / 2 ]]    ],    Y: [     [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0.3, 0 ]],     [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, - 0.3, 0 ], [ 0, 0, Math.PI ]]    ],    Z: [     [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, 0.3 ], [ Math.PI / 2, 0, 0 ]],     [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, - 0.3 ], [ - Math.PI / 2, 0, 0 ]]    ],    XY: [     [ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0.15, 0 ]],    ],    YZ: [     [ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]],    ],    XZ: [     [ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]],    ],    XYZ: [     [ new Mesh( new BoxGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 0, 0, 0 ]],    ]   };    const helperScale = {    X: [     [ new Line( lineGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]    ],    Y: [     [ new Line( lineGeometry, matHelper.clone() ), [ 0, - 1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]    ],    Z: [     [ new Line( lineGeometry, matHelper.clone() ), [ 0, 0, - 1e3 ], [ 0, - Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]    ]   };    // Creates an Object3D with gizmos described in custom hierarchy definition.    function setupGizmo( gizmoMap ) {     const gizmo = new Object3D();     for ( const name in gizmoMap ) {      for ( let i = gizmoMap[ name ].length; i --; ) {       const object = gizmoMap[ name ][ i ][ 0 ].clone();      const position = gizmoMap[ name ][ i ][ 1 ];      const rotation = gizmoMap[ name ][ i ][ 2 ];      const scale = gizmoMap[ name ][ i ][ 3 ];      const tag = gizmoMap[ name ][ i ][ 4 ];       // name and tag properties are essential for picking and updating logic.      object.name = name;      object.tag = tag;       if ( position ) {        object.position.set( position[ 0 ], position[ 1 ], position[ 2 ] );       }       if ( rotation ) {        object.rotation.set( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ] );       }       if ( scale ) {        object.scale.set( scale[ 0 ], scale[ 1 ], scale[ 2 ] );       }       object.updateMatrix();       const tempGeometry = object.geometry.clone();      tempGeometry.applyMatrix4( object.matrix );      object.geometry = tempGeometry;      object.renderOrder = Infinity;       object.position.set( 0, 0, 0 );      object.rotation.set( 0, 0, 0 );      object.scale.set( 1, 1, 1 );       gizmo.add( object );      }     }     return gizmo;    }    // Gizmo creation    this.gizmo = {};   this.picker = {};   this.helper = {};    this.add( this.gizmo[ 'translate' ] = setupGizmo( gizmoTranslate ) );   this.add( this.gizmo[ 'rotate' ] = setupGizmo( gizmoRotate ) );   this.add( this.gizmo[ 'scale' ] = setupGizmo( gizmoScale ) );   this.add( this.picker[ 'translate' ] = setupGizmo( pickerTranslate ) );   this.add( this.picker[ 'rotate' ] = setupGizmo( pickerRotate ) );   this.add( this.picker[ 'scale' ] = setupGizmo( pickerScale ) );   this.add( this.helper[ 'translate' ] = setupGizmo( helperTranslate ) );   this.add( this.helper[ 'rotate' ] = setupGizmo( helperRotate ) );   this.add( this.helper[ 'scale' ] = setupGizmo( helperScale ) );    // Pickers should be hidden always    this.picker[ 'translate' ].visible = false;   this.picker[ 'rotate' ].visible = false;   this.picker[ 'scale' ].visible = false;   }   // updateMatrixWorld will update transformations and appearance of individual handles   updateMatrixWorld( force ) {    const space = ( this.mode === 'scale' ) ? 'local' : this.space; // scale always oriented to local rotation    const quaternion = ( space === 'local' ) ? this.worldQuaternion : _identityQuaternion;    // Show only gizmos for current transform mode    this.gizmo[ 'translate' ].visible = this.mode === 'translate';   this.gizmo[ 'rotate' ].visible = this.mode === 'rotate';   this.gizmo[ 'scale' ].visible = this.mode === 'scale';    this.helper[ 'translate' ].visible = this.mode === 'translate';   this.helper[ 'rotate' ].visible = this.mode === 'rotate';   this.helper[ 'scale' ].visible = this.mode === 'scale';     let handles = [];   handles = handles.concat( this.picker[ this.mode ].children );   handles = handles.concat( this.gizmo[ this.mode ].children );   handles = handles.concat( this.helper[ this.mode ].children );    for ( let i = 0; i < handles.length; i ++ ) {     const handle = handles[ i ];     // hide aligned to camera     handle.visible = true;    handle.rotation.set( 0, 0, 0 );    handle.position.copy( this.worldPosition );     let factor;     if ( this.camera.isOrthographicCamera ) {      factor = ( this.camera.top - this.camera.bottom ) / this.camera.zoom;     } else {      factor = this.worldPosition.distanceTo( this.cameraPosition ) * Math.min( 1.9 * Math.tan( Math.PI * this.camera.fov / 360 ) / this.camera.zoom, 7 );     }     handle.scale.set( 1, 1, 1 ).multiplyScalar( factor * this.size / 4 );     // TODO: simplify helpers and consider decoupling from gizmo     if ( handle.tag === 'helper' ) {      handle.visible = false;      if ( handle.name === 'AXIS' ) {       handle.visible = !! this.axis;       if ( this.axis === 'X' ) {        _tempQuaternion.setFromEuler( _tempEuler.set( 0, 0, 0 ) );       handle.quaternion.copy( quaternion ).multiply( _tempQuaternion );        if ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {         handle.visible = false;        }       }       if ( this.axis === 'Y' ) {        _tempQuaternion.setFromEuler( _tempEuler.set( 0, 0, Math.PI / 2 ) );       handle.quaternion.copy( quaternion ).multiply( _tempQuaternion );        if ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {         handle.visible = false;        }       }       if ( this.axis === 'Z' ) {        _tempQuaternion.setFromEuler( _tempEuler.set( 0, Math.PI / 2, 0 ) );       handle.quaternion.copy( quaternion ).multiply( _tempQuaternion );        if ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {         handle.visible = false;        }       }       if ( this.axis === 'XYZE' ) {        _tempQuaternion.setFromEuler( _tempEuler.set( 0, Math.PI / 2, 0 ) );       _alignVector.copy( this.rotationAxis );       handle.quaternion.setFromRotationMatrix( _lookAtMatrix.lookAt( _zeroVector, _alignVector, _unitY ) );       handle.quaternion.multiply( _tempQuaternion );       handle.visible = this.dragging;       }       if ( this.axis === 'E' ) {        handle.visible = false;       }       } else if ( handle.name === 'START' ) {       handle.position.copy( this.worldPositionStart );      handle.visible = this.dragging;      } else if ( handle.name === 'END' ) {       handle.position.copy( this.worldPosition );      handle.visible = this.dragging;      } else if ( handle.name === 'DELTA' ) {       handle.position.copy( this.worldPositionStart );      handle.quaternion.copy( this.worldQuaternionStart );      _tempVector.set( 1e-10, 1e-10, 1e-10 ).add( this.worldPositionStart ).sub( this.worldPosition ).multiplyScalar( - 1 );      _tempVector.applyQuaternion( this.worldQuaternionStart.clone().invert() );      handle.scale.copy( _tempVector );      handle.visible = this.dragging;      } else {       handle.quaternion.copy( quaternion );       if ( this.dragging ) {        handle.position.copy( this.worldPositionStart );       } else {        handle.position.copy( this.worldPosition );       }       if ( this.axis ) {        handle.visible = this.axis.search( handle.name ) !== - 1;       }      }      // If updating helper, skip rest of the loop     continue;     }     // Align handles to current local or world rotation     handle.quaternion.copy( quaternion );     if ( this.mode === 'translate' || this.mode === 'scale' ) {      // Hide translate and scale axis facing the camera      const AXIS_HIDE_THRESHOLD = 0.99;     const PLANE_HIDE_THRESHOLD = 0.2;      if ( handle.name === 'X' ) {       if ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_THRESHOLD ) {        handle.scale.set( 1e-10, 1e-10, 1e-10 );       handle.visible = false;       }      }      if ( handle.name === 'Y' ) {       if ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_THRESHOLD ) {        handle.scale.set( 1e-10, 1e-10, 1e-10 );       handle.visible = false;       }      }      if ( handle.name === 'Z' ) {       if ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_THRESHOLD ) {        handle.scale.set( 1e-10, 1e-10, 1e-10 );       handle.visible = false;       }      }      if ( handle.name === 'XY' ) {       if ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_THRESHOLD ) {        handle.scale.set( 1e-10, 1e-10, 1e-10 );       handle.visible = false;       }      }      if ( handle.name === 'YZ' ) {       if ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_THRESHOLD ) {        handle.scale.set( 1e-10, 1e-10, 1e-10 );       handle.visible = false;       }      }      if ( handle.name === 'XZ' ) {       if ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_THRESHOLD ) {        handle.scale.set( 1e-10, 1e-10, 1e-10 );       handle.visible = false;       }      }     } else if ( this.mode === 'rotate' ) {      // Align handles to current local or world rotation      _tempQuaternion2.copy( quaternion );     _alignVector.copy( this.eye ).applyQuaternion( _tempQuaternion.copy( quaternion ).invert() );      if ( handle.name.search( 'E' ) !== - 1 ) {       handle.quaternion.setFromRotationMatrix( _lookAtMatrix.lookAt( this.eye, _zeroVector, _unitY ) );      }      if ( handle.name === 'X' ) {       _tempQuaternion.setFromAxisAngle( _unitX, Math.atan2( - _alignVector.y, _alignVector.z ) );      _tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion );      handle.quaternion.copy( _tempQuaternion );      }      if ( handle.name === 'Y' ) {       _tempQuaternion.setFromAxisAngle( _unitY, Math.atan2( _alignVector.x, _alignVector.z ) );      _tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion );      handle.quaternion.copy( _tempQuaternion );      }      if ( handle.name === 'Z' ) {       _tempQuaternion.setFromAxisAngle( _unitZ, Math.atan2( _alignVector.y, _alignVector.x ) );      _tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion );      handle.quaternion.copy( _tempQuaternion );      }     }     // Hide disabled axes    handle.visible = handle.visible && ( handle.name.indexOf( 'X' ) === - 1 || this.showX );    handle.visible = handle.visible && ( handle.name.indexOf( 'Y' ) === - 1 || this.showY );    handle.visible = handle.visible && ( handle.name.indexOf( 'Z' ) === - 1 || this.showZ );    handle.visible = handle.visible && ( handle.name.indexOf( 'E' ) === - 1 || ( this.showX && this.showY && this.showZ ) );     // highlight selected axis     handle.material._color = handle.material._color || handle.material.color.clone();    handle.material._opacity = handle.material._opacity || handle.material.opacity;     handle.material.color.copy( handle.material._color );    handle.material.opacity = handle.material._opacity;     if ( this.enabled && this.axis ) {      if ( handle.name === this.axis ) {       handle.material.color.setHex( 0xffff00 );      handle.material.opacity = 1.0;      } else if ( this.axis.split( '' ).some( function ( a ) {       return handle.name === a;      } ) ) {       handle.material.color.setHex( 0xffff00 );      handle.material.opacity = 1.0;      }     }    }    super.updateMatrixWorld( force );   }  }  //  class TransformControlsPlane extends Mesh {   constructor() {    super(    new PlaneGeometry( 100000, 100000, 2, 2 ),    new MeshBasicMaterial( { visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false } )   );    this.isTransformControlsPlane = true;    this.type = 'TransformControlsPlane';   }   updateMatrixWorld( force ) {    let space = this.space;    this.position.copy( this.worldPosition );    if ( this.mode === 'scale' ) space = 'local'; // scale always oriented to local rotation    _v1.copy( _unitX ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion );   _v2.copy( _unitY ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion );   _v3.copy( _unitZ ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion );    // Align the plane for current transform mode, axis and space.    _alignVector.copy( _v2 );    switch ( this.mode ) {     case 'translate':    case 'scale':     switch ( this.axis ) {       case 'X':       _alignVector.copy( this.eye ).cross( _v1 );       _dirVector.copy( _v1 ).cross( _alignVector );       break;      case 'Y':       _alignVector.copy( this.eye ).cross( _v2 );       _dirVector.copy( _v2 ).cross( _alignVector );       break;      case 'Z':       _alignVector.copy( this.eye ).cross( _v3 );       _dirVector.copy( _v3 ).cross( _alignVector );       break;      case 'XY':       _dirVector.copy( _v3 );       break;      case 'YZ':       _dirVector.copy( _v1 );       break;      case 'XZ':       _alignVector.copy( _v3 );       _dirVector.copy( _v2 );       break;      case 'XYZ':      case 'E':       _dirVector.set( 0, 0, 0 );       break;      }      break;    case 'rotate':    default:     // special case for rotate     _dirVector.set( 0, 0, 0 );    }    if ( _dirVector.length() === 0 ) {     // If in rotate mode, make the plane parallel to camera    this.quaternion.copy( this.cameraQuaternion );    } else {     _tempMatrix.lookAt( _tempVector.set( 0, 0, 0 ), _dirVector, _alignVector );     this.quaternion.setFromRotationMatrix( _tempMatrix );    }    super.updateMatrixWorld( force );   }  }  export { TransformControls, TransformControlsGizmo, TransformControlsPlane }; 
^..^ FILENAME ^..^
addons|csm|CSM.js
^..^ CONTENTS ^..^
import {  Vector2,  Vector3,  DirectionalLight,  MathUtils,  ShaderChunk,  Matrix4,  Box3 } from 'three'; import { CSMFrustum } from './CSMFrustum.js'; import { CSMShader } from './CSMShader.js';  const _cameraToLightMatrix = new Matrix4(); const _lightSpaceFrustum = new CSMFrustum(); const _center = new Vector3(); const _bbox = new Box3(); const _uniformArray = []; const _logArray = []; const _lightOrientationMatrix = new Matrix4(); const _lightOrientationMatrixInverse = new Matrix4(); const _up = new Vector3( 0, 1, 0 );  export class CSM {   constructor( data ) {    this.camera = data.camera;   this.parent = data.parent;   this.cascades = data.cascades || 3;   this.maxFar = data.maxFar || 100000;   this.mode = data.mode || 'practical';   this.shadowMapSize = data.shadowMapSize || 2048;   this.shadowBias = data.shadowBias || 0.000001;   this.lightDirection = data.lightDirection || new Vector3( 1, - 1, 1 ).normalize();   this.lightIntensity = data.lightIntensity || 3;   this.lightNear = data.lightNear || 1;   this.lightFar = data.lightFar || 2000;   this.lightMargin = data.lightMargin || 200;   this.customSplitsCallback = data.customSplitsCallback;   this.fade = false;   this.mainFrustum = new CSMFrustum();   this.frustums = [];   this.breaks = [];    this.lights = [];   this.shaders = new Map();    this.createLights();   this.updateFrustums();   this.injectInclude();   }   createLights() {    for ( let i = 0; i < this.cascades; i ++ ) {     const light = new DirectionalLight( 0xffffff, this.lightIntensity );    light.castShadow = true;    light.shadow.mapSize.width = this.shadowMapSize;    light.shadow.mapSize.height = this.shadowMapSize;     light.shadow.camera.near = this.lightNear;    light.shadow.camera.far = this.lightFar;    light.shadow.bias = this.shadowBias;     this.parent.add( light );    this.parent.add( light.target );    this.lights.push( light );    }   }   initCascades() {    const camera = this.camera;   camera.updateProjectionMatrix();   this.mainFrustum.setFromProjectionMatrix( camera.projectionMatrix, this.maxFar );   this.mainFrustum.split( this.breaks, this.frustums );   }   updateShadowBounds() {    const frustums = this.frustums;   for ( let i = 0; i < frustums.length; i ++ ) {     const light = this.lights[ i ];    const shadowCam = light.shadow.camera;    const frustum = this.frustums[ i ];     // Get the two points that represent that furthest points on the frustum assuming    // that's either the diagonal across the far plane or the diagonal across the whole    // frustum itself.    const nearVerts = frustum.vertices.near;    const farVerts = frustum.vertices.far;    const point1 = farVerts[ 0 ];    let point2;    if ( point1.distanceTo( farVerts[ 2 ] ) > point1.distanceTo( nearVerts[ 2 ] ) ) {      point2 = farVerts[ 2 ];     } else {      point2 = nearVerts[ 2 ];     }     let squaredBBWidth = point1.distanceTo( point2 );    if ( this.fade ) {      // expand the shadow extents by the fade margin if fade is enabled.     const camera = this.camera;     const far = Math.max( camera.far, this.maxFar );     const linearDepth = frustum.vertices.far[ 0 ].z / ( far - camera.near );     const margin = 0.25 * Math.pow( linearDepth, 2.0 ) * ( far - camera.near );      squaredBBWidth += margin;     }     shadowCam.left = - squaredBBWidth / 2;    shadowCam.right = squaredBBWidth / 2;    shadowCam.top = squaredBBWidth / 2;    shadowCam.bottom = - squaredBBWidth / 2;    shadowCam.updateProjectionMatrix();    }   }   getBreaks() {    const camera = this.camera;   const far = Math.min( camera.far, this.maxFar );   this.breaks.length = 0;    switch ( this.mode ) {     case 'uniform':     uniformSplit( this.cascades, camera.near, far, this.breaks );     break;    case 'logarithmic':     logarithmicSplit( this.cascades, camera.near, far, this.breaks );     break;    case 'practical':     practicalSplit( this.cascades, camera.near, far, 0.5, this.breaks );     break;    case 'custom':     if ( this.customSplitsCallback === undefined ) console.error( 'CSM: Custom split scheme callback not defined.' );     this.customSplitsCallback( this.cascades, camera.near, far, this.breaks );     break;    }    function uniformSplit( amount, near, far, target ) {     for ( let i = 1; i < amount; i ++ ) {      target.push( ( near + ( far - near ) * i / amount ) / far );     }     target.push( 1 );    }    function logarithmicSplit( amount, near, far, target ) {     for ( let i = 1; i < amount; i ++ ) {      target.push( ( near * ( far / near ) ** ( i / amount ) ) / far );     }     target.push( 1 );    }    function practicalSplit( amount, near, far, lambda, target ) {     _uniformArray.length = 0;    _logArray.length = 0;    logarithmicSplit( amount, near, far, _logArray );    uniformSplit( amount, near, far, _uniformArray );     for ( let i = 1; i < amount; i ++ ) {      target.push( MathUtils.lerp( _uniformArray[ i - 1 ], _logArray[ i - 1 ], lambda ) );     }     target.push( 1 );    }   }   update() {    const camera = this.camera;   const frustums = this.frustums;    // for each frustum we need to find its min-max box aligned with the light orientation   // the position in _lightOrientationMatrix does not matter, as we transform there and back   _lightOrientationMatrix.lookAt( new Vector3(), this.lightDirection, _up );   _lightOrientationMatrixInverse.copy( _lightOrientationMatrix ).invert();    for ( let i = 0; i < frustums.length; i ++ ) {     const light = this.lights[ i ];    const shadowCam = light.shadow.camera;    const texelWidth = ( shadowCam.right - shadowCam.left ) / this.shadowMapSize;    const texelHeight = ( shadowCam.top - shadowCam.bottom ) / this.shadowMapSize;    _cameraToLightMatrix.multiplyMatrices( _lightOrientationMatrixInverse, camera.matrixWorld );    frustums[ i ].toSpace( _cameraToLightMatrix, _lightSpaceFrustum );     const nearVerts = _lightSpaceFrustum.vertices.near;    const farVerts = _lightSpaceFrustum.vertices.far;    _bbox.makeEmpty();    for ( let j = 0; j < 4; j ++ ) {      _bbox.expandByPoint( nearVerts[ j ] );     _bbox.expandByPoint( farVerts[ j ] );     }     _bbox.getCenter( _center );    _center.z = _bbox.max.z + this.lightMargin;    _center.x = Math.floor( _center.x / texelWidth ) * texelWidth;    _center.y = Math.floor( _center.y / texelHeight ) * texelHeight;    _center.applyMatrix4( _lightOrientationMatrix );     light.position.copy( _center );    light.target.position.copy( _center );     light.target.position.x += this.lightDirection.x;    light.target.position.y += this.lightDirection.y;    light.target.position.z += this.lightDirection.z;    }   }   injectInclude() {    ShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin;   ShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin;   }   setupMaterial( material ) {    material.defines = material.defines || {};   material.defines.USE_CSM = 1;   material.defines.CSM_CASCADES = this.cascades;    if ( this.fade ) {     material.defines.CSM_FADE = '';    }    const breaksVec2 = [];   const scope = this;   const shaders = this.shaders;    material.onBeforeCompile = function ( shader ) {     const far = Math.min( scope.camera.far, scope.maxFar );    scope.getExtendedBreaks( breaksVec2 );     shader.uniforms.CSM_cascades = { value: breaksVec2 };    shader.uniforms.cameraNear = { value: scope.camera.near };    shader.uniforms.shadowFar = { value: far };     shaders.set( material, shader );    };    shaders.set( material, null );   }   updateUniforms() {    const far = Math.min( this.camera.far, this.maxFar );   const shaders = this.shaders;    shaders.forEach( function ( shader, material ) {     if ( shader !== null ) {      const uniforms = shader.uniforms;     this.getExtendedBreaks( uniforms.CSM_cascades.value );     uniforms.cameraNear.value = this.camera.near;     uniforms.shadowFar.value = far;     }     if ( ! this.fade && 'CSM_FADE' in material.defines ) {      delete material.defines.CSM_FADE;     material.needsUpdate = true;     } else if ( this.fade && ! ( 'CSM_FADE' in material.defines ) ) {      material.defines.CSM_FADE = '';     material.needsUpdate = true;     }    }, this );   }   getExtendedBreaks( target ) {    while ( target.length < this.breaks.length ) {     target.push( new Vector2() );    }    target.length = this.breaks.length;    for ( let i = 0; i < this.cascades; i ++ ) {     const amount = this.breaks[ i ];    const prev = this.breaks[ i - 1 ] || 0;    target[ i ].x = prev;    target[ i ].y = amount;    }   }   updateFrustums() {    this.getBreaks();   this.initCascades();   this.updateShadowBounds();   this.updateUniforms();   }   remove() {    for ( let i = 0; i < this.lights.length; i ++ ) {     this.parent.remove( this.lights[ i ].target );    this.parent.remove( this.lights[ i ] );    }   }   dispose() {    const shaders = this.shaders;   shaders.forEach( function ( shader, material ) {     delete material.onBeforeCompile;    delete material.defines.USE_CSM;    delete material.defines.CSM_CASCADES;    delete material.defines.CSM_FADE;     if ( shader !== null ) {      delete shader.uniforms.CSM_cascades;     delete shader.uniforms.cameraNear;     delete shader.uniforms.shadowFar;     }     material.needsUpdate = true;    } );   shaders.clear();   }  } 
^..^ FILENAME ^..^
addons|csm|CSMFrustum.js
^..^ CONTENTS ^..^
import { Vector3, Matrix4 } from 'three';  const inverseProjectionMatrix = new Matrix4();  class CSMFrustum {   constructor( data ) {    data = data || {};    this.vertices = {    near: [     new Vector3(),     new Vector3(),     new Vector3(),     new Vector3()    ],    far: [     new Vector3(),     new Vector3(),     new Vector3(),     new Vector3()    ]   };    if ( data.projectionMatrix !== undefined ) {     this.setFromProjectionMatrix( data.projectionMatrix, data.maxFar || 10000 );    }   }   setFromProjectionMatrix( projectionMatrix, maxFar ) {    const isOrthographic = projectionMatrix.elements[ 2 * 4 + 3 ] === 0;    inverseProjectionMatrix.copy( projectionMatrix ).invert();    // 3 --- 0  vertices.near/far order   // |     |   // 2 --- 1   // clip space spans from [-1, 1]    this.vertices.near[ 0 ].set( 1, 1, - 1 );   this.vertices.near[ 1 ].set( 1, - 1, - 1 );   this.vertices.near[ 2 ].set( - 1, - 1, - 1 );   this.vertices.near[ 3 ].set( - 1, 1, - 1 );   this.vertices.near.forEach( function ( v ) {     v.applyMatrix4( inverseProjectionMatrix );    } );    this.vertices.far[ 0 ].set( 1, 1, 1 );   this.vertices.far[ 1 ].set( 1, - 1, 1 );   this.vertices.far[ 2 ].set( - 1, - 1, 1 );   this.vertices.far[ 3 ].set( - 1, 1, 1 );   this.vertices.far.forEach( function ( v ) {     v.applyMatrix4( inverseProjectionMatrix );     const absZ = Math.abs( v.z );    if ( isOrthographic ) {      v.z *= Math.min( maxFar / absZ, 1.0 );     } else {      v.multiplyScalar( Math.min( maxFar / absZ, 1.0 ) );     }    } );    return this.vertices;   }   split( breaks, target ) {    while ( breaks.length > target.length ) {     target.push( new CSMFrustum() );    }    target.length = breaks.length;    for ( let i = 0; i < breaks.length; i ++ ) {     const cascade = target[ i ];     if ( i === 0 ) {      for ( let j = 0; j < 4; j ++ ) {       cascade.vertices.near[ j ].copy( this.vertices.near[ j ] );      }     } else {      for ( let j = 0; j < 4; j ++ ) {       cascade.vertices.near[ j ].lerpVectors( this.vertices.near[ j ], this.vertices.far[ j ], breaks[ i - 1 ] );      }     }     if ( i === breaks.length - 1 ) {      for ( let j = 0; j < 4; j ++ ) {       cascade.vertices.far[ j ].copy( this.vertices.far[ j ] );      }     } else {      for ( let j = 0; j < 4; j ++ ) {       cascade.vertices.far[ j ].lerpVectors( this.vertices.near[ j ], this.vertices.far[ j ], breaks[ i ] );      }     }    }   }   toSpace( cameraMatrix, target ) {    for ( let i = 0; i < 4; i ++ ) {     target.vertices.near[ i ]     .copy( this.vertices.near[ i ] )     .applyMatrix4( cameraMatrix );     target.vertices.far[ i ]     .copy( this.vertices.far[ i ] )     .applyMatrix4( cameraMatrix );    }   }  }  export { CSMFrustum }; 
^..^ FILENAME ^..^
addons|csm|CSMHelper.js
^..^ CONTENTS ^..^
import {  Group,  Mesh,  LineSegments,  BufferGeometry,  LineBasicMaterial,  Box3Helper,  Box3,  PlaneGeometry,  MeshBasicMaterial,  BufferAttribute,  DoubleSide } from 'three';  class CSMHelper extends Group {   constructor( csm ) {    super();   this.csm = csm;   this.displayFrustum = true;   this.displayPlanes = true;   this.displayShadowBounds = true;    const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );   const positions = new Float32Array( 24 );   const frustumGeometry = new BufferGeometry();   frustumGeometry.setIndex( new BufferAttribute( indices, 1 ) );   frustumGeometry.setAttribute( 'position', new BufferAttribute( positions, 3, false ) );   const frustumLines = new LineSegments( frustumGeometry, new LineBasicMaterial() );   this.add( frustumLines );    this.frustumLines = frustumLines;   this.cascadeLines = [];   this.cascadePlanes = [];   this.shadowLines = [];   }   updateVisibility() {    const displayFrustum = this.displayFrustum;   const displayPlanes = this.displayPlanes;   const displayShadowBounds = this.displayShadowBounds;    const frustumLines = this.frustumLines;   const cascadeLines = this.cascadeLines;   const cascadePlanes = this.cascadePlanes;   const shadowLines = this.shadowLines;   for ( let i = 0, l = cascadeLines.length; i < l; i ++ ) {     const cascadeLine = cascadeLines[ i ];    const cascadePlane = cascadePlanes[ i ];    const shadowLineGroup = shadowLines[ i ];     cascadeLine.visible = displayFrustum;    cascadePlane.visible = displayFrustum && displayPlanes;    shadowLineGroup.visible = displayShadowBounds;    }    frustumLines.visible = displayFrustum;   }   update() {    const csm = this.csm;   const camera = csm.camera;   const cascades = csm.cascades;   const mainFrustum = csm.mainFrustum;   const frustums = csm.frustums;   const lights = csm.lights;    const frustumLines = this.frustumLines;   const frustumLinePositions = frustumLines.geometry.getAttribute( 'position' );   const cascadeLines = this.cascadeLines;   const cascadePlanes = this.cascadePlanes;   const shadowLines = this.shadowLines;    this.position.copy( camera.position );   this.quaternion.copy( camera.quaternion );   this.scale.copy( camera.scale );   this.updateMatrixWorld( true );    while ( cascadeLines.length > cascades ) {     this.remove( cascadeLines.pop() );    this.remove( cascadePlanes.pop() );    this.remove( shadowLines.pop() );    }    while ( cascadeLines.length < cascades ) {     const cascadeLine = new Box3Helper( new Box3(), 0xffffff );    const planeMat = new MeshBasicMaterial( { transparent: true, opacity: 0.1, depthWrite: false, side: DoubleSide } );    const cascadePlane = new Mesh( new PlaneGeometry(), planeMat );    const shadowLineGroup = new Group();    const shadowLine = new Box3Helper( new Box3(), 0xffff00 );    shadowLineGroup.add( shadowLine );     this.add( cascadeLine );    this.add( cascadePlane );    this.add( shadowLineGroup );     cascadeLines.push( cascadeLine );    cascadePlanes.push( cascadePlane );    shadowLines.push( shadowLineGroup );    }    for ( let i = 0; i < cascades; i ++ ) {     const frustum = frustums[ i ];    const light = lights[ i ];    const shadowCam = light.shadow.camera;    const farVerts = frustum.vertices.far;     const cascadeLine = cascadeLines[ i ];    const cascadePlane = cascadePlanes[ i ];    const shadowLineGroup = shadowLines[ i ];    const shadowLine = shadowLineGroup.children[ 0 ];     cascadeLine.box.min.copy( farVerts[ 2 ] );    cascadeLine.box.max.copy( farVerts[ 0 ] );    cascadeLine.box.max.z += 1e-4;     cascadePlane.position.addVectors( farVerts[ 0 ], farVerts[ 2 ] );    cascadePlane.position.multiplyScalar( 0.5 );    cascadePlane.scale.subVectors( farVerts[ 0 ], farVerts[ 2 ] );    cascadePlane.scale.z = 1e-4;     this.remove( shadowLineGroup );    shadowLineGroup.position.copy( shadowCam.position );    shadowLineGroup.quaternion.copy( shadowCam.quaternion );    shadowLineGroup.scale.copy( shadowCam.scale );    shadowLineGroup.updateMatrixWorld( true );    this.attach( shadowLineGroup );     shadowLine.box.min.set( shadowCam.bottom, shadowCam.left, - shadowCam.far );    shadowLine.box.max.set( shadowCam.top, shadowCam.right, - shadowCam.near );    }    const nearVerts = mainFrustum.vertices.near;   const farVerts = mainFrustum.vertices.far;   frustumLinePositions.setXYZ( 0, farVerts[ 0 ].x, farVerts[ 0 ].y, farVerts[ 0 ].z );   frustumLinePositions.setXYZ( 1, farVerts[ 3 ].x, farVerts[ 3 ].y, farVerts[ 3 ].z );   frustumLinePositions.setXYZ( 2, farVerts[ 2 ].x, farVerts[ 2 ].y, farVerts[ 2 ].z );   frustumLinePositions.setXYZ( 3, farVerts[ 1 ].x, farVerts[ 1 ].y, farVerts[ 1 ].z );    frustumLinePositions.setXYZ( 4, nearVerts[ 0 ].x, nearVerts[ 0 ].y, nearVerts[ 0 ].z );   frustumLinePositions.setXYZ( 5, nearVerts[ 3 ].x, nearVerts[ 3 ].y, nearVerts[ 3 ].z );   frustumLinePositions.setXYZ( 6, nearVerts[ 2 ].x, nearVerts[ 2 ].y, nearVerts[ 2 ].z );   frustumLinePositions.setXYZ( 7, nearVerts[ 1 ].x, nearVerts[ 1 ].y, nearVerts[ 1 ].z );   frustumLinePositions.needsUpdate = true;   }   dispose() {    const frustumLines = this.frustumLines;   const cascadeLines = this.cascadeLines;   const cascadePlanes = this.cascadePlanes;   const shadowLines = this.shadowLines;    frustumLines.geometry.dispose();   frustumLines.material.dispose();    const cascades = this.csm.cascades;    for ( let i = 0; i < cascades; i ++ ) {     const cascadeLine = cascadeLines[ i ];    const cascadePlane = cascadePlanes[ i ];    const shadowLineGroup = shadowLines[ i ];    const shadowLine = shadowLineGroup.children[ 0 ];     cascadeLine.dispose(); // Box3Helper     cascadePlane.geometry.dispose();    cascadePlane.material.dispose();     shadowLine.dispose(); // Box3Helper    }   }  }  export { CSMHelper }; 
^..^ FILENAME ^..^
addons|csm|CSMShader.js
^..^ CONTENTS ^..^
import { ShaderChunk } from 'three';  const CSMShader = {  lights_fragment_begin: /* glsl */| vec3 geometryPosition = - vViewPosition; vec3 geometryNormal = normal; vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );  vec3 geometryClearcoatNormal = vec3( 0.0 );  #ifdef USE_CLEARCOAT   geometryClearcoatNormal = clearcoatNormal;  #endif  #ifdef USE_IRIDESCENCE  float dotNVi = saturate( dot( normal, geometryViewDir ) );  if ( material.iridescenceThickness == 0.0 ) {   material.iridescence = 0.0;  } else {   material.iridescence = saturate( material.iridescence );  }  if ( material.iridescence > 0.0 ) {   material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );   // Iridescence F0 approximation   material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );  } #endif  IncidentLight directLight;  #if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )   PointLight pointLight;  #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0  PointLightShadow pointLightShadow;  #endif   #pragma unroll_loop_start  for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {    pointLight = pointLights[ i ];    getPointLightInfo( pointLight, geometryPosition, directLight );    #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )   pointLightShadow = pointLightShadows[ i ];   directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;   #endif    RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );   }  #pragma unroll_loop_end  #endif  #if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )   SpotLight spotLight;   vec4 spotColor;  vec3 spotLightCoord;  bool inSpotLightMap;   #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0  SpotLightShadow spotLightShadow;  #endif   #pragma unroll_loop_start  for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {    spotLight = spotLights[ i ];    getSpotLightInfo( spotLight, geometryPosition, directLight );      // spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]   #if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )   #define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX   #elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )   #define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS   #else   #define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )   #endif   #if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )    spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;    inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );    spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );    directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;   #endif   #undef SPOT_LIGHT_MAP_INDEX    #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )   spotLightShadow = spotLightShadows[ i ];   directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;    #endif    RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );   }  #pragma unroll_loop_end  #endif  #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )   DirectionalLight directionalLight;  float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);  #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0  DirectionalLightShadow directionalLightShadow;  #endif   #if defined( USE_SHADOWMAP ) && defined( CSM_FADE )   vec2 cascade;   float cascadeCenter;   float closestEdge;   float margin;   float csmx;   float csmy;    #pragma unroll_loop_start   for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {     directionalLight = directionalLights[ i ];    getDirectionalLightInfo( directionalLight, directLight );     #if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )     // NOTE: Depth gets larger away from the camera.     // cascade.x is closer, cascade.y is further     cascade = CSM_cascades[ i ];     cascadeCenter = ( cascade.x + cascade.y ) / 2.0;     closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;     margin = 0.25 * pow( closestEdge, 2.0 );     csmx = cascade.x - margin / 2.0;     csmy = cascade.y + margin / 2.0;     if( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {       float dist = min( linearDepth - csmx, csmy - linearDepth );      float ratio = clamp( dist / margin, 0.0, 1.0 );       vec3 prevColor = directLight.color;      directionalLightShadow = directionalLightShadows[ i ];      directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;       bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;      directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );       ReflectedLight prevLight = reflectedLight;      RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );       bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;      float blendRatio = shouldBlend ? ratio : 1.0;       reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );      reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );      reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );      reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );      }    #endif    }   #pragma unroll_loop_end  #elif defined (USE_SHADOWMAP)    #pragma unroll_loop_start   for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {     directionalLight = directionalLights[ i ];    getDirectionalLightInfo( directionalLight, directLight );     #if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )      directionalLightShadow = directionalLightShadows[ i ];     if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;      if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );     #endif    }   #pragma unroll_loop_end   #elif ( NUM_DIR_LIGHT_SHADOWS > 0 )   // note: no loop here - all CSM lights are in fact one light only   getDirectionalLightInfo( directionalLights[0], directLight );   RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );   #endif   #if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)   // compute the lights not casting shadows (if any)    #pragma unroll_loop_start   for ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {     directionalLight = directionalLights[ i ];     getDirectionalLightInfo( directionalLight, directLight );     RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );    }   #pragma unroll_loop_end   #endif  #endif   #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )   DirectionalLight directionalLight;  #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0  DirectionalLightShadow directionalLightShadow;  #endif   #pragma unroll_loop_start  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {    directionalLight = directionalLights[ i ];    getDirectionalLightInfo( directionalLight, directLight );    #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )   directionalLightShadow = directionalLightShadows[ i ];   directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;   #endif    RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );   }  #pragma unroll_loop_end  #endif  #if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )   RectAreaLight rectAreaLight;   #pragma unroll_loop_start  for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {    rectAreaLight = rectAreaLights[ i ];   RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );   }  #pragma unroll_loop_end  #endif  #if defined( RE_IndirectDiffuse )   vec3 iblIrradiance = vec3( 0.0 );   vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );   #if defined( USE_LIGHT_PROBES )    irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );   #endif   #if ( NUM_HEMI_LIGHTS > 0 )    #pragma unroll_loop_start   for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {     irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );    }   #pragma unroll_loop_end   #endif  #endif  #if defined( RE_IndirectSpecular )   vec3 radiance = vec3( 0.0 );  vec3 clearcoatRadiance = vec3( 0.0 );  #endif |,  lights_pars_begin: /* glsl */| #if defined( USE_CSM ) && defined( CSM_CASCADES ) uniform vec2 CSM_cascades[CSM_CASCADES]; uniform float cameraNear; uniform float shadowFar; #endif  | + ShaderChunk.lights_pars_begin };  export { CSMShader }; 
^..^ FILENAME ^..^
addons|curves|CurveExtras.js
^..^ CONTENTS ^..^
import {  Curve,  Vector3 } from 'three';  /**  * A bunch of parametric curves  *  * Formulas collected from various sources  * http://mathworld.wolfram.com/HeartCurve.html  * http://en.wikipedia.org/wiki/Viviani%27s_curve  * http://www.mi.sanu.ac.rs/vismath/taylorapril2011/Taylor.pdf  * https://prideout.net/blog/old/blog/index.html@p=44.html  */  // GrannyKnot  class GrannyKnot extends Curve {   getPoint( t, optionalTarget = new Vector3() ) {    const point = optionalTarget;    t = 2 * Math.PI * t;    const x = - 0.22 * Math.cos( t ) - 1.28 * Math.sin( t ) - 0.44 * Math.cos( 3 * t ) - 0.78 * Math.sin( 3 * t );   const y = - 0.1 * Math.cos( 2 * t ) - 0.27 * Math.sin( 2 * t ) + 0.38 * Math.cos( 4 * t ) + 0.46 * Math.sin( 4 * t );   const z = 0.7 * Math.cos( 3 * t ) - 0.4 * Math.sin( 3 * t );    return point.set( x, y, z ).multiplyScalar( 20 );   }  }  // HeartCurve  class HeartCurve extends Curve {   constructor( scale = 5 ) {    super();    this.scale = scale;   }   getPoint( t, optionalTarget = new Vector3() ) {    const point = optionalTarget;    t *= 2 * Math.PI;    const x = 16 * Math.pow( Math.sin( t ), 3 );   const y = 13 * Math.cos( t ) - 5 * Math.cos( 2 * t ) - 2 * Math.cos( 3 * t ) - Math.cos( 4 * t );   const z = 0;    return point.set( x, y, z ).multiplyScalar( this.scale );   }  }  // Viviani's Curve  class VivianiCurve extends Curve {   constructor( scale = 70 ) {    super();    this.scale = scale;   }   getPoint( t, optionalTarget = new Vector3() ) {    const point = optionalTarget;    t = t * 4 * Math.PI; // normalized to 0..1   const a = this.scale / 2;    const x = a * ( 1 + Math.cos( t ) );   const y = a * Math.sin( t );   const z = 2 * a * Math.sin( t / 2 );    return point.set( x, y, z );   }  }  // KnotCurve  class KnotCurve extends Curve {   getPoint( t, optionalTarget = new Vector3() ) {    const point = optionalTarget;    t *= 2 * Math.PI;    const R = 10;   const s = 50;    const x = s * Math.sin( t );   const y = Math.cos( t ) * ( R + s * Math.cos( t ) );   const z = Math.sin( t ) * ( R + s * Math.cos( t ) );    return point.set( x, y, z );   }  }   // HelixCurve  class HelixCurve extends Curve {   getPoint( t, optionalTarget = new Vector3() ) {    const point = optionalTarget;    const a = 30; // radius   const b = 150; // height    const t2 = 2 * Math.PI * t * b / 30;    const x = Math.cos( t2 ) * a;   const y = Math.sin( t2 ) * a;   const z = b * t;    return point.set( x, y, z );   }  }  // TrefoilKnot  class TrefoilKnot extends Curve {   constructor( scale = 10 ) {    super();    this.scale = scale;   }   getPoint( t, optionalTarget = new Vector3() ) {    const point = optionalTarget;    t *= Math.PI * 2;    const x = ( 2 + Math.cos( 3 * t ) ) * Math.cos( 2 * t );   const y = ( 2 + Math.cos( 3 * t ) ) * Math.sin( 2 * t );   const z = Math.sin( 3 * t );    return point.set( x, y, z ).multiplyScalar( this.scale );   }  }  // TorusKnot  class TorusKnot extends Curve {   constructor( scale = 10 ) {    super();    this.scale = scale;   }   getPoint( t, optionalTarget = new Vector3() ) {    const point = optionalTarget;    const p = 3;   const q = 4;    t *= Math.PI * 2;    const x = ( 2 + Math.cos( q * t ) ) * Math.cos( p * t );   const y = ( 2 + Math.cos( q * t ) ) * Math.sin( p * t );   const z = Math.sin( q * t );    return point.set( x, y, z ).multiplyScalar( this.scale );   }  }  // CinquefoilKnot  class CinquefoilKnot extends Curve {   constructor( scale = 10 ) {    super();    this.scale = scale;   }   getPoint( t, optionalTarget = new Vector3() ) {    const point = optionalTarget;    const p = 2;   const q = 5;    t *= Math.PI * 2;    const x = ( 2 + Math.cos( q * t ) ) * Math.cos( p * t );   const y = ( 2 + Math.cos( q * t ) ) * Math.sin( p * t );   const z = Math.sin( q * t );    return point.set( x, y, z ).multiplyScalar( this.scale );   }  }   // TrefoilPolynomialKnot  class TrefoilPolynomialKnot extends Curve {   constructor( scale = 10 ) {    super();    this.scale = scale;   }   getPoint( t, optionalTarget = new Vector3() ) {    const point = optionalTarget;    t = t * 4 - 2;    const x = Math.pow( t, 3 ) - 3 * t;   const y = Math.pow( t, 4 ) - 4 * t * t;   const z = 1 / 5 * Math.pow( t, 5 ) - 2 * t;    return point.set( x, y, z ).multiplyScalar( this.scale );   }  }  function scaleTo( x, y, t ) {   const r = y - x;  return t * r + x;  }  // FigureEightPolynomialKnot  class FigureEightPolynomialKnot extends Curve {   constructor( scale = 1 ) {    super();    this.scale = scale;   }   getPoint( t, optionalTarget = new Vector3() ) {    const point = optionalTarget;    t = scaleTo( - 4, 4, t );    const x = 2 / 5 * t * ( t * t - 7 ) * ( t * t - 10 );   const y = Math.pow( t, 4 ) - 13 * t * t;   const z = 1 / 10 * t * ( t * t - 4 ) * ( t * t - 9 ) * ( t * t - 12 );    return point.set( x, y, z ).multiplyScalar( this.scale );   }  }  // DecoratedTorusKnot4a  class DecoratedTorusKnot4a extends Curve {   constructor( scale = 40 ) {    super();    this.scale = scale;   }   getPoint( t, optionalTarget = new Vector3() ) {    const point = optionalTarget;    t *= Math.PI * 2;    const x = Math.cos( 2 * t ) * ( 1 + 0.6 * ( Math.cos( 5 * t ) + 0.75 * Math.cos( 10 * t ) ) );   const y = Math.sin( 2 * t ) * ( 1 + 0.6 * ( Math.cos( 5 * t ) + 0.75 * Math.cos( 10 * t ) ) );   const z = 0.35 * Math.sin( 5 * t );    return point.set( x, y, z ).multiplyScalar( this.scale );   }  }  // DecoratedTorusKnot4b  class DecoratedTorusKnot4b extends Curve {   constructor( scale = 40 ) {    super();    this.scale = scale;   }   getPoint( t, optionalTarget = new Vector3() ) {    const point = optionalTarget;    const fi = t * Math.PI * 2;    const x = Math.cos( 2 * fi ) * ( 1 + 0.45 * Math.cos( 3 * fi ) + 0.4 * Math.cos( 9 * fi ) );   const y = Math.sin( 2 * fi ) * ( 1 + 0.45 * Math.cos( 3 * fi ) + 0.4 * Math.cos( 9 * fi ) );   const z = 0.2 * Math.sin( 9 * fi );    return point.set( x, y, z ).multiplyScalar( this.scale );   }  }   // DecoratedTorusKnot5a  class DecoratedTorusKnot5a extends Curve {   constructor( scale = 40 ) {    super();    this.scale = scale;   }   getPoint( t, optionalTarget = new Vector3() ) {    const point = optionalTarget;    const fi = t * Math.PI * 2;    const x = Math.cos( 3 * fi ) * ( 1 + 0.3 * Math.cos( 5 * fi ) + 0.5 * Math.cos( 10 * fi ) );   const y = Math.sin( 3 * fi ) * ( 1 + 0.3 * Math.cos( 5 * fi ) + 0.5 * Math.cos( 10 * fi ) );   const z = 0.2 * Math.sin( 20 * fi );    return point.set( x, y, z ).multiplyScalar( this.scale );   }  }  // DecoratedTorusKnot5c  class DecoratedTorusKnot5c extends Curve {   constructor( scale = 40 ) {    super();    this.scale = scale;   }   getPoint( t, optionalTarget = new Vector3() ) {    const point = optionalTarget;    const fi = t * Math.PI * 2;    const x = Math.cos( 4 * fi ) * ( 1 + 0.5 * ( Math.cos( 5 * fi ) + 0.4 * Math.cos( 20 * fi ) ) );   const y = Math.sin( 4 * fi ) * ( 1 + 0.5 * ( Math.cos( 5 * fi ) + 0.4 * Math.cos( 20 * fi ) ) );   const z = 0.35 * Math.sin( 15 * fi );    return point.set( x, y, z ).multiplyScalar( this.scale );   }  }  export {  GrannyKnot,  HeartCurve,  VivianiCurve,  KnotCurve,  HelixCurve,  TrefoilKnot,  TorusKnot,  CinquefoilKnot,  TrefoilPolynomialKnot,  FigureEightPolynomialKnot,  DecoratedTorusKnot4a,  DecoratedTorusKnot4b,  DecoratedTorusKnot5a,  DecoratedTorusKnot5c }; 
^..^ FILENAME ^..^
addons|curves|NURBSCurve.js
^..^ CONTENTS ^..^
import {  Curve,  Vector3,  Vector4 } from 'three'; import * as NURBSUtils from '../curves/NURBSUtils.js';  /**  * NURBS curve object  *  * Derives from Curve, overriding getPoint and getTangent.  *  * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.  *  **/  class NURBSCurve extends Curve {   constructor(   degree,   knots /* array of reals */,   controlPoints /* array of Vector(2|3|4) */,   startKnot /* index in knots */,   endKnot /* index in knots */  ) {    super();    this.degree = degree;   this.knots = knots;   this.controlPoints = [];   // Used by periodic NURBS to remove hidden spans   this.startKnot = startKnot || 0;   this.endKnot = endKnot || ( this.knots.length - 1 );    for ( let i = 0; i < controlPoints.length; ++ i ) {     // ensure Vector4 for control points    const point = controlPoints[ i ];    this.controlPoints[ i ] = new Vector4( point.x, point.y, point.z, point.w );    }   }   getPoint( t, optionalTarget = new Vector3() ) {    const point = optionalTarget;    const u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u    // following results in (wx, wy, wz, w) homogeneous point   const hpoint = NURBSUtils.calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );    if ( hpoint.w !== 1.0 ) {     // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)    hpoint.divideScalar( hpoint.w );    }    return point.set( hpoint.x, hpoint.y, hpoint.z );   }   getTangent( t, optionalTarget = new Vector3() ) {    const tangent = optionalTarget;    const u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );   const ders = NURBSUtils.calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );   tangent.copy( ders[ 1 ] ).normalize();    return tangent;   }  }  export { NURBSCurve }; 
^..^ FILENAME ^..^
addons|curves|NURBSSurface.js
^..^ CONTENTS ^..^
import {  Vector4 } from 'three'; import * as NURBSUtils from '../curves/NURBSUtils.js';  /**  * NURBS surface object  *  * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.  **/  class NURBSSurface {   constructor( degree1, degree2, knots1, knots2 /* arrays of reals */, controlPoints /* array^2 of Vector(2|3|4) */ ) {    this.degree1 = degree1;   this.degree2 = degree2;   this.knots1 = knots1;   this.knots2 = knots2;   this.controlPoints = [];    const len1 = knots1.length - degree1 - 1;   const len2 = knots2.length - degree2 - 1;    // ensure Vector4 for control points   for ( let i = 0; i < len1; ++ i ) {     this.controlPoints[ i ] = [];     for ( let j = 0; j < len2; ++ j ) {      const point = controlPoints[ i ][ j ];     this.controlPoints[ i ][ j ] = new Vector4( point.x, point.y, point.z, point.w );     }    }   }   getPoint( t1, t2, target ) {    const u = this.knots1[ 0 ] + t1 * ( this.knots1[ this.knots1.length - 1 ] - this.knots1[ 0 ] ); // linear mapping t1->u   const v = this.knots2[ 0 ] + t2 * ( this.knots2[ this.knots2.length - 1 ] - this.knots2[ 0 ] ); // linear mapping t2->u    NURBSUtils.calcSurfacePoint( this.degree1, this.degree2, this.knots1, this.knots2, this.controlPoints, u, v, target );   }  }  export { NURBSSurface }; 
^..^ FILENAME ^..^
addons|curves|NURBSUtils.js
^..^ CONTENTS ^..^
import {  Vector3,  Vector4 } from 'three';  /**  * NURBS utils  *  * See NURBSCurve and NURBSSurface.  **/   /**************************************************************  * NURBS Utils  **************************************************************/  /* Finds knot vector span.  p : degree u : parametric value U : knot vector  returns the span */ function findSpan( p, u, U ) {   const n = U.length - p - 1;   if ( u >= U[ n ] ) {    return n - 1;   }   if ( u <= U[ p ] ) {    return p;   }   let low = p;  let high = n;  let mid = Math.floor( ( low + high ) / 2 );   while ( u < U[ mid ] || u >= U[ mid + 1 ] ) {    if ( u < U[ mid ] ) {     high = mid;    } else {     low = mid;    }    mid = Math.floor( ( low + high ) / 2 );   }   return mid;  }   /* Calculate basis functions. See The NURBS Book, page 70, algorithm A2.2  span : span in which u lies u    : parametric point p    : degree U    : knot vector  returns array[p+1] with basis functions values. */ function calcBasisFunctions( span, u, p, U ) {   const N = [];  const left = [];  const right = [];  N[ 0 ] = 1.0;   for ( let j = 1; j <= p; ++ j ) {    left[ j ] = u - U[ span + 1 - j ];   right[ j ] = U[ span + j ] - u;    let saved = 0.0;    for ( let r = 0; r < j; ++ r ) {     const rv = right[ r + 1 ];    const lv = left[ j - r ];    const temp = N[ r ] / ( rv + lv );    N[ r ] = saved + rv * temp;    saved = lv * temp;    }    N[ j ] = saved;   }   return N;  }   /* Calculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.  p : degree of B-Spline U : knot vector P : control points (x, y, z, w) u : parametric point  returns point for given u */ function calcBSplinePoint( p, U, P, u ) {   const span = findSpan( p, u, U );  const N = calcBasisFunctions( span, u, p, U );  const C = new Vector4( 0, 0, 0, 0 );   for ( let j = 0; j <= p; ++ j ) {    const point = P[ span - p + j ];   const Nj = N[ j ];   const wNj = point.w * Nj;   C.x += point.x * wNj;   C.y += point.y * wNj;   C.z += point.z * wNj;   C.w += point.w * Nj;   }   return C;  }   /* Calculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.  span : span in which u lies u    : parametric point p    : degree n    : number of derivatives to calculate U    : knot vector  returns array[n+1][p+1] with basis functions derivatives */ function calcBasisFunctionDerivatives( span, u, p, n, U ) {   const zeroArr = [];  for ( let i = 0; i <= p; ++ i )   zeroArr[ i ] = 0.0;   const ders = [];   for ( let i = 0; i <= n; ++ i )   ders[ i ] = zeroArr.slice( 0 );   const ndu = [];   for ( let i = 0; i <= p; ++ i )   ndu[ i ] = zeroArr.slice( 0 );   ndu[ 0 ][ 0 ] = 1.0;   const left = zeroArr.slice( 0 );  const right = zeroArr.slice( 0 );   for ( let j = 1; j <= p; ++ j ) {    left[ j ] = u - U[ span + 1 - j ];   right[ j ] = U[ span + j ] - u;    let saved = 0.0;    for ( let r = 0; r < j; ++ r ) {     const rv = right[ r + 1 ];    const lv = left[ j - r ];    ndu[ j ][ r ] = rv + lv;     const temp = ndu[ r ][ j - 1 ] / ndu[ j ][ r ];    ndu[ r ][ j ] = saved + rv * temp;    saved = lv * temp;    }    ndu[ j ][ j ] = saved;   }   for ( let j = 0; j <= p; ++ j ) {    ders[ 0 ][ j ] = ndu[ j ][ p ];   }   for ( let r = 0; r <= p; ++ r ) {    let s1 = 0;   let s2 = 1;    const a = [];   for ( let i = 0; i <= p; ++ i ) {     a[ i ] = zeroArr.slice( 0 );    }    a[ 0 ][ 0 ] = 1.0;    for ( let k = 1; k <= n; ++ k ) {     let d = 0.0;    const rk = r - k;    const pk = p - k;     if ( r >= k ) {      a[ s2 ][ 0 ] = a[ s1 ][ 0 ] / ndu[ pk + 1 ][ rk ];     d = a[ s2 ][ 0 ] * ndu[ rk ][ pk ];     }     const j1 = ( rk >= - 1 ) ? 1 : - rk;    const j2 = ( r - 1 <= pk ) ? k - 1 : p - r;     for ( let j = j1; j <= j2; ++ j ) {      a[ s2 ][ j ] = ( a[ s1 ][ j ] - a[ s1 ][ j - 1 ] ) / ndu[ pk + 1 ][ rk + j ];     d += a[ s2 ][ j ] * ndu[ rk + j ][ pk ];     }     if ( r <= pk ) {      a[ s2 ][ k ] = - a[ s1 ][ k - 1 ] / ndu[ pk + 1 ][ r ];     d += a[ s2 ][ k ] * ndu[ r ][ pk ];     }     ders[ k ][ r ] = d;     const j = s1;    s1 = s2;    s2 = j;    }   }   let r = p;   for ( let k = 1; k <= n; ++ k ) {    for ( let j = 0; j <= p; ++ j ) {     ders[ k ][ j ] *= r;    }    r *= p - k;   }   return ders;  }   /*  Calculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.   p  : degree  U  : knot vector  P  : control points  u  : Parametric points  nd : number of derivatives   returns array[d+1] with derivatives  */ function calcBSplineDerivatives( p, U, P, u, nd ) {   const du = nd < p ? nd : p;  const CK = [];  const span = findSpan( p, u, U );  const nders = calcBasisFunctionDerivatives( span, u, p, du, U );  const Pw = [];   for ( let i = 0; i < P.length; ++ i ) {    const point = P[ i ].clone();   const w = point.w;    point.x *= w;   point.y *= w;   point.z *= w;    Pw[ i ] = point;   }   for ( let k = 0; k <= du; ++ k ) {    const point = Pw[ span - p ].clone().multiplyScalar( nders[ k ][ 0 ] );    for ( let j = 1; j <= p; ++ j ) {     point.add( Pw[ span - p + j ].clone().multiplyScalar( nders[ k ][ j ] ) );    }    CK[ k ] = point;   }   for ( let k = du + 1; k <= nd + 1; ++ k ) {    CK[ k ] = new Vector4( 0, 0, 0 );   }   return CK;  }   /* Calculate "K over I"  returns k!/(i!(k-i)!) */ function calcKoverI( k, i ) {   let nom = 1;   for ( let j = 2; j <= k; ++ j ) {    nom *= j;   }   let denom = 1;   for ( let j = 2; j <= i; ++ j ) {    denom *= j;   }   for ( let j = 2; j <= k - i; ++ j ) {    denom *= j;   }   return nom / denom;  }   /* Calculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.  Pders : result of function calcBSplineDerivatives  returns array with derivatives for rational curve. */ function calcRationalCurveDerivatives( Pders ) {   const nd = Pders.length;  const Aders = [];  const wders = [];   for ( let i = 0; i < nd; ++ i ) {    const point = Pders[ i ];   Aders[ i ] = new Vector3( point.x, point.y, point.z );   wders[ i ] = point.w;   }   const CK = [];   for ( let k = 0; k < nd; ++ k ) {    const v = Aders[ k ].clone();    for ( let i = 1; i <= k; ++ i ) {     v.sub( CK[ k - i ].clone().multiplyScalar( calcKoverI( k, i ) * wders[ i ] ) );    }    CK[ k ] = v.divideScalar( wders[ 0 ] );   }   return CK;  }   /* Calculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.  p  : degree U  : knot vector P  : control points in homogeneous space u  : parametric points nd : number of derivatives  returns array with derivatives. */ function calcNURBSDerivatives( p, U, P, u, nd ) {   const Pders = calcBSplineDerivatives( p, U, P, u, nd );  return calcRationalCurveDerivatives( Pders );  }   /* Calculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.  p, q : degrees of B-Spline surface U, V : knot vectors P    : control points (x, y, z, w) u, v : parametric values  returns point for given (u, v) */ function calcSurfacePoint( p, q, U, V, P, u, v, target ) {   const uspan = findSpan( p, u, U );  const vspan = findSpan( q, v, V );  const Nu = calcBasisFunctions( uspan, u, p, U );  const Nv = calcBasisFunctions( vspan, v, q, V );  const temp = [];   for ( let l = 0; l <= q; ++ l ) {    temp[ l ] = new Vector4( 0, 0, 0, 0 );   for ( let k = 0; k <= p; ++ k ) {     const point = P[ uspan - p + k ][ vspan - q + l ].clone();    const w = point.w;    point.x *= w;    point.y *= w;    point.z *= w;    temp[ l ].add( point.multiplyScalar( Nu[ k ] ) );    }   }   const Sw = new Vector4( 0, 0, 0, 0 );  for ( let l = 0; l <= q; ++ l ) {    Sw.add( temp[ l ].multiplyScalar( Nv[ l ] ) );   }   Sw.divideScalar( Sw.w );  target.set( Sw.x, Sw.y, Sw.z );  }  /* Calculate rational B-Spline volume point. See The NURBS Book, page 134, algorithm A4.3.  p, q, r   : degrees of B-Splinevolume U, V, W   : knot vectors P         : control points (x, y, z, w) u, v, w   : parametric values  returns point for given (u, v, w) */ function calcVolumePoint( p, q, r, U, V, W, P, u, v, w, target ) {   const uspan = findSpan( p, u, U );  const vspan = findSpan( q, v, V );  const wspan = findSpan( r, w, W );  const Nu = calcBasisFunctions( uspan, u, p, U );  const Nv = calcBasisFunctions( vspan, v, q, V );  const Nw = calcBasisFunctions( wspan, w, r, W );  const temp = [];   for ( let m = 0; m <= r; ++ m ) {    temp[ m ] = [];    for ( let l = 0; l <= q; ++ l ) {     temp[ m ][ l ] = new Vector4( 0, 0, 0, 0 );    for ( let k = 0; k <= p; ++ k ) {      const point = P[ uspan - p + k ][ vspan - q + l ][ wspan - r + m ].clone();     const w = point.w;     point.x *= w;     point.y *= w;     point.z *= w;     temp[ m ][ l ].add( point.multiplyScalar( Nu[ k ] ) );     }    }   }  const Sw = new Vector4( 0, 0, 0, 0 );  for ( let m = 0; m <= r; ++ m ) {   for ( let l = 0; l <= q; ++ l ) {     Sw.add( temp[ m ][ l ].multiplyScalar( Nw[ m ] ).multiplyScalar( Nv[ l ] ) );    }  }   Sw.divideScalar( Sw.w );  target.set( Sw.x, Sw.y, Sw.z );  }   export {  findSpan,  calcBasisFunctions,  calcBSplinePoint,  calcBasisFunctionDerivatives,  calcBSplineDerivatives,  calcKoverI,  calcRationalCurveDerivatives,  calcNURBSDerivatives,  calcSurfacePoint,  calcVolumePoint, }; 
^..^ FILENAME ^..^
addons|curves|NURBSVolume.js
^..^ CONTENTS ^..^
import {  Vector4 } from 'three'; import * as NURBSUtils from '../curves/NURBSUtils.js';  /**  * NURBS volume object  *  * Implementation is based on (x, y, z [, w=1]]) control points with w=weight.  **/  class NURBSVolume {   constructor( degree1, degree2, degree3, knots1, knots2, knots3 /* arrays of reals */, controlPoints /* array^3 of Vector(2|3|4) */ ) {    this.degree1 = degree1;   this.degree2 = degree2;   this.degree3 = degree3;   this.knots1 = knots1;   this.knots2 = knots2;   this.knots3 = knots3;   this.controlPoints = [];    const len1 = knots1.length - degree1 - 1;   const len2 = knots2.length - degree2 - 1;   const len3 = knots3.length - degree3 - 1;    // ensure Vector4 for control points   for ( let i = 0; i < len1; ++ i ) {     this.controlPoints[ i ] = [];     for ( let j = 0; j < len2; ++ j ) {      this.controlPoints[ i ][ j ] = [];      for ( let k = 0; k < len3; ++ k ) {       const point = controlPoints[ i ][ j ][ k ];      this.controlPoints[ i ][ j ][ k ] = new Vector4( point.x, point.y, point.z, point.w );      }     }    }   }   getPoint( t1, t2, t3, target ) {    const u = this.knots1[ 0 ] + t1 * ( this.knots1[ this.knots1.length - 1 ] - this.knots1[ 0 ] ); // linear mapping t1->u   const v = this.knots2[ 0 ] + t2 * ( this.knots2[ this.knots2.length - 1 ] - this.knots2[ 0 ] ); // linear mapping t2->v   const w = this.knots3[ 0 ] + t3 * ( this.knots3[ this.knots3.length - 1 ] - this.knots3[ 0 ] ); // linear mapping t3->w    NURBSUtils.calcVolumePoint( this.degree1, this.degree2, this.degree3, this.knots1, this.knots2, this.knots3, this.controlPoints, u, v, w, target );   }  }  export { NURBSVolume }; 
^..^ FILENAME ^..^
addons|effects|AnaglyphEffect.js
^..^ CONTENTS ^..^
import {  LinearFilter,  Matrix3,  NearestFilter,  RGBAFormat,  ShaderMaterial,  StereoCamera,  WebGLRenderTarget } from 'three'; import { FullScreenQuad } from '../postprocessing/Pass.js';  class AnaglyphEffect {   constructor( renderer, width = 512, height = 512 ) {    // Dubois matrices from https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.7.6968&rep=rep1&type=pdf#page=4    this.colorMatrixLeft = new Matrix3().fromArray( [    0.456100, - 0.0400822, - 0.0152161,    0.500484, - 0.0378246, - 0.0205971,    0.176381, - 0.0157589, - 0.00546856   ] );    this.colorMatrixRight = new Matrix3().fromArray( [    - 0.0434706, 0.378476, - 0.0721527,    - 0.0879388, 0.73364, - 0.112961,    - 0.00155529, - 0.0184503, 1.2264   ] );    const _stereo = new StereoCamera();    const _params = { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat };    const _renderTargetL = new WebGLRenderTarget( width, height, _params );   const _renderTargetR = new WebGLRenderTarget( width, height, _params );    const _material = new ShaderMaterial( {     uniforms: {      'mapLeft': { value: _renderTargetL.texture },     'mapRight': { value: _renderTargetR.texture },      'colorMatrixLeft': { value: this.colorMatrixLeft },     'colorMatrixRight': { value: this.colorMatrixRight }     },     vertexShader: [      'varying vec2 vUv;',      'void main() {',      ' vUv = vec2( uv.x, uv.y );',     ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',      '}'     ].join( '|n' ),     fragmentShader: [      'uniform sampler2D mapLeft;',     'uniform sampler2D mapRight;',     'varying vec2 vUv;',      'uniform mat3 colorMatrixLeft;',     'uniform mat3 colorMatrixRight;',      'void main() {',      ' vec2 uv = vUv;',      ' vec4 colorL = texture2D( mapLeft, uv );',     ' vec4 colorR = texture2D( mapRight, uv );',      ' vec3 color = clamp(',     '   colorMatrixLeft * colorL.rgb +',     '   colorMatrixRight * colorR.rgb, 0., 1. );',      ' gl_FragColor = vec4(',     '   color.r, color.g, color.b,',     '   max( colorL.a, colorR.a ) );',      ' #include <tonemapping_fragment>',     ' #include <colorspace_fragment>',      '}'     ].join( '|n' )    } );    const _quad = new FullScreenQuad( _material );    this.setSize = function ( width, height ) {     renderer.setSize( width, height );     const pixelRatio = renderer.getPixelRatio();     _renderTargetL.setSize( width * pixelRatio, height * pixelRatio );    _renderTargetR.setSize( width * pixelRatio, height * pixelRatio );    };    this.render = function ( scene, camera ) {     const currentRenderTarget = renderer.getRenderTarget();     if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();     if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();     _stereo.update( camera );     renderer.setRenderTarget( _renderTargetL );    renderer.clear();    renderer.render( scene, _stereo.cameraL );     renderer.setRenderTarget( _renderTargetR );    renderer.clear();    renderer.render( scene, _stereo.cameraR );     renderer.setRenderTarget( null );    _quad.render( renderer );     renderer.setRenderTarget( currentRenderTarget );    };    this.dispose = function () {     _renderTargetL.dispose();    _renderTargetR.dispose();     _material.dispose();    _quad.dispose();    };   }  }  export { AnaglyphEffect }; 
^..^ FILENAME ^..^
addons|effects|AsciiEffect.js
^..^ CONTENTS ^..^
/**  * Ascii generation is based on https://github.com/hassadee/jsascii/blob/master/jsascii.js  *  * 16 April 2012 - @blurspline  */  class AsciiEffect {   constructor( renderer, charSet = ' .:-=+*#%@', options = {} ) {    // ' .,:;=|iI+hHOE#|$';   // darker bolder character set from https://github.com/saw/Canvas-ASCII-Art/   // ' .|'|^",:;Il!i~+_-?][}{1)(|/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$'.split('');    // Some ASCII settings    const fResolution = options[ 'resolution' ] || 0.15; // Higher for more details   const iScale = options[ 'scale' ] || 1;   const bColor = options[ 'color' ] || false; // nice but slows down rendering!   const bAlpha = options[ 'alpha' ] || false; // Transparency   const bBlock = options[ 'block' ] || false; // blocked characters. like good O dos   const bInvert = options[ 'invert' ] || false; // black is white, white is black   const strResolution = options[ 'strResolution' ] || 'low';    let width, height;    const domElement = document.createElement( 'div' );   domElement.style.cursor = 'default';    const oAscii = document.createElement( 'table' );   domElement.appendChild( oAscii );    let iWidth, iHeight;   let oImg;    this.setSize = function ( w, h ) {     width = w;    height = h;     renderer.setSize( w, h );     initAsciiSize();    };     this.render = function ( scene, camera ) {     renderer.render( scene, camera );    asciifyImage( oAscii );    };    this.domElement = domElement;     // Throw in ascii library from https://github.com/hassadee/jsascii/blob/master/jsascii.js (MIT License)    function initAsciiSize() {     iWidth = Math.floor( width * fResolution );    iHeight = Math.floor( height * fResolution );     oCanvas.width = iWidth;    oCanvas.height = iHeight;    // oCanvas.style.display = "none";    // oCanvas.style.width = iWidth;    // oCanvas.style.height = iHeight;     oImg = renderer.domElement;     if ( oImg.style.backgroundColor ) {      oAscii.rows[ 0 ].cells[ 0 ].style.backgroundColor = oImg.style.backgroundColor;     oAscii.rows[ 0 ].cells[ 0 ].style.color = oImg.style.color;     }     oAscii.cellSpacing = 0;    oAscii.cellPadding = 0;     const oStyle = oAscii.style;    oStyle.whiteSpace = 'pre';    oStyle.margin = '0px';    oStyle.padding = '0px';    oStyle.letterSpacing = fLetterSpacing + 'px';    oStyle.fontFamily = strFont;    oStyle.fontSize = fFontSize + 'px';    oStyle.lineHeight = fLineHeight + 'px';    oStyle.textAlign = 'left';    oStyle.textDecoration = 'none';    }     const aDefaultCharList = ( ' .,:;i1tfLCG08@' ).split( '' );   const aDefaultColorCharList = ( ' CGO08@' ).split( '' );   const strFont = 'courier new, monospace';    const oCanvasImg = renderer.domElement;    const oCanvas = document.createElement( 'canvas' );   if ( ! oCanvas.getContext ) {     return;    }    const oCtx = oCanvas.getContext( '2d' );   if ( ! oCtx.getImageData ) {     return;    }    let aCharList = ( bColor ? aDefaultColorCharList : aDefaultCharList );    if ( charSet ) aCharList = charSet;    // Setup dom    const fFontSize = ( 2 / fResolution ) * iScale;   const fLineHeight = ( 2 / fResolution ) * iScale;    // adjust letter-spacing for all combinations of scale and resolution to get it to fit the image width.    let fLetterSpacing = 0;    if ( strResolution == 'low' ) {     switch ( iScale ) {      case 1 : fLetterSpacing = - 1; break;     case 2 :     case 3 : fLetterSpacing = - 2.1; break;     case 4 : fLetterSpacing = - 3.1; break;     case 5 : fLetterSpacing = - 4.15; break;     }    }    if ( strResolution == 'medium' ) {     switch ( iScale ) {      case 1 : fLetterSpacing = 0; break;     case 2 : fLetterSpacing = - 1; break;     case 3 : fLetterSpacing = - 1.04; break;     case 4 :     case 5 : fLetterSpacing = - 2.1; break;     }    }    if ( strResolution == 'high' ) {     switch ( iScale ) {      case 1 :     case 2 : fLetterSpacing = 0; break;     case 3 :     case 4 :     case 5 : fLetterSpacing = - 1; break;     }    }     // can't get a span or div to flow like an img element, but a table works?     // convert img element to ascii    function asciifyImage( oAscii ) {     oCtx.clearRect( 0, 0, iWidth, iHeight );    oCtx.drawImage( oCanvasImg, 0, 0, iWidth, iHeight );    const oImgData = oCtx.getImageData( 0, 0, iWidth, iHeight ).data;     // Coloring loop starts now    let strChars = '';     // console.time('rendering');     for ( let y = 0; y < iHeight; y += 2 ) {      for ( let x = 0; x < iWidth; x ++ ) {       const iOffset = ( y * iWidth + x ) * 4;       const iRed = oImgData[ iOffset ];      const iGreen = oImgData[ iOffset + 1 ];      const iBlue = oImgData[ iOffset + 2 ];      const iAlpha = oImgData[ iOffset + 3 ];      let iCharIdx;       let fBrightness;       fBrightness = ( 0.3 * iRed + 0.59 * iGreen + 0.11 * iBlue ) / 255;      // fBrightness = (0.3*iRed + 0.5*iGreen + 0.3*iBlue) / 255;       if ( iAlpha == 0 ) {        // should calculate alpha instead, but quick hack :)       //fBrightness *= (iAlpha / 255);       fBrightness = 1;       }       iCharIdx = Math.floor( ( 1 - fBrightness ) * ( aCharList.length - 1 ) );       if ( bInvert ) {        iCharIdx = aCharList.length - iCharIdx - 1;       }       // good for debugging      //fBrightness = Math.floor(fBrightness * 10);      //strThisChar = fBrightness;       let strThisChar = aCharList[ iCharIdx ];       if ( strThisChar === undefined || strThisChar == ' ' )       strThisChar = '&nbsp;';       if ( bColor ) {        strChars += '<span style=|''        + 'color:rgb(' + iRed + ',' + iGreen + ',' + iBlue + ');'        + ( bBlock ? 'background-color:rgb(' + iRed + ',' + iGreen + ',' + iBlue + ');' : '' )        + ( bAlpha ? 'opacity:' + ( iAlpha / 255 ) + ';' : '' )        + '|'>' + strThisChar + '</span>';       } else {        strChars += strThisChar;       }      }      strChars += '<br/>';     }     oAscii.innerHTML = |<tr><td style="display:block;width:|width}px;height:|height}px;overflow:hidden">|strChars}</td></tr>|;     // console.timeEnd('rendering');     // return oAscii;    }   }  }  export { AsciiEffect }; 
^..^ FILENAME ^..^
addons|effects|OutlineEffect.js
^..^ CONTENTS ^..^
import {  BackSide,  Color,  ShaderMaterial,  UniformsLib,  UniformsUtils } from 'three';  /**  * Reference: https://en.wikipedia.org/wiki/Cel_shading  *  * API  *  * 1. Traditional  *  * const effect = new OutlineEffect( renderer );  *  * function render() {  *  *  effect.render( scene, camera );  *  * }  *  * 2. VR compatible  *  * const effect = new OutlineEffect( renderer );  * let renderingOutline = false;  *  * scene.onAfterRender = function () {  *  *  if ( renderingOutline ) return;  *  *  renderingOutline = true;  *  *  effect.renderOutline( scene, camera );  *  *  renderingOutline = false;  *  * };  *  * function render() {  *  *  renderer.render( scene, camera );  *  * }  *  * // How to set default outline parameters  * new OutlineEffect( renderer, {  *  defaultThickness: 0.01,  *  defaultColor: [ 0, 0, 0 ],  *  defaultAlpha: 0.8,  *  defaultKeepAlive: true // keeps outline material in cache even if material is removed from scene  * } );  *  * // How to set outline parameters for each material  * material.userData.outlineParameters = {  *  thickness: 0.01,  *  color: [ 0, 0, 0 ],  *  alpha: 0.8,  *  visible: true,  *  keepAlive: true  * };  */  class OutlineEffect {   constructor( renderer, parameters = {} ) {    this.enabled = true;    const defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;   const defaultColor = new Color().fromArray( parameters.defaultColor !== undefined ? parameters.defaultColor : [ 0, 0, 0 ] );   const defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;   const defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false;    // object.material.uuid -> outlineMaterial or   // object.material[ n ].uuid -> outlineMaterial   // save at the outline material creation and release   // if it's unused removeThresholdCount frames   // unless keepAlive is true.   const cache = {};    const removeThresholdCount = 60;    // outlineMaterial.uuid -> object.material or   // outlineMaterial.uuid -> object.material[ n ]   // save before render and release after render.   const originalMaterials = {};    // object.uuid -> originalOnBeforeRender   // save before render and release after render.   const originalOnBeforeRenders = {};    //this.cache = cache;  // for debug    const uniformsOutline = {    outlineThickness: { value: defaultThickness },    outlineColor: { value: defaultColor },    outlineAlpha: { value: defaultAlpha }   };    const vertexShader = [    '#include <common>',    '#include <uv_pars_vertex>',    '#include <displacementmap_pars_vertex>',    '#include <fog_pars_vertex>',    '#include <morphtarget_pars_vertex>',    '#include <skinning_pars_vertex>',    '#include <logdepthbuf_pars_vertex>',    '#include <clipping_planes_pars_vertex>',     'uniform float outlineThickness;',     'vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {',    ' float thickness = outlineThickness;',    ' const float ratio = 1.0;', // TODO: support outline thickness ratio for each vertex    ' vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );',    // NOTE: subtract pos2 from pos because BackSide objectNormal is negative    ' vec4 norm = normalize( pos - pos2 );',    ' return pos + norm * thickness * pos.w * ratio;',    '}',     'void main() {',     ' #include <uv_vertex>',     ' #include <beginnormal_vertex>',    ' #include <morphnormal_vertex>',    ' #include <skinbase_vertex>',    ' #include <skinnormal_vertex>',     ' #include <begin_vertex>',    ' #include <morphtarget_vertex>',    ' #include <skinning_vertex>',    ' #include <displacementmap_vertex>',    ' #include <project_vertex>',     ' vec3 outlineNormal = - objectNormal;', // the outline material is always rendered with BackSide     ' gl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );',     ' #include <logdepthbuf_vertex>',    ' #include <clipping_planes_vertex>',    ' #include <fog_vertex>',     '}',    ].join( '|n' );    const fragmentShader = [     '#include <common>',    '#include <fog_pars_fragment>',    '#include <logdepthbuf_pars_fragment>',    '#include <clipping_planes_pars_fragment>',     'uniform vec3 outlineColor;',    'uniform float outlineAlpha;',     'void main() {',     ' #include <clipping_planes_fragment>',    ' #include <logdepthbuf_fragment>',     ' gl_FragColor = vec4( outlineColor, outlineAlpha );',     ' #include <tonemapping_fragment>',    ' #include <colorspace_fragment>',    ' #include <fog_fragment>',    ' #include <premultiplied_alpha_fragment>',     '}'    ].join( '|n' );    function createMaterial() {     return new ShaderMaterial( {     type: 'OutlineEffect',     uniforms: UniformsUtils.merge( [      UniformsLib[ 'fog' ],      UniformsLib[ 'displacementmap' ],      uniformsOutline     ] ),     vertexShader: vertexShader,     fragmentShader: fragmentShader,     side: BackSide    } );    }    function getOutlineMaterialFromCache( originalMaterial ) {     let data = cache[ originalMaterial.uuid ];     if ( data === undefined ) {      data = {      material: createMaterial(),      used: true,      keepAlive: defaultKeepAlive,      count: 0     };      cache[ originalMaterial.uuid ] = data;     }     data.used = true;     return data.material;    }    function getOutlineMaterial( originalMaterial ) {     const outlineMaterial = getOutlineMaterialFromCache( originalMaterial );     originalMaterials[ outlineMaterial.uuid ] = originalMaterial;     updateOutlineMaterial( outlineMaterial, originalMaterial );     return outlineMaterial;    }    function isCompatible( object ) {     const geometry = object.geometry;    const hasNormals = ( geometry !== undefined ) && ( geometry.attributes.normal !== undefined );     return ( object.isMesh === true && object.material !== undefined && hasNormals === true );    }    function setOutlineMaterial( object ) {     if ( isCompatible( object ) === false ) return;     if ( Array.isArray( object.material ) ) {      for ( let i = 0, il = object.material.length; i < il; i ++ ) {       object.material[ i ] = getOutlineMaterial( object.material[ i ] );      }     } else {      object.material = getOutlineMaterial( object.material );     }     originalOnBeforeRenders[ object.uuid ] = object.onBeforeRender;    object.onBeforeRender = onBeforeRender;    }    function restoreOriginalMaterial( object ) {     if ( isCompatible( object ) === false ) return;     if ( Array.isArray( object.material ) ) {      for ( let i = 0, il = object.material.length; i < il; i ++ ) {       object.material[ i ] = originalMaterials[ object.material[ i ].uuid ];      }     } else {      object.material = originalMaterials[ object.material.uuid ];     }     object.onBeforeRender = originalOnBeforeRenders[ object.uuid ];    }    function onBeforeRender( renderer, scene, camera, geometry, material ) {     const originalMaterial = originalMaterials[ material.uuid ];     // just in case    if ( originalMaterial === undefined ) return;     updateUniforms( material, originalMaterial );    }    function updateUniforms( material, originalMaterial ) {     const outlineParameters = originalMaterial.userData.outlineParameters;     material.uniforms.outlineAlpha.value = originalMaterial.opacity;     if ( outlineParameters !== undefined ) {      if ( outlineParameters.thickness !== undefined ) material.uniforms.outlineThickness.value = outlineParameters.thickness;     if ( outlineParameters.color !== undefined ) material.uniforms.outlineColor.value.fromArray( outlineParameters.color );     if ( outlineParameters.alpha !== undefined ) material.uniforms.outlineAlpha.value = outlineParameters.alpha;     }     if ( originalMaterial.displacementMap ) {      material.uniforms.displacementMap.value = originalMaterial.displacementMap;     material.uniforms.displacementScale.value = originalMaterial.displacementScale;     material.uniforms.displacementBias.value = originalMaterial.displacementBias;     }    }    function updateOutlineMaterial( material, originalMaterial ) {     if ( material.name === 'invisible' ) return;     const outlineParameters = originalMaterial.userData.outlineParameters;     material.fog = originalMaterial.fog;    material.toneMapped = originalMaterial.toneMapped;    material.premultipliedAlpha = originalMaterial.premultipliedAlpha;    material.displacementMap = originalMaterial.displacementMap;     if ( outlineParameters !== undefined ) {      if ( originalMaterial.visible === false ) {       material.visible = false;      } else {       material.visible = ( outlineParameters.visible !== undefined ) ? outlineParameters.visible : true;      }      material.transparent = ( outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ) ? true : originalMaterial.transparent;      if ( outlineParameters.keepAlive !== undefined ) cache[ originalMaterial.uuid ].keepAlive = outlineParameters.keepAlive;     } else {      material.transparent = originalMaterial.transparent;     material.visible = originalMaterial.visible;     }     if ( originalMaterial.wireframe === true || originalMaterial.depthTest === false ) material.visible = false;     if ( originalMaterial.clippingPlanes ) {      material.clipping = true;      material.clippingPlanes = originalMaterial.clippingPlanes;     material.clipIntersection = originalMaterial.clipIntersection;     material.clipShadows = originalMaterial.clipShadows;     }     material.version = originalMaterial.version; // update outline material if necessary    }    function cleanupCache() {     let keys;     // clear originialMaterials    keys = Object.keys( originalMaterials );     for ( let i = 0, il = keys.length; i < il; i ++ ) {      originalMaterials[ keys[ i ] ] = undefined;     }     // clear originalOnBeforeRenders    keys = Object.keys( originalOnBeforeRenders );     for ( let i = 0, il = keys.length; i < il; i ++ ) {      originalOnBeforeRenders[ keys[ i ] ] = undefined;     }     // remove unused outlineMaterial from cache    keys = Object.keys( cache );     for ( let i = 0, il = keys.length; i < il; i ++ ) {      const key = keys[ i ];      if ( cache[ key ].used === false ) {       cache[ key ].count ++;       if ( cache[ key ].keepAlive === false && cache[ key ].count > removeThresholdCount ) {        delete cache[ key ];       }      } else {       cache[ key ].used = false;      cache[ key ].count = 0;      }     }    }    this.render = function ( scene, camera ) {     if ( this.enabled === false ) {      renderer.render( scene, camera );     return;     }     const currentAutoClear = renderer.autoClear;    renderer.autoClear = this.autoClear;     renderer.render( scene, camera );     renderer.autoClear = currentAutoClear;     this.renderOutline( scene, camera );    };    this.renderOutline = function ( scene, camera ) {     const currentAutoClear = renderer.autoClear;    const currentSceneAutoUpdate = scene.matrixWorldAutoUpdate;    const currentSceneBackground = scene.background;    const currentShadowMapEnabled = renderer.shadowMap.enabled;     scene.matrixWorldAutoUpdate = false;    scene.background = null;    renderer.autoClear = false;    renderer.shadowMap.enabled = false;     scene.traverse( setOutlineMaterial );     renderer.render( scene, camera );     scene.traverse( restoreOriginalMaterial );     cleanupCache();     scene.matrixWorldAutoUpdate = currentSceneAutoUpdate;    scene.background = currentSceneBackground;    renderer.autoClear = currentAutoClear;    renderer.shadowMap.enabled = currentShadowMapEnabled;    };    /*    * See #9918    *    * The following property copies and wrapper methods enable    * OutlineEffect to be called from other *Effect, like    *    * effect = new StereoEffect( new OutlineEffect( renderer ) );    *    * function render () {    *     *  effect.render( scene, camera );    *    * }    */   this.autoClear = renderer.autoClear;   this.domElement = renderer.domElement;   this.shadowMap = renderer.shadowMap;    this.clear = function ( color, depth, stencil ) {     renderer.clear( color, depth, stencil );    };    this.getPixelRatio = function () {     return renderer.getPixelRatio();    };    this.setPixelRatio = function ( value ) {     renderer.setPixelRatio( value );    };    this.getSize = function ( target ) {     return renderer.getSize( target );    };    this.setSize = function ( width, height, updateStyle ) {     renderer.setSize( width, height, updateStyle );    };    this.setViewport = function ( x, y, width, height ) {     renderer.setViewport( x, y, width, height );    };    this.setScissor = function ( x, y, width, height ) {     renderer.setScissor( x, y, width, height );    };    this.setScissorTest = function ( boolean ) {     renderer.setScissorTest( boolean );    };    this.setRenderTarget = function ( renderTarget ) {     renderer.setRenderTarget( renderTarget );    };   }  }  export { OutlineEffect }; 
^..^ FILENAME ^..^
addons|effects|ParallaxBarrierEffect.js
^..^ CONTENTS ^..^
import {  LinearFilter,  NearestFilter,  RGBAFormat,  ShaderMaterial,  StereoCamera,  WebGLRenderTarget } from 'three'; import { FullScreenQuad } from '../postprocessing/Pass.js';  class ParallaxBarrierEffect {   constructor( renderer ) {    const _stereo = new StereoCamera();    const _params = { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat };    const _renderTargetL = new WebGLRenderTarget( 512, 512, _params );   const _renderTargetR = new WebGLRenderTarget( 512, 512, _params );    const _material = new ShaderMaterial( {     uniforms: {      'mapLeft': { value: _renderTargetL.texture },     'mapRight': { value: _renderTargetR.texture }     },     vertexShader: [      'varying vec2 vUv;',      'void main() {',      ' vUv = vec2( uv.x, uv.y );',     ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',      '}'     ].join( '|n' ),     fragmentShader: [      'uniform sampler2D mapLeft;',     'uniform sampler2D mapRight;',     'varying vec2 vUv;',      'void main() {',      ' vec2 uv = vUv;',      ' if ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {',      '  gl_FragColor = texture2D( mapLeft, uv );',      ' } else {',      '  gl_FragColor = texture2D( mapRight, uv );',      ' }',      ' #include <tonemapping_fragment>',     ' #include <colorspace_fragment>',      '}'     ].join( '|n' )    } );    const _quad = new FullScreenQuad( _material );    this.setSize = function ( width, height ) {     renderer.setSize( width, height );     const pixelRatio = renderer.getPixelRatio();     _renderTargetL.setSize( width * pixelRatio, height * pixelRatio );    _renderTargetR.setSize( width * pixelRatio, height * pixelRatio );    };    this.render = function ( scene, camera ) {     const currentRenderTarget = renderer.getRenderTarget();     if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();     if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();     _stereo.update( camera );     renderer.setRenderTarget( _renderTargetL );    renderer.clear();    renderer.render( scene, _stereo.cameraL );     renderer.setRenderTarget( _renderTargetR );    renderer.clear();    renderer.render( scene, _stereo.cameraR );     renderer.setRenderTarget( null );    _quad.render( renderer );     renderer.setRenderTarget( currentRenderTarget );    };    this.dispose = function () {     _renderTargetL.dispose();    _renderTargetR.dispose();     _material.dispose();    _quad.dispose();    };   }  }  export { ParallaxBarrierEffect }; 
^..^ FILENAME ^..^
addons|effects|PeppersGhostEffect.js
^..^ CONTENTS ^..^
import {  PerspectiveCamera,  Quaternion,  Vector3 } from 'three';  /**  * peppers ghost effect based on http://www.instructables.com/id/Reflective-Prism/?ALLSTEPS  */  class PeppersGhostEffect {   constructor( renderer ) {    const scope = this;    scope.cameraDistance = 15;   scope.reflectFromAbove = false;    // Internals   let _halfWidth, _width, _height;    const _cameraF = new PerspectiveCamera(); //front   const _cameraB = new PerspectiveCamera(); //back   const _cameraL = new PerspectiveCamera(); //left   const _cameraR = new PerspectiveCamera(); //right    const _position = new Vector3();   const _quaternion = new Quaternion();   const _scale = new Vector3();    // Initialization   renderer.autoClear = false;    this.setSize = function ( width, height ) {     _halfWidth = width / 2;    if ( width < height ) {      _width = width / 3;     _height = width / 3;     } else {      _width = height / 3;     _height = height / 3;     }     renderer.setSize( width, height );    };    this.render = function ( scene, camera ) {     if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();     if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();     camera.matrixWorld.decompose( _position, _quaternion, _scale );     // front    _cameraF.position.copy( _position );    _cameraF.quaternion.copy( _quaternion );    _cameraF.translateZ( scope.cameraDistance );    _cameraF.lookAt( scene.position );     // back    _cameraB.position.copy( _position );    _cameraB.quaternion.copy( _quaternion );    _cameraB.translateZ( - ( scope.cameraDistance ) );    _cameraB.lookAt( scene.position );    _cameraB.rotation.z += 180 * ( Math.PI / 180 );     // left    _cameraL.position.copy( _position );    _cameraL.quaternion.copy( _quaternion );    _cameraL.translateX( - ( scope.cameraDistance ) );    _cameraL.lookAt( scene.position );    _cameraL.rotation.x += 90 * ( Math.PI / 180 );     // right    _cameraR.position.copy( _position );    _cameraR.quaternion.copy( _quaternion );    _cameraR.translateX( scope.cameraDistance );    _cameraR.lookAt( scene.position );    _cameraR.rotation.x += 90 * ( Math.PI / 180 );      renderer.clear();    renderer.setScissorTest( true );     renderer.setScissor( _halfWidth - ( _width / 2 ), ( _height * 2 ), _width, _height );    renderer.setViewport( _halfWidth - ( _width / 2 ), ( _height * 2 ), _width, _height );     if ( scope.reflectFromAbove ) {      renderer.render( scene, _cameraB );     } else {      renderer.render( scene, _cameraF );     }     renderer.setScissor( _halfWidth - ( _width / 2 ), 0, _width, _height );    renderer.setViewport( _halfWidth - ( _width / 2 ), 0, _width, _height );     if ( scope.reflectFromAbove ) {      renderer.render( scene, _cameraF );     } else {      renderer.render( scene, _cameraB );     }     renderer.setScissor( _halfWidth - ( _width / 2 ) - _width, _height, _width, _height );    renderer.setViewport( _halfWidth - ( _width / 2 ) - _width, _height, _width, _height );     if ( scope.reflectFromAbove ) {      renderer.render( scene, _cameraR );     } else {      renderer.render( scene, _cameraL );     }     renderer.setScissor( _halfWidth + ( _width / 2 ), _height, _width, _height );    renderer.setViewport( _halfWidth + ( _width / 2 ), _height, _width, _height );     if ( scope.reflectFromAbove ) {      renderer.render( scene, _cameraL );     } else {      renderer.render( scene, _cameraR );     }     renderer.setScissorTest( false );    };   }  }  export { PeppersGhostEffect }; 
^..^ FILENAME ^..^
addons|effects|StereoEffect.js
^..^ CONTENTS ^..^
import {  StereoCamera,  Vector2 } from 'three';  class StereoEffect {   constructor( renderer ) {    const _stereo = new StereoCamera();   _stereo.aspect = 0.5;   const size = new Vector2();    this.setEyeSeparation = function ( eyeSep ) {     _stereo.eyeSep = eyeSep;    };    this.setSize = function ( width, height ) {     renderer.setSize( width, height );    };    this.render = function ( scene, camera ) {     if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();     if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();     _stereo.update( camera );     const currentAutoClear = renderer.autoClear;    renderer.getSize( size );     renderer.autoClear = false;    renderer.clear();     renderer.setScissorTest( true );     renderer.setScissor( 0, 0, size.width / 2, size.height );    renderer.setViewport( 0, 0, size.width / 2, size.height );    renderer.render( scene, _stereo.cameraL );     renderer.setScissor( size.width / 2, 0, size.width / 2, size.height );    renderer.setViewport( size.width / 2, 0, size.width / 2, size.height );    renderer.render( scene, _stereo.cameraR );     renderer.setScissorTest( false );     renderer.autoClear = currentAutoClear;    };   }  }  export { StereoEffect }; 
^..^ FILENAME ^..^
addons|environments|DebugEnvironment.js
^..^ CONTENTS ^..^
import {  BackSide,  BoxGeometry,  Mesh,  MeshLambertMaterial,  MeshStandardMaterial,  PointLight,  Scene, } from 'three';  class DebugEnvironment extends Scene {   constructor() {    super();    const geometry = new BoxGeometry();   geometry.deleteAttribute( 'uv' );   const roomMaterial = new MeshStandardMaterial( { metalness: 0, side: BackSide } );   const room = new Mesh( geometry, roomMaterial );   room.scale.setScalar( 10 );   this.add( room );    const mainLight = new PointLight( 0xffffff, 50, 0, 2 );   this.add( mainLight );    const material1 = new MeshLambertMaterial( { color: 0xff0000, emissive: 0xffffff, emissiveIntensity: 10 } );    const light1 = new Mesh( geometry, material1 );   light1.position.set( - 5, 2, 0 );   light1.scale.set( 0.1, 1, 1 );   this.add( light1 );    const material2 = new MeshLambertMaterial( { color: 0x00ff00, emissive: 0xffffff, emissiveIntensity: 10 } );    const light2 = new Mesh( geometry, material2 );   light2.position.set( 0, 5, 0 );   light2.scale.set( 1, 0.1, 1 );   this.add( light2 );    const material3 = new MeshLambertMaterial( { color: 0x0000ff, emissive: 0xffffff, emissiveIntensity: 10 } );    const light3 = new Mesh( geometry, material3 );   light3.position.set( 2, 1, 5 );   light3.scale.set( 1.5, 2, 0.1 );   this.add( light3 );   }  }  export { DebugEnvironment }; 
^..^ FILENAME ^..^
addons|environments|RoomEnvironment.js
^..^ CONTENTS ^..^
/**  * https://github.com/google/model-viewer/blob/master/packages/model-viewer/src/three-components/EnvironmentScene.ts  */  import {   BackSide,   BoxGeometry,   Mesh,  MeshBasicMaterial,   MeshStandardMaterial,   PointLight,   Scene, } from 'three';  class RoomEnvironment extends Scene {   constructor() {    super();    const geometry = new BoxGeometry();   geometry.deleteAttribute( 'uv' );    const roomMaterial = new MeshStandardMaterial( { side: BackSide } );   const boxMaterial = new MeshStandardMaterial();    const mainLight = new PointLight( 0xffffff, 900, 28, 2 );   mainLight.position.set( 0.418, 16.199, 0.300 );   this.add( mainLight );    const room = new Mesh( geometry, roomMaterial );   room.position.set( - 0.757, 13.219, 0.717 );   room.scale.set( 31.713, 28.305, 28.591 );   this.add( room );    const box1 = new Mesh( geometry, boxMaterial );   box1.position.set( - 10.906, 2.009, 1.846 );   box1.rotation.set( 0, - 0.195, 0 );   box1.scale.set( 2.328, 7.905, 4.651 );   this.add( box1 );    const box2 = new Mesh( geometry, boxMaterial );   box2.position.set( - 5.607, - 0.754, - 0.758 );   box2.rotation.set( 0, 0.994, 0 );   box2.scale.set( 1.970, 1.534, 3.955 );   this.add( box2 );    const box3 = new Mesh( geometry, boxMaterial );   box3.position.set( 6.167, 0.857, 7.803 );   box3.rotation.set( 0, 0.561, 0 );   box3.scale.set( 3.927, 6.285, 3.687 );   this.add( box3 );    const box4 = new Mesh( geometry, boxMaterial );   box4.position.set( - 2.017, 0.018, 6.124 );   box4.rotation.set( 0, 0.333, 0 );   box4.scale.set( 2.002, 4.566, 2.064 );   this.add( box4 );    const box5 = new Mesh( geometry, boxMaterial );   box5.position.set( 2.291, - 0.756, - 2.621 );   box5.rotation.set( 0, - 0.286, 0 );   box5.scale.set( 1.546, 1.552, 1.496 );   this.add( box5 );    const box6 = new Mesh( geometry, boxMaterial );   box6.position.set( - 2.193, - 0.369, - 5.547 );   box6.rotation.set( 0, 0.516, 0 );   box6.scale.set( 3.875, 3.487, 2.986 );   this.add( box6 );     // -x right   const light1 = new Mesh( geometry, createAreaLightMaterial( 50 ) );   light1.position.set( - 16.116, 14.37, 8.208 );   light1.scale.set( 0.1, 2.428, 2.739 );   this.add( light1 );    // -x left   const light2 = new Mesh( geometry, createAreaLightMaterial( 50 ) );   light2.position.set( - 16.109, 18.021, - 8.207 );   light2.scale.set( 0.1, 2.425, 2.751 );   this.add( light2 );    // +x   const light3 = new Mesh( geometry, createAreaLightMaterial( 17 ) );   light3.position.set( 14.904, 12.198, - 1.832 );   light3.scale.set( 0.15, 4.265, 6.331 );   this.add( light3 );    // +z   const light4 = new Mesh( geometry, createAreaLightMaterial( 43 ) );   light4.position.set( - 0.462, 8.89, 14.520 );   light4.scale.set( 4.38, 5.441, 0.088 );   this.add( light4 );    // -z   const light5 = new Mesh( geometry, createAreaLightMaterial( 20 ) );   light5.position.set( 3.235, 11.486, - 12.541 );   light5.scale.set( 2.5, 2.0, 0.1 );   this.add( light5 );    // +y   const light6 = new Mesh( geometry, createAreaLightMaterial( 100 ) );   light6.position.set( 0.0, 20.0, 0.0 );   light6.scale.set( 1.0, 0.1, 1.0 );   this.add( light6 );   }   dispose() {    const resources = new Set();    this.traverse( ( object ) => {     if ( object.isMesh ) {      resources.add( object.geometry );     resources.add( object.material );     }    } );    for ( const resource of resources ) {     resource.dispose();    }   }  }  function createAreaLightMaterial( intensity ) {   const material = new MeshBasicMaterial();  material.color.setScalar( intensity );  return material;  }  export { RoomEnvironment }; 
^..^ FILENAME ^..^
addons|exporters|DRACOExporter.js
^..^ CONTENTS ^..^
import { Color, ColorManagement, SRGBColorSpace } from 'three';  /**  * Export draco compressed files from threejs geometry objects.  *  * Draco files are compressed and usually are smaller than conventional 3D file formats.  *  * The exporter receives a options object containing  *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)  *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)  *  - encoderMethod  *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)  *  - exportUvs  *  - exportNormals  *  - exportColor  */  /* global DracoEncoderModule */  class DRACOExporter {   parse( object, options = {} ) {    options = Object.assign( {    decodeSpeed: 5,    encodeSpeed: 5,    encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,    quantization: [ 16, 8, 8, 8, 8 ],    exportUvs: true,    exportNormals: true,    exportColor: false,   }, options );    if ( DracoEncoderModule === undefined ) {     throw new Error( 'THREE.DRACOExporter: required the draco_encoder to work.' );    }    const geometry = object.geometry;    const dracoEncoder = DracoEncoderModule();   const encoder = new dracoEncoder.Encoder();   let builder;   let dracoObject;    if ( object.isMesh === true ) {     builder = new dracoEncoder.MeshBuilder();    dracoObject = new dracoEncoder.Mesh();     const vertices = geometry.getAttribute( 'position' );    builder.AddFloatAttributeToMesh( dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array );     const faces = geometry.getIndex();     if ( faces !== null ) {      builder.AddFacesToMesh( dracoObject, faces.count / 3, faces.array );     } else {      const faces = new ( vertices.count > 65535 ? Uint32Array : Uint16Array )( vertices.count );      for ( let i = 0; i < faces.length; i ++ ) {       faces[ i ] = i;      }      builder.AddFacesToMesh( dracoObject, vertices.count, faces );     }     if ( options.exportNormals === true ) {      const normals = geometry.getAttribute( 'normal' );      if ( normals !== undefined ) {       builder.AddFloatAttributeToMesh( dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array );      }     }     if ( options.exportUvs === true ) {      const uvs = geometry.getAttribute( 'uv' );      if ( uvs !== undefined ) {       builder.AddFloatAttributeToMesh( dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array );      }     }     if ( options.exportColor === true ) {      const colors = geometry.getAttribute( 'color' );      if ( colors !== undefined ) {       const array = createVertexColorSRGBArray( colors );       builder.AddFloatAttributeToMesh( dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, array );      }     }    } else if ( object.isPoints === true ) {     builder = new dracoEncoder.PointCloudBuilder();    dracoObject = new dracoEncoder.PointCloud();     const vertices = geometry.getAttribute( 'position' );    builder.AddFloatAttribute( dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array );     if ( options.exportColor === true ) {      const colors = geometry.getAttribute( 'color' );      if ( colors !== undefined ) {       const array = createVertexColorSRGBArray( colors );       builder.AddFloatAttribute( dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, array );      }     }    } else {     throw new Error( 'DRACOExporter: Unsupported object type.' );    }    //Compress using draco encoder    const encodedData = new dracoEncoder.DracoInt8Array();    //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).    const encodeSpeed = ( options.encodeSpeed !== undefined ) ? options.encodeSpeed : 5;   const decodeSpeed = ( options.decodeSpeed !== undefined ) ? options.decodeSpeed : 5;    encoder.SetSpeedOptions( encodeSpeed, decodeSpeed );    // Sets the desired encoding method for a given geometry.    if ( options.encoderMethod !== undefined ) {     encoder.SetEncodingMethod( options.encoderMethod );    }    // Sets the quantization (number of bits used to represent) compression options for a named attribute.   // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.   if ( options.quantization !== undefined ) {     for ( let i = 0; i < 5; i ++ ) {      if ( options.quantization[ i ] !== undefined ) {       encoder.SetAttributeQuantization( i, options.quantization[ i ] );      }     }    }    let length;    if ( object.isMesh === true ) {     length = encoder.EncodeMeshToDracoBuffer( dracoObject, encodedData );    } else {     length = encoder.EncodePointCloudToDracoBuffer( dracoObject, true, encodedData );    }    dracoEncoder.destroy( dracoObject );    if ( length === 0 ) {     throw new Error( 'THREE.DRACOExporter: Draco encoding failed.' );    }    //Copy encoded data to buffer.   const outputData = new Int8Array( new ArrayBuffer( length ) );    for ( let i = 0; i < length; i ++ ) {     outputData[ i ] = encodedData.GetValue( i );    }    dracoEncoder.destroy( encodedData );   dracoEncoder.destroy( encoder );   dracoEncoder.destroy( builder );    return outputData;   }  }  function createVertexColorSRGBArray( attribute ) {   // While .drc files do not specify colorspace, the only 'official' tooling  // is PLY and OBJ converters, which use sRGB. We'll assume sRGB is expected  // for .drc files, but note that Draco buffers embedded in glTF files will  // be Linear-sRGB instead.   const _color = new Color();   const count = attribute.count;  const itemSize = attribute.itemSize;  const array = new Float32Array( count * itemSize );   for ( let i = 0, il = count; i < il; i ++ ) {    _color.fromBufferAttribute( attribute, i );    ColorManagement.fromWorkingColorSpace( _color, SRGBColorSpace );    array[ i * itemSize ] = _color.r;   array[ i * itemSize + 1 ] = _color.g;   array[ i * itemSize + 2 ] = _color.b;    if ( itemSize === 4 ) {     array[ i * itemSize + 3 ] = attribute.getW( i );    }   }   return array;  }  // Encoder methods  DRACOExporter.MESH_EDGEBREAKER_ENCODING = 1; DRACOExporter.MESH_SEQUENTIAL_ENCODING = 0;  // Geometry type  DRACOExporter.POINT_CLOUD = 0; DRACOExporter.TRIANGULAR_MESH = 1;  // Attribute type  DRACOExporter.INVALID = - 1; DRACOExporter.POSITION = 0; DRACOExporter.NORMAL = 1; DRACOExporter.COLOR = 2; DRACOExporter.TEX_COORD = 3; DRACOExporter.GENERIC = 4;  export { DRACOExporter }; 
^..^ FILENAME ^..^
addons|exporters|EXRExporter.js
^..^ CONTENTS ^..^
/**  * @author sciecode / https://github.com/sciecode  *  * EXR format references:  *  https://www.openexr.com/documentation/openexrfilelayout.pdf  */  import {  FloatType,  HalfFloatType,  RGBAFormat,  DataUtils, } from 'three'; import * as fflate from '../libs/fflate.module.js';  const textEncoder = new TextEncoder();  const NO_COMPRESSION = 0; const ZIPS_COMPRESSION = 2; const ZIP_COMPRESSION = 3;  class EXRExporter {   async parse( arg1, arg2, arg3 ) {    if ( ! arg1 || ! ( arg1.isWebGLRenderer || arg1.isWebGPURenderer || arg1.isDataTexture ) ) {     throw Error( 'EXRExporter.parse: Unsupported first parameter, expected instance of WebGLRenderer or DataTexture.' );    } else if ( arg1.isWebGLRenderer || arg1.isWebGPURenderer ) {     const renderer = arg1, renderTarget = arg2, options = arg3;     supportedRTT( renderTarget );     const info = buildInfoRTT( renderTarget, options ),     dataBuffer = await getPixelData( renderer, renderTarget, info ),     rawContentBuffer = reorganizeDataBuffer( dataBuffer, info ),     chunks = compressData( rawContentBuffer, info );     return fillData( chunks, info );    } else if ( arg1.isDataTexture ) {     const texture = arg1, options = arg2;     supportedDT( texture );     const info = buildInfoDT( texture, options ),     dataBuffer = texture.image.data,     rawContentBuffer = reorganizeDataBuffer( dataBuffer, info ),     chunks = compressData( rawContentBuffer, info );     return fillData( chunks, info );    }   }  }  function supportedRTT( renderTarget ) {   if ( ! renderTarget || ! renderTarget.isRenderTarget ) {    throw Error( 'EXRExporter.parse: Unsupported second parameter, expected instance of WebGLRenderTarget.' );   }   if ( renderTarget.isWebGLCubeRenderTarget || renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {    throw Error( 'EXRExporter.parse: Unsupported render target type, expected instance of WebGLRenderTarget.' );   }   if ( renderTarget.texture.type !== FloatType && renderTarget.texture.type !== HalfFloatType ) {    throw Error( 'EXRExporter.parse: Unsupported WebGLRenderTarget texture type.' );   }   if ( renderTarget.texture.format !== RGBAFormat ) {    throw Error( 'EXRExporter.parse: Unsupported WebGLRenderTarget texture format, expected RGBAFormat.' );   }  }  function supportedDT( texture ) {   if ( texture.type !== FloatType && texture.type !== HalfFloatType ) {    throw Error( 'EXRExporter.parse: Unsupported DataTexture texture type.' );   }   if ( texture.format !== RGBAFormat ) {    throw Error( 'EXRExporter.parse: Unsupported DataTexture texture format, expected RGBAFormat.' );   }   if ( ! texture.image.data ) {    throw Error( 'EXRExporter.parse: Invalid DataTexture image data.' );   }   if ( texture.type === FloatType && texture.image.data.constructor.name !== 'Float32Array' ) {    throw Error( 'EXRExporter.parse: DataTexture image data doesn|'t match type, expected |'Float32Array|'.' );   }   if ( texture.type === HalfFloatType && texture.image.data.constructor.name !== 'Uint16Array' ) {    throw Error( 'EXRExporter.parse: DataTexture image data doesn|'t match type, expected |'Uint16Array|'.' );   }  }  function buildInfoRTT( renderTarget, options = {} ) {   const compressionSizes = {   0: 1,   2: 1,   3: 16  };   const WIDTH = renderTarget.width,   HEIGHT = renderTarget.height,   TYPE = renderTarget.texture.type,   FORMAT = renderTarget.texture.format,   COMPRESSION = ( options.compression !== undefined ) ? options.compression : ZIP_COMPRESSION,   EXPORTER_TYPE = ( options.type !== undefined ) ? options.type : HalfFloatType,   OUT_TYPE = ( EXPORTER_TYPE === FloatType ) ? 2 : 1,   COMPRESSION_SIZE = compressionSizes[ COMPRESSION ],   NUM_CHANNELS = 4;   return {   width: WIDTH,   height: HEIGHT,   type: TYPE,   format: FORMAT,   compression: COMPRESSION,   blockLines: COMPRESSION_SIZE,   dataType: OUT_TYPE,   dataSize: 2 * OUT_TYPE,   numBlocks: Math.ceil( HEIGHT / COMPRESSION_SIZE ),   numInputChannels: 4,   numOutputChannels: NUM_CHANNELS,  };  }  function buildInfoDT( texture, options = {} ) {   const compressionSizes = {   0: 1,   2: 1,   3: 16  };   const WIDTH = texture.image.width,   HEIGHT = texture.image.height,   TYPE = texture.type,   FORMAT = texture.format,   COMPRESSION = ( options.compression !== undefined ) ? options.compression : ZIP_COMPRESSION,   EXPORTER_TYPE = ( options.type !== undefined ) ? options.type : HalfFloatType,   OUT_TYPE = ( EXPORTER_TYPE === FloatType ) ? 2 : 1,   COMPRESSION_SIZE = compressionSizes[ COMPRESSION ],   NUM_CHANNELS = 4;   return {   width: WIDTH,   height: HEIGHT,   type: TYPE,   format: FORMAT,   compression: COMPRESSION,   blockLines: COMPRESSION_SIZE,   dataType: OUT_TYPE,   dataSize: 2 * OUT_TYPE,   numBlocks: Math.ceil( HEIGHT / COMPRESSION_SIZE ),   numInputChannels: 4,   numOutputChannels: NUM_CHANNELS,  };  }  async function getPixelData( renderer, rtt, info ) {   let dataBuffer;   if ( renderer.isWebGLRenderer ) {    if ( info.type === FloatType ) {     dataBuffer = new Float32Array( info.width * info.height * info.numInputChannels );    } else {     dataBuffer = new Uint16Array( info.width * info.height * info.numInputChannels );    }    await renderer.readRenderTargetPixelsAsync( rtt, 0, 0, info.width, info.height, dataBuffer );   } else {    dataBuffer = await renderer.readRenderTargetPixelsAsync( rtt, 0, 0, info.width, info.height );   }   return dataBuffer;  }  function reorganizeDataBuffer( inBuffer, info ) {   const w = info.width,   h = info.height,   dec = { r: 0, g: 0, b: 0, a: 0 },   offset = { value: 0 },   cOffset = ( info.numOutputChannels == 4 ) ? 1 : 0,   getValue = ( info.type == FloatType ) ? getFloat32 : getFloat16,   setValue = ( info.dataType == 1 ) ? setFloat16 : setFloat32,   outBuffer = new Uint8Array( info.width * info.height * info.numOutputChannels * info.dataSize ),   dv = new DataView( outBuffer.buffer );   for ( let y = 0; y < h; ++ y ) {    for ( let x = 0; x < w; ++ x ) {     const i = y * w * 4 + x * 4;     const r = getValue( inBuffer, i );    const g = getValue( inBuffer, i + 1 );    const b = getValue( inBuffer, i + 2 );    const a = getValue( inBuffer, i + 3 );     const line = ( h - y - 1 ) * w * ( 3 + cOffset ) * info.dataSize;     decodeLinear( dec, r, g, b, a );     offset.value = line + x * info.dataSize;    setValue( dv, dec.a, offset );     offset.value = line + ( cOffset ) * w * info.dataSize + x * info.dataSize;    setValue( dv, dec.b, offset );     offset.value = line + ( 1 + cOffset ) * w * info.dataSize + x * info.dataSize;    setValue( dv, dec.g, offset );     offset.value = line + ( 2 + cOffset ) * w * info.dataSize + x * info.dataSize;    setValue( dv, dec.r, offset );    }   }   return outBuffer;  }  function compressData( inBuffer, info ) {   let compress,   tmpBuffer,   sum = 0;   const chunks = { data: new Array(), totalSize: 0 },   size = info.width * info.numOutputChannels * info.blockLines * info.dataSize;   switch ( info.compression ) {    case 0:    compress = compressNONE;    break;    case 2:   case 3:    compress = compressZIP;    break;   }   if ( info.compression !== 0 ) {    tmpBuffer = new Uint8Array( size );   }   for ( let i = 0; i < info.numBlocks; ++ i ) {    const arr = inBuffer.subarray( size * i, size * ( i + 1 ) );    const block = compress( arr, tmpBuffer );    sum += block.length;    chunks.data.push( { dataChunk: block, size: block.length } );   }   chunks.totalSize = sum;   return chunks;  }  function compressNONE( data ) {   return data;  }  function compressZIP( data, tmpBuffer ) {   //  // Reorder the pixel data.  //   let t1 = 0,   t2 = Math.floor( ( data.length + 1 ) / 2 ),   s = 0;   const stop = data.length - 1;   while ( true ) {    if ( s > stop ) break;   tmpBuffer[ t1 ++ ] = data[ s ++ ];    if ( s > stop ) break;   tmpBuffer[ t2 ++ ] = data[ s ++ ];   }   //  // Predictor.  //   let p = tmpBuffer[ 0 ];   for ( let t = 1; t < tmpBuffer.length; t ++ ) {    const d = tmpBuffer[ t ] - p + ( 128 + 256 );   p = tmpBuffer[ t ];   tmpBuffer[ t ] = d;   }   const deflate = fflate.zlibSync( tmpBuffer );   return deflate;  }  function fillHeader( outBuffer, chunks, info ) {   const offset = { value: 0 };  const dv = new DataView( outBuffer.buffer );   setUint32( dv, 20000630, offset ); // magic  setUint32( dv, 2, offset ); // mask   // = HEADER =   setString( dv, 'compression', offset );  setString( dv, 'compression', offset );  setUint32( dv, 1, offset );  setUint8( dv, info.compression, offset );   setString( dv, 'screenWindowCenter', offset );  setString( dv, 'v2f', offset );  setUint32( dv, 8, offset );  setUint32( dv, 0, offset );  setUint32( dv, 0, offset );   setString( dv, 'screenWindowWidth', offset );  setString( dv, 'float', offset );  setUint32( dv, 4, offset );  setFloat32( dv, 1.0, offset );   setString( dv, 'pixelAspectRatio', offset );  setString( dv, 'float', offset );  setUint32( dv, 4, offset );  setFloat32( dv, 1.0, offset );   setString( dv, 'lineOrder', offset );  setString( dv, 'lineOrder', offset );  setUint32( dv, 1, offset );  setUint8( dv, 0, offset );   setString( dv, 'dataWindow', offset );  setString( dv, 'box2i', offset );  setUint32( dv, 16, offset );  setUint32( dv, 0, offset );  setUint32( dv, 0, offset );  setUint32( dv, info.width - 1, offset );  setUint32( dv, info.height - 1, offset );   setString( dv, 'displayWindow', offset );  setString( dv, 'box2i', offset );  setUint32( dv, 16, offset );  setUint32( dv, 0, offset );  setUint32( dv, 0, offset );  setUint32( dv, info.width - 1, offset );  setUint32( dv, info.height - 1, offset );   setString( dv, 'channels', offset );  setString( dv, 'chlist', offset );  setUint32( dv, info.numOutputChannels * 18 + 1, offset );   setString( dv, 'A', offset );  setUint32( dv, info.dataType, offset );  offset.value += 4;  setUint32( dv, 1, offset );  setUint32( dv, 1, offset );   setString( dv, 'B', offset );  setUint32( dv, info.dataType, offset );  offset.value += 4;  setUint32( dv, 1, offset );  setUint32( dv, 1, offset );   setString( dv, 'G', offset );  setUint32( dv, info.dataType, offset );  offset.value += 4;  setUint32( dv, 1, offset );  setUint32( dv, 1, offset );   setString( dv, 'R', offset );  setUint32( dv, info.dataType, offset );  offset.value += 4;  setUint32( dv, 1, offset );  setUint32( dv, 1, offset );   setUint8( dv, 0, offset );   // null-byte  setUint8( dv, 0, offset );   // = OFFSET TABLE =   let sum = offset.value + info.numBlocks * 8;   for ( let i = 0; i < chunks.data.length; ++ i ) {    setUint64( dv, sum, offset );    sum += chunks.data[ i ].size + 8;   }  }  function fillData( chunks, info ) {   const TableSize = info.numBlocks * 8,   HeaderSize = 259 + ( 18 * info.numOutputChannels ), // 259 + 18 * chlist   offset = { value: HeaderSize + TableSize },   outBuffer = new Uint8Array( HeaderSize + TableSize + chunks.totalSize + info.numBlocks * 8 ),   dv = new DataView( outBuffer.buffer );   fillHeader( outBuffer, chunks, info );   for ( let i = 0; i < chunks.data.length; ++ i ) {    const data = chunks.data[ i ].dataChunk;   const size = chunks.data[ i ].size;    setUint32( dv, i * info.blockLines, offset );   setUint32( dv, size, offset );    outBuffer.set( data, offset.value );   offset.value += size;   }   return outBuffer;  }  function decodeLinear( dec, r, g, b, a ) {   dec.r = r;  dec.g = g;  dec.b = b;  dec.a = a;  }  // function decodeSRGB( dec, r, g, b, a ) {  //  dec.r = r > 0.04045 ? Math.pow( r * 0.9478672986 + 0.0521327014, 2.4 ) : r * 0.0773993808; //  dec.g = g > 0.04045 ? Math.pow( g * 0.9478672986 + 0.0521327014, 2.4 ) : g * 0.0773993808; //  dec.b = b > 0.04045 ? Math.pow( b * 0.9478672986 + 0.0521327014, 2.4 ) : b * 0.0773993808; //  dec.a = a;  // }   function setUint8( dv, value, offset ) {   dv.setUint8( offset.value, value );   offset.value += 1;  }  function setUint32( dv, value, offset ) {   dv.setUint32( offset.value, value, true );   offset.value += 4;  }  function setFloat16( dv, value, offset ) {   dv.setUint16( offset.value, DataUtils.toHalfFloat( value ), true );   offset.value += 2;  }  function setFloat32( dv, value, offset ) {   dv.setFloat32( offset.value, value, true );   offset.value += 4;  }  function setUint64( dv, value, offset ) {   dv.setBigUint64( offset.value, BigInt( value ), true );   offset.value += 8;  }  function setString( dv, string, offset ) {   const tmp = textEncoder.encode( string + '|0' );   for ( let i = 0; i < tmp.length; ++ i ) {    setUint8( dv, tmp[ i ], offset );   }  }  function decodeFloat16( binary ) {   const exponent = ( binary & 0x7C00 ) >> 10,   fraction = binary & 0x03FF;   return ( binary >> 15 ? - 1 : 1 ) * (   exponent ?    (     exponent === 0x1F ?      fraction ? NaN : Infinity :      Math.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )    ) :    6.103515625e-5 * ( fraction / 0x400 )  );  }  function getFloat16( arr, i ) {   return decodeFloat16( arr[ i ] );  }  function getFloat32( arr, i ) {   return arr[ i ];  }  export { EXRExporter, NO_COMPRESSION, ZIP_COMPRESSION, ZIPS_COMPRESSION }; 
^..^ FILENAME ^..^
addons|exporters|GLTFExporter.js
^..^ CONTENTS ^..^
import {  BufferAttribute,  ClampToEdgeWrapping,  Color,  DoubleSide,  InterpolateDiscrete,  InterpolateLinear,  NoColorSpace,  LinearFilter,  LinearMipmapLinearFilter,  LinearMipmapNearestFilter,  MathUtils,  Matrix4,  MirroredRepeatWrapping,  NearestFilter,  NearestMipmapLinearFilter,  NearestMipmapNearestFilter,  PropertyBinding,  RGBAFormat,  RepeatWrapping,  Scene,  Source,  SRGBColorSpace,  CompressedTexture,  Vector3,  Quaternion,  REVISION } from 'three'; import { decompress } from './../utils/TextureUtils.js';   /**  * The KHR_mesh_quantization extension allows these extra attribute component types  *  * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes  */ const KHR_mesh_quantization_ExtraAttrTypes = {  POSITION: [   'byte',   'byte normalized',   'unsigned byte',   'unsigned byte normalized',   'short',   'short normalized',   'unsigned short',   'unsigned short normalized',  ],  NORMAL: [   'byte normalized',   'short normalized',  ],  TANGENT: [   'byte normalized',   'short normalized',  ],  TEXCOORD: [   'byte',   'byte normalized',   'unsigned byte',   'short',   'short normalized',   'unsigned short',  ], };   class GLTFExporter {   constructor() {    this.pluginCallbacks = [];    this.register( function ( writer ) {     return new GLTFLightExtension( writer );    } );    this.register( function ( writer ) {     return new GLTFMaterialsUnlitExtension( writer );    } );    this.register( function ( writer ) {     return new GLTFMaterialsTransmissionExtension( writer );    } );    this.register( function ( writer ) {     return new GLTFMaterialsVolumeExtension( writer );    } );    this.register( function ( writer ) {     return new GLTFMaterialsIorExtension( writer );    } );    this.register( function ( writer ) {     return new GLTFMaterialsSpecularExtension( writer );    } );    this.register( function ( writer ) {     return new GLTFMaterialsClearcoatExtension( writer );    } );    this.register( function ( writer ) {     return new GLTFMaterialsDispersionExtension( writer );    } );    this.register( function ( writer ) {     return new GLTFMaterialsIridescenceExtension( writer );    } );    this.register( function ( writer ) {     return new GLTFMaterialsSheenExtension( writer );    } );    this.register( function ( writer ) {     return new GLTFMaterialsAnisotropyExtension( writer );    } );    this.register( function ( writer ) {     return new GLTFMaterialsEmissiveStrengthExtension( writer );    } );    this.register( function ( writer ) {     return new GLTFMaterialsBumpExtension( writer );    } );    this.register( function ( writer ) {     return new GLTFMeshGpuInstancing( writer );    } );   }   register( callback ) {    if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {     this.pluginCallbacks.push( callback );    }    return this;   }   unregister( callback ) {    if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {     this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );    }    return this;   }   /**   * Parse scenes and generate GLTF output   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes   * @param  {Function} onDone  Callback on completed   * @param  {Function} onError  Callback on errors   * @param  {Object} options options   */  parse( input, onDone, onError, options ) {    const writer = new GLTFWriter();   const plugins = [];    for ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {     plugins.push( this.pluginCallbacks[ i ]( writer ) );    }    writer.setPlugins( plugins );   writer.write( input, onDone, options ).catch( onError );   }   parseAsync( input, options ) {    const scope = this;    return new Promise( function ( resolve, reject ) {     scope.parse( input, resolve, reject, options );    } );   }  }  //------------------------------------------------------------------------------ // Constants //------------------------------------------------------------------------------  const WEBGL_CONSTANTS = {  POINTS: 0x0000,  LINES: 0x0001,  LINE_LOOP: 0x0002,  LINE_STRIP: 0x0003,  TRIANGLES: 0x0004,  TRIANGLE_STRIP: 0x0005,  TRIANGLE_FAN: 0x0006,   BYTE: 0x1400,  UNSIGNED_BYTE: 0x1401,  SHORT: 0x1402,  UNSIGNED_SHORT: 0x1403,  INT: 0x1404,  UNSIGNED_INT: 0x1405,  FLOAT: 0x1406,   ARRAY_BUFFER: 0x8892,  ELEMENT_ARRAY_BUFFER: 0x8893,   NEAREST: 0x2600,  LINEAR: 0x2601,  NEAREST_MIPMAP_NEAREST: 0x2700,  LINEAR_MIPMAP_NEAREST: 0x2701,  NEAREST_MIPMAP_LINEAR: 0x2702,  LINEAR_MIPMAP_LINEAR: 0x2703,   CLAMP_TO_EDGE: 33071,  MIRRORED_REPEAT: 33648,  REPEAT: 10497 };  const KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';  const THREE_TO_WEBGL = {};  THREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST; THREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST; THREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR; THREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR; THREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST; THREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;  THREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE; THREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT; THREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;  const PATH_PROPERTIES = {  scale: 'scale',  position: 'translation',  quaternion: 'rotation',  morphTargetInfluences: 'weights' };  const DEFAULT_SPECULAR_COLOR = new Color();  // GLB constants // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification  const GLB_HEADER_BYTES = 12; const GLB_HEADER_MAGIC = 0x46546C67; const GLB_VERSION = 2;  const GLB_CHUNK_PREFIX_BYTES = 8; const GLB_CHUNK_TYPE_JSON = 0x4E4F534A; const GLB_CHUNK_TYPE_BIN = 0x004E4942;  //------------------------------------------------------------------------------ // Utility functions //------------------------------------------------------------------------------  /**  * Compare two arrays  * @param  {Array} array1 Array 1 to compare  * @param  {Array} array2 Array 2 to compare  * @return {Boolean}        Returns true if both arrays are equal  */ function equalArray( array1, array2 ) {   return ( array1.length === array2.length ) && array1.every( function ( element, index ) {    return element === array2[ index ];   } );  }  /**  * Converts a string to an ArrayBuffer.  * @param  {string} text  * @return {ArrayBuffer}  */ function stringToArrayBuffer( text ) {   return new TextEncoder().encode( text ).buffer;  }  /**  * Is identity matrix  *  * @param {Matrix4} matrix  * @returns {Boolean} Returns true, if parameter is identity matrix  */ function isIdentityMatrix( matrix ) {   return equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );  }  /**  * Get the min and max vectors from the given attribute  * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count  * @param  {Integer} start  * @param  {Integer} count  * @return {Object} Object containing the |min| and |max| values (As an array of attribute.itemSize components)  */ function getMinMax( attribute, start, count ) {   const output = {    min: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),   max: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )   };   for ( let i = start; i < start + count; i ++ ) {    for ( let a = 0; a < attribute.itemSize; a ++ ) {     let value;     if ( attribute.itemSize > 4 ) {       // no support for interleaved data for itemSize > 4      value = attribute.array[ i * attribute.itemSize + a ];     } else {      if ( a === 0 ) value = attribute.getX( i );     else if ( a === 1 ) value = attribute.getY( i );     else if ( a === 2 ) value = attribute.getZ( i );     else if ( a === 3 ) value = attribute.getW( i );      if ( attribute.normalized === true ) {       value = MathUtils.normalize( value, attribute.array );      }     }     output.min[ a ] = Math.min( output.min[ a ], value );    output.max[ a ] = Math.max( output.max[ a ], value );    }   }   return output;  }  /**  * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.  * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment  *  * @param {Integer} bufferSize The size the original buffer.  * @returns {Integer} new buffer size with required padding.  *  */ function getPaddedBufferSize( bufferSize ) {   return Math.ceil( bufferSize / 4 ) * 4;  }  /**  * Returns a buffer aligned to 4-byte boundary.  *  * @param {ArrayBuffer} arrayBuffer Buffer to pad  * @param {Integer} paddingByte (Optional)  * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer  */ function getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {   const paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );   if ( paddedLength !== arrayBuffer.byteLength ) {    const array = new Uint8Array( paddedLength );   array.set( new Uint8Array( arrayBuffer ) );    if ( paddingByte !== 0 ) {     for ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {      array[ i ] = paddingByte;     }    }    return array.buffer;   }   return arrayBuffer;  }  function getCanvas() {   if ( typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined' ) {    return new OffscreenCanvas( 1, 1 );   }   return document.createElement( 'canvas' );  }  function getToBlobPromise( canvas, mimeType ) {   if ( canvas.toBlob !== undefined ) {    return new Promise( ( resolve ) => canvas.toBlob( resolve, mimeType ) );   }   let quality;   // Blink's implementation of convertToBlob seems to default to a quality level of 100%  // Use the Blink default quality levels of toBlob instead so that file sizes are comparable.  if ( mimeType === 'image/jpeg' ) {    quality = 0.92;   } else if ( mimeType === 'image/webp' ) {    quality = 0.8;   }   return canvas.convertToBlob( {    type: mimeType,   quality: quality   } );  }  /**  * Writer  */ class GLTFWriter {   constructor() {    this.plugins = [];    this.options = {};   this.pending = [];   this.buffers = [];    this.byteOffset = 0;   this.buffers = [];   this.nodeMap = new Map();   this.skins = [];    this.extensionsUsed = {};   this.extensionsRequired = {};    this.uids = new Map();   this.uid = 0;    this.json = {    asset: {     version: '2.0',     generator: 'THREE.GLTFExporter r' + REVISION    }   };    this.cache = {    meshes: new Map(),    attributes: new Map(),    attributesNormalized: new Map(),    materials: new Map(),    textures: new Map(),    images: new Map()   };   }   setPlugins( plugins ) {    this.plugins = plugins;   }   /**   * Parse scenes and generate GLTF output   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes   * @param  {Function} onDone  Callback on completed   * @param  {Object} options options   */  async write( input, onDone, options = {} ) {    this.options = Object.assign( {    // default options    binary: false,    trs: false,    onlyVisible: true,    maxTextureSize: Infinity,    animations: [],    includeCustomExtensions: false   }, options );    if ( this.options.animations.length > 0 ) {     // Only TRS properties, and not matrices, may be targeted by animation.    this.options.trs = true;    }    this.processInput( input );    await Promise.all( this.pending );    const writer = this;   const buffers = writer.buffers;   const json = writer.json;   options = writer.options;    const extensionsUsed = writer.extensionsUsed;   const extensionsRequired = writer.extensionsRequired;    // Merge buffers.   const blob = new Blob( buffers, { type: 'application/octet-stream' } );    // Declare extensions.   const extensionsUsedList = Object.keys( extensionsUsed );   const extensionsRequiredList = Object.keys( extensionsRequired );    if ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;   if ( extensionsRequiredList.length > 0 ) json.extensionsRequired = extensionsRequiredList;    // Update bytelength of the single buffer.   if ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;    if ( options.binary === true ) {     // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification     const reader = new FileReader();    reader.readAsArrayBuffer( blob );    reader.onloadend = function () {      // Binary chunk.     const binaryChunk = getPaddedArrayBuffer( reader.result );     const binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );     binaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );     binaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );      // JSON chunk.     const jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );     const jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );     jsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );     jsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );      // GLB header.     const header = new ArrayBuffer( GLB_HEADER_BYTES );     const headerView = new DataView( header );     headerView.setUint32( 0, GLB_HEADER_MAGIC, true );     headerView.setUint32( 4, GLB_VERSION, true );     const totalByteLength = GLB_HEADER_BYTES      + jsonChunkPrefix.byteLength + jsonChunk.byteLength      + binaryChunkPrefix.byteLength + binaryChunk.byteLength;     headerView.setUint32( 8, totalByteLength, true );      const glbBlob = new Blob( [      header,      jsonChunkPrefix,      jsonChunk,      binaryChunkPrefix,      binaryChunk     ], { type: 'application/octet-stream' } );      const glbReader = new FileReader();     glbReader.readAsArrayBuffer( glbBlob );     glbReader.onloadend = function () {       onDone( glbReader.result );      };     };    } else {     if ( json.buffers && json.buffers.length > 0 ) {      const reader = new FileReader();     reader.readAsDataURL( blob );     reader.onloadend = function () {       const base64data = reader.result;      json.buffers[ 0 ].uri = base64data;      onDone( json );      };     } else {      onDone( json );     }    }    }   /**   * Serializes a userData.   *   * @param {THREE.Object3D|THREE.Material} object   * @param {Object} objectDef   */  serializeUserData( object, objectDef ) {    if ( Object.keys( object.userData ).length === 0 ) return;    const options = this.options;   const extensionsUsed = this.extensionsUsed;    try {     const json = JSON.parse( JSON.stringify( object.userData ) );     if ( options.includeCustomExtensions && json.gltfExtensions ) {      if ( objectDef.extensions === undefined ) objectDef.extensions = {};      for ( const extensionName in json.gltfExtensions ) {       objectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];      extensionsUsed[ extensionName ] = true;      }      delete json.gltfExtensions;     }     if ( Object.keys( json ).length > 0 ) objectDef.extras = json;    } catch ( error ) {     console.warn( 'THREE.GLTFExporter: userData of |'' + object.name + '|' ' +     'won|'t be serialized because of JSON.stringify error - ' + error.message );    }   }   /**   * Returns ids for buffer attributes.   * @param  {Object} object   * @return {Integer}   */  getUID( attribute, isRelativeCopy = false ) {    if ( this.uids.has( attribute ) === false ) {     const uids = new Map();     uids.set( true, this.uid ++ );    uids.set( false, this.uid ++ );     this.uids.set( attribute, uids );    }    const uids = this.uids.get( attribute );    return uids.get( isRelativeCopy );   }   /**   * Checks if normal attribute values are normalized.   *   * @param {BufferAttribute} normal   * @returns {Boolean}   */  isNormalizedNormalAttribute( normal ) {    const cache = this.cache;    if ( cache.attributesNormalized.has( normal ) ) return false;    const v = new Vector3();    for ( let i = 0, il = normal.count; i < il; i ++ ) {     // 0.0005 is from glTF-validator    if ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;    }    return true;   }   /**   * Creates normalized normal buffer attribute.   *   * @param {BufferAttribute} normal   * @returns {BufferAttribute}   *   */  createNormalizedNormalAttribute( normal ) {    const cache = this.cache;    if ( cache.attributesNormalized.has( normal ) ) return cache.attributesNormalized.get( normal );    const attribute = normal.clone();   const v = new Vector3();    for ( let i = 0, il = attribute.count; i < il; i ++ ) {     v.fromBufferAttribute( attribute, i );     if ( v.x === 0 && v.y === 0 && v.z === 0 ) {      // if values can't be normalized set (1, 0, 0)     v.setX( 1.0 );     } else {      v.normalize();     }     attribute.setXYZ( i, v.x, v.y, v.z );    }    cache.attributesNormalized.set( normal, attribute );    return attribute;   }   /**   * Applies a texture transform, if present, to the map definition. Requires   * the KHR_texture_transform extension.   *   * @param {Object} mapDef   * @param {THREE.Texture} texture   */  applyTextureTransform( mapDef, texture ) {    let didTransform = false;   const transformDef = {};    if ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {     transformDef.offset = texture.offset.toArray();    didTransform = true;    }    if ( texture.rotation !== 0 ) {     transformDef.rotation = texture.rotation;    didTransform = true;    }    if ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {     transformDef.scale = texture.repeat.toArray();    didTransform = true;    }    if ( didTransform ) {     mapDef.extensions = mapDef.extensions || {};    mapDef.extensions[ 'KHR_texture_transform' ] = transformDef;    this.extensionsUsed[ 'KHR_texture_transform' ] = true;    }   }   buildMetalRoughTexture( metalnessMap, roughnessMap ) {    if ( metalnessMap === roughnessMap ) return metalnessMap;    function getEncodingConversion( map ) {     if ( map.colorSpace === SRGBColorSpace ) {      return function SRGBToLinear( c ) {       return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );      };     }     return function LinearToLinear( c ) {      return c;     };    }    console.warn( 'THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.' );    if ( metalnessMap instanceof CompressedTexture ) {     metalnessMap = decompress( metalnessMap );    }    if ( roughnessMap instanceof CompressedTexture ) {     roughnessMap = decompress( roughnessMap );    }    const metalness = metalnessMap ? metalnessMap.image : null;   const roughness = roughnessMap ? roughnessMap.image : null;    const width = Math.max( metalness ? metalness.width : 0, roughness ? roughness.width : 0 );   const height = Math.max( metalness ? metalness.height : 0, roughness ? roughness.height : 0 );    const canvas = getCanvas();   canvas.width = width;   canvas.height = height;    const context = canvas.getContext( '2d', {    willReadFrequently: true,   } );   context.fillStyle = '#00ffff';   context.fillRect( 0, 0, width, height );    const composite = context.getImageData( 0, 0, width, height );    if ( metalness ) {     context.drawImage( metalness, 0, 0, width, height );     const convert = getEncodingConversion( metalnessMap );    const data = context.getImageData( 0, 0, width, height ).data;     for ( let i = 2; i < data.length; i += 4 ) {      composite.data[ i ] = convert( data[ i ] / 256 ) * 256;     }    }    if ( roughness ) {     context.drawImage( roughness, 0, 0, width, height );     const convert = getEncodingConversion( roughnessMap );    const data = context.getImageData( 0, 0, width, height ).data;     for ( let i = 1; i < data.length; i += 4 ) {      composite.data[ i ] = convert( data[ i ] / 256 ) * 256;     }    }    context.putImageData( composite, 0, 0 );    //    const reference = metalnessMap || roughnessMap;    const texture = reference.clone();    texture.source = new Source( canvas );   texture.colorSpace = NoColorSpace;   texture.channel = ( metalnessMap || roughnessMap ).channel;    if ( metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel ) {     console.warn( 'THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.' );    }    return texture;   }   /**   * Process a buffer to append to the default one.   * @param  {ArrayBuffer} buffer   * @return {Integer}   */  processBuffer( buffer ) {    const json = this.json;   const buffers = this.buffers;    if ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];    // All buffers are merged before export.   buffers.push( buffer );    return 0;   }   /**   * Process and generate a BufferView   * @param  {BufferAttribute} attribute   * @param  {number} componentType   * @param  {number} start   * @param  {number} count   * @param  {number} target (Optional) Target usage of the BufferView   * @return {Object}   */  processBufferView( attribute, componentType, start, count, target ) {    const json = this.json;    if ( ! json.bufferViews ) json.bufferViews = [];    // Create a new dataview and dump the attribute's array into it    let componentSize;    switch ( componentType ) {     case WEBGL_CONSTANTS.BYTE:    case WEBGL_CONSTANTS.UNSIGNED_BYTE:      componentSize = 1;      break;     case WEBGL_CONSTANTS.SHORT:    case WEBGL_CONSTANTS.UNSIGNED_SHORT:      componentSize = 2;      break;     default:      componentSize = 4;    }    let byteStride = attribute.itemSize * componentSize;    if ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {     // Each element of a vertex attribute MUST be aligned to 4-byte boundaries    // inside a bufferView    byteStride = Math.ceil( byteStride / 4 ) * 4;    }    const byteLength = getPaddedBufferSize( count * byteStride );   const dataView = new DataView( new ArrayBuffer( byteLength ) );   let offset = 0;    for ( let i = start; i < start + count; i ++ ) {     for ( let a = 0; a < attribute.itemSize; a ++ ) {      let value;      if ( attribute.itemSize > 4 ) {        // no support for interleaved data for itemSize > 4       value = attribute.array[ i * attribute.itemSize + a ];      } else {       if ( a === 0 ) value = attribute.getX( i );      else if ( a === 1 ) value = attribute.getY( i );      else if ( a === 2 ) value = attribute.getZ( i );      else if ( a === 3 ) value = attribute.getW( i );       if ( attribute.normalized === true ) {        value = MathUtils.normalize( value, attribute.array );       }      }      if ( componentType === WEBGL_CONSTANTS.FLOAT ) {       dataView.setFloat32( offset, value, true );      } else if ( componentType === WEBGL_CONSTANTS.INT ) {       dataView.setInt32( offset, value, true );      } else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {       dataView.setUint32( offset, value, true );      } else if ( componentType === WEBGL_CONSTANTS.SHORT ) {       dataView.setInt16( offset, value, true );      } else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {       dataView.setUint16( offset, value, true );      } else if ( componentType === WEBGL_CONSTANTS.BYTE ) {       dataView.setInt8( offset, value );      } else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {       dataView.setUint8( offset, value );      }      offset += componentSize;     }     if ( ( offset % byteStride ) !== 0 ) {      offset += byteStride - ( offset % byteStride );     }    }    const bufferViewDef = {     buffer: this.processBuffer( dataView.buffer ),    byteOffset: this.byteOffset,    byteLength: byteLength    };    if ( target !== undefined ) bufferViewDef.target = target;    if ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {     // Only define byteStride for vertex attributes.    bufferViewDef.byteStride = byteStride;    }    this.byteOffset += byteLength;    json.bufferViews.push( bufferViewDef );    // @TODO Merge bufferViews where possible.   const output = {     id: json.bufferViews.length - 1,    byteLength: 0    };    return output;   }   /**   * Process and generate a BufferView from an image Blob.   * @param {Blob} blob   * @return {Promise<Integer>}   */  processBufferViewImage( blob ) {    const writer = this;   const json = writer.json;    if ( ! json.bufferViews ) json.bufferViews = [];    return new Promise( function ( resolve ) {     const reader = new FileReader();    reader.readAsArrayBuffer( blob );    reader.onloadend = function () {      const buffer = getPaddedArrayBuffer( reader.result );      const bufferViewDef = {      buffer: writer.processBuffer( buffer ),      byteOffset: writer.byteOffset,      byteLength: buffer.byteLength     };      writer.byteOffset += buffer.byteLength;     resolve( json.bufferViews.push( bufferViewDef ) - 1 );     };    } );   }   /**   * Process attribute to generate an accessor   * @param  {BufferAttribute} attribute Attribute to process   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range   * @param  {Integer} start (Optional)   * @param  {Integer} count (Optional)   * @return {Integer|null} Index of the processed accessor on the "accessors" array   */  processAccessor( attribute, geometry, start, count ) {    const json = this.json;    const types = {     1: 'SCALAR',    2: 'VEC2',    3: 'VEC3',    4: 'VEC4',    9: 'MAT3',    16: 'MAT4'    };    let componentType;    // Detect the component type of the attribute array   if ( attribute.array.constructor === Float32Array ) {     componentType = WEBGL_CONSTANTS.FLOAT;    } else if ( attribute.array.constructor === Int32Array ) {     componentType = WEBGL_CONSTANTS.INT;    } else if ( attribute.array.constructor === Uint32Array ) {     componentType = WEBGL_CONSTANTS.UNSIGNED_INT;    } else if ( attribute.array.constructor === Int16Array ) {     componentType = WEBGL_CONSTANTS.SHORT;    } else if ( attribute.array.constructor === Uint16Array ) {     componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;    } else if ( attribute.array.constructor === Int8Array ) {     componentType = WEBGL_CONSTANTS.BYTE;    } else if ( attribute.array.constructor === Uint8Array ) {     componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;    } else {     throw new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type: ' + attribute.array.constructor.name );    }    if ( start === undefined ) start = 0;   if ( count === undefined || count === Infinity ) count = attribute.count;    // Skip creating an accessor if the attribute doesn't have data to export   if ( count === 0 ) return null;    const minMax = getMinMax( attribute, start, count );   let bufferViewTarget;    // If geometry isn't provided, don't infer the target usage of the bufferView. For   // animation samplers, target must not be set.   if ( geometry !== undefined ) {     bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;    }    const bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );    const accessorDef = {     bufferView: bufferView.id,    byteOffset: bufferView.byteOffset,    componentType: componentType,    count: count,    max: minMax.max,    min: minMax.min,    type: types[ attribute.itemSize ]    };    if ( attribute.normalized === true ) accessorDef.normalized = true;   if ( ! json.accessors ) json.accessors = [];    return json.accessors.push( accessorDef ) - 1;   }   /**   * Process image   * @param  {Image} image to process   * @param  {Integer} format of the image (RGBAFormat)   * @param  {Boolean} flipY before writing out the image   * @param  {String} mimeType export format   * @return {Integer}     Index of the processed texture in the "images" array   */  processImage( image, format, flipY, mimeType = 'image/png' ) {    if ( image !== null ) {     const writer = this;    const cache = writer.cache;    const json = writer.json;    const options = writer.options;    const pending = writer.pending;     if ( ! cache.images.has( image ) ) cache.images.set( image, {} );     const cachedImages = cache.images.get( image );     const key = mimeType + ':flipY/' + flipY.toString();     if ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];     if ( ! json.images ) json.images = [];     const imageDef = { mimeType: mimeType };     const canvas = getCanvas();     canvas.width = Math.min( image.width, options.maxTextureSize );    canvas.height = Math.min( image.height, options.maxTextureSize );     const ctx = canvas.getContext( '2d', {     willReadFrequently: true,    } );     if ( flipY === true ) {      ctx.translate( 0, canvas.height );     ctx.scale( 1, - 1 );     }     if ( image.data !== undefined ) { // THREE.DataTexture      if ( format !== RGBAFormat ) {       console.error( 'GLTFExporter: Only RGBAFormat is supported.', format );      }      if ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {       console.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );      }      const data = new Uint8ClampedArray( image.height * image.width * 4 );      for ( let i = 0; i < data.length; i += 4 ) {       data[ i + 0 ] = image.data[ i + 0 ];      data[ i + 1 ] = image.data[ i + 1 ];      data[ i + 2 ] = image.data[ i + 2 ];      data[ i + 3 ] = image.data[ i + 3 ];      }      ctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );     } else {      if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||      ( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||      ( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||      ( typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas ) ) {       ctx.drawImage( image, 0, 0, canvas.width, canvas.height );      } else {       throw new Error( 'THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.' );      }     }     if ( options.binary === true ) {      pending.push(       getToBlobPromise( canvas, mimeType )       .then( blob => writer.processBufferViewImage( blob ) )       .then( bufferViewIndex => {         imageDef.bufferView = bufferViewIndex;        } )      );     } else {      if ( canvas.toDataURL !== undefined ) {       imageDef.uri = canvas.toDataURL( mimeType );      } else {       pending.push(        getToBlobPromise( canvas, mimeType )        .then( blob => new FileReader().readAsDataURL( blob ) )        .then( dataURL => {          imageDef.uri = dataURL;         } )       );      }     }     const index = json.images.push( imageDef ) - 1;    cachedImages[ key ] = index;    return index;    } else {     throw new Error( 'THREE.GLTFExporter: No valid image data found. Unable to process texture.' );    }   }   /**   * Process sampler   * @param  {Texture} map Texture to process   * @return {Integer}     Index of the processed texture in the "samplers" array   */  processSampler( map ) {    const json = this.json;    if ( ! json.samplers ) json.samplers = [];    const samplerDef = {    magFilter: THREE_TO_WEBGL[ map.magFilter ],    minFilter: THREE_TO_WEBGL[ map.minFilter ],    wrapS: THREE_TO_WEBGL[ map.wrapS ],    wrapT: THREE_TO_WEBGL[ map.wrapT ]   };    return json.samplers.push( samplerDef ) - 1;   }   /**   * Process texture   * @param  {Texture} map Map to process   * @return {Integer} Index of the processed texture in the "textures" array   */  processTexture( map ) {    const writer = this;   const options = writer.options;   const cache = this.cache;   const json = this.json;    if ( cache.textures.has( map ) ) return cache.textures.get( map );    if ( ! json.textures ) json.textures = [];    // make non-readable textures (e.g. CompressedTexture) readable by blitting them into a new texture   if ( map instanceof CompressedTexture ) {     map = decompress( map, options.maxTextureSize );    }    let mimeType = map.userData.mimeType;    if ( mimeType === 'image/webp' ) mimeType = 'image/png';    const textureDef = {    sampler: this.processSampler( map ),    source: this.processImage( map.image, map.format, map.flipY, mimeType )   };    if ( map.name ) textureDef.name = map.name;    this._invokeAll( function ( ext ) {     ext.writeTexture && ext.writeTexture( map, textureDef );    } );    const index = json.textures.push( textureDef ) - 1;   cache.textures.set( map, index );   return index;   }   /**   * Process material   * @param  {THREE.Material} material Material to process   * @return {Integer|null} Index of the processed material in the "materials" array   */  processMaterial( material ) {    const cache = this.cache;   const json = this.json;    if ( cache.materials.has( material ) ) return cache.materials.get( material );    if ( material.isShaderMaterial ) {     console.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );    return null;    }    if ( ! json.materials ) json.materials = [];    // @QUESTION Should we avoid including any attribute that has the default value?   const materialDef = { pbrMetallicRoughness: {} };    if ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {     console.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );    }    // pbrMetallicRoughness.baseColorFactor   const color = material.color.toArray().concat( [ material.opacity ] );    if ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {     materialDef.pbrMetallicRoughness.baseColorFactor = color;    }    if ( material.isMeshStandardMaterial ) {     materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;    materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;    } else {     materialDef.pbrMetallicRoughness.metallicFactor = 0.5;    materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;    }    // pbrMetallicRoughness.metallicRoughnessTexture   if ( material.metalnessMap || material.roughnessMap ) {     const metalRoughTexture = this.buildMetalRoughTexture( material.metalnessMap, material.roughnessMap );     const metalRoughMapDef = {     index: this.processTexture( metalRoughTexture ),     channel: metalRoughTexture.channel    };    this.applyTextureTransform( metalRoughMapDef, metalRoughTexture );    materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;    }    // pbrMetallicRoughness.baseColorTexture   if ( material.map ) {     const baseColorMapDef = {     index: this.processTexture( material.map ),     texCoord: material.map.channel    };    this.applyTextureTransform( baseColorMapDef, material.map );    materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;    }    if ( material.emissive ) {     const emissive = material.emissive;    const maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );     if ( maxEmissiveComponent > 0 ) {      materialDef.emissiveFactor = material.emissive.toArray();     }     // emissiveTexture    if ( material.emissiveMap ) {      const emissiveMapDef = {      index: this.processTexture( material.emissiveMap ),      texCoord: material.emissiveMap.channel     };     this.applyTextureTransform( emissiveMapDef, material.emissiveMap );     materialDef.emissiveTexture = emissiveMapDef;     }    }    // normalTexture   if ( material.normalMap ) {     const normalMapDef = {     index: this.processTexture( material.normalMap ),     texCoord: material.normalMap.channel    };     if ( material.normalScale && material.normalScale.x !== 1 ) {      // glTF normal scale is univariate. Ignore |y|, which may be flipped.     // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995     normalMapDef.scale = material.normalScale.x;     }     this.applyTextureTransform( normalMapDef, material.normalMap );    materialDef.normalTexture = normalMapDef;    }    // occlusionTexture   if ( material.aoMap ) {     const occlusionMapDef = {     index: this.processTexture( material.aoMap ),     texCoord: material.aoMap.channel    };     if ( material.aoMapIntensity !== 1.0 ) {      occlusionMapDef.strength = material.aoMapIntensity;     }     this.applyTextureTransform( occlusionMapDef, material.aoMap );    materialDef.occlusionTexture = occlusionMapDef;    }    // alphaMode   if ( material.transparent ) {     materialDef.alphaMode = 'BLEND';    } else {     if ( material.alphaTest > 0.0 ) {      materialDef.alphaMode = 'MASK';     materialDef.alphaCutoff = material.alphaTest;     }    }    // doubleSided   if ( material.side === DoubleSide ) materialDef.doubleSided = true;   if ( material.name !== '' ) materialDef.name = material.name;    this.serializeUserData( material, materialDef );    this._invokeAll( function ( ext ) {     ext.writeMaterial && ext.writeMaterial( material, materialDef );    } );    const index = json.materials.push( materialDef ) - 1;   cache.materials.set( material, index );   return index;   }   /**   * Process mesh   * @param  {THREE.Mesh} mesh Mesh to process   * @return {Integer|null} Index of the processed mesh in the "meshes" array   */  processMesh( mesh ) {    const cache = this.cache;   const json = this.json;    const meshCacheKeyParts = [ mesh.geometry.uuid ];    if ( Array.isArray( mesh.material ) ) {     for ( let i = 0, l = mesh.material.length; i < l; i ++ ) {      meshCacheKeyParts.push( mesh.material[ i ].uuid );     }    } else {     meshCacheKeyParts.push( mesh.material.uuid );    }    const meshCacheKey = meshCacheKeyParts.join( ':' );    if ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );    const geometry = mesh.geometry;    let mode;    // Use the correct mode   if ( mesh.isLineSegments ) {     mode = WEBGL_CONSTANTS.LINES;    } else if ( mesh.isLineLoop ) {     mode = WEBGL_CONSTANTS.LINE_LOOP;    } else if ( mesh.isLine ) {     mode = WEBGL_CONSTANTS.LINE_STRIP;    } else if ( mesh.isPoints ) {     mode = WEBGL_CONSTANTS.POINTS;    } else {     mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;    }    const meshDef = {};   const attributes = {};   const primitives = [];   const targets = [];    // Conversion between attributes names in threejs and gltf spec   const nameConversion = {    uv: 'TEXCOORD_0',    uv1: 'TEXCOORD_1',    uv2: 'TEXCOORD_2',    uv3: 'TEXCOORD_3',    color: 'COLOR_0',    skinWeight: 'WEIGHTS_0',    skinIndex: 'JOINTS_0'   };    const originalNormal = geometry.getAttribute( 'normal' );    if ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {     console.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );     geometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );    }    // @QUESTION Detect if .vertexColors = true?   // For every attribute create an accessor   let modifiedAttribute = null;    for ( let attributeName in geometry.attributes ) {     // Ignore morph target attributes, which are exported later.    if ( attributeName.slice( 0, 5 ) === 'morph' ) continue;     const attribute = geometry.attributes[ attributeName ];    attributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();     // Prefix all geometry attributes except the ones specifically    // listed in the spec; non-spec attributes are considered custom.    const validVertexAttributes =      /^(POSITION|NORMAL|TANGENT|TEXCOORD_|d+|COLOR_|d+|JOINTS_|d+|WEIGHTS_|d+)$/;     if ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;     if ( cache.attributes.has( this.getUID( attribute ) ) ) {      attributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );     continue;     }     // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.    modifiedAttribute = null;    const array = attribute.array;     if ( attributeName === 'JOINTS_0' &&     ! ( array instanceof Uint16Array ) &&     ! ( array instanceof Uint8Array ) ) {      console.warn( 'GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.' );     modifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );     }     const accessor = this.processAccessor( modifiedAttribute || attribute, geometry );     if ( accessor !== null ) {      if ( ! attributeName.startsWith( '_' ) ) {       this.detectMeshQuantization( attributeName, attribute );      }      attributes[ attributeName ] = accessor;     cache.attributes.set( this.getUID( attribute ), accessor );     }    }    if ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );    // Skip if no exportable attributes found   if ( Object.keys( attributes ).length === 0 ) return null;    // Morph targets   if ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {     const weights = [];    const targetNames = [];    const reverseDictionary = {};     if ( mesh.morphTargetDictionary !== undefined ) {      for ( const key in mesh.morphTargetDictionary ) {       reverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;      }     }     for ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {      const target = {};     let warned = false;      for ( const attributeName in geometry.morphAttributes ) {       // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.      // Three.js doesn't support TANGENT yet.       if ( attributeName !== 'position' && attributeName !== 'normal' ) {        if ( ! warned ) {         console.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );        warned = true;        }        continue;       }       const attribute = geometry.morphAttributes[ attributeName ][ i ];      const gltfAttributeName = attributeName.toUpperCase();       // Three.js morph attribute has absolute values while the one of glTF has relative values.      //      // glTF 2.0 Specification:      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets       const baseAttribute = geometry.attributes[ attributeName ];       if ( cache.attributes.has( this.getUID( attribute, true ) ) ) {        target[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute, true ) );       continue;       }       // Clones attribute not to override      const relativeAttribute = attribute.clone();       if ( ! geometry.morphTargetsRelative ) {        for ( let j = 0, jl = attribute.count; j < jl; j ++ ) {         for ( let a = 0; a < attribute.itemSize; a ++ ) {          if ( a === 0 ) relativeAttribute.setX( j, attribute.getX( j ) - baseAttribute.getX( j ) );         if ( a === 1 ) relativeAttribute.setY( j, attribute.getY( j ) - baseAttribute.getY( j ) );         if ( a === 2 ) relativeAttribute.setZ( j, attribute.getZ( j ) - baseAttribute.getZ( j ) );         if ( a === 3 ) relativeAttribute.setW( j, attribute.getW( j ) - baseAttribute.getW( j ) );         }        }       }       target[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );      cache.attributes.set( this.getUID( baseAttribute, true ), target[ gltfAttributeName ] );      }      targets.push( target );      weights.push( mesh.morphTargetInfluences[ i ] );      if ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );     }     meshDef.weights = weights;     if ( targetNames.length > 0 ) {      meshDef.extras = {};     meshDef.extras.targetNames = targetNames;     }    }    const isMultiMaterial = Array.isArray( mesh.material );    if ( isMultiMaterial && geometry.groups.length === 0 ) return null;    let didForceIndices = false;    if ( isMultiMaterial && geometry.index === null ) {     const indices = [];     for ( let i = 0, il = geometry.attributes.position.count; i < il; i ++ ) {      indices[ i ] = i;     }     geometry.setIndex( indices );     didForceIndices = true;    }    const materials = isMultiMaterial ? mesh.material : [ mesh.material ];   const groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];    for ( let i = 0, il = groups.length; i < il; i ++ ) {     const primitive = {     mode: mode,     attributes: attributes,    };     this.serializeUserData( geometry, primitive );     if ( targets.length > 0 ) primitive.targets = targets;     if ( geometry.index !== null ) {      let cacheKey = this.getUID( geometry.index );      if ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {       cacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;      }      if ( cache.attributes.has( cacheKey ) ) {       primitive.indices = cache.attributes.get( cacheKey );      } else {       primitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );      cache.attributes.set( cacheKey, primitive.indices );      }      if ( primitive.indices === null ) delete primitive.indices;     }     const material = this.processMaterial( materials[ groups[ i ].materialIndex ] );     if ( material !== null ) primitive.material = material;     primitives.push( primitive );    }    if ( didForceIndices === true ) {     geometry.setIndex( null );    }    meshDef.primitives = primitives;    if ( ! json.meshes ) json.meshes = [];    this._invokeAll( function ( ext ) {     ext.writeMesh && ext.writeMesh( mesh, meshDef );    } );    const index = json.meshes.push( meshDef ) - 1;   cache.meshes.set( meshCacheKey, index );   return index;   }   /**   * If a vertex attribute with a   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)   * is used, it is checked whether it is a valid data type according to the   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)   * extension.   * In this case the extension is automatically added to the list of used extensions.   *   * @param {string} attributeName   * @param {THREE.BufferAttribute} attribute   */  detectMeshQuantization( attributeName, attribute ) {    if ( this.extensionsUsed[ KHR_MESH_QUANTIZATION ] ) return;    let attrType = undefined;    switch ( attribute.array.constructor ) {     case Int8Array:      attrType = 'byte';      break;     case Uint8Array:      attrType = 'unsigned byte';      break;     case Int16Array:      attrType = 'short';      break;     case Uint16Array:      attrType = 'unsigned short';      break;     default:      return;    }    if ( attribute.normalized ) attrType += ' normalized';    const attrNamePrefix = attributeName.split( '_', 1 )[ 0 ];    if ( KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ] && KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ].includes( attrType ) ) {     this.extensionsUsed[ KHR_MESH_QUANTIZATION ] = true;    this.extensionsRequired[ KHR_MESH_QUANTIZATION ] = true;    }   }   /**   * Process camera   * @param  {THREE.Camera} camera Camera to process   * @return {Integer}      Index of the processed mesh in the "camera" array   */  processCamera( camera ) {    const json = this.json;    if ( ! json.cameras ) json.cameras = [];    const isOrtho = camera.isOrthographicCamera;    const cameraDef = {    type: isOrtho ? 'orthographic' : 'perspective'   };    if ( isOrtho ) {     cameraDef.orthographic = {     xmag: camera.right * 2,     ymag: camera.top * 2,     zfar: camera.far <= 0 ? 0.001 : camera.far,     znear: camera.near < 0 ? 0 : camera.near    };    } else {     cameraDef.perspective = {     aspectRatio: camera.aspect,     yfov: MathUtils.degToRad( camera.fov ),     zfar: camera.far <= 0 ? 0.001 : camera.far,     znear: camera.near < 0 ? 0 : camera.near    };    }    // Question: Is saving "type" as name intentional?   if ( camera.name !== '' ) cameraDef.name = camera.type;    return json.cameras.push( cameraDef ) - 1;   }   /**   * Creates glTF animation entry from AnimationClip object.   *   * Status:   * - Only properties listed in PATH_PROPERTIES may be animated.   *   * @param {THREE.AnimationClip} clip   * @param {THREE.Object3D} root   * @return {number|null}   */  processAnimation( clip, root ) {    const json = this.json;   const nodeMap = this.nodeMap;    if ( ! json.animations ) json.animations = [];    clip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );    const tracks = clip.tracks;   const channels = [];   const samplers = [];    for ( let i = 0; i < tracks.length; ++ i ) {     const track = tracks[ i ];    const trackBinding = PropertyBinding.parseTrackName( track.name );    let trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );    const trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];     if ( trackBinding.objectName === 'bones' ) {      if ( trackNode.isSkinnedMesh === true ) {       trackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );      } else {       trackNode = undefined;      }     }     if ( ! trackNode || ! trackProperty ) {      console.warn( 'THREE.GLTFExporter: Could not export animation track "%s".', track.name );     continue;     }     const inputItemSize = 1;    let outputItemSize = track.values.length / track.times.length;     if ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {      outputItemSize /= trackNode.morphTargetInfluences.length;     }     let interpolation;     // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE     // Detecting glTF cubic spline interpolant by checking factory method's special property    // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return    // valid value from .getInterpolation().    if ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {      interpolation = 'CUBICSPLINE';      // itemSize of CUBICSPLINE keyframe is 9     // (VEC3 * 3: inTangent, splineVertex, and outTangent)     // but needs to be stored as VEC3 so dividing by 3 here.     outputItemSize /= 3;     } else if ( track.getInterpolation() === InterpolateDiscrete ) {      interpolation = 'STEP';     } else {      interpolation = 'LINEAR';     }     samplers.push( {     input: this.processAccessor( new BufferAttribute( track.times, inputItemSize ) ),     output: this.processAccessor( new BufferAttribute( track.values, outputItemSize ) ),     interpolation: interpolation    } );     channels.push( {     sampler: samplers.length - 1,     target: {      node: nodeMap.get( trackNode ),      path: trackProperty     }    } );    }    json.animations.push( {    name: clip.name || 'clip_' + json.animations.length,    samplers: samplers,    channels: channels   } );    return json.animations.length - 1;   }   /**   * @param {THREE.Object3D} object   * @return {number|null}   */   processSkin( object ) {    const json = this.json;   const nodeMap = this.nodeMap;    const node = json.nodes[ nodeMap.get( object ) ];    const skeleton = object.skeleton;    if ( skeleton === undefined ) return null;    const rootJoint = object.skeleton.bones[ 0 ];    if ( rootJoint === undefined ) return null;    const joints = [];   const inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );   const temporaryBoneInverse = new Matrix4();    for ( let i = 0; i < skeleton.bones.length; ++ i ) {     joints.push( nodeMap.get( skeleton.bones[ i ] ) );    temporaryBoneInverse.copy( skeleton.boneInverses[ i ] );    temporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );    }    if ( json.skins === undefined ) json.skins = [];    json.skins.push( {    inverseBindMatrices: this.processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),    joints: joints,    skeleton: nodeMap.get( rootJoint )   } );    const skinIndex = node.skin = json.skins.length - 1;    return skinIndex;   }   /**   * Process Object3D node   * @param  {THREE.Object3D} node Object3D to processNode   * @return {Integer} Index of the node in the nodes list   */  processNode( object ) {    const json = this.json;   const options = this.options;   const nodeMap = this.nodeMap;    if ( ! json.nodes ) json.nodes = [];    const nodeDef = {};    if ( options.trs ) {     const rotation = object.quaternion.toArray();    const position = object.position.toArray();    const scale = object.scale.toArray();     if ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {      nodeDef.rotation = rotation;     }     if ( ! equalArray( position, [ 0, 0, 0 ] ) ) {      nodeDef.translation = position;     }     if ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {      nodeDef.scale = scale;     }    } else {     if ( object.matrixAutoUpdate ) {      object.updateMatrix();     }     if ( isIdentityMatrix( object.matrix ) === false ) {      nodeDef.matrix = object.matrix.elements;     }    }    // We don't export empty strings name because it represents no-name in Three.js.   if ( object.name !== '' ) nodeDef.name = String( object.name );    this.serializeUserData( object, nodeDef );    if ( object.isMesh || object.isLine || object.isPoints ) {     const meshIndex = this.processMesh( object );     if ( meshIndex !== null ) nodeDef.mesh = meshIndex;    } else if ( object.isCamera ) {     nodeDef.camera = this.processCamera( object );    }    if ( object.isSkinnedMesh ) this.skins.push( object );    if ( object.children.length > 0 ) {     const children = [];     for ( let i = 0, l = object.children.length; i < l; i ++ ) {      const child = object.children[ i ];      if ( child.visible || options.onlyVisible === false ) {       const nodeIndex = this.processNode( child );       if ( nodeIndex !== null ) children.push( nodeIndex );      }     }     if ( children.length > 0 ) nodeDef.children = children;    }    this._invokeAll( function ( ext ) {     ext.writeNode && ext.writeNode( object, nodeDef );    } );    const nodeIndex = json.nodes.push( nodeDef ) - 1;   nodeMap.set( object, nodeIndex );   return nodeIndex;   }   /**   * Process Scene   * @param  {Scene} node Scene to process   */  processScene( scene ) {    const json = this.json;   const options = this.options;    if ( ! json.scenes ) {     json.scenes = [];    json.scene = 0;    }    const sceneDef = {};    if ( scene.name !== '' ) sceneDef.name = scene.name;    json.scenes.push( sceneDef );    const nodes = [];    for ( let i = 0, l = scene.children.length; i < l; i ++ ) {     const child = scene.children[ i ];     if ( child.visible || options.onlyVisible === false ) {      const nodeIndex = this.processNode( child );      if ( nodeIndex !== null ) nodes.push( nodeIndex );     }    }    if ( nodes.length > 0 ) sceneDef.nodes = nodes;    this.serializeUserData( scene, sceneDef );   }   /**   * Creates a Scene to hold a list of objects and parse it   * @param  {Array} objects List of objects to process   */  processObjects( objects ) {    const scene = new Scene();   scene.name = 'AuxScene';    for ( let i = 0; i < objects.length; i ++ ) {     // We push directly to children instead of calling |add| to prevent    // modify the .parent and break its original scene and hierarchy    scene.children.push( objects[ i ] );    }    this.processScene( scene );   }   /**   * @param {THREE.Object3D|Array<THREE.Object3D>} input   */  processInput( input ) {    const options = this.options;    input = input instanceof Array ? input : [ input ];    this._invokeAll( function ( ext ) {     ext.beforeParse && ext.beforeParse( input );    } );    const objectsWithoutScene = [];    for ( let i = 0; i < input.length; i ++ ) {     if ( input[ i ] instanceof Scene ) {      this.processScene( input[ i ] );     } else {      objectsWithoutScene.push( input[ i ] );     }    }    if ( objectsWithoutScene.length > 0 ) this.processObjects( objectsWithoutScene );    for ( let i = 0; i < this.skins.length; ++ i ) {     this.processSkin( this.skins[ i ] );    }    for ( let i = 0; i < options.animations.length; ++ i ) {     this.processAnimation( options.animations[ i ], input[ 0 ] );    }    this._invokeAll( function ( ext ) {     ext.afterParse && ext.afterParse( input );    } );   }   _invokeAll( func ) {    for ( let i = 0, il = this.plugins.length; i < il; i ++ ) {     func( this.plugins[ i ] );    }   }  }  /**  * Punctual Lights Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual  */ class GLTFLightExtension {   constructor( writer ) {    this.writer = writer;   this.name = 'KHR_lights_punctual';   }   writeNode( light, nodeDef ) {    if ( ! light.isLight ) return;    if ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {     console.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );    return;    }    const writer = this.writer;   const json = writer.json;   const extensionsUsed = writer.extensionsUsed;    const lightDef = {};    if ( light.name ) lightDef.name = light.name;    lightDef.color = light.color.toArray();    lightDef.intensity = light.intensity;    if ( light.isDirectionalLight ) {     lightDef.type = 'directional';    } else if ( light.isPointLight ) {     lightDef.type = 'point';     if ( light.distance > 0 ) lightDef.range = light.distance;    } else if ( light.isSpotLight ) {     lightDef.type = 'spot';     if ( light.distance > 0 ) lightDef.range = light.distance;     lightDef.spot = {};    lightDef.spot.innerConeAngle = ( 1.0 - light.penumbra ) * light.angle;    lightDef.spot.outerConeAngle = light.angle;    }    if ( light.decay !== undefined && light.decay !== 2 ) {     console.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '     + 'and expects light.decay=2.' );    }    if ( light.target     && ( light.target.parent !== light     || light.target.position.x !== 0     || light.target.position.y !== 0     || light.target.position.z !== - 1 ) ) {     console.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '     + 'make light.target a child of the light with position 0,0,-1.' );    }    if ( ! extensionsUsed[ this.name ] ) {     json.extensions = json.extensions || {};    json.extensions[ this.name ] = { lights: [] };    extensionsUsed[ this.name ] = true;    }    const lights = json.extensions[ this.name ].lights;   lights.push( lightDef );    nodeDef.extensions = nodeDef.extensions || {};   nodeDef.extensions[ this.name ] = { light: lights.length - 1 };   }  }  /**  * Unlit Materials Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit  */ class GLTFMaterialsUnlitExtension {   constructor( writer ) {    this.writer = writer;   this.name = 'KHR_materials_unlit';   }   writeMaterial( material, materialDef ) {    if ( ! material.isMeshBasicMaterial ) return;    const writer = this.writer;   const extensionsUsed = writer.extensionsUsed;    materialDef.extensions = materialDef.extensions || {};   materialDef.extensions[ this.name ] = {};    extensionsUsed[ this.name ] = true;    materialDef.pbrMetallicRoughness.metallicFactor = 0.0;   materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;   }  }  /**  * Clearcoat Materials Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat  */ class GLTFMaterialsClearcoatExtension {   constructor( writer ) {    this.writer = writer;   this.name = 'KHR_materials_clearcoat';   }   writeMaterial( material, materialDef ) {    if ( ! material.isMeshPhysicalMaterial || material.clearcoat === 0 ) return;    const writer = this.writer;   const extensionsUsed = writer.extensionsUsed;    const extensionDef = {};    extensionDef.clearcoatFactor = material.clearcoat;    if ( material.clearcoatMap ) {     const clearcoatMapDef = {     index: writer.processTexture( material.clearcoatMap ),     texCoord: material.clearcoatMap.channel    };    writer.applyTextureTransform( clearcoatMapDef, material.clearcoatMap );    extensionDef.clearcoatTexture = clearcoatMapDef;    }    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;    if ( material.clearcoatRoughnessMap ) {     const clearcoatRoughnessMapDef = {     index: writer.processTexture( material.clearcoatRoughnessMap ),     texCoord: material.clearcoatRoughnessMap.channel    };    writer.applyTextureTransform( clearcoatRoughnessMapDef, material.clearcoatRoughnessMap );    extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;    }    if ( material.clearcoatNormalMap ) {     const clearcoatNormalMapDef = {     index: writer.processTexture( material.clearcoatNormalMap ),     texCoord: material.clearcoatNormalMap.channel    };     if ( material.clearcoatNormalScale.x !== 1 ) clearcoatNormalMapDef.scale = material.clearcoatNormalScale.x;     writer.applyTextureTransform( clearcoatNormalMapDef, material.clearcoatNormalMap );    extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;    }    materialDef.extensions = materialDef.extensions || {};   materialDef.extensions[ this.name ] = extensionDef;    extensionsUsed[ this.name ] = true;    }  }  /**  * Materials dispersion Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_dispersion  */ class GLTFMaterialsDispersionExtension {   constructor( writer ) {    this.writer = writer;   this.name = 'KHR_materials_dispersion';   }   writeMaterial( material, materialDef ) {    if ( ! material.isMeshPhysicalMaterial || material.dispersion === 0 ) return;    const writer = this.writer;   const extensionsUsed = writer.extensionsUsed;    const extensionDef = {};    extensionDef.dispersion = material.dispersion;    materialDef.extensions = materialDef.extensions || {};   materialDef.extensions[ this.name ] = extensionDef;    extensionsUsed[ this.name ] = true;   }  }  /**  * Iridescence Materials Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence  */ class GLTFMaterialsIridescenceExtension {   constructor( writer ) {    this.writer = writer;   this.name = 'KHR_materials_iridescence';   }   writeMaterial( material, materialDef ) {    if ( ! material.isMeshPhysicalMaterial || material.iridescence === 0 ) return;    const writer = this.writer;   const extensionsUsed = writer.extensionsUsed;    const extensionDef = {};    extensionDef.iridescenceFactor = material.iridescence;    if ( material.iridescenceMap ) {     const iridescenceMapDef = {     index: writer.processTexture( material.iridescenceMap ),     texCoord: material.iridescenceMap.channel    };    writer.applyTextureTransform( iridescenceMapDef, material.iridescenceMap );    extensionDef.iridescenceTexture = iridescenceMapDef;    }    extensionDef.iridescenceIor = material.iridescenceIOR;   extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[ 0 ];   extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[ 1 ];    if ( material.iridescenceThicknessMap ) {     const iridescenceThicknessMapDef = {     index: writer.processTexture( material.iridescenceThicknessMap ),     texCoord: material.iridescenceThicknessMap.channel    };    writer.applyTextureTransform( iridescenceThicknessMapDef, material.iridescenceThicknessMap );    extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;    }    materialDef.extensions = materialDef.extensions || {};   materialDef.extensions[ this.name ] = extensionDef;    extensionsUsed[ this.name ] = true;   }  }  /**  * Transmission Materials Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission  */ class GLTFMaterialsTransmissionExtension {   constructor( writer ) {    this.writer = writer;   this.name = 'KHR_materials_transmission';   }   writeMaterial( material, materialDef ) {    if ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;    const writer = this.writer;   const extensionsUsed = writer.extensionsUsed;    const extensionDef = {};    extensionDef.transmissionFactor = material.transmission;    if ( material.transmissionMap ) {     const transmissionMapDef = {     index: writer.processTexture( material.transmissionMap ),     texCoord: material.transmissionMap.channel    };    writer.applyTextureTransform( transmissionMapDef, material.transmissionMap );    extensionDef.transmissionTexture = transmissionMapDef;    }    materialDef.extensions = materialDef.extensions || {};   materialDef.extensions[ this.name ] = extensionDef;    extensionsUsed[ this.name ] = true;   }  }  /**  * Materials Volume Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume  */ class GLTFMaterialsVolumeExtension {   constructor( writer ) {    this.writer = writer;   this.name = 'KHR_materials_volume';   }   writeMaterial( material, materialDef ) {    if ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;    const writer = this.writer;   const extensionsUsed = writer.extensionsUsed;    const extensionDef = {};    extensionDef.thicknessFactor = material.thickness;    if ( material.thicknessMap ) {     const thicknessMapDef = {     index: writer.processTexture( material.thicknessMap ),     texCoord: material.thicknessMap.channel    };    writer.applyTextureTransform( thicknessMapDef, material.thicknessMap );    extensionDef.thicknessTexture = thicknessMapDef;    }    if ( material.attenuationDistance !== Infinity ) {     extensionDef.attenuationDistance = material.attenuationDistance;    }    extensionDef.attenuationColor = material.attenuationColor.toArray();    materialDef.extensions = materialDef.extensions || {};   materialDef.extensions[ this.name ] = extensionDef;    extensionsUsed[ this.name ] = true;   }  }  /**  * Materials ior Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior  */ class GLTFMaterialsIorExtension {   constructor( writer ) {    this.writer = writer;   this.name = 'KHR_materials_ior';   }   writeMaterial( material, materialDef ) {    if ( ! material.isMeshPhysicalMaterial || material.ior === 1.5 ) return;    const writer = this.writer;   const extensionsUsed = writer.extensionsUsed;    const extensionDef = {};    extensionDef.ior = material.ior;    materialDef.extensions = materialDef.extensions || {};   materialDef.extensions[ this.name ] = extensionDef;    extensionsUsed[ this.name ] = true;   }  }  /**  * Materials specular Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular  */ class GLTFMaterialsSpecularExtension {   constructor( writer ) {    this.writer = writer;   this.name = 'KHR_materials_specular';   }   writeMaterial( material, materialDef ) {    if ( ! material.isMeshPhysicalMaterial || ( material.specularIntensity === 1.0 &&          material.specularColor.equals( DEFAULT_SPECULAR_COLOR ) &&        ! material.specularIntensityMap && ! material.specularColorMap ) ) return;    const writer = this.writer;   const extensionsUsed = writer.extensionsUsed;    const extensionDef = {};    if ( material.specularIntensityMap ) {     const specularIntensityMapDef = {     index: writer.processTexture( material.specularIntensityMap ),     texCoord: material.specularIntensityMap.channel    };    writer.applyTextureTransform( specularIntensityMapDef, material.specularIntensityMap );    extensionDef.specularTexture = specularIntensityMapDef;    }    if ( material.specularColorMap ) {     const specularColorMapDef = {     index: writer.processTexture( material.specularColorMap ),     texCoord: material.specularColorMap.channel    };    writer.applyTextureTransform( specularColorMapDef, material.specularColorMap );    extensionDef.specularColorTexture = specularColorMapDef;    }    extensionDef.specularFactor = material.specularIntensity;   extensionDef.specularColorFactor = material.specularColor.toArray();    materialDef.extensions = materialDef.extensions || {};   materialDef.extensions[ this.name ] = extensionDef;    extensionsUsed[ this.name ] = true;   }  }  /**  * Sheen Materials Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen  */ class GLTFMaterialsSheenExtension {   constructor( writer ) {    this.writer = writer;   this.name = 'KHR_materials_sheen';   }   writeMaterial( material, materialDef ) {    if ( ! material.isMeshPhysicalMaterial || material.sheen == 0.0 ) return;    const writer = this.writer;   const extensionsUsed = writer.extensionsUsed;    const extensionDef = {};    if ( material.sheenRoughnessMap ) {     const sheenRoughnessMapDef = {     index: writer.processTexture( material.sheenRoughnessMap ),     texCoord: material.sheenRoughnessMap.channel    };    writer.applyTextureTransform( sheenRoughnessMapDef, material.sheenRoughnessMap );    extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;    }    if ( material.sheenColorMap ) {     const sheenColorMapDef = {     index: writer.processTexture( material.sheenColorMap ),     texCoord: material.sheenColorMap.channel    };    writer.applyTextureTransform( sheenColorMapDef, material.sheenColorMap );    extensionDef.sheenColorTexture = sheenColorMapDef;    }    extensionDef.sheenRoughnessFactor = material.sheenRoughness;   extensionDef.sheenColorFactor = material.sheenColor.toArray();    materialDef.extensions = materialDef.extensions || {};   materialDef.extensions[ this.name ] = extensionDef;    extensionsUsed[ this.name ] = true;   }  }  /**  * Anisotropy Materials Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy  */ class GLTFMaterialsAnisotropyExtension {   constructor( writer ) {    this.writer = writer;   this.name = 'KHR_materials_anisotropy';   }   writeMaterial( material, materialDef ) {    if ( ! material.isMeshPhysicalMaterial || material.anisotropy == 0.0 ) return;    const writer = this.writer;   const extensionsUsed = writer.extensionsUsed;    const extensionDef = {};    if ( material.anisotropyMap ) {     const anisotropyMapDef = { index: writer.processTexture( material.anisotropyMap ) };    writer.applyTextureTransform( anisotropyMapDef, material.anisotropyMap );    extensionDef.anisotropyTexture = anisotropyMapDef;    }    extensionDef.anisotropyStrength = material.anisotropy;   extensionDef.anisotropyRotation = material.anisotropyRotation;    materialDef.extensions = materialDef.extensions || {};   materialDef.extensions[ this.name ] = extensionDef;    extensionsUsed[ this.name ] = true;   }  }  /**  * Materials Emissive Strength Extension  *  * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md  */ class GLTFMaterialsEmissiveStrengthExtension {   constructor( writer ) {    this.writer = writer;   this.name = 'KHR_materials_emissive_strength';   }   writeMaterial( material, materialDef ) {    if ( ! material.isMeshStandardMaterial || material.emissiveIntensity === 1.0 ) return;    const writer = this.writer;   const extensionsUsed = writer.extensionsUsed;    const extensionDef = {};    extensionDef.emissiveStrength = material.emissiveIntensity;    materialDef.extensions = materialDef.extensions || {};   materialDef.extensions[ this.name ] = extensionDef;    extensionsUsed[ this.name ] = true;   }  }   /**  * Materials bump Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump  */ class GLTFMaterialsBumpExtension {   constructor( writer ) {    this.writer = writer;   this.name = 'EXT_materials_bump';   }   writeMaterial( material, materialDef ) {    if ( ! material.isMeshStandardMaterial || (          material.bumpScale === 1 &&        ! material.bumpMap ) ) return;    const writer = this.writer;   const extensionsUsed = writer.extensionsUsed;    const extensionDef = {};    if ( material.bumpMap ) {     const bumpMapDef = {     index: writer.processTexture( material.bumpMap ),     texCoord: material.bumpMap.channel    };    writer.applyTextureTransform( bumpMapDef, material.bumpMap );    extensionDef.bumpTexture = bumpMapDef;    }    extensionDef.bumpFactor = material.bumpScale;    materialDef.extensions = materialDef.extensions || {};   materialDef.extensions[ this.name ] = extensionDef;    extensionsUsed[ this.name ] = true;   }  }  /**  * GPU Instancing Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing  */ class GLTFMeshGpuInstancing {   constructor( writer ) {    this.writer = writer;   this.name = 'EXT_mesh_gpu_instancing';   }   writeNode( object, nodeDef ) {    if ( ! object.isInstancedMesh ) return;    const writer = this.writer;    const mesh = object;    const translationAttr = new Float32Array( mesh.count * 3 );   const rotationAttr = new Float32Array( mesh.count * 4 );   const scaleAttr = new Float32Array( mesh.count * 3 );    const matrix = new Matrix4();   const position = new Vector3();   const quaternion = new Quaternion();   const scale = new Vector3();    for ( let i = 0; i < mesh.count; i ++ ) {     mesh.getMatrixAt( i, matrix );    matrix.decompose( position, quaternion, scale );     position.toArray( translationAttr, i * 3 );    quaternion.toArray( rotationAttr, i * 4 );    scale.toArray( scaleAttr, i * 3 );    }    const attributes = {    TRANSLATION: writer.processAccessor( new BufferAttribute( translationAttr, 3 ) ),    ROTATION: writer.processAccessor( new BufferAttribute( rotationAttr, 4 ) ),    SCALE: writer.processAccessor( new BufferAttribute( scaleAttr, 3 ) ),   };    if ( mesh.instanceColor )    attributes._COLOR_0 = writer.processAccessor( mesh.instanceColor );    nodeDef.extensions = nodeDef.extensions || {};   nodeDef.extensions[ this.name ] = { attributes };    writer.extensionsUsed[ this.name ] = true;   writer.extensionsRequired[ this.name ] = true;   }  }  /**  * Static utility functions  */ GLTFExporter.Utils = {   insertKeyframe: function ( track, time ) {    const tolerance = 0.001; // 1ms   const valueSize = track.getValueSize();    const times = new track.TimeBufferType( track.times.length + 1 );   const values = new track.ValueBufferType( track.values.length + valueSize );   const interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );    let index;    if ( track.times.length === 0 ) {     times[ 0 ] = time;     for ( let i = 0; i < valueSize; i ++ ) {      values[ i ] = 0;     }     index = 0;    } else if ( time < track.times[ 0 ] ) {     if ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;     times[ 0 ] = time;    times.set( track.times, 1 );     values.set( interpolant.evaluate( time ), 0 );    values.set( track.values, valueSize );     index = 0;    } else if ( time > track.times[ track.times.length - 1 ] ) {     if ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {      return track.times.length - 1;     }     times[ times.length - 1 ] = time;    times.set( track.times, 0 );     values.set( track.values, 0 );    values.set( interpolant.evaluate( time ), track.values.length );     index = times.length - 1;    } else {     for ( let i = 0; i < track.times.length; i ++ ) {      if ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;      if ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {       times.set( track.times.slice( 0, i + 1 ), 0 );      times[ i + 1 ] = time;      times.set( track.times.slice( i + 1 ), i + 2 );       values.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );      values.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );      values.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );       index = i + 1;       break;      }     }    }    track.times = times;   track.values = values;    return index;   },   mergeMorphTargetTracks: function ( clip, root ) {    const tracks = [];   const mergedTracks = {};   const sourceTracks = clip.tracks;    for ( let i = 0; i < sourceTracks.length; ++ i ) {     let sourceTrack = sourceTracks[ i ];    const sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );    const sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );     if ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {      // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.     tracks.push( sourceTrack );     continue;     }     if ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete     && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {      if ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {       // This should never happen, because glTF morph target animations      // affect all targets already.      throw new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );      }      console.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );      sourceTrack = sourceTrack.clone();     sourceTrack.setInterpolation( InterpolateLinear );     }     const targetCount = sourceTrackNode.morphTargetInfluences.length;    const targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];     if ( targetIndex === undefined ) {      throw new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );     }     let mergedTrack;     // If this is the first time we've seen this object, create a new    // track to store merged keyframe data for each morph target.    if ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {      mergedTrack = sourceTrack.clone();      const values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );      for ( let j = 0; j < mergedTrack.times.length; j ++ ) {       values[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];      }      // We need to take into consideration the intended target node     // of our original un-merged morphTarget animation.     mergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';     mergedTrack.values = values;      mergedTracks[ sourceTrackNode.uuid ] = mergedTrack;     tracks.push( mergedTrack );      continue;     }     const sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );     mergedTrack = mergedTracks[ sourceTrackNode.uuid ];     // For every existing keyframe of the merged track, write a (possibly    // interpolated) value from the source track.    for ( let j = 0; j < mergedTrack.times.length; j ++ ) {      mergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );     }     // For every existing keyframe of the source track, write a (possibly    // new) keyframe to the merged track. Values from the previous loop may    // be written again, but keyframes are de-duplicated.    for ( let j = 0; j < sourceTrack.times.length; j ++ ) {      const keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );     mergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];     }    }    clip.tracks = tracks;    return clip;   }  };  export { GLTFExporter }; 
^..^ FILENAME ^..^
addons|exporters|KTX2Exporter.js
^..^ CONTENTS ^..^
import {  FloatType,  HalfFloatType,  UnsignedByteType,  RGBAFormat,  RGFormat,  RGIntegerFormat,  RedFormat,  RedIntegerFormat,  NoColorSpace,  LinearSRGBColorSpace,  SRGBColorSpace,  DataTexture,  REVISION, } from 'three';  import {  write,  KTX2Container,  KHR_DF_CHANNEL_RGBSDA_ALPHA,  KHR_DF_CHANNEL_RGBSDA_BLUE,  KHR_DF_CHANNEL_RGBSDA_GREEN,  KHR_DF_CHANNEL_RGBSDA_RED,  KHR_DF_MODEL_RGBSDA,  KHR_DF_PRIMARIES_BT709,  KHR_DF_PRIMARIES_UNSPECIFIED,  KHR_DF_SAMPLE_DATATYPE_FLOAT,  KHR_DF_SAMPLE_DATATYPE_LINEAR,  KHR_DF_SAMPLE_DATATYPE_SIGNED,  KHR_DF_TRANSFER_LINEAR,  KHR_DF_TRANSFER_SRGB,  VK_FORMAT_R16_SFLOAT,  VK_FORMAT_R16G16_SFLOAT,  VK_FORMAT_R16G16B16A16_SFLOAT,  VK_FORMAT_R32_SFLOAT,  VK_FORMAT_R32G32_SFLOAT,  VK_FORMAT_R32G32B32A32_SFLOAT,  VK_FORMAT_R8_SRGB,  VK_FORMAT_R8_UNORM,  VK_FORMAT_R8G8_SRGB,  VK_FORMAT_R8G8_UNORM,  VK_FORMAT_R8G8B8A8_SRGB,  VK_FORMAT_R8G8B8A8_UNORM, } from '../libs/ktx-parse.module.js';  const VK_FORMAT_MAP = {   [ RGBAFormat ]: {   [ FloatType ]: {    [ NoColorSpace ]: VK_FORMAT_R32G32B32A32_SFLOAT,    [ LinearSRGBColorSpace ]: VK_FORMAT_R32G32B32A32_SFLOAT,   },   [ HalfFloatType ]: {    [ NoColorSpace ]: VK_FORMAT_R16G16B16A16_SFLOAT,    [ LinearSRGBColorSpace ]: VK_FORMAT_R16G16B16A16_SFLOAT,   },   [ UnsignedByteType ]: {    [ NoColorSpace ]: VK_FORMAT_R8G8B8A8_UNORM,    [ LinearSRGBColorSpace ]: VK_FORMAT_R8G8B8A8_UNORM,    [ SRGBColorSpace ]: VK_FORMAT_R8G8B8A8_SRGB,   },  },   [ RGFormat ]: {   [ FloatType ]: {    [ NoColorSpace ]: VK_FORMAT_R32G32_SFLOAT,    [ LinearSRGBColorSpace ]: VK_FORMAT_R32G32_SFLOAT,   },   [ HalfFloatType ]: {    [ NoColorSpace ]: VK_FORMAT_R16G16_SFLOAT,    [ LinearSRGBColorSpace ]: VK_FORMAT_R16G16_SFLOAT,   },   [ UnsignedByteType ]: {    [ NoColorSpace ]: VK_FORMAT_R8G8_UNORM,    [ LinearSRGBColorSpace ]: VK_FORMAT_R8G8_UNORM,    [ SRGBColorSpace ]: VK_FORMAT_R8G8_SRGB,   },  },   [ RedFormat ]: {   [ FloatType ]: {    [ NoColorSpace ]: VK_FORMAT_R32_SFLOAT,    [ LinearSRGBColorSpace ]: VK_FORMAT_R32_SFLOAT,   },   [ HalfFloatType ]: {    [ NoColorSpace ]: VK_FORMAT_R16_SFLOAT,    [ LinearSRGBColorSpace ]: VK_FORMAT_R16_SFLOAT,   },   [ UnsignedByteType ]: {    [ NoColorSpace ]: VK_FORMAT_R8_UNORM,    [ LinearSRGBColorSpace ]: VK_FORMAT_R8_UNORM,    [ SRGBColorSpace ]: VK_FORMAT_R8_SRGB,   },  },  };  const KHR_DF_CHANNEL_MAP = {   0: KHR_DF_CHANNEL_RGBSDA_RED,  1: KHR_DF_CHANNEL_RGBSDA_GREEN,  2: KHR_DF_CHANNEL_RGBSDA_BLUE,  3: KHR_DF_CHANNEL_RGBSDA_ALPHA,  };  const ERROR_INPUT = 'THREE.KTX2Exporter: Supported inputs are DataTexture, Data3DTexture, or WebGLRenderer and WebGLRenderTarget.'; const ERROR_FORMAT = 'THREE.KTX2Exporter: Supported formats are RGBAFormat, RGFormat, or RedFormat.'; const ERROR_TYPE = 'THREE.KTX2Exporter: Supported types are FloatType, HalfFloatType, or UnsignedByteType."'; const ERROR_COLOR_SPACE = 'THREE.KTX2Exporter: Supported color spaces are SRGBColorSpace (UnsignedByteType only), LinearSRGBColorSpace, or NoColorSpace.';  export class KTX2Exporter {   async parse( arg1, arg2 ) {    let texture;    if ( arg1.isDataTexture || arg1.isData3DTexture ) {     texture = arg1;    } else if ( ( arg1.isWebGLRenderer || arg1.isWebGPURenderer ) && arg2.isRenderTarget ) {     texture = await toDataTexture( arg1, arg2 );    } else {     throw new Error( ERROR_INPUT );    }    if ( VK_FORMAT_MAP[ texture.format ] === undefined ) {     throw new Error( ERROR_FORMAT );    }    if ( VK_FORMAT_MAP[ texture.format ][ texture.type ] === undefined ) {     throw new Error( ERROR_TYPE );    }    if ( VK_FORMAT_MAP[ texture.format ][ texture.type ][ texture.colorSpace ] === undefined ) {     throw new Error( ERROR_COLOR_SPACE );    }    //    const array = texture.image.data;   const channelCount = getChannelCount( texture );   const container = new KTX2Container();    container.vkFormat = VK_FORMAT_MAP[ texture.format ][ texture.type ][ texture.colorSpace ];   container.typeSize = array.BYTES_PER_ELEMENT;   container.pixelWidth = texture.image.width;   container.pixelHeight = texture.image.height;    if ( texture.isData3DTexture ) {     container.pixelDepth = texture.image.depth;    }    //    const basicDesc = container.dataFormatDescriptor[ 0 ];    basicDesc.colorModel = KHR_DF_MODEL_RGBSDA;   basicDesc.colorPrimaries = texture.colorSpace === NoColorSpace    ? KHR_DF_PRIMARIES_UNSPECIFIED    : KHR_DF_PRIMARIES_BT709;   basicDesc.transferFunction = texture.colorSpace === SRGBColorSpace    ? KHR_DF_TRANSFER_SRGB    : KHR_DF_TRANSFER_LINEAR;    basicDesc.texelBlockDimension = [ 0, 0, 0, 0 ];    basicDesc.bytesPlane = [     container.typeSize * channelCount, 0, 0, 0, 0, 0, 0, 0,    ];    for ( let i = 0; i < channelCount; ++ i ) {     let channelType = KHR_DF_CHANNEL_MAP[ i ];     if ( texture.colorSpace === LinearSRGBColorSpace || texture.colorSpace === NoColorSpace ) {      channelType |= KHR_DF_SAMPLE_DATATYPE_LINEAR;     }     if ( texture.type === FloatType || texture.type === HalfFloatType ) {      channelType |= KHR_DF_SAMPLE_DATATYPE_FLOAT;     channelType |= KHR_DF_SAMPLE_DATATYPE_SIGNED;     }     basicDesc.samples.push( {      channelType: channelType,     bitOffset: i * array.BYTES_PER_ELEMENT,     bitLength: array.BYTES_PER_ELEMENT * 8 - 1,     samplePosition: [ 0, 0, 0, 0 ],     sampleLower: texture.type === UnsignedByteType ? 0 : - 1,     sampleUpper: texture.type === UnsignedByteType ? 255 : 1,     } );    }    //    container.levels = [ {     levelData: new Uint8Array( array.buffer, array.byteOffset, array.byteLength ),    uncompressedByteLength: array.byteLength,    } ];    //    container.keyValue[ 'KTXwriter' ] = |three.js | REVISION }|;    //    return write( container, { keepWriter: true } );   }  }  async function toDataTexture( renderer, rtt ) {   const channelCount = getChannelCount( rtt.texture );   let view;   if ( renderer.isWebGLRenderer ) {    if ( rtt.texture.type === FloatType ) {     view = new Float32Array( rtt.width * rtt.height * channelCount );    } else if ( rtt.texture.type === HalfFloatType ) {     view = new Uint16Array( rtt.width * rtt.height * channelCount );    } else if ( rtt.texture.type === UnsignedByteType ) {     view = new Uint8Array( rtt.width * rtt.height * channelCount );    } else {     throw new Error( ERROR_TYPE );    }    await renderer.readRenderTargetPixelsAsync( rtt, 0, 0, rtt.width, rtt.height, view );   } else {    view = await renderer.readRenderTargetPixelsAsync( rtt, 0, 0, rtt.width, rtt.height );   }   return new DataTexture( view, rtt.width, rtt.height, rtt.texture.format, rtt.texture.type );  }  function getChannelCount( texture ) {   switch ( texture.format ) {    case RGBAFormat:     return 4;    case RGFormat:   case RGIntegerFormat:     return 2;    case RedFormat:   case RedIntegerFormat:     return 1;    default:     throw new Error( ERROR_FORMAT );   }  } 
^..^ FILENAME ^..^
addons|exporters|MMDExporter.js
^..^ CONTENTS ^..^
import {  Matrix4,  Quaternion,  Vector3 } from 'three'; import { MMDParser } from '../libs/mmdparser.module.js';  /**  * Dependencies  *  - mmd-parser https://github.com/takahirox/mmd-parser  */  class MMDExporter {   /* TODO: implement  // mesh -> pmd  this.parsePmd = function ( object ) {   };  */   /* TODO: implement  // mesh -> pmx  this.parsePmx = function ( object ) {   };  */   /* TODO: implement  // animation + skeleton -> vmd  this.parseVmd = function ( object ) {   };  */   /*   * skeleton -> vpd   * Returns Shift_JIS encoded Uint8Array. Otherwise return strings.   */  parseVpd( skin, outputShiftJis, useOriginalBones ) {    if ( skin.isSkinnedMesh !== true ) {     console.warn( 'THREE.MMDExporter: parseVpd() requires SkinnedMesh instance.' );    return null;    }    function toStringsFromNumber( num ) {     if ( Math.abs( num ) < 1e-6 ) num = 0;     let a = num.toString();     if ( a.indexOf( '.' ) === - 1 ) {      a += '.';     }     a += '000000';     const index = a.indexOf( '.' );     const d = a.slice( 0, index );    const p = a.slice( index + 1, index + 7 );     return d + '.' + p;    }    function toStringsFromArray( array ) {     const a = [];     for ( let i = 0, il = array.length; i < il; i ++ ) {      a.push( toStringsFromNumber( array[ i ] ) );     }     return a.join( ',' );    }    skin.updateMatrixWorld( true );    const bones = skin.skeleton.bones;   const bones2 = getBindBones( skin );    const position = new Vector3();   const quaternion = new Quaternion();   const quaternion2 = new Quaternion();   const matrix = new Matrix4();    const array = [];   array.push( 'Vocaloid Pose Data file' );   array.push( '' );   array.push( ( skin.name !== '' ? skin.name.replace( /|s/g, '_' ) : 'skin' ) + '.osm;' );   array.push( bones.length + ';' );   array.push( '' );    for ( let i = 0, il = bones.length; i < il; i ++ ) {     const bone = bones[ i ];    const bone2 = bones2[ i ];     /*     * use the bone matrix saved before solving IK.     * see CCDIKSolver for the detail.     */    if ( useOriginalBones === true &&     bone.userData.ik !== undefined &&     bone.userData.ik.originalMatrix !== undefined ) {      matrix.fromArray( bone.userData.ik.originalMatrix );     } else {      matrix.copy( bone.matrix );     }     position.setFromMatrixPosition( matrix );    quaternion.setFromRotationMatrix( matrix );     const pArray = position.sub( bone2.position ).toArray();    const qArray = quaternion2.copy( bone2.quaternion ).conjugate().multiply( quaternion ).toArray();     // right to left    pArray[ 2 ] = - pArray[ 2 ];    qArray[ 0 ] = - qArray[ 0 ];    qArray[ 1 ] = - qArray[ 1 ];     array.push( 'Bone' + i + '{' + bone.name );    array.push( '  ' + toStringsFromArray( pArray ) + ';' );    array.push( '  ' + toStringsFromArray( qArray ) + ';' );    array.push( '}' );    array.push( '' );    }    array.push( '' );    const lines = array.join( '|n' );    return ( outputShiftJis === true ) ? unicodeToShiftjis( lines ) : lines;   }  }  // Unicode to Shift_JIS table let u2sTable;  function unicodeToShiftjis( str ) {   if ( u2sTable === undefined ) {    const encoder = new MMDParser.CharsetEncoder();   const table = encoder.s2uTable;   u2sTable = {};    const keys = Object.keys( table );    for ( let i = 0, il = keys.length; i < il; i ++ ) {     let key = keys[ i ];     const value = table[ key ];    key = parseInt( key );     u2sTable[ value ] = key;    }   }   const array = [];   for ( let i = 0, il = str.length; i < il; i ++ ) {    const code = str.charCodeAt( i );    const value = u2sTable[ code ];    if ( value === undefined ) {     throw new Error( 'cannot convert charcode 0x' + code.toString( 16 ) );    } else if ( value > 0xff ) {     array.push( ( value >> 8 ) & 0xff );    array.push( value & 0xff );    } else {     array.push( value & 0xff );    }   }   return new Uint8Array( array );  }  function getBindBones( skin ) {   // any more efficient ways?  const poseSkin = skin.clone();  poseSkin.pose();  return poseSkin.skeleton.bones;  }  export { MMDExporter }; 
^..^ FILENAME ^..^
addons|exporters|OBJExporter.js
^..^ CONTENTS ^..^
import {  Color,  ColorManagement,  Matrix3,  SRGBColorSpace,  Vector2,  Vector3 } from 'three';  class OBJExporter {   parse( object ) {    let output = '';    let indexVertex = 0;   let indexVertexUvs = 0;   let indexNormals = 0;    const vertex = new Vector3();   const color = new Color();   const normal = new Vector3();   const uv = new Vector2();    const face = [];    function parseMesh( mesh ) {     let nbVertex = 0;    let nbNormals = 0;    let nbVertexUvs = 0;     const geometry = mesh.geometry;     const normalMatrixWorld = new Matrix3();     // shortcuts    const vertices = geometry.getAttribute( 'position' );    const normals = geometry.getAttribute( 'normal' );    const uvs = geometry.getAttribute( 'uv' );    const indices = geometry.getIndex();     // name of the mesh object    output += 'o ' + mesh.name + '|n';     // name of the mesh material    if ( mesh.material && mesh.material.name ) {      output += 'usemtl ' + mesh.material.name + '|n';     }     // vertices     if ( vertices !== undefined ) {      for ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {       vertex.fromBufferAttribute( vertices, i );       // transform the vertex to world space      vertex.applyMatrix4( mesh.matrixWorld );       // transform the vertex to export format      output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '|n';      }     }     // uvs     if ( uvs !== undefined ) {      for ( let i = 0, l = uvs.count; i < l; i ++, nbVertexUvs ++ ) {       uv.fromBufferAttribute( uvs, i );       // transform the uv to export format      output += 'vt ' + uv.x + ' ' + uv.y + '|n';      }     }     // normals     if ( normals !== undefined ) {      normalMatrixWorld.getNormalMatrix( mesh.matrixWorld );      for ( let i = 0, l = normals.count; i < l; i ++, nbNormals ++ ) {       normal.fromBufferAttribute( normals, i );       // transform the normal to world space      normal.applyMatrix3( normalMatrixWorld ).normalize();       // transform the normal to export format      output += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '|n';      }     }     // faces     if ( indices !== null ) {      for ( let i = 0, l = indices.count; i < l; i += 3 ) {       for ( let m = 0; m < 3; m ++ ) {        const j = indices.getX( i + m ) + 1;        face[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );       }       // transform the face to export format      output += 'f ' + face.join( ' ' ) + '|n';      }     } else {      for ( let i = 0, l = vertices.count; i < l; i += 3 ) {       for ( let m = 0; m < 3; m ++ ) {        const j = i + m + 1;        face[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );       }       // transform the face to export format      output += 'f ' + face.join( ' ' ) + '|n';      }     }     // update index    indexVertex += nbVertex;    indexVertexUvs += nbVertexUvs;    indexNormals += nbNormals;    }    function parseLine( line ) {     let nbVertex = 0;     const geometry = line.geometry;    const type = line.type;     // shortcuts    const vertices = geometry.getAttribute( 'position' );     // name of the line object    output += 'o ' + line.name + '|n';     if ( vertices !== undefined ) {      for ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {       vertex.fromBufferAttribute( vertices, i );       // transform the vertex to world space      vertex.applyMatrix4( line.matrixWorld );       // transform the vertex to export format      output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '|n';      }     }     if ( type === 'Line' ) {      output += 'l ';      for ( let j = 1, l = vertices.count; j <= l; j ++ ) {       output += ( indexVertex + j ) + ' ';      }      output += '|n';     }     if ( type === 'LineSegments' ) {      for ( let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1 ) {       output += 'l ' + ( indexVertex + j ) + ' ' + ( indexVertex + k ) + '|n';      }     }     // update index    indexVertex += nbVertex;    }    function parsePoints( points ) {     let nbVertex = 0;     const geometry = points.geometry;     const vertices = geometry.getAttribute( 'position' );    const colors = geometry.getAttribute( 'color' );     output += 'o ' + points.name + '|n';     if ( vertices !== undefined ) {      for ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {       vertex.fromBufferAttribute( vertices, i );      vertex.applyMatrix4( points.matrixWorld );       output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z;       if ( colors !== undefined ) {        color.fromBufferAttribute( colors, i );        ColorManagement.fromWorkingColorSpace( color, SRGBColorSpace );        output += ' ' + color.r + ' ' + color.g + ' ' + color.b;       }       output += '|n';      }      output += 'p ';      for ( let j = 1, l = vertices.count; j <= l; j ++ ) {       output += ( indexVertex + j ) + ' ';      }      output += '|n';     }     // update index    indexVertex += nbVertex;    }    object.traverse( function ( child ) {     if ( child.isMesh === true ) {      parseMesh( child );     }     if ( child.isLine === true ) {      parseLine( child );     }     if ( child.isPoints === true ) {      parsePoints( child );     }    } );    return output;   }  }  export { OBJExporter }; 
^..^ FILENAME ^..^
addons|exporters|PLYExporter.js
^..^ CONTENTS ^..^
import {  Matrix3,  Vector3,  Color,  ColorManagement,  SRGBColorSpace } from 'three';  /**  * https://github.com/gkjohnson/ply-exporter-js  *  * Usage:  *  const exporter = new PLYExporter();  *  *  // second argument is a list of options  *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });  *  * Format Definition:  * http://paulbourke.net/dataformats/ply/  */  class PLYExporter {   parse( object, onDone, options = {} ) {    // Iterate over the valid meshes in the object   function traverseMeshes( cb ) {     object.traverse( function ( child ) {      if ( child.isMesh === true || child.isPoints ) {       const mesh = child;      const geometry = mesh.geometry;       if ( geometry.hasAttribute( 'position' ) === true ) {        cb( mesh, geometry );       }      }     } );    }    // Default options   const defaultOptions = {    binary: false,    excludeAttributes: [], // normal, uv, color, index    littleEndian: false   };    options = Object.assign( defaultOptions, options );    const excludeAttributes = options.excludeAttributes;   let includeIndices = true;   let includeNormals = false;   let includeColors = false;   let includeUVs = false;    // count the vertices, check which properties are used,   // and cache the BufferGeometry   let vertexCount = 0;   let faceCount = 0;    object.traverse( function ( child ) {     if ( child.isMesh === true ) {      const mesh = child;     const geometry = mesh.geometry;      const vertices = geometry.getAttribute( 'position' );     const normals = geometry.getAttribute( 'normal' );     const uvs = geometry.getAttribute( 'uv' );     const colors = geometry.getAttribute( 'color' );     const indices = geometry.getIndex();      if ( vertices === undefined ) {       return;      }      vertexCount += vertices.count;     faceCount += indices ? indices.count / 3 : vertices.count / 3;      if ( normals !== undefined ) includeNormals = true;      if ( uvs !== undefined ) includeUVs = true;      if ( colors !== undefined ) includeColors = true;     } else if ( child.isPoints ) {      const mesh = child;     const geometry = mesh.geometry;      const vertices = geometry.getAttribute( 'position' );     const normals = geometry.getAttribute( 'normal' );     const colors = geometry.getAttribute( 'color' );      vertexCount += vertices.count;      if ( normals !== undefined ) includeNormals = true;      if ( colors !== undefined ) includeColors = true;      includeIndices = false;     }    } );    const tempColor = new Color();   includeIndices = includeIndices && excludeAttributes.indexOf( 'index' ) === - 1;   includeNormals = includeNormals && excludeAttributes.indexOf( 'normal' ) === - 1;   includeColors = includeColors && excludeAttributes.indexOf( 'color' ) === - 1;   includeUVs = includeUVs && excludeAttributes.indexOf( 'uv' ) === - 1;     if ( includeIndices && faceCount !== Math.floor( faceCount ) ) {     // point cloud meshes will not have an index array and may not have a    // number of vertices that is divisble by 3 (and therefore representable    // as triangles)    console.error(      'PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' +     'number of indices is not divisible by 3.'     );     return null;    }    const indexByteCount = 4;    let header =    'ply|n' +    |format | options.binary ? ( options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' ) : 'ascii' } 1.0|n| +    |element vertex |vertexCount}|n| +     // position    'property float x|n' +    'property float y|n' +    'property float z|n';    if ( includeNormals === true ) {     // normal    header +=     'property float nx|n' +     'property float ny|n' +     'property float nz|n';    }    if ( includeUVs === true ) {     // uvs    header +=     'property float s|n' +     'property float t|n';    }    if ( includeColors === true ) {     // colors    header +=     'property uchar red|n' +     'property uchar green|n' +     'property uchar blue|n';    }    if ( includeIndices === true ) {     // faces    header +=     |element face |faceCount}|n| +     'property list uchar int vertex_index|n';    }    header += 'end_header|n';     // Generate attribute data   const vertex = new Vector3();   const normalMatrixWorld = new Matrix3();   let result = null;    if ( options.binary === true ) {     // Binary File Generation    const headerBin = new TextEncoder().encode( header );     // 3 position values at 4 bytes    // 3 normal values at 4 bytes    // 3 color channels with 1 byte    // 2 uv values at 4 bytes    const vertexListLength = vertexCount * ( 4 * 3 + ( includeNormals ? 4 * 3 : 0 ) + ( includeColors ? 3 : 0 ) + ( includeUVs ? 4 * 2 : 0 ) );     // 1 byte shape desciptor    // 3 vertex indices at |indexByteCount} bytes    const faceListLength = includeIndices ? faceCount * ( indexByteCount * 3 + 1 ) : 0;    const output = new DataView( new ArrayBuffer( headerBin.length + vertexListLength + faceListLength ) );    new Uint8Array( output.buffer ).set( headerBin, 0 );      let vOffset = headerBin.length;    let fOffset = headerBin.length + vertexListLength;    let writtenVertices = 0;    traverseMeshes( function ( mesh, geometry ) {      const vertices = geometry.getAttribute( 'position' );     const normals = geometry.getAttribute( 'normal' );     const uvs = geometry.getAttribute( 'uv' );     const colors = geometry.getAttribute( 'color' );     const indices = geometry.getIndex();      normalMatrixWorld.getNormalMatrix( mesh.matrixWorld );      for ( let i = 0, l = vertices.count; i < l; i ++ ) {       vertex.fromBufferAttribute( vertices, i );       vertex.applyMatrix4( mesh.matrixWorld );        // Position information      output.setFloat32( vOffset, vertex.x, options.littleEndian );      vOffset += 4;       output.setFloat32( vOffset, vertex.y, options.littleEndian );      vOffset += 4;       output.setFloat32( vOffset, vertex.z, options.littleEndian );      vOffset += 4;       // Normal information      if ( includeNormals === true ) {        if ( normals != null ) {         vertex.fromBufferAttribute( normals, i );         vertex.applyMatrix3( normalMatrixWorld ).normalize();         output.setFloat32( vOffset, vertex.x, options.littleEndian );        vOffset += 4;         output.setFloat32( vOffset, vertex.y, options.littleEndian );        vOffset += 4;         output.setFloat32( vOffset, vertex.z, options.littleEndian );        vOffset += 4;        } else {         output.setFloat32( vOffset, 0, options.littleEndian );        vOffset += 4;         output.setFloat32( vOffset, 0, options.littleEndian );        vOffset += 4;         output.setFloat32( vOffset, 0, options.littleEndian );        vOffset += 4;        }       }       // UV information      if ( includeUVs === true ) {        if ( uvs != null ) {         output.setFloat32( vOffset, uvs.getX( i ), options.littleEndian );        vOffset += 4;         output.setFloat32( vOffset, uvs.getY( i ), options.littleEndian );        vOffset += 4;        } else {         output.setFloat32( vOffset, 0, options.littleEndian );        vOffset += 4;         output.setFloat32( vOffset, 0, options.littleEndian );        vOffset += 4;        }       }       // Color information      if ( includeColors === true ) {        if ( colors != null ) {         tempColor.fromBufferAttribute( colors, i );         ColorManagement.fromWorkingColorSpace( tempColor, SRGBColorSpace );         output.setUint8( vOffset, Math.floor( tempColor.r * 255 ) );        vOffset += 1;         output.setUint8( vOffset, Math.floor( tempColor.g * 255 ) );        vOffset += 1;         output.setUint8( vOffset, Math.floor( tempColor.b * 255 ) );        vOffset += 1;        } else {         output.setUint8( vOffset, 255 );        vOffset += 1;         output.setUint8( vOffset, 255 );        vOffset += 1;         output.setUint8( vOffset, 255 );        vOffset += 1;        }       }      }      if ( includeIndices === true ) {       // Create the face list       if ( indices !== null ) {        for ( let i = 0, l = indices.count; i < l; i += 3 ) {         output.setUint8( fOffset, 3 );        fOffset += 1;         output.setUint32( fOffset, indices.getX( i + 0 ) + writtenVertices, options.littleEndian );        fOffset += indexByteCount;         output.setUint32( fOffset, indices.getX( i + 1 ) + writtenVertices, options.littleEndian );        fOffset += indexByteCount;         output.setUint32( fOffset, indices.getX( i + 2 ) + writtenVertices, options.littleEndian );        fOffset += indexByteCount;        }       } else {        for ( let i = 0, l = vertices.count; i < l; i += 3 ) {         output.setUint8( fOffset, 3 );        fOffset += 1;         output.setUint32( fOffset, writtenVertices + i, options.littleEndian );        fOffset += indexByteCount;         output.setUint32( fOffset, writtenVertices + i + 1, options.littleEndian );        fOffset += indexByteCount;         output.setUint32( fOffset, writtenVertices + i + 2, options.littleEndian );        fOffset += indexByteCount;        }       }      }       // Save the amount of verts we've already written so we can offset     // the face index on the next mesh     writtenVertices += vertices.count;     } );     result = output.buffer;    } else {     // Ascii File Generation    // count the number of vertices    let writtenVertices = 0;    let vertexList = '';    let faceList = '';     traverseMeshes( function ( mesh, geometry ) {      const vertices = geometry.getAttribute( 'position' );     const normals = geometry.getAttribute( 'normal' );     const uvs = geometry.getAttribute( 'uv' );     const colors = geometry.getAttribute( 'color' );     const indices = geometry.getIndex();      normalMatrixWorld.getNormalMatrix( mesh.matrixWorld );      // form each line     for ( let i = 0, l = vertices.count; i < l; i ++ ) {       vertex.fromBufferAttribute( vertices, i );       vertex.applyMatrix4( mesh.matrixWorld );        // Position information      let line =       vertex.x + ' ' +       vertex.y + ' ' +       vertex.z;       // Normal information      if ( includeNormals === true ) {        if ( normals != null ) {         vertex.fromBufferAttribute( normals, i );         vertex.applyMatrix3( normalMatrixWorld ).normalize();         line += ' ' +         vertex.x + ' ' +         vertex.y + ' ' +         vertex.z;        } else {         line += ' 0 0 0';        }       }       // UV information      if ( includeUVs === true ) {        if ( uvs != null ) {         line += ' ' +         uvs.getX( i ) + ' ' +         uvs.getY( i );        } else {         line += ' 0 0';        }       }       // Color information      if ( includeColors === true ) {        if ( colors != null ) {         tempColor.fromBufferAttribute( colors, i );         ColorManagement.fromWorkingColorSpace( tempColor, SRGBColorSpace );         line += ' ' +         Math.floor( tempColor.r * 255 ) + ' ' +         Math.floor( tempColor.g * 255 ) + ' ' +         Math.floor( tempColor.b * 255 );        } else {         line += ' 255 255 255';        }       }       vertexList += line + '|n';      }      // Create the face list     if ( includeIndices === true ) {       if ( indices !== null ) {        for ( let i = 0, l = indices.count; i < l; i += 3 ) {         faceList += |3 | indices.getX( i + 0 ) + writtenVertices }|;        faceList += | | indices.getX( i + 1 ) + writtenVertices }|;        faceList += | | indices.getX( i + 2 ) + writtenVertices }|n|;        }       } else {        for ( let i = 0, l = vertices.count; i < l; i += 3 ) {         faceList += |3 | writtenVertices + i } | writtenVertices + i + 1 } | writtenVertices + i + 2 }|n|;        }       }       faceCount += indices ? indices.count / 3 : vertices.count / 3;      }      writtenVertices += vertices.count;     } );     result = || header }|vertexList}| includeIndices ? ||faceList}|n| : '|n' }|;    }    if ( typeof onDone === 'function' ) requestAnimationFrame( () => onDone( result ) );    return result;   }  }  export { PLYExporter }; 
^..^ FILENAME ^..^
addons|exporters|STLExporter.js
^..^ CONTENTS ^..^
import { Vector3 } from 'three';  /**  * Usage:  *  const exporter = new STLExporter();  *  *  // second argument is a list of options  *  const data = exporter.parse( mesh, { binary: true } );  *  */  class STLExporter {   parse( scene, options = {} ) {    options = Object.assign( {    binary: false   }, options );    const binary = options.binary;    //    const objects = [];   let triangles = 0;    scene.traverse( function ( object ) {     if ( object.isMesh ) {      const geometry = object.geometry;      const index = geometry.index;     const positionAttribute = geometry.getAttribute( 'position' );      triangles += ( index !== null ) ? ( index.count / 3 ) : ( positionAttribute.count / 3 );      objects.push( {      object3d: object,      geometry: geometry     } );     }    } );    let output;   let offset = 80; // skip header    if ( binary === true ) {     const bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;    const arrayBuffer = new ArrayBuffer( bufferLength );    output = new DataView( arrayBuffer );    output.setUint32( offset, triangles, true ); offset += 4;    } else {     output = '';    output += 'solid exported|n';    }    const vA = new Vector3();   const vB = new Vector3();   const vC = new Vector3();   const cb = new Vector3();   const ab = new Vector3();   const normal = new Vector3();    for ( let i = 0, il = objects.length; i < il; i ++ ) {     const object = objects[ i ].object3d;    const geometry = objects[ i ].geometry;     const index = geometry.index;    const positionAttribute = geometry.getAttribute( 'position' );     if ( index !== null ) {      // indexed geometry      for ( let j = 0; j < index.count; j += 3 ) {       const a = index.getX( j + 0 );      const b = index.getX( j + 1 );      const c = index.getX( j + 2 );       writeFace( a, b, c, positionAttribute, object );      }     } else {      // non-indexed geometry      for ( let j = 0; j < positionAttribute.count; j += 3 ) {       const a = j + 0;      const b = j + 1;      const c = j + 2;       writeFace( a, b, c, positionAttribute, object );      }     }    }    if ( binary === false ) {     output += 'endsolid exported|n';    }    return output;    function writeFace( a, b, c, positionAttribute, object ) {     vA.fromBufferAttribute( positionAttribute, a );    vB.fromBufferAttribute( positionAttribute, b );    vC.fromBufferAttribute( positionAttribute, c );     if ( object.isSkinnedMesh === true ) {      object.applyBoneTransform( a, vA );     object.applyBoneTransform( b, vB );     object.applyBoneTransform( c, vC );     }     vA.applyMatrix4( object.matrixWorld );    vB.applyMatrix4( object.matrixWorld );    vC.applyMatrix4( object.matrixWorld );     writeNormal( vA, vB, vC );     writeVertex( vA );    writeVertex( vB );    writeVertex( vC );     if ( binary === true ) {      output.setUint16( offset, 0, true ); offset += 2;     } else {      output += '|t|tendloop|n';     output += '|tendfacet|n';     }    }    function writeNormal( vA, vB, vC ) {     cb.subVectors( vC, vB );    ab.subVectors( vA, vB );    cb.cross( ab ).normalize();     normal.copy( cb ).normalize();     if ( binary === true ) {      output.setFloat32( offset, normal.x, true ); offset += 4;     output.setFloat32( offset, normal.y, true ); offset += 4;     output.setFloat32( offset, normal.z, true ); offset += 4;     } else {      output += '|tfacet normal ' + normal.x + ' ' + normal.y + ' ' + normal.z + '|n';     output += '|t|touter loop|n';     }    }    function writeVertex( vertex ) {     if ( binary === true ) {      output.setFloat32( offset, vertex.x, true ); offset += 4;     output.setFloat32( offset, vertex.y, true ); offset += 4;     output.setFloat32( offset, vertex.z, true ); offset += 4;     } else {      output += '|t|t|tvertex ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '|n';     }    }   }  }  export { STLExporter }; 
^..^ FILENAME ^..^
addons|exporters|USDZExporter.js
^..^ CONTENTS ^..^
import {  NoColorSpace,  DoubleSide,  Color, } from 'three';  import {  strToU8,  zipSync, } from '../libs/fflate.module.js';  import { decompress } from './../utils/TextureUtils.js';  class USDZExporter {   parse( scene, onDone, onError, options ) {    this.parseAsync( scene, options ).then( onDone ).catch( onError );   }   async parseAsync( scene, options = {} ) {    options = Object.assign( {    ar: {     anchoring: { type: 'plane' },     planeAnchoring: { alignment: 'horizontal' }    },    includeAnchoringProperties: true,    quickLookCompatible: false,    maxTextureSize: 1024,   }, options );    const files = {};   const modelFileName = 'model.usda';    // model file should be first in USDZ archive so we init it here   files[ modelFileName ] = null;    let output = buildHeader();    output += buildSceneStart( options );    const materials = {};   const textures = {};    scene.traverseVisible( ( object ) => {     if ( object.isMesh ) {      const geometry = object.geometry;     const material = object.material;      if ( material.isMeshStandardMaterial ) {       const geometryFileName = 'geometries/Geometry_' + geometry.id + '.usda';       if ( ! ( geometryFileName in files ) ) {        const meshObject = buildMeshObject( geometry );       files[ geometryFileName ] = buildUSDFileAsString( meshObject );       }       if ( ! ( material.uuid in materials ) ) {        materials[ material.uuid ] = material;       }       output += buildXform( object, geometry, material );      } else {       console.warn( 'THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)', object );      }     } else if ( object.isCamera ) {      output += buildCamera( object );     }    } );     output += buildSceneEnd();    output += buildMaterials( materials, textures, options.quickLookCompatible );    files[ modelFileName ] = strToU8( output );   output = null;    for ( const id in textures ) {     let texture = textures[ id ];     if ( texture.isCompressedTexture === true ) {      texture = decompress( texture );     }     const canvas = imageToCanvas( texture.image, texture.flipY, options.maxTextureSize );    const blob = await new Promise( resolve => canvas.toBlob( resolve, 'image/png', 1 ) );     files[ |textures/Texture_| id }.png| ] = new Uint8Array( await blob.arrayBuffer() );    }    // 64 byte alignment   // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109    let offset = 0;    for ( const filename in files ) {     const file = files[ filename ];    const headerSize = 34 + filename.length;     offset += headerSize;     const offsetMod64 = offset & 63;     if ( offsetMod64 !== 4 ) {      const padLength = 64 - offsetMod64;     const padding = new Uint8Array( padLength );      files[ filename ] = [ file, { extra: { 12345: padding } } ];     }     offset = file.length;    }    return zipSync( files, { level: 0 } );   }  }  function imageToCanvas( image, flipY, maxTextureSize ) {   if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||   ( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||   ( typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas ) ||   ( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {    const scale = maxTextureSize / Math.max( image.width, image.height );    const canvas = document.createElement( 'canvas' );   canvas.width = image.width * Math.min( 1, scale );   canvas.height = image.height * Math.min( 1, scale );    const context = canvas.getContext( '2d' );    // TODO: We should be able to do this in the UsdTransform2d?    if ( flipY === true ) {     context.translate( 0, canvas.height );    context.scale( 1, - 1 );    }    context.drawImage( image, 0, 0, canvas.width, canvas.height );    return canvas;   } else {    throw new Error( 'THREE.USDZExporter: No valid image data found. Unable to process texture.' );   }  }  //  const PRECISION = 7;  function buildHeader() {   return |#usda 1.0 (  customLayerData = {   string creator = "Three.js USDZExporter"  }  defaultPrim = "Root"  metersPerUnit = 1  upAxis = "Y" )  |;  }  function buildSceneStart( options ) {   const alignment = options.includeAnchoringProperties === true ? |   token preliminary:anchoring:type = "|options.ar.anchoring.type}"   token preliminary:planeAnchoring:alignment = "|options.ar.planeAnchoring.alignment}"  | : '';  return |def Xform "Root" {  def Scope "Scenes" (   kind = "sceneLibrary"  )  {   def Xform "Scene" (    customData = {     bool preliminary_collidesWithEnvironment = 0     string sceneName = "Scene"    }    sceneName = "Scene"   )   {|alignment} |;  }  function buildSceneEnd() {   return |   }  } }  |;  }  function buildUSDFileAsString( dataToInsert ) {   let output = buildHeader();  output += dataToInsert;  return strToU8( output );  }  // Xform  function buildXform( object, geometry, material ) {   const name = 'Object_' + object.id;  const transform = buildMatrix( object.matrixWorld );   if ( object.matrixWorld.determinant() < 0 ) {    console.warn( 'THREE.USDZExporter: USDZ does not support negative scales', object );   }   return |def Xform "| name }" (  prepend references = @./geometries/Geometry_| geometry.id }.usda@</Geometry>  prepend apiSchemas = ["MaterialBindingAPI"] ) {  matrix4d xformOp:transform = | transform }  uniform token[] xformOpOrder = ["xformOp:transform"]   rel material:binding = </Materials/Material_| material.id }> }  |;  }  function buildMatrix( matrix ) {   const array = matrix.elements;   return |( | buildMatrixRow( array, 0 ) }, | buildMatrixRow( array, 4 ) }, | buildMatrixRow( array, 8 ) }, | buildMatrixRow( array, 12 ) } )|;  }  function buildMatrixRow( array, offset ) {   return |(| array[ offset + 0 ] }, | array[ offset + 1 ] }, | array[ offset + 2 ] }, | array[ offset + 3 ] })|;  }  // Mesh  function buildMeshObject( geometry ) {   const mesh = buildMesh( geometry );  return | def "Geometry" { |mesh} } |;  }  function buildMesh( geometry ) {   const name = 'Geometry';  const attributes = geometry.attributes;  const count = attributes.position.count;   return |  def Mesh "| name }"  {   int[] faceVertexCounts = [| buildMeshVertexCount( geometry ) }]   int[] faceVertexIndices = [| buildMeshVertexIndices( geometry ) }]   normal3f[] normals = [| buildVector3Array( attributes.normal, count )}] (    interpolation = "vertex"   )   point3f[] points = [| buildVector3Array( attributes.position, count )}] | buildPrimvars( attributes ) }   uniform token subdivisionScheme = "none"  } |;  }  function buildMeshVertexCount( geometry ) {   const count = geometry.index !== null ? geometry.index.count : geometry.attributes.position.count;   return Array( count / 3 ).fill( 3 ).join( ', ' );  }  function buildMeshVertexIndices( geometry ) {   const index = geometry.index;  const array = [];   if ( index !== null ) {    for ( let i = 0; i < index.count; i ++ ) {     array.push( index.getX( i ) );    }   } else {    const length = geometry.attributes.position.count;    for ( let i = 0; i < length; i ++ ) {     array.push( i );    }   }   return array.join( ', ' );  }  function buildVector3Array( attribute, count ) {   if ( attribute === undefined ) {    console.warn( 'USDZExporter: Normals missing.' );   return Array( count ).fill( '(0, 0, 0)' ).join( ', ' );   }   const array = [];   for ( let i = 0; i < attribute.count; i ++ ) {    const x = attribute.getX( i );   const y = attribute.getY( i );   const z = attribute.getZ( i );    array.push( |(| x.toPrecision( PRECISION ) }, | y.toPrecision( PRECISION ) }, | z.toPrecision( PRECISION ) })| );   }   return array.join( ', ' );  }  function buildVector2Array( attribute ) {   const array = [];   for ( let i = 0; i < attribute.count; i ++ ) {    const x = attribute.getX( i );   const y = attribute.getY( i );    array.push( |(| x.toPrecision( PRECISION ) }, | 1 - y.toPrecision( PRECISION ) })| );   }   return array.join( ', ' );  }  function buildPrimvars( attributes ) {   let string = '';   for ( let i = 0; i < 4; i ++ ) {    const id = ( i > 0 ? i : '' );   const attribute = attributes[ 'uv' + id ];    if ( attribute !== undefined ) {     string += |   texCoord2f[] primvars:st| id } = [| buildVector2Array( attribute )}] (    interpolation = "vertex"   )|;    }   }   // vertex colors   const colorAttribute = attributes.color;   if ( colorAttribute !== undefined ) {    const count = colorAttribute.count;    string += |  color3f[] primvars:displayColor = [|buildVector3Array( colorAttribute, count )}] (   interpolation = "vertex"   )|;   }   return string;  }  // Materials  function buildMaterials( materials, textures, quickLookCompatible = false ) {   const array = [];   for ( const uuid in materials ) {    const material = materials[ uuid ];    array.push( buildMaterial( material, textures, quickLookCompatible ) );   }   return |def "Materials" { | array.join( '' ) } }  |;  }  function buildMaterial( material, textures, quickLookCompatible = false ) {   // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html   const pad = '   ';  const inputs = [];  const samplers = [];   function buildTexture( texture, mapType, color ) {    const id = texture.source.id + '_' + texture.flipY;    textures[ id ] = texture;    const uv = texture.channel > 0 ? 'st' + texture.channel : 'st';    const WRAPPINGS = {    1000: 'repeat', // RepeatWrapping    1001: 'clamp', // ClampToEdgeWrapping    1002: 'mirror' // MirroredRepeatWrapping   };    const repeat = texture.repeat.clone();   const offset = texture.offset.clone();   const rotation = texture.rotation;    // rotation is around the wrong point. after rotation we need to shift offset again so that we're rotating around the right spot   const xRotationOffset = Math.sin( rotation );   const yRotationOffset = Math.cos( rotation );    // texture coordinates start in the opposite corner, need to correct   offset.y = 1 - offset.y - repeat.y;    // turns out QuickLook is buggy and interprets texture repeat inverted/applies operations in a different order.   // Apple Feedback:  FB10036297 and FB11442287   if ( quickLookCompatible ) {     // This is NOT correct yet in QuickLook, but comes close for a range of models.    // It becomes more incorrect the bigger the offset is     offset.x = offset.x / repeat.x;    offset.y = offset.y / repeat.y;     offset.x += xRotationOffset / repeat.x;    offset.y += yRotationOffset - 1;    } else {     // results match glTF results exactly. verified correct in usdview.    offset.x += xRotationOffset * repeat.x;    offset.y += ( 1 - yRotationOffset ) * repeat.y;    }    return |   def Shader "PrimvarReader_| mapType }"   {    uniform token info:id = "UsdPrimvarReader_float2"    float2 inputs:fallback = (0.0, 0.0)    token inputs:varname = "| uv }"    float2 outputs:result   }    def Shader "Transform2d_| mapType }"   {    uniform token info:id = "UsdTransform2d"    token inputs:in.connect = </Materials/Material_| material.id }/PrimvarReader_| mapType }.outputs:result>    float inputs:rotation = | ( rotation * ( 180 / Math.PI ) ).toFixed( PRECISION ) }    float2 inputs:scale = | buildVector2( repeat ) }    float2 inputs:translation = | buildVector2( offset ) }    float2 outputs:result   }    def Shader "Texture_| texture.id }_| mapType }"   {    uniform token info:id = "UsdUVTexture"    asset inputs:file = @textures/Texture_| id }.png@    float2 inputs:st.connect = </Materials/Material_| material.id }/Transform2d_| mapType }.outputs:result>    | color !== undefined ? 'float4 inputs:scale = ' + buildColor4( color ) : '' }    token inputs:sourceColorSpace = "| texture.colorSpace === NoColorSpace ? 'raw' : 'sRGB' }"    token inputs:wrapS = "| WRAPPINGS[ texture.wrapS ] }"    token inputs:wrapT = "| WRAPPINGS[ texture.wrapT ] }"    float outputs:r    float outputs:g    float outputs:b    float3 outputs:rgb    | material.transparent || material.alphaTest > 0.0 ? 'float outputs:a' : '' }   }|;   }    if ( material.side === DoubleSide ) {    console.warn( 'THREE.USDZExporter: USDZ does not support double sided materials', material );   }   if ( material.map !== null ) {    inputs.push( || pad }color3f inputs:diffuseColor.connect = </Materials/Material_| material.id }/Texture_| material.map.id }_diffuse.outputs:rgb>| );    if ( material.transparent ) {     inputs.push( || pad }float inputs:opacity.connect = </Materials/Material_| material.id }/Texture_| material.map.id }_diffuse.outputs:a>| );    } else if ( material.alphaTest > 0.0 ) {     inputs.push( || pad }float inputs:opacity.connect = </Materials/Material_| material.id }/Texture_| material.map.id }_diffuse.outputs:a>| );    inputs.push( || pad }float inputs:opacityThreshold = |material.alphaTest}| );    }    samplers.push( buildTexture( material.map, 'diffuse', material.color ) );   } else {    inputs.push( || pad }color3f inputs:diffuseColor = | buildColor( material.color ) }| );   }   if ( material.emissiveMap !== null ) {    inputs.push( || pad }color3f inputs:emissiveColor.connect = </Materials/Material_| material.id }/Texture_| material.emissiveMap.id }_emissive.outputs:rgb>| );    samplers.push( buildTexture( material.emissiveMap, 'emissive', new Color( material.emissive.r * material.emissiveIntensity, material.emissive.g * material.emissiveIntensity, material.emissive.b * material.emissiveIntensity ) ) );   } else if ( material.emissive.getHex() > 0 ) {    inputs.push( || pad }color3f inputs:emissiveColor = | buildColor( material.emissive ) }| );   }   if ( material.normalMap !== null ) {    inputs.push( || pad }normal3f inputs:normal.connect = </Materials/Material_| material.id }/Texture_| material.normalMap.id }_normal.outputs:rgb>| );    samplers.push( buildTexture( material.normalMap, 'normal' ) );   }   if ( material.aoMap !== null ) {    inputs.push( || pad }float inputs:occlusion.connect = </Materials/Material_| material.id }/Texture_| material.aoMap.id }_occlusion.outputs:r>| );    samplers.push( buildTexture( material.aoMap, 'occlusion', new Color( material.aoMapIntensity, material.aoMapIntensity, material.aoMapIntensity ) ) );   }   if ( material.roughnessMap !== null ) {    inputs.push( || pad }float inputs:roughness.connect = </Materials/Material_| material.id }/Texture_| material.roughnessMap.id }_roughness.outputs:g>| );    samplers.push( buildTexture( material.roughnessMap, 'roughness', new Color( material.roughness, material.roughness, material.roughness ) ) );   } else {    inputs.push( || pad }float inputs:roughness = | material.roughness }| );   }   if ( material.metalnessMap !== null ) {    inputs.push( || pad }float inputs:metallic.connect = </Materials/Material_| material.id }/Texture_| material.metalnessMap.id }_metallic.outputs:b>| );    samplers.push( buildTexture( material.metalnessMap, 'metallic', new Color( material.metalness, material.metalness, material.metalness ) ) );   } else {    inputs.push( || pad }float inputs:metallic = | material.metalness }| );   }   if ( material.alphaMap !== null ) {    inputs.push( ||pad}float inputs:opacity.connect = </Materials/Material_|material.id}/Texture_|material.alphaMap.id}_opacity.outputs:r>| );   inputs.push( ||pad}float inputs:opacityThreshold = 0.0001| );    samplers.push( buildTexture( material.alphaMap, 'opacity' ) );   } else {    inputs.push( ||pad}float inputs:opacity = |material.opacity}| );   }   if ( material.isMeshPhysicalMaterial ) {    if ( material.clearcoatMap !== null ) {     inputs.push( ||pad}float inputs:clearcoat.connect = </Materials/Material_|material.id}/Texture_|material.clearcoatMap.id}_clearcoat.outputs:r>| );    samplers.push( buildTexture( material.clearcoatMap, 'clearcoat', new Color( material.clearcoat, material.clearcoat, material.clearcoat ) ) );    } else {     inputs.push( ||pad}float inputs:clearcoat = |material.clearcoat}| );    }    if ( material.clearcoatRoughnessMap !== null ) {     inputs.push( ||pad}float inputs:clearcoatRoughness.connect = </Materials/Material_|material.id}/Texture_|material.clearcoatRoughnessMap.id}_clearcoatRoughness.outputs:g>| );    samplers.push( buildTexture( material.clearcoatRoughnessMap, 'clearcoatRoughness', new Color( material.clearcoatRoughness, material.clearcoatRoughness, material.clearcoatRoughness ) ) );    } else {     inputs.push( ||pad}float inputs:clearcoatRoughness = |material.clearcoatRoughness}| );    }    inputs.push( || pad }float inputs:ior = | material.ior }| );   }   return |  def Material "Material_| material.id }"  {   def Shader "PreviewSurface"   {    uniform token info:id = "UsdPreviewSurface" | inputs.join( '|n' ) }    int inputs:useSpecularWorkflow = 0    token outputs:surface   }    token outputs:surface.connect = </Materials/Material_| material.id }/PreviewSurface.outputs:surface>  | samplers.join( '|n' ) }   } |;  }  function buildColor( color ) {   return |(| color.r }, | color.g }, | color.b })|;  }  function buildColor4( color ) {   return |(| color.r }, | color.g }, | color.b }, 1.0)|;  }  function buildVector2( vector ) {   return |(| vector.x }, | vector.y })|;  }   function buildCamera( camera ) {   const name = camera.name ? camera.name : 'Camera_' + camera.id;   const transform = buildMatrix( camera.matrixWorld );   if ( camera.matrixWorld.determinant() < 0 ) {    console.warn( 'THREE.USDZExporter: USDZ does not support negative scales', camera );   }   if ( camera.isOrthographicCamera ) {    return |def Camera "|name}"   {    matrix4d xformOp:transform = | transform }    uniform token[] xformOpOrder = ["xformOp:transform"]     float2 clippingRange = (| camera.near.toPrecision( PRECISION ) }, | camera.far.toPrecision( PRECISION ) })    float horizontalAperture = | ( ( Math.abs( camera.left ) + Math.abs( camera.right ) ) * 10 ).toPrecision( PRECISION ) }    float verticalAperture = | ( ( Math.abs( camera.top ) + Math.abs( camera.bottom ) ) * 10 ).toPrecision( PRECISION ) }    token projection = "orthographic"   }    |;   } else {    return |def Camera "|name}"   {    matrix4d xformOp:transform = | transform }    uniform token[] xformOpOrder = ["xformOp:transform"]     float2 clippingRange = (| camera.near.toPrecision( PRECISION ) }, | camera.far.toPrecision( PRECISION ) })    float focalLength = | camera.getFocalLength().toPrecision( PRECISION ) }    float focusDistance = | camera.focus.toPrecision( PRECISION ) }    float horizontalAperture = | camera.getFilmWidth().toPrecision( PRECISION ) }    token projection = "perspective"    float verticalAperture = | camera.getFilmHeight().toPrecision( PRECISION ) }   }    |;   }  }  export { USDZExporter }; 
^..^ FILENAME ^..^
addons|geometries|BoxLineGeometry.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  Float32BufferAttribute } from 'three';  class BoxLineGeometry extends BufferGeometry {   constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {    super();    widthSegments = Math.floor( widthSegments );   heightSegments = Math.floor( heightSegments );   depthSegments = Math.floor( depthSegments );    const widthHalf = width / 2;   const heightHalf = height / 2;   const depthHalf = depth / 2;    const segmentWidth = width / widthSegments;   const segmentHeight = height / heightSegments;   const segmentDepth = depth / depthSegments;    const vertices = [];    let x = - widthHalf;   let y = - heightHalf;   let z = - depthHalf;    for ( let i = 0; i <= widthSegments; i ++ ) {     vertices.push( x, - heightHalf, - depthHalf, x, heightHalf, - depthHalf );    vertices.push( x, heightHalf, - depthHalf, x, heightHalf, depthHalf );    vertices.push( x, heightHalf, depthHalf, x, - heightHalf, depthHalf );    vertices.push( x, - heightHalf, depthHalf, x, - heightHalf, - depthHalf );     x += segmentWidth;    }    for ( let i = 0; i <= heightSegments; i ++ ) {     vertices.push( - widthHalf, y, - depthHalf, widthHalf, y, - depthHalf );    vertices.push( widthHalf, y, - depthHalf, widthHalf, y, depthHalf );    vertices.push( widthHalf, y, depthHalf, - widthHalf, y, depthHalf );    vertices.push( - widthHalf, y, depthHalf, - widthHalf, y, - depthHalf );     y += segmentHeight;    }    for ( let i = 0; i <= depthSegments; i ++ ) {     vertices.push( - widthHalf, - heightHalf, z, - widthHalf, heightHalf, z );    vertices.push( - widthHalf, heightHalf, z, widthHalf, heightHalf, z );    vertices.push( widthHalf, heightHalf, z, widthHalf, - heightHalf, z );    vertices.push( widthHalf, - heightHalf, z, - widthHalf, - heightHalf, z );     z += segmentDepth;    }    this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );   }  }  export { BoxLineGeometry }; 
^..^ FILENAME ^..^
addons|geometries|ConvexGeometry.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  Float32BufferAttribute } from 'three'; import { ConvexHull } from '../math/ConvexHull.js';  class ConvexGeometry extends BufferGeometry {   constructor( points = [] ) {    super();    // buffers    const vertices = [];   const normals = [];    const convexHull = new ConvexHull().setFromPoints( points );    // generate vertices and normals    const faces = convexHull.faces;    for ( let i = 0; i < faces.length; i ++ ) {     const face = faces[ i ];    let edge = face.edge;     // we move along a doubly-connected edge list to access all face points (see HalfEdge docs)     do {      const point = edge.head().point;      vertices.push( point.x, point.y, point.z );     normals.push( face.normal.x, face.normal.y, face.normal.z );      edge = edge.next;     } while ( edge !== face.edge );    }    // build geometry    this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );   this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );   }  }  export { ConvexGeometry }; 
^..^ FILENAME ^..^
addons|geometries|DecalGeometry.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  Float32BufferAttribute,  Matrix3,  Matrix4,  Vector3 } from 'three';  /**  * You can use this geometry to create a decal mesh, that serves different kinds of purposes.  * e.g. adding unique details to models, performing dynamic visual environmental changes or covering seams.  *  * Constructor parameter:  *  * mesh ?" Any mesh object  * position ?" Position of the decal projector  * orientation ?" Orientation of the decal projector  * size ?" Size of the decal projector  *  * reference: http://blog.wolfire.com/2009/06/how-to-project-decals/  *  */  class DecalGeometry extends BufferGeometry {   constructor( mesh, position, orientation, size ) {    super();    // buffers    const vertices = [];   const normals = [];   const uvs = [];    // helpers    const plane = new Vector3();    const normalMatrix = new Matrix3().getNormalMatrix( mesh.matrixWorld );    // this matrix represents the transformation of the decal projector    const projectorMatrix = new Matrix4();   projectorMatrix.makeRotationFromEuler( orientation );   projectorMatrix.setPosition( position );    const projectorMatrixInverse = new Matrix4();   projectorMatrixInverse.copy( projectorMatrix ).invert();    // generate buffers    generate();    // build geometry    this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );   this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );   this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );    function generate() {     let decalVertices = [];     const vertex = new Vector3();    const normal = new Vector3();     // handle different geometry types     const geometry = mesh.geometry;     const positionAttribute = geometry.attributes.position;    const normalAttribute = geometry.attributes.normal;     // first, create an array of 'DecalVertex' objects    // three consecutive 'DecalVertex' objects represent a single face    //    // this data structure will be later used to perform the clipping     if ( geometry.index !== null ) {      // indexed BufferGeometry      const index = geometry.index;      for ( let i = 0; i < index.count; i ++ ) {       vertex.fromBufferAttribute( positionAttribute, index.getX( i ) );      normal.fromBufferAttribute( normalAttribute, index.getX( i ) );       pushDecalVertex( decalVertices, vertex, normal );      }     } else {      // non-indexed BufferGeometry      for ( let i = 0; i < positionAttribute.count; i ++ ) {       vertex.fromBufferAttribute( positionAttribute, i );      normal.fromBufferAttribute( normalAttribute, i );       pushDecalVertex( decalVertices, vertex, normal );      }     }     // second, clip the geometry so that it doesn't extend out from the projector     decalVertices = clipGeometry( decalVertices, plane.set( 1, 0, 0 ) );    decalVertices = clipGeometry( decalVertices, plane.set( - 1, 0, 0 ) );    decalVertices = clipGeometry( decalVertices, plane.set( 0, 1, 0 ) );    decalVertices = clipGeometry( decalVertices, plane.set( 0, - 1, 0 ) );    decalVertices = clipGeometry( decalVertices, plane.set( 0, 0, 1 ) );    decalVertices = clipGeometry( decalVertices, plane.set( 0, 0, - 1 ) );     // third, generate final vertices, normals and uvs     for ( let i = 0; i < decalVertices.length; i ++ ) {      const decalVertex = decalVertices[ i ];      // create texture coordinates (we are still in projector space)      uvs.push(      0.5 + ( decalVertex.position.x / size.x ),      0.5 + ( decalVertex.position.y / size.y )     );      // transform the vertex back to world space      decalVertex.position.applyMatrix4( projectorMatrix );      // now create vertex and normal buffer data      vertices.push( decalVertex.position.x, decalVertex.position.y, decalVertex.position.z );     normals.push( decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z );     }    }    function pushDecalVertex( decalVertices, vertex, normal ) {     // transform the vertex to world space, then to projector space     vertex.applyMatrix4( mesh.matrixWorld );    vertex.applyMatrix4( projectorMatrixInverse );     normal.applyNormalMatrix( normalMatrix );     decalVertices.push( new DecalVertex( vertex.clone(), normal.clone() ) );    }    function clipGeometry( inVertices, plane ) {     const outVertices = [];     const s = 0.5 * Math.abs( size.dot( plane ) );     // a single iteration clips one face,    // which consists of three consecutive 'DecalVertex' objects     for ( let i = 0; i < inVertices.length; i += 3 ) {      let total = 0;     let nV1;     let nV2;     let nV3;     let nV4;      const d1 = inVertices[ i + 0 ].position.dot( plane ) - s;     const d2 = inVertices[ i + 1 ].position.dot( plane ) - s;     const d3 = inVertices[ i + 2 ].position.dot( plane ) - s;      const v1Out = d1 > 0;     const v2Out = d2 > 0;     const v3Out = d3 > 0;      // calculate, how many vertices of the face lie outside of the clipping plane      total = ( v1Out ? 1 : 0 ) + ( v2Out ? 1 : 0 ) + ( v3Out ? 1 : 0 );      switch ( total ) {       case 0: {        // the entire face lies inside of the plane, no clipping needed        outVertices.push( inVertices[ i ] );       outVertices.push( inVertices[ i + 1 ] );       outVertices.push( inVertices[ i + 2 ] );       break;       }       case 1: {        // one vertex lies outside of the plane, perform clipping        if ( v1Out ) {         nV1 = inVertices[ i + 1 ];        nV2 = inVertices[ i + 2 ];        nV3 = clip( inVertices[ i ], nV1, plane, s );        nV4 = clip( inVertices[ i ], nV2, plane, s );        }        if ( v2Out ) {         nV1 = inVertices[ i ];        nV2 = inVertices[ i + 2 ];        nV3 = clip( inVertices[ i + 1 ], nV1, plane, s );        nV4 = clip( inVertices[ i + 1 ], nV2, plane, s );         outVertices.push( nV3 );        outVertices.push( nV2.clone() );        outVertices.push( nV1.clone() );         outVertices.push( nV2.clone() );        outVertices.push( nV3.clone() );        outVertices.push( nV4 );        break;        }        if ( v3Out ) {         nV1 = inVertices[ i ];        nV2 = inVertices[ i + 1 ];        nV3 = clip( inVertices[ i + 2 ], nV1, plane, s );        nV4 = clip( inVertices[ i + 2 ], nV2, plane, s );        }        outVertices.push( nV1.clone() );       outVertices.push( nV2.clone() );       outVertices.push( nV3 );        outVertices.push( nV4 );       outVertices.push( nV3.clone() );       outVertices.push( nV2.clone() );        break;       }       case 2: {        // two vertices lies outside of the plane, perform clipping        if ( ! v1Out ) {         nV1 = inVertices[ i ].clone();        nV2 = clip( nV1, inVertices[ i + 1 ], plane, s );        nV3 = clip( nV1, inVertices[ i + 2 ], plane, s );        outVertices.push( nV1 );        outVertices.push( nV2 );        outVertices.push( nV3 );        }        if ( ! v2Out ) {         nV1 = inVertices[ i + 1 ].clone();        nV2 = clip( nV1, inVertices[ i + 2 ], plane, s );        nV3 = clip( nV1, inVertices[ i ], plane, s );        outVertices.push( nV1 );        outVertices.push( nV2 );        outVertices.push( nV3 );        }        if ( ! v3Out ) {         nV1 = inVertices[ i + 2 ].clone();        nV2 = clip( nV1, inVertices[ i ], plane, s );        nV3 = clip( nV1, inVertices[ i + 1 ], plane, s );        outVertices.push( nV1 );        outVertices.push( nV2 );        outVertices.push( nV3 );        }        break;       }       case 3: {        // the entire face lies outside of the plane, so let's discard the corresponding vertices        break;       }      }     }     return outVertices;    }    function clip( v0, v1, p, s ) {     const d0 = v0.position.dot( p ) - s;    const d1 = v1.position.dot( p ) - s;     const s0 = d0 / ( d0 - d1 );     const v = new DecalVertex(     new Vector3(      v0.position.x + s0 * ( v1.position.x - v0.position.x ),      v0.position.y + s0 * ( v1.position.y - v0.position.y ),      v0.position.z + s0 * ( v1.position.z - v0.position.z )     ),     new Vector3(      v0.normal.x + s0 * ( v1.normal.x - v0.normal.x ),      v0.normal.y + s0 * ( v1.normal.y - v0.normal.y ),      v0.normal.z + s0 * ( v1.normal.z - v0.normal.z )     )    );     // need to clip more values (texture coordinates)? do it this way:    // intersectpoint.value = a.value + s * ( b.value - a.value );     return v;    }   }  }  // helper  class DecalVertex {   constructor( position, normal ) {    this.position = position;   this.normal = normal;   }   clone() {    return new this.constructor( this.position.clone(), this.normal.clone() );   }  }  export { DecalGeometry, DecalVertex }; 
^..^ FILENAME ^..^
addons|geometries|InstancedPointsGeometry.js
^..^ CONTENTS ^..^
import {  Box3,  Float32BufferAttribute,  InstancedBufferGeometry,  InstancedBufferAttribute,  Sphere,  Vector3 } from 'three';  const _vector = new Vector3();  class InstancedPointsGeometry extends InstancedBufferGeometry {   constructor() {    super();    this.isInstancedPointsGeometry = true;    this.type = 'InstancedPointsGeometry';    const positions = [ - 1, 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];   const uvs = [ 0, 1, 1, 1, 0, 0, 1, 0 ];   const index = [ 0, 2, 1, 2, 3, 1 ];    this.setIndex( index );   this.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );   this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );   }   applyMatrix4( matrix ) {    const pos = this.attributes.instancePosition;    if ( pos !== undefined ) {     pos.applyMatrix4( matrix );     pos.needsUpdate = true;    }    if ( this.boundingBox !== null ) {     this.computeBoundingBox();    }    if ( this.boundingSphere !== null ) {     this.computeBoundingSphere();    }    return this;   }   setPositions( array ) {    let points;    if ( array instanceof Float32Array ) {     points = array;    } else if ( Array.isArray( array ) ) {     points = new Float32Array( array );    }    this.setAttribute( 'instancePosition', new InstancedBufferAttribute( points, 3 ) ); // xyz    //    this.computeBoundingBox();   this.computeBoundingSphere();    return this;   }   setColors( array ) {    let colors;    if ( array instanceof Float32Array ) {     colors = array;    } else if ( Array.isArray( array ) ) {     colors = new Float32Array( array );    }    this.setAttribute( 'instanceColor', new InstancedBufferAttribute( colors, 3 ) ); // rgb    return this;   }   computeBoundingBox() {    if ( this.boundingBox === null ) {     this.boundingBox = new Box3();    }    const pos = this.attributes.instancePosition;    if ( pos !== undefined ) {     this.boundingBox.setFromBufferAttribute( pos );    }   }   computeBoundingSphere() {    if ( this.boundingSphere === null ) {     this.boundingSphere = new Sphere();    }    if ( this.boundingBox === null ) {     this.computeBoundingBox();    }    const pos = this.attributes.instancePosition;    if ( pos !== undefined ) {     const center = this.boundingSphere.center;     this.boundingBox.getCenter( center );     let maxRadiusSq = 0;     for ( let i = 0, il = pos.count; i < il; i ++ ) {      _vector.fromBufferAttribute( pos, i );     maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );     }     this.boundingSphere.radius = Math.sqrt( maxRadiusSq );     if ( isNaN( this.boundingSphere.radius ) ) {      console.error( 'THREE.InstancedPointsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );     }    }   }   toJSON() {    // todo   }  }  export default InstancedPointsGeometry; 
^..^ FILENAME ^..^
addons|geometries|ParametricGeometries.js
^..^ CONTENTS ^..^
import {  Curve,  Vector3 } from 'three';  import { ParametricGeometry } from './ParametricGeometry.js';  /**  * Experimenting of primitive geometry creation using Surface Parametric equations  */  const ParametricGeometries = {   klein: function ( v, u, target ) {    u *= Math.PI;   v *= 2 * Math.PI;    u = u * 2;   let x, z;   if ( u < Math.PI ) {     x = 3 * Math.cos( u ) * ( 1 + Math.sin( u ) ) + ( 2 * ( 1 - Math.cos( u ) / 2 ) ) * Math.cos( u ) * Math.cos( v );    z = - 8 * Math.sin( u ) - 2 * ( 1 - Math.cos( u ) / 2 ) * Math.sin( u ) * Math.cos( v );    } else {     x = 3 * Math.cos( u ) * ( 1 + Math.sin( u ) ) + ( 2 * ( 1 - Math.cos( u ) / 2 ) ) * Math.cos( v + Math.PI );    z = - 8 * Math.sin( u );    }    const y = - 2 * ( 1 - Math.cos( u ) / 2 ) * Math.sin( v );    target.set( x, y, z );   },   plane: function ( width, height ) {    return function ( u, v, target ) {     const x = u * width;    const y = 0;    const z = v * height;     target.set( x, y, z );    };   },   mobius: function ( u, t, target ) {    // flat mobius strip   // http://www.wolframalpha.com/input/?i=M%C3%B6bius+strip+parametric+equations&lk=1&a=ClashPrefs_*Surface.MoebiusStrip.SurfaceProperty.ParametricEquations-   u = u - 0.5;   const v = 2 * Math.PI * t;    const a = 2;    const x = Math.cos( v ) * ( a + u * Math.cos( v / 2 ) );   const y = Math.sin( v ) * ( a + u * Math.cos( v / 2 ) );   const z = u * Math.sin( v / 2 );    target.set( x, y, z );   },   mobius3d: function ( u, t, target ) {    // volumetric mobius strip    u *= Math.PI;   t *= 2 * Math.PI;    u = u * 2;   const phi = u / 2;   const major = 2.25, a = 0.125, b = 0.65;    let x = a * Math.cos( t ) * Math.cos( phi ) - b * Math.sin( t ) * Math.sin( phi );   const z = a * Math.cos( t ) * Math.sin( phi ) + b * Math.sin( t ) * Math.cos( phi );   const y = ( major + x ) * Math.sin( u );   x = ( major + x ) * Math.cos( u );    target.set( x, y, z );   }  };   /*********************************************  *  * Parametric Replacement for TubeGeometry  *  *********************************************/  ParametricGeometries.TubeGeometry = class TubeGeometry extends ParametricGeometry {   constructor( path, segments = 64, radius = 1, segmentsRadius = 8, closed = false ) {    const numpoints = segments + 1;    const frames = path.computeFrenetFrames( segments, closed ),    tangents = frames.tangents,    normals = frames.normals,    binormals = frames.binormals;    const position = new Vector3();    function ParametricTube( u, v, target ) {     v *= 2 * Math.PI;     const i = Math.floor( u * ( numpoints - 1 ) );     path.getPointAt( u, position );     const normal = normals[ i ];    const binormal = binormals[ i ];     const cx = - radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.    const cy = radius * Math.sin( v );     position.x += cx * normal.x + cy * binormal.x;    position.y += cx * normal.y + cy * binormal.y;    position.z += cx * normal.z + cy * binormal.z;     target.copy( position );    }    super( ParametricTube, segments, segmentsRadius );    // proxy internals    this.tangents = tangents;   this.normals = normals;   this.binormals = binormals;    this.path = path;   this.segments = segments;   this.radius = radius;   this.segmentsRadius = segmentsRadius;   this.closed = closed;   }  };   /*********************************************   *   * Parametric Replacement for TorusKnotGeometry   *   *********************************************/ ParametricGeometries.TorusKnotGeometry = class TorusKnotGeometry extends ParametricGeometries.TubeGeometry {   constructor( radius = 200, tube = 40, segmentsT = 64, segmentsR = 8, p = 2, q = 3 ) {    class TorusKnotCurve extends Curve {     getPoint( t, optionalTarget = new Vector3() ) {      const point = optionalTarget;      t *= Math.PI * 2;      const r = 0.5;      const x = ( 1 + r * Math.cos( q * t ) ) * Math.cos( p * t );     const y = ( 1 + r * Math.cos( q * t ) ) * Math.sin( p * t );     const z = r * Math.sin( q * t );      return point.set( x, y, z ).multiplyScalar( radius );     }    }    const segments = segmentsT;   const radiusSegments = segmentsR;   const extrudePath = new TorusKnotCurve();    super( extrudePath, segments, tube, radiusSegments, true, false );    this.radius = radius;   this.tube = tube;   this.segmentsT = segmentsT;   this.segmentsR = segmentsR;   this.p = p;   this.q = q;   }  };  /*********************************************   *   * Parametric Replacement for SphereGeometry   *   *********************************************/ ParametricGeometries.SphereGeometry = class SphereGeometry extends ParametricGeometry {   constructor( size, u, v ) {    function sphere( u, v, target ) {     u *= Math.PI;    v *= 2 * Math.PI;     const x = size * Math.sin( u ) * Math.cos( v );    const y = size * Math.sin( u ) * Math.sin( v );    const z = size * Math.cos( u );     target.set( x, y, z );    }    super( sphere, u, v );   }  };   /*********************************************   *   * Parametric Replacement for PlaneGeometry   *   *********************************************/  ParametricGeometries.PlaneGeometry = class PlaneGeometry extends ParametricGeometry {   constructor( width, depth, segmentsWidth, segmentsDepth ) {    function plane( u, v, target ) {     const x = u * width;    const y = 0;    const z = v * depth;     target.set( x, y, z );    }    super( plane, segmentsWidth, segmentsDepth );   }  };  export { ParametricGeometries }; 
^..^ FILENAME ^..^
addons|geometries|ParametricGeometry.js
^..^ CONTENTS ^..^
/**  * Parametric Surfaces Geometry  * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html  */  import {  BufferGeometry,  Float32BufferAttribute,  Vector3 } from 'three';  class ParametricGeometry extends BufferGeometry {   constructor( func = ( u, v, target ) => target.set( u, v, Math.cos( u ) * Math.sin( v ) ), slices = 8, stacks = 8 ) {    super();    this.type = 'ParametricGeometry';    this.parameters = {    func: func,    slices: slices,    stacks: stacks   };    // buffers    const indices = [];   const vertices = [];   const normals = [];   const uvs = [];    const EPS = 0.00001;    const normal = new Vector3();    const p0 = new Vector3(), p1 = new Vector3();   const pu = new Vector3(), pv = new Vector3();    // generate vertices, normals and uvs    const sliceCount = slices + 1;    for ( let i = 0; i <= stacks; i ++ ) {     const v = i / stacks;     for ( let j = 0; j <= slices; j ++ ) {      const u = j / slices;      // vertex      func( u, v, p0 );     vertices.push( p0.x, p0.y, p0.z );      // normal      // approximate tangent vectors via finite differences      if ( u - EPS >= 0 ) {       func( u - EPS, v, p1 );      pu.subVectors( p0, p1 );      } else {       func( u + EPS, v, p1 );      pu.subVectors( p1, p0 );      }      if ( v - EPS >= 0 ) {       func( u, v - EPS, p1 );      pv.subVectors( p0, p1 );      } else {       func( u, v + EPS, p1 );      pv.subVectors( p1, p0 );      }      // cross product of tangent vectors returns surface normal      normal.crossVectors( pu, pv ).normalize();     normals.push( normal.x, normal.y, normal.z );      // uv      uvs.push( u, v );     }    }    // generate indices    for ( let i = 0; i < stacks; i ++ ) {     for ( let j = 0; j < slices; j ++ ) {      const a = i * sliceCount + j;     const b = i * sliceCount + j + 1;     const c = ( i + 1 ) * sliceCount + j + 1;     const d = ( i + 1 ) * sliceCount + j;      // faces one and two      indices.push( a, b, d );     indices.push( b, c, d );     }    }    // build geometry    this.setIndex( indices );   this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );   this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );   this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );   }   copy( source ) {    super.copy( source );    this.parameters = Object.assign( {}, source.parameters );    return this;   }  }  export { ParametricGeometry }; 
^..^ FILENAME ^..^
addons|geometries|RoundedBoxGeometry.js
^..^ CONTENTS ^..^
import {  BoxGeometry,  Vector3 } from 'three';  const _tempNormal = new Vector3();  function getUv( faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength ) {   const totArcLength = 2 * Math.PI * radius / 4;   // length of the planes between the arcs on each axis  const centerLength = Math.max( sideLength - 2 * radius, 0 );  const halfArc = Math.PI / 4;   // Get the vector projected onto the Y plane  _tempNormal.copy( normal );  _tempNormal[ projectionAxis ] = 0;  _tempNormal.normalize();   // total amount of UV space alloted to a single arc  const arcUvRatio = 0.5 * totArcLength / ( totArcLength + centerLength );   // the distance along one arc the point is at  const arcAngleRatio = 1.0 - ( _tempNormal.angleTo( faceDirVector ) / halfArc );   if ( Math.sign( _tempNormal[ uvAxis ] ) === 1 ) {    return arcAngleRatio * arcUvRatio;   } else {    // total amount of UV space alloted to the plane between the arcs   const lenUv = centerLength / ( totArcLength + centerLength );   return lenUv + arcUvRatio + arcUvRatio * ( 1.0 - arcAngleRatio );   }  }  class RoundedBoxGeometry extends BoxGeometry {   constructor( width = 1, height = 1, depth = 1, segments = 2, radius = 0.1 ) {    // ensure segments is odd so we have a plane connecting the rounded corners   segments = segments * 2 + 1;    // ensure radius isn't bigger than shortest side   radius = Math.min( width / 2, height / 2, depth / 2, radius );    super( 1, 1, 1, segments, segments, segments );    // if we just have one segment we're the same as a regular box   if ( segments === 1 ) return;    const geometry2 = this.toNonIndexed();    this.index = null;   this.attributes.position = geometry2.attributes.position;   this.attributes.normal = geometry2.attributes.normal;   this.attributes.uv = geometry2.attributes.uv;    //    const position = new Vector3();   const normal = new Vector3();    const box = new Vector3( width, height, depth ).divideScalar( 2 ).subScalar( radius );    const positions = this.attributes.position.array;   const normals = this.attributes.normal.array;   const uvs = this.attributes.uv.array;    const faceTris = positions.length / 6;   const faceDirVector = new Vector3();   const halfSegmentSize = 0.5 / segments;    for ( let i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {     position.fromArray( positions, i );    normal.copy( position );    normal.x -= Math.sign( normal.x ) * halfSegmentSize;    normal.y -= Math.sign( normal.y ) * halfSegmentSize;    normal.z -= Math.sign( normal.z ) * halfSegmentSize;    normal.normalize();     positions[ i + 0 ] = box.x * Math.sign( position.x ) + normal.x * radius;    positions[ i + 1 ] = box.y * Math.sign( position.y ) + normal.y * radius;    positions[ i + 2 ] = box.z * Math.sign( position.z ) + normal.z * radius;     normals[ i + 0 ] = normal.x;    normals[ i + 1 ] = normal.y;    normals[ i + 2 ] = normal.z;     const side = Math.floor( i / faceTris );     switch ( side ) {      case 0: // right       // generate UVs along Z then Y      faceDirVector.set( 1, 0, 0 );      uvs[ j + 0 ] = getUv( faceDirVector, normal, 'z', 'y', radius, depth );      uvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'z', radius, height );      break;      case 1: // left       // generate UVs along Z then Y      faceDirVector.set( - 1, 0, 0 );      uvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'z', 'y', radius, depth );      uvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'z', radius, height );      break;      case 2: // top       // generate UVs along X then Z      faceDirVector.set( 0, 1, 0 );      uvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'z', radius, width );      uvs[ j + 1 ] = getUv( faceDirVector, normal, 'z', 'x', radius, depth );      break;      case 3: // bottom       // generate UVs along X then Z      faceDirVector.set( 0, - 1, 0 );      uvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'z', radius, width );      uvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'z', 'x', radius, depth );      break;      case 4: // front       // generate UVs along X then Y      faceDirVector.set( 0, 0, 1 );      uvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'y', radius, width );      uvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'x', radius, height );      break;      case 5: // back       // generate UVs along X then Y      faceDirVector.set( 0, 0, - 1 );      uvs[ j + 0 ] = getUv( faceDirVector, normal, 'x', 'y', radius, width );      uvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'x', radius, height );      break;     }    }   }  }  export { RoundedBoxGeometry }; 
^..^ FILENAME ^..^
addons|geometries|TeapotGeometry.js
^..^ CONTENTS ^..^
import {  BufferAttribute,  BufferGeometry,  Matrix4,  Vector3,  Vector4 } from 'three';  /**  * Tessellates the famous Utah teapot database by Martin Newell into triangles.  *  * Parameters: size = 50, segments = 10, bottom = true, lid = true, body = true,  *   fitLid = true, blinn = true  *  * size is a relative scale: I've scaled the teapot to fit vertically between -1 and 1.  * Think of it as a "radius".  * segments - number of line segments to subdivide each patch edge;  *   1 is possible but gives degenerates, so two is the real minimum.  * bottom - boolean, if true (default) then the bottom patches are added. Some consider  *   adding the bottom heresy, so set this to "false" to adhere to the One True Way.  * lid - to remove the lid and look inside, set to true.  * body - to remove the body and leave the lid, set this and "bottom" to false.  * fitLid - the lid is a tad small in the original. This stretches it a bit so you can't  *   see the teapot's insides through the gap.  * blinn - Jim Blinn scaled the original data vertically by dividing by about 1.3 to look  *   nicer. If you want to see the original teapot, similar to the real-world model, set  *   this to false. True by default.  *   See http://en.wikipedia.org/wiki/File:Original_Utah_Teapot.jpg for the original  *   real-world teapot (from http://en.wikipedia.org/wiki/Utah_teapot).  *  * Note that the bottom (the last four patches) is not flat - blame Frank Crow, not me.  *  * The teapot should normally be rendered as a double sided object, since for some  * patches both sides can be seen, e.g., the gap around the lid and inside the spout.  *  * Segments 'n' determines the number of triangles output.  *   Total triangles = 32*2*n*n - 8*n    [degenerates at the top and bottom cusps are deleted]  *  *   size_factor   # triangles  *       1          56  *       2         240  *       3         552  *       4         992  *  *      10        6320  *      20       25440  *      30       57360  *  * Code converted from my ancient SPD software, http://tog.acm.org/resources/SPD/  * Created for the Udacity course "Interactive Rendering", http://bit.ly/ericity  * YouTube video on teapot history: https://www.youtube.com/watch?v=DxMfblPzFNc  *  * See https://en.wikipedia.org/wiki/Utah_teapot for the history of the teapot  *  */  class TeapotGeometry extends BufferGeometry {   constructor( size = 50, segments = 10, bottom = true, lid = true, body = true, fitLid = true, blinn = true ) {    // 32 * 4 * 4 Bezier spline patches   const teapotPatches = [    /*rim*/    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,    3, 16, 17, 18, 7, 19, 20, 21, 11, 22, 23, 24, 15, 25, 26, 27,    18, 28, 29, 30, 21, 31, 32, 33, 24, 34, 35, 36, 27, 37, 38, 39,    30, 40, 41, 0, 33, 42, 43, 4, 36, 44, 45, 8, 39, 46, 47, 12,    /*body*/    12, 13, 14, 15, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,    15, 25, 26, 27, 51, 60, 61, 62, 55, 63, 64, 65, 59, 66, 67, 68,    27, 37, 38, 39, 62, 69, 70, 71, 65, 72, 73, 74, 68, 75, 76, 77,    39, 46, 47, 12, 71, 78, 79, 48, 74, 80, 81, 52, 77, 82, 83, 56,    56, 57, 58, 59, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,    59, 66, 67, 68, 87, 96, 97, 98, 91, 99, 100, 101, 95, 102, 103, 104,    68, 75, 76, 77, 98, 105, 106, 107, 101, 108, 109, 110, 104, 111, 112, 113,    77, 82, 83, 56, 107, 114, 115, 84, 110, 116, 117, 88, 113, 118, 119, 92,    /*handle*/    120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135,    123, 136, 137, 120, 127, 138, 139, 124, 131, 140, 141, 128, 135, 142, 143, 132,    132, 133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 151, 68, 152, 153, 154,    135, 142, 143, 132, 147, 155, 156, 144, 151, 157, 158, 148, 154, 159, 160, 68,    /*spout*/    161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176,    164, 177, 178, 161, 168, 179, 180, 165, 172, 181, 182, 169, 176, 183, 184, 173,    173, 174, 175, 176, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196,    176, 183, 184, 173, 188, 197, 198, 185, 192, 199, 200, 189, 196, 201, 202, 193,    /*lid*/    203, 203, 203, 203, 204, 205, 206, 207, 208, 208, 208, 208, 209, 210, 211, 212,    203, 203, 203, 203, 207, 213, 214, 215, 208, 208, 208, 208, 212, 216, 217, 218,    203, 203, 203, 203, 215, 219, 220, 221, 208, 208, 208, 208, 218, 222, 223, 224,    203, 203, 203, 203, 221, 225, 226, 204, 208, 208, 208, 208, 224, 227, 228, 209,    209, 210, 211, 212, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240,    212, 216, 217, 218, 232, 241, 242, 243, 236, 244, 245, 246, 240, 247, 248, 249,    218, 222, 223, 224, 243, 250, 251, 252, 246, 253, 254, 255, 249, 256, 257, 258,    224, 227, 228, 209, 252, 259, 260, 229, 255, 261, 262, 233, 258, 263, 264, 237,    /*bottom*/    265, 265, 265, 265, 266, 267, 268, 269, 270, 271, 272, 273, 92, 119, 118, 113,    265, 265, 265, 265, 269, 274, 275, 276, 273, 277, 278, 279, 113, 112, 111, 104,    265, 265, 265, 265, 276, 280, 281, 282, 279, 283, 284, 285, 104, 103, 102, 95,    265, 265, 265, 265, 282, 286, 287, 266, 285, 288, 289, 270, 95, 94, 93, 92   ];    const teapotVertices = [    1.4, 0, 2.4,    1.4, - 0.784, 2.4,    0.784, - 1.4, 2.4,    0, - 1.4, 2.4,    1.3375, 0, 2.53125,    1.3375, - 0.749, 2.53125,    0.749, - 1.3375, 2.53125,    0, - 1.3375, 2.53125,    1.4375, 0, 2.53125,    1.4375, - 0.805, 2.53125,    0.805, - 1.4375, 2.53125,    0, - 1.4375, 2.53125,    1.5, 0, 2.4,    1.5, - 0.84, 2.4,    0.84, - 1.5, 2.4,    0, - 1.5, 2.4,    - 0.784, - 1.4, 2.4,    - 1.4, - 0.784, 2.4,    - 1.4, 0, 2.4,    - 0.749, - 1.3375, 2.53125,    - 1.3375, - 0.749, 2.53125,    - 1.3375, 0, 2.53125,    - 0.805, - 1.4375, 2.53125,    - 1.4375, - 0.805, 2.53125,    - 1.4375, 0, 2.53125,    - 0.84, - 1.5, 2.4,    - 1.5, - 0.84, 2.4,    - 1.5, 0, 2.4,    - 1.4, 0.784, 2.4,    - 0.784, 1.4, 2.4,    0, 1.4, 2.4,    - 1.3375, 0.749, 2.53125,    - 0.749, 1.3375, 2.53125,    0, 1.3375, 2.53125,    - 1.4375, 0.805, 2.53125,    - 0.805, 1.4375, 2.53125,    0, 1.4375, 2.53125,    - 1.5, 0.84, 2.4,    - 0.84, 1.5, 2.4,    0, 1.5, 2.4,    0.784, 1.4, 2.4,    1.4, 0.784, 2.4,    0.749, 1.3375, 2.53125,    1.3375, 0.749, 2.53125,    0.805, 1.4375, 2.53125,    1.4375, 0.805, 2.53125,    0.84, 1.5, 2.4,    1.5, 0.84, 2.4,    1.75, 0, 1.875,    1.75, - 0.98, 1.875,    0.98, - 1.75, 1.875,    0, - 1.75, 1.875,    2, 0, 1.35,    2, - 1.12, 1.35,    1.12, - 2, 1.35,    0, - 2, 1.35,    2, 0, 0.9,    2, - 1.12, 0.9,    1.12, - 2, 0.9,    0, - 2, 0.9,    - 0.98, - 1.75, 1.875,    - 1.75, - 0.98, 1.875,    - 1.75, 0, 1.875,    - 1.12, - 2, 1.35,    - 2, - 1.12, 1.35,    - 2, 0, 1.35,    - 1.12, - 2, 0.9,    - 2, - 1.12, 0.9,    - 2, 0, 0.9,    - 1.75, 0.98, 1.875,    - 0.98, 1.75, 1.875,    0, 1.75, 1.875,    - 2, 1.12, 1.35,    - 1.12, 2, 1.35,    0, 2, 1.35,    - 2, 1.12, 0.9,    - 1.12, 2, 0.9,    0, 2, 0.9,    0.98, 1.75, 1.875,    1.75, 0.98, 1.875,    1.12, 2, 1.35,    2, 1.12, 1.35,    1.12, 2, 0.9,    2, 1.12, 0.9,    2, 0, 0.45,    2, - 1.12, 0.45,    1.12, - 2, 0.45,    0, - 2, 0.45,    1.5, 0, 0.225,    1.5, - 0.84, 0.225,    0.84, - 1.5, 0.225,    0, - 1.5, 0.225,    1.5, 0, 0.15,    1.5, - 0.84, 0.15,    0.84, - 1.5, 0.15,    0, - 1.5, 0.15,    - 1.12, - 2, 0.45,    - 2, - 1.12, 0.45,    - 2, 0, 0.45,    - 0.84, - 1.5, 0.225,    - 1.5, - 0.84, 0.225,    - 1.5, 0, 0.225,    - 0.84, - 1.5, 0.15,    - 1.5, - 0.84, 0.15,    - 1.5, 0, 0.15,    - 2, 1.12, 0.45,    - 1.12, 2, 0.45,    0, 2, 0.45,    - 1.5, 0.84, 0.225,    - 0.84, 1.5, 0.225,    0, 1.5, 0.225,    - 1.5, 0.84, 0.15,    - 0.84, 1.5, 0.15,    0, 1.5, 0.15,    1.12, 2, 0.45,    2, 1.12, 0.45,    0.84, 1.5, 0.225,    1.5, 0.84, 0.225,    0.84, 1.5, 0.15,    1.5, 0.84, 0.15,    - 1.6, 0, 2.025,    - 1.6, - 0.3, 2.025,    - 1.5, - 0.3, 2.25,    - 1.5, 0, 2.25,    - 2.3, 0, 2.025,    - 2.3, - 0.3, 2.025,    - 2.5, - 0.3, 2.25,    - 2.5, 0, 2.25,    - 2.7, 0, 2.025,    - 2.7, - 0.3, 2.025,    - 3, - 0.3, 2.25,    - 3, 0, 2.25,    - 2.7, 0, 1.8,    - 2.7, - 0.3, 1.8,    - 3, - 0.3, 1.8,    - 3, 0, 1.8,    - 1.5, 0.3, 2.25,    - 1.6, 0.3, 2.025,    - 2.5, 0.3, 2.25,    - 2.3, 0.3, 2.025,    - 3, 0.3, 2.25,    - 2.7, 0.3, 2.025,    - 3, 0.3, 1.8,    - 2.7, 0.3, 1.8,    - 2.7, 0, 1.575,    - 2.7, - 0.3, 1.575,    - 3, - 0.3, 1.35,    - 3, 0, 1.35,    - 2.5, 0, 1.125,    - 2.5, - 0.3, 1.125,    - 2.65, - 0.3, 0.9375,    - 2.65, 0, 0.9375,    - 2, - 0.3, 0.9,    - 1.9, - 0.3, 0.6,    - 1.9, 0, 0.6,    - 3, 0.3, 1.35,    - 2.7, 0.3, 1.575,    - 2.65, 0.3, 0.9375,    - 2.5, 0.3, 1.125,    - 1.9, 0.3, 0.6,    - 2, 0.3, 0.9,    1.7, 0, 1.425,    1.7, - 0.66, 1.425,    1.7, - 0.66, 0.6,    1.7, 0, 0.6,    2.6, 0, 1.425,    2.6, - 0.66, 1.425,    3.1, - 0.66, 0.825,    3.1, 0, 0.825,    2.3, 0, 2.1,    2.3, - 0.25, 2.1,    2.4, - 0.25, 2.025,    2.4, 0, 2.025,    2.7, 0, 2.4,    2.7, - 0.25, 2.4,    3.3, - 0.25, 2.4,    3.3, 0, 2.4,    1.7, 0.66, 0.6,    1.7, 0.66, 1.425,    3.1, 0.66, 0.825,    2.6, 0.66, 1.425,    2.4, 0.25, 2.025,    2.3, 0.25, 2.1,    3.3, 0.25, 2.4,    2.7, 0.25, 2.4,    2.8, 0, 2.475,    2.8, - 0.25, 2.475,    3.525, - 0.25, 2.49375,    3.525, 0, 2.49375,    2.9, 0, 2.475,    2.9, - 0.15, 2.475,    3.45, - 0.15, 2.5125,    3.45, 0, 2.5125,    2.8, 0, 2.4,    2.8, - 0.15, 2.4,    3.2, - 0.15, 2.4,    3.2, 0, 2.4,    3.525, 0.25, 2.49375,    2.8, 0.25, 2.475,    3.45, 0.15, 2.5125,    2.9, 0.15, 2.475,    3.2, 0.15, 2.4,    2.8, 0.15, 2.4,    0, 0, 3.15,    0.8, 0, 3.15,    0.8, - 0.45, 3.15,    0.45, - 0.8, 3.15,    0, - 0.8, 3.15,    0, 0, 2.85,    0.2, 0, 2.7,    0.2, - 0.112, 2.7,    0.112, - 0.2, 2.7,    0, - 0.2, 2.7,    - 0.45, - 0.8, 3.15,    - 0.8, - 0.45, 3.15,    - 0.8, 0, 3.15,    - 0.112, - 0.2, 2.7,    - 0.2, - 0.112, 2.7,    - 0.2, 0, 2.7,    - 0.8, 0.45, 3.15,    - 0.45, 0.8, 3.15,    0, 0.8, 3.15,    - 0.2, 0.112, 2.7,    - 0.112, 0.2, 2.7,    0, 0.2, 2.7,    0.45, 0.8, 3.15,    0.8, 0.45, 3.15,    0.112, 0.2, 2.7,    0.2, 0.112, 2.7,    0.4, 0, 2.55,    0.4, - 0.224, 2.55,    0.224, - 0.4, 2.55,    0, - 0.4, 2.55,    1.3, 0, 2.55,    1.3, - 0.728, 2.55,    0.728, - 1.3, 2.55,    0, - 1.3, 2.55,    1.3, 0, 2.4,    1.3, - 0.728, 2.4,    0.728, - 1.3, 2.4,    0, - 1.3, 2.4,    - 0.224, - 0.4, 2.55,    - 0.4, - 0.224, 2.55,    - 0.4, 0, 2.55,    - 0.728, - 1.3, 2.55,    - 1.3, - 0.728, 2.55,    - 1.3, 0, 2.55,    - 0.728, - 1.3, 2.4,    - 1.3, - 0.728, 2.4,    - 1.3, 0, 2.4,    - 0.4, 0.224, 2.55,    - 0.224, 0.4, 2.55,    0, 0.4, 2.55,    - 1.3, 0.728, 2.55,    - 0.728, 1.3, 2.55,    0, 1.3, 2.55,    - 1.3, 0.728, 2.4,    - 0.728, 1.3, 2.4,    0, 1.3, 2.4,    0.224, 0.4, 2.55,    0.4, 0.224, 2.55,    0.728, 1.3, 2.55,    1.3, 0.728, 2.55,    0.728, 1.3, 2.4,    1.3, 0.728, 2.4,    0, 0, 0,    1.425, 0, 0,    1.425, 0.798, 0,    0.798, 1.425, 0,    0, 1.425, 0,    1.5, 0, 0.075,    1.5, 0.84, 0.075,    0.84, 1.5, 0.075,    0, 1.5, 0.075,    - 0.798, 1.425, 0,    - 1.425, 0.798, 0,    - 1.425, 0, 0,    - 0.84, 1.5, 0.075,    - 1.5, 0.84, 0.075,    - 1.5, 0, 0.075,    - 1.425, - 0.798, 0,    - 0.798, - 1.425, 0,    0, - 1.425, 0,    - 1.5, - 0.84, 0.075,    - 0.84, - 1.5, 0.075,    0, - 1.5, 0.075,    0.798, - 1.425, 0,    1.425, - 0.798, 0,    0.84, - 1.5, 0.075,    1.5, - 0.84, 0.075   ];    super();    // number of segments per patch   segments = Math.max( 2, Math.floor( segments ) );    // Jim Blinn scaled the teapot down in size by about 1.3 for   // some rendering tests. He liked the new proportions that he kept   // the data in this form. The model was distributed with these new   // proportions and became the norm. Trivia: comparing images of the   // real teapot and the computer model, the ratio for the bowl of the   // real teapot is more like 1.25, but since 1.3 is the traditional   // value given, we use it here.   const blinnScale = 1.3;    // scale the size to be the real scaling factor   const maxHeight = 3.15 * ( blinn ? 1 : blinnScale );    const maxHeight2 = maxHeight / 2;   const trueSize = size / maxHeight2;    // Number of elements depends on what is needed. Subtract degenerate   // triangles at tip of bottom and lid out in advance.   let numTriangles = bottom ? ( 8 * segments - 4 ) * segments : 0;   numTriangles += lid ? ( 16 * segments - 4 ) * segments : 0;   numTriangles += body ? 40 * segments * segments : 0;    const indices = new Uint32Array( numTriangles * 3 );    let numVertices = bottom ? 4 : 0;   numVertices += lid ? 8 : 0;   numVertices += body ? 20 : 0;   numVertices *= ( segments + 1 ) * ( segments + 1 );    const vertices = new Float32Array( numVertices * 3 );   const normals = new Float32Array( numVertices * 3 );   const uvs = new Float32Array( numVertices * 2 );    // Bezier form   const ms = new Matrix4();   ms.set(    - 1.0, 3.0, - 3.0, 1.0,    3.0, - 6.0, 3.0, 0.0,    - 3.0, 3.0, 0.0, 0.0,    1.0, 0.0, 0.0, 0.0 );    const g = [];    const sp = [];   const tp = [];   const dsp = [];   const dtp = [];    // M * G * M matrix, sort of see   // http://www.cs.helsinki.fi/group/goa/mallinnus/curves/surfaces.html   const mgm = [];    const vert = [];   const sdir = [];   const tdir = [];    const norm = new Vector3();    let tcoord;    let sval;   let tval;   let p;   let dsval = 0;   let dtval = 0;    const normOut = new Vector3();    const gmx = new Matrix4();   const tmtx = new Matrix4();    const vsp = new Vector4();   const vtp = new Vector4();   const vdsp = new Vector4();   const vdtp = new Vector4();    const vsdir = new Vector3();   const vtdir = new Vector3();    const mst = ms.clone();   mst.transpose();    // internal function: test if triangle has any matching vertices;   // if so, don't save triangle, since it won't display anything.   const notDegenerate = ( vtx1, vtx2, vtx3 ) => // if any vertex matches, return false    ! ( ( ( vertices[ vtx1 * 3 ] === vertices[ vtx2 * 3 ] ) &&      ( vertices[ vtx1 * 3 + 1 ] === vertices[ vtx2 * 3 + 1 ] ) &&      ( vertices[ vtx1 * 3 + 2 ] === vertices[ vtx2 * 3 + 2 ] ) ) ||      ( ( vertices[ vtx1 * 3 ] === vertices[ vtx3 * 3 ] ) &&      ( vertices[ vtx1 * 3 + 1 ] === vertices[ vtx3 * 3 + 1 ] ) &&      ( vertices[ vtx1 * 3 + 2 ] === vertices[ vtx3 * 3 + 2 ] ) ) || ( vertices[ vtx2 * 3 ] === vertices[ vtx3 * 3 ] ) &&      ( vertices[ vtx2 * 3 + 1 ] === vertices[ vtx3 * 3 + 1 ] ) &&      ( vertices[ vtx2 * 3 + 2 ] === vertices[ vtx3 * 3 + 2 ] ) );     for ( let i = 0; i < 3; i ++ ) {     mgm[ i ] = new Matrix4();    }    const minPatches = body ? 0 : 20;   const maxPatches = bottom ? 32 : 28;    const vertPerRow = segments + 1;    let surfCount = 0;    let vertCount = 0;   let normCount = 0;   let uvCount = 0;    let indexCount = 0;    for ( let surf = minPatches; surf < maxPatches; surf ++ ) {     // lid is in the middle of the data, patches 20-27,    // so ignore it for this part of the loop if the lid is not desired    if ( lid || ( surf < 20 || surf >= 28 ) ) {      // get M * G * M matrix for x,y,z     for ( let i = 0; i < 3; i ++ ) {       // get control patches      for ( let r = 0; r < 4; r ++ ) {        for ( let c = 0; c < 4; c ++ ) {         // transposed        g[ c * 4 + r ] = teapotVertices[ teapotPatches[ surf * 16 + r * 4 + c ] * 3 + i ];         // is the lid to be made larger, and is this a point on the lid        // that is X or Y?        if ( fitLid && ( surf >= 20 && surf < 28 ) && ( i !== 2 ) ) {          // increase XY size by 7.7%, found empirically. I don't         // increase Z so that the teapot will continue to fit in the         // space -1 to 1 for Y (Y is up for the final model).         g[ c * 4 + r ] *= 1.077;         }         // Blinn "fixed" the teapot by dividing Z by blinnScale, and that's the        // data we now use. The original teapot is taller. Fix it:        if ( ! blinn && ( i === 2 ) ) {          g[ c * 4 + r ] *= blinnScale;         }        }       }       gmx.set( g[ 0 ], g[ 1 ], g[ 2 ], g[ 3 ], g[ 4 ], g[ 5 ], g[ 6 ], g[ 7 ], g[ 8 ], g[ 9 ], g[ 10 ], g[ 11 ], g[ 12 ], g[ 13 ], g[ 14 ], g[ 15 ] );       tmtx.multiplyMatrices( gmx, ms );      mgm[ i ].multiplyMatrices( mst, tmtx );      }      // step along, get points, and output     for ( let sstep = 0; sstep <= segments; sstep ++ ) {       const s = sstep / segments;       for ( let tstep = 0; tstep <= segments; tstep ++ ) {        const t = tstep / segments;        // point from basis       // get power vectors and their derivatives       for ( p = 4, sval = tval = 1.0; p --; ) {         sp[ p ] = sval;        tp[ p ] = tval;        sval *= s;        tval *= t;         if ( p === 3 ) {          dsp[ p ] = dtp[ p ] = 0.0;         dsval = dtval = 1.0;         } else {          dsp[ p ] = dsval * ( 3 - p );         dtp[ p ] = dtval * ( 3 - p );         dsval *= s;         dtval *= t;         }        }        vsp.fromArray( sp );       vtp.fromArray( tp );       vdsp.fromArray( dsp );       vdtp.fromArray( dtp );        // do for x,y,z       for ( let i = 0; i < 3; i ++ ) {         // multiply power vectors times matrix to get value        tcoord = vsp.clone();        tcoord.applyMatrix4( mgm[ i ] );        vert[ i ] = tcoord.dot( vtp );         // get s and t tangent vectors        tcoord = vdsp.clone();        tcoord.applyMatrix4( mgm[ i ] );        sdir[ i ] = tcoord.dot( vtp );         tcoord = vsp.clone();        tcoord.applyMatrix4( mgm[ i ] );        tdir[ i ] = tcoord.dot( vdtp );        }        // find normal       vsdir.fromArray( sdir );       vtdir.fromArray( tdir );       norm.crossVectors( vtdir, vsdir );       norm.normalize();        // if X and Z length is 0, at the cusp, so point the normal up or down, depending on patch number       if ( vert[ 0 ] === 0 && vert[ 1 ] === 0 ) {         // if above the middle of the teapot, normal points up, else down        normOut.set( 0, vert[ 2 ] > maxHeight2 ? 1 : - 1, 0 );        } else {         // standard output: rotate on X axis        normOut.set( norm.x, norm.z, - norm.y );        }        // store it all       vertices[ vertCount ++ ] = trueSize * vert[ 0 ];       vertices[ vertCount ++ ] = trueSize * ( vert[ 2 ] - maxHeight2 );       vertices[ vertCount ++ ] = - trueSize * vert[ 1 ];        normals[ normCount ++ ] = normOut.x;       normals[ normCount ++ ] = normOut.y;       normals[ normCount ++ ] = normOut.z;        uvs[ uvCount ++ ] = 1 - t;       uvs[ uvCount ++ ] = 1 - s;       }      }      // save the faces     for ( let sstep = 0; sstep < segments; sstep ++ ) {       for ( let tstep = 0; tstep < segments; tstep ++ ) {        const v1 = surfCount * vertPerRow * vertPerRow + sstep * vertPerRow + tstep;       const v2 = v1 + 1;       const v3 = v2 + vertPerRow;       const v4 = v1 + vertPerRow;        // Normals and UVs cannot be shared. Without clone(), you can see the consequences       // of sharing if you call geometry.applyMatrix4( matrix ).       if ( notDegenerate( v1, v2, v3 ) ) {         indices[ indexCount ++ ] = v1;        indices[ indexCount ++ ] = v2;        indices[ indexCount ++ ] = v3;        }        if ( notDegenerate( v1, v3, v4 ) ) {         indices[ indexCount ++ ] = v1;        indices[ indexCount ++ ] = v3;        indices[ indexCount ++ ] = v4;        }       }      }      // increment only if a surface was used     surfCount ++;     }    }    this.setIndex( new BufferAttribute( indices, 1 ) );   this.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );   this.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );   this.setAttribute( 'uv', new BufferAttribute( uvs, 2 ) );    this.computeBoundingSphere();   }  }  export { TeapotGeometry }; 
^..^ FILENAME ^..^
addons|geometries|TextGeometry.js
^..^ CONTENTS ^..^
/**  * Text = 3D Text  *  * parameters = {  *  font: <THREE.Font>, // font  *  *  size: <float>, // size of the text  *  depth: <float>, // thickness to extrude text  *  curveSegments: <int>, // number of points on the curves  *  *  bevelEnabled: <bool>, // turn on bevel  *  bevelThickness: <float>, // how deep into text bevel goes  *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel  *  bevelOffset: <float> // how far from text outline does bevel start  * }  */  import {  ExtrudeGeometry } from 'three';  class TextGeometry extends ExtrudeGeometry {   constructor( text, parameters = {} ) {    const font = parameters.font;    if ( font === undefined ) {     super(); // generate default extrude geometry    } else {     const shapes = font.generateShapes( text, parameters.size );     // translate parameters to ExtrudeGeometry API     if ( parameters.depth === undefined && parameters.height !== undefined ) {      console.warn( 'THREE.TextGeometry: .height is now depreciated. Please use .depth instead' ); // @deprecated, r163     }     parameters.depth = parameters.depth !== undefined ?     parameters.depth : parameters.height !== undefined ?      parameters.height : 50;     // defaults     if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;    if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;    if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;     super( shapes, parameters );    }    this.type = 'TextGeometry';   }  }   export { TextGeometry }; 
^..^ FILENAME ^..^
addons|helpers|LightProbeHelper.js
^..^ CONTENTS ^..^
import {  Mesh,  ShaderMaterial,  SphereGeometry } from 'three';  class LightProbeHelper extends Mesh {   constructor( lightProbe, size = 1 ) {    const material = new ShaderMaterial( {     type: 'LightProbeHelperMaterial',     uniforms: {      sh: { value: lightProbe.sh.coefficients }, // by reference      intensity: { value: lightProbe.intensity }     },     vertexShader: /* glsl */|      varying vec3 vNormal;      void main() {       vNormal = normalize( normalMatrix * normal );       gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );      }     |,     fragmentShader: /* glsl */|      #define RECIPROCAL_PI 0.318309886      vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {       // matrix is assumed to be orthogonal       return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );      }      // source: https://graphics.stanford.edu/papers/envmap/envmap.pdf,     vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {       // normal is assumed to have unit length,       float x = normal.x, y = normal.y, z = normal.z;       // band 0,      vec3 result = shCoefficients[ 0 ] * 0.886227;       // band 1,      result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;      result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;      result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;       // band 2,      result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;      result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;      result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );      result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;      result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );      return result;      }      uniform vec3 sh[ 9 ]; // sh coefficients      uniform float intensity; // light probe intensity      varying vec3 vNormal;      void main() {       vec3 normal = normalize( vNormal );       vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );       vec3 irradiance = shGetIrradianceAt( worldNormal, sh );       vec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;       gl_FragColor = linearToOutputTexel( vec4( outgoingLight, 1.0 ) );      }     |,    } );    const geometry = new SphereGeometry( 1, 32, 16 );    super( geometry, material );    this.lightProbe = lightProbe;   this.size = size;   this.type = 'LightProbeHelper';    this.onBeforeRender();   }   dispose() {    this.geometry.dispose();   this.material.dispose();   }   onBeforeRender() {    this.position.copy( this.lightProbe.position );    this.scale.set( 1, 1, 1 ).multiplyScalar( this.size );    this.material.uniforms.intensity.value = this.lightProbe.intensity;   }  }  export { LightProbeHelper }; 
^..^ FILENAME ^..^
addons|helpers|LightProbeHelperGPU.js
^..^ CONTENTS ^..^
import {  Mesh,  NodeMaterial,  SphereGeometry } from 'three'; import { float, Fn, getShIrradianceAt, normalWorld, uniformArray, uniform, vec4 } from 'three/tsl';  class LightProbeHelper extends Mesh {   constructor( lightProbe, size = 1 ) {    const sh = uniformArray( lightProbe.sh.coefficients );   const intensity = uniform( lightProbe.intensity );    const RECIPROCAL_PI = float( 1 / Math.PI );    const fragmentNode = Fn( () => {     const irradiance = getShIrradianceAt( normalWorld, sh );     const outgoingLight = RECIPROCAL_PI.mul( irradiance ).mul( intensity );     return vec4( outgoingLight, 1.0 );    } )();    const material = new NodeMaterial();   material.fragmentNode = fragmentNode;    const geometry = new SphereGeometry( 1, 32, 16 );    super( geometry, material );    this.lightProbe = lightProbe;   this.size = size;   this.type = 'LightProbeHelper';    this._intensity = intensity;   this._sh = sh;    this.onBeforeRender();   }   dispose() {    this.geometry.dispose();   this.material.dispose();   }   onBeforeRender() {    this.position.copy( this.lightProbe.position );    this.scale.set( 1, 1, 1 ).multiplyScalar( this.size );    this._intensity.value = this.lightProbe.intensity;   this._sh.array = this.lightProbe.sh.coefficients;   }  }  export { LightProbeHelper }; 
^..^ FILENAME ^..^
addons|helpers|OctreeHelper.js
^..^ CONTENTS ^..^
import {  LineSegments,  BufferGeometry,  Float32BufferAttribute,  LineBasicMaterial } from 'three';  class OctreeHelper extends LineSegments {   constructor( octree, color = 0xffff00 ) {    super( new BufferGeometry(), new LineBasicMaterial( { color: color, toneMapped: false } ) );    this.octree = octree;   this.color = color;    this.type = 'OctreeHelper';    this.update();   }   update() {    const vertices = [];    function traverse( tree ) {     for ( let i = 0; i < tree.length; i ++ ) {      const min = tree[ i ].box.min;     const max = tree[ i ].box.max;      vertices.push( max.x, max.y, max.z ); vertices.push( min.x, max.y, max.z ); // 0, 1     vertices.push( min.x, max.y, max.z ); vertices.push( min.x, min.y, max.z ); // 1, 2     vertices.push( min.x, min.y, max.z ); vertices.push( max.x, min.y, max.z ); // 2, 3     vertices.push( max.x, min.y, max.z ); vertices.push( max.x, max.y, max.z ); // 3, 0      vertices.push( max.x, max.y, min.z ); vertices.push( min.x, max.y, min.z ); // 4, 5     vertices.push( min.x, max.y, min.z ); vertices.push( min.x, min.y, min.z ); // 5, 6     vertices.push( min.x, min.y, min.z ); vertices.push( max.x, min.y, min.z ); // 6, 7     vertices.push( max.x, min.y, min.z ); vertices.push( max.x, max.y, min.z ); // 7, 4      vertices.push( max.x, max.y, max.z ); vertices.push( max.x, max.y, min.z ); // 0, 4     vertices.push( min.x, max.y, max.z ); vertices.push( min.x, max.y, min.z ); // 1, 5     vertices.push( min.x, min.y, max.z ); vertices.push( min.x, min.y, min.z ); // 2, 6     vertices.push( max.x, min.y, max.z ); vertices.push( max.x, min.y, min.z ); // 3, 7      traverse( tree[ i ].subTrees );     }    }    traverse( this.octree.subTrees );    this.geometry.dispose();    this.geometry = new BufferGeometry();   this.geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );   }   dispose() {    this.geometry.dispose();   this.material.dispose();   }  }  export { OctreeHelper }; 
^..^ FILENAME ^..^
addons|helpers|PositionalAudioHelper.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  BufferAttribute,  LineBasicMaterial,  Line,  MathUtils } from 'three';  class PositionalAudioHelper extends Line {   constructor( audio, range = 1, divisionsInnerAngle = 16, divisionsOuterAngle = 2 ) {    const geometry = new BufferGeometry();   const divisions = divisionsInnerAngle + divisionsOuterAngle * 2;   const positions = new Float32Array( ( divisions * 3 + 3 ) * 3 );   geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );    const materialInnerAngle = new LineBasicMaterial( { color: 0x00ff00 } );   const materialOuterAngle = new LineBasicMaterial( { color: 0xffff00 } );    super( geometry, [ materialOuterAngle, materialInnerAngle ] );    this.audio = audio;   this.range = range;   this.divisionsInnerAngle = divisionsInnerAngle;   this.divisionsOuterAngle = divisionsOuterAngle;   this.type = 'PositionalAudioHelper';    this.update();   }   update() {    const audio = this.audio;   const range = this.range;   const divisionsInnerAngle = this.divisionsInnerAngle;   const divisionsOuterAngle = this.divisionsOuterAngle;    const coneInnerAngle = MathUtils.degToRad( audio.panner.coneInnerAngle );   const coneOuterAngle = MathUtils.degToRad( audio.panner.coneOuterAngle );    const halfConeInnerAngle = coneInnerAngle / 2;   const halfConeOuterAngle = coneOuterAngle / 2;    let start = 0;   let count = 0;   let i;   let stride;    const geometry = this.geometry;   const positionAttribute = geometry.attributes.position;    geometry.clearGroups();    //    function generateSegment( from, to, divisions, materialIndex ) {     const step = ( to - from ) / divisions;     positionAttribute.setXYZ( start, 0, 0, 0 );    count ++;     for ( i = from; i < to; i += step ) {      stride = start + count;      positionAttribute.setXYZ( stride, Math.sin( i ) * range, 0, Math.cos( i ) * range );     positionAttribute.setXYZ( stride + 1, Math.sin( Math.min( i + step, to ) ) * range, 0, Math.cos( Math.min( i + step, to ) ) * range );     positionAttribute.setXYZ( stride + 2, 0, 0, 0 );      count += 3;     }     geometry.addGroup( start, count, materialIndex );     start += count;    count = 0;    }    //    generateSegment( - halfConeOuterAngle, - halfConeInnerAngle, divisionsOuterAngle, 0 );   generateSegment( - halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1 );   generateSegment( halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0 );    //    positionAttribute.needsUpdate = true;    if ( coneInnerAngle === coneOuterAngle ) this.material[ 0 ].visible = false;   }   dispose() {    this.geometry.dispose();   this.material[ 0 ].dispose();   this.material[ 1 ].dispose();   }  }   export { PositionalAudioHelper }; 
^..^ FILENAME ^..^
addons|helpers|RectAreaLightHelper.js
^..^ CONTENTS ^..^
import {  BackSide,  BufferGeometry,  Float32BufferAttribute,  Line,  LineBasicMaterial,  Mesh,  MeshBasicMaterial } from 'three';  /**  *  This helper must be added as a child of the light  */  class RectAreaLightHelper extends Line {   constructor( light, color ) {    const positions = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];    const geometry = new BufferGeometry();   geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );   geometry.computeBoundingSphere();    const material = new LineBasicMaterial( { fog: false } );    super( geometry, material );    this.light = light;   this.color = color; // optional hardwired color for the helper   this.type = 'RectAreaLightHelper';    //    const positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];    const geometry2 = new BufferGeometry();   geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );   geometry2.computeBoundingSphere();    this.add( new Mesh( geometry2, new MeshBasicMaterial( { side: BackSide, fog: false } ) ) );   }   updateMatrixWorld() {    this.scale.set( 0.5 * this.light.width, 0.5 * this.light.height, 1 );    if ( this.color !== undefined ) {     this.material.color.set( this.color );    this.children[ 0 ].material.color.set( this.color );    } else {     this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );     // prevent hue shift    const c = this.material.color;    const max = Math.max( c.r, c.g, c.b );    if ( max > 1 ) c.multiplyScalar( 1 / max );     this.children[ 0 ].material.color.copy( this.material.color );    }    // ignore world scale on light   this.matrixWorld.extractRotation( this.light.matrixWorld ).scale( this.scale ).copyPosition( this.light.matrixWorld );    this.children[ 0 ].matrixWorld.copy( this.matrixWorld );   }   dispose() {    this.geometry.dispose();   this.material.dispose();   this.children[ 0 ].geometry.dispose();   this.children[ 0 ].material.dispose();   }  }  export { RectAreaLightHelper }; 
^..^ FILENAME ^..^
addons|helpers|TextureHelper.js
^..^ CONTENTS ^..^
import {  BoxGeometry,  BufferAttribute,  DoubleSide,  Mesh,  PlaneGeometry,  ShaderMaterial,  Vector3, } from 'three'; import { mergeGeometries } from '../utils/BufferGeometryUtils.js';  class TextureHelper extends Mesh {   constructor( texture, width = 1, height = 1, depth = 1 ) {    const material = new ShaderMaterial( {     type: 'TextureHelperMaterial',     side: DoubleSide,    transparent: true,     uniforms: {      map: { value: texture },     alpha: { value: getAlpha( texture ) },     },     vertexShader: [      'attribute vec3 uvw;',      'varying vec3 vUvw;',      'void main() {',      ' vUvw = uvw;',      ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',      '}',     ].join( '|n' ),     fragmentShader: [      'precision highp float;',      'precision highp sampler2DArray;',      'precision highp sampler3D;',      'uniform {samplerType} map;',      'uniform float alpha;',      'varying vec3 vUvw;',      'vec4 textureHelper( in sampler2D map ) { return texture( map, vUvw.xy ); }',      'vec4 textureHelper( in sampler2DArray map ) { return texture( map, vUvw ); }',      'vec4 textureHelper( in sampler3D map ) { return texture( map, vUvw ); }',      'vec4 textureHelper( in samplerCube map ) { return texture( map, vUvw ); }',      'void main() {',      ' gl_FragColor = linearToOutputTexel( vec4( textureHelper( map ).xyz, alpha ) );',      '}'     ].join( '|n' ).replace( '{samplerType}', getSamplerType( texture ) )    } );    const geometry = texture.isCubeTexture    ? createCubeGeometry( width, height, depth )    : createSliceGeometry( texture, width, height, depth );    super( geometry, material );    this.texture = texture;   this.type = 'TextureHelper';   }   dispose() {    this.geometry.dispose();   this.material.dispose();   }  }  function getSamplerType( texture ) {   if ( texture.isCubeTexture ) {    return 'samplerCube';   } else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {    return 'sampler2DArray';   } else if ( texture.isData3DTexture || texture.isCompressed3DTexture ) {    return 'sampler3D';   } else {    return 'sampler2D';   }  }  function getImageCount( texture ) {   if ( texture.isCubeTexture ) {    return 6;   } else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {    return texture.image.depth;   } else if ( texture.isData3DTexture || texture.isCompressed3DTexture ) {    return texture.image.depth;   } else {    return 1;   }  }  function getAlpha( texture ) {   if ( texture.isCubeTexture ) {    return 1;   } else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {    return Math.max( 1 / texture.image.depth, 0.25 );   } else if ( texture.isData3DTexture || texture.isCompressed3DTexture ) {    return Math.max( 1 / texture.image.depth, 0.25 );   } else {    return 1;   }  }  function createCubeGeometry( width, height, depth ) {   const geometry = new BoxGeometry( width, height, depth );   const position = geometry.attributes.position;  const uv = geometry.attributes.uv;  const uvw = new BufferAttribute( new Float32Array( uv.count * 3 ), 3 );   const _direction = new Vector3();   for ( let j = 0, jl = uv.count; j < jl; ++ j ) {    _direction.fromBufferAttribute( position, j ).normalize();    const u = _direction.x;   const v = _direction.y;   const w = _direction.z;    uvw.setXYZ( j, u, v, w );   }   geometry.deleteAttribute( 'uv' );  geometry.setAttribute( 'uvw', uvw );   return geometry;  }  function createSliceGeometry( texture, width, height, depth ) {   const sliceCount = getImageCount( texture );   const geometries = [];   for ( let i = 0; i < sliceCount; ++ i ) {    const geometry = new PlaneGeometry( width, height );    if ( sliceCount > 1 ) {     geometry.translate( 0, 0, depth * ( i / ( sliceCount - 1 ) - 0.5 ) );    }    const uv = geometry.attributes.uv;   const uvw = new BufferAttribute( new Float32Array( uv.count * 3 ), 3 );    for ( let j = 0, jl = uv.count; j < jl; ++ j ) {     const u = uv.getX( j );    const v = texture.flipY ? uv.getY( j ) : 1 - uv.getY( j );    const w = sliceCount === 1     ? 1     : texture.isDataArrayTexture || texture.isCompressedArrayTexture      ? i      : i / ( sliceCount - 1 );     uvw.setXYZ( j, u, v, w );    }    geometry.deleteAttribute( 'uv' );   geometry.setAttribute( 'uvw', uvw );    geometries.push( geometry );   }   return mergeGeometries( geometries );  }  export { TextureHelper }; 
^..^ FILENAME ^..^
addons|helpers|VertexNormalsHelper.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  Float32BufferAttribute,  LineSegments,  LineBasicMaterial,  Matrix3,  Vector3 } from 'three';  const _v1 = new Vector3(); const _v2 = new Vector3(); const _normalMatrix = new Matrix3();  class VertexNormalsHelper extends LineSegments {   constructor( object, size = 1, color = 0xff0000 ) {    const geometry = new BufferGeometry();    const nNormals = object.geometry.attributes.normal.count;   const positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );    geometry.setAttribute( 'position', positions );    super( geometry, new LineBasicMaterial( { color, toneMapped: false } ) );    this.object = object;   this.size = size;   this.type = 'VertexNormalsHelper';    //    this.matrixAutoUpdate = false;    this.update();   }   update() {    this.object.updateMatrixWorld( true );    _normalMatrix.getNormalMatrix( this.object.matrixWorld );    const matrixWorld = this.object.matrixWorld;    const position = this.geometry.attributes.position;    //    const objGeometry = this.object.geometry;    if ( objGeometry ) {     const objPos = objGeometry.attributes.position;     const objNorm = objGeometry.attributes.normal;     let idx = 0;     // for simplicity, ignore index and drawcalls, and render every normal     for ( let j = 0, jl = objPos.count; j < jl; j ++ ) {      _v1.fromBufferAttribute( objPos, j ).applyMatrix4( matrixWorld );      _v2.fromBufferAttribute( objNorm, j );      _v2.applyMatrix3( _normalMatrix ).normalize().multiplyScalar( this.size ).add( _v1 );      position.setXYZ( idx, _v1.x, _v1.y, _v1.z );      idx = idx + 1;      position.setXYZ( idx, _v2.x, _v2.y, _v2.z );      idx = idx + 1;     }    }    position.needsUpdate = true;   }   dispose() {    this.geometry.dispose();   this.material.dispose();   }  }  export { VertexNormalsHelper }; 
^..^ FILENAME ^..^
addons|helpers|VertexTangentsHelper.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  Float32BufferAttribute,  LineSegments,  LineBasicMaterial,  Vector3 } from 'three';  const _v1 = new Vector3(); const _v2 = new Vector3();  class VertexTangentsHelper extends LineSegments {   constructor( object, size = 1, color = 0x00ffff ) {    const geometry = new BufferGeometry();    const nTangents = object.geometry.attributes.tangent.count;   const positions = new Float32BufferAttribute( nTangents * 2 * 3, 3 );    geometry.setAttribute( 'position', positions );    super( geometry, new LineBasicMaterial( { color, toneMapped: false } ) );    this.object = object;   this.size = size;   this.type = 'VertexTangentsHelper';    //    this.matrixAutoUpdate = false;    this.update();   }   update() {    this.object.updateMatrixWorld( true );    const matrixWorld = this.object.matrixWorld;    const position = this.geometry.attributes.position;    //    const objGeometry = this.object.geometry;    const objPos = objGeometry.attributes.position;    const objTan = objGeometry.attributes.tangent;    let idx = 0;    // for simplicity, ignore index and drawcalls, and render every tangent    for ( let j = 0, jl = objPos.count; j < jl; j ++ ) {     _v1.fromBufferAttribute( objPos, j ).applyMatrix4( matrixWorld );     _v2.fromBufferAttribute( objTan, j );     _v2.transformDirection( matrixWorld ).multiplyScalar( this.size ).add( _v1 );     position.setXYZ( idx, _v1.x, _v1.y, _v1.z );     idx = idx + 1;     position.setXYZ( idx, _v2.x, _v2.y, _v2.z );     idx = idx + 1;    }    position.needsUpdate = true;   }   dispose() {    this.geometry.dispose();   this.material.dispose();   }  }  export { VertexTangentsHelper }; 
^..^ FILENAME ^..^
addons|helpers|ViewHelper.js
^..^ CONTENTS ^..^
import {  CylinderGeometry,  CanvasTexture,  Color,  Euler,  Mesh,  MeshBasicMaterial,  Object3D,  OrthographicCamera,  Quaternion,  Raycaster,  Sprite,  SpriteMaterial,  SRGBColorSpace,  Vector2,  Vector3,  Vector4 } from 'three';  class ViewHelper extends Object3D {   constructor( camera, domElement ) {    super();    this.isViewHelper = true;    this.animating = false;   this.center = new Vector3();    const color1 = new Color( '#ff4466' );   const color2 = new Color( '#88ff44' );   const color3 = new Color( '#4488ff' );   const color4 = new Color( '#000000' );    const options = {};    const interactiveObjects = [];   const raycaster = new Raycaster();   const mouse = new Vector2();   const dummy = new Object3D();    const orthoCamera = new OrthographicCamera( - 2, 2, 2, - 2, 0, 4 );   orthoCamera.position.set( 0, 0, 2 );    const geometry = new CylinderGeometry( 0.04, 0.04, 0.8, 5 ).rotateZ( - Math.PI / 2 ).translate( 0.4, 0, 0 );    const xAxis = new Mesh( geometry, getAxisMaterial( color1 ) );   const yAxis = new Mesh( geometry, getAxisMaterial( color2 ) );   const zAxis = new Mesh( geometry, getAxisMaterial( color3 ) );    yAxis.rotation.z = Math.PI / 2;   zAxis.rotation.y = - Math.PI / 2;    this.add( xAxis );   this.add( zAxis );   this.add( yAxis );    const spriteMaterial1 = getSpriteMaterial( color1 );   const spriteMaterial2 = getSpriteMaterial( color2 );   const spriteMaterial3 = getSpriteMaterial( color3 );   const spriteMaterial4 = getSpriteMaterial( color4 );    const posXAxisHelper = new Sprite( spriteMaterial1 );   const posYAxisHelper = new Sprite( spriteMaterial2 );   const posZAxisHelper = new Sprite( spriteMaterial3 );   const negXAxisHelper = new Sprite( spriteMaterial4 );   const negYAxisHelper = new Sprite( spriteMaterial4 );   const negZAxisHelper = new Sprite( spriteMaterial4 );    posXAxisHelper.position.x = 1;   posYAxisHelper.position.y = 1;   posZAxisHelper.position.z = 1;   negXAxisHelper.position.x = - 1;   negYAxisHelper.position.y = - 1;   negZAxisHelper.position.z = - 1;    negXAxisHelper.material.opacity = 0.2;   negYAxisHelper.material.opacity = 0.2;   negZAxisHelper.material.opacity = 0.2;    posXAxisHelper.userData.type = 'posX';   posYAxisHelper.userData.type = 'posY';   posZAxisHelper.userData.type = 'posZ';   negXAxisHelper.userData.type = 'negX';   negYAxisHelper.userData.type = 'negY';   negZAxisHelper.userData.type = 'negZ';    this.add( posXAxisHelper );   this.add( posYAxisHelper );   this.add( posZAxisHelper );   this.add( negXAxisHelper );   this.add( negYAxisHelper );   this.add( negZAxisHelper );    interactiveObjects.push( posXAxisHelper );   interactiveObjects.push( posYAxisHelper );   interactiveObjects.push( posZAxisHelper );   interactiveObjects.push( negXAxisHelper );   interactiveObjects.push( negYAxisHelper );   interactiveObjects.push( negZAxisHelper );    const point = new Vector3();   const dim = 128;   const turnRate = 2 * Math.PI; // turn rate in angles per second    this.render = function ( renderer ) {     this.quaternion.copy( camera.quaternion ).invert();    this.updateMatrixWorld();     point.set( 0, 0, 1 );    point.applyQuaternion( camera.quaternion );     //     const x = domElement.offsetWidth - dim;     renderer.clearDepth();     renderer.getViewport( viewport );    renderer.setViewport( x, 0, dim, dim );     renderer.render( this, orthoCamera );     renderer.setViewport( viewport.x, viewport.y, viewport.z, viewport.w );    };    const targetPosition = new Vector3();   const targetQuaternion = new Quaternion();    const q1 = new Quaternion();   const q2 = new Quaternion();   const viewport = new Vector4();   let radius = 0;    this.handleClick = function ( event ) {     if ( this.animating === true ) return false;     const rect = domElement.getBoundingClientRect();    const offsetX = rect.left + ( domElement.offsetWidth - dim );    const offsetY = rect.top + ( domElement.offsetHeight - dim );    mouse.x = ( ( event.clientX - offsetX ) / ( rect.right - offsetX ) ) * 2 - 1;    mouse.y = - ( ( event.clientY - offsetY ) / ( rect.bottom - offsetY ) ) * 2 + 1;     raycaster.setFromCamera( mouse, orthoCamera );     const intersects = raycaster.intersectObjects( interactiveObjects );     if ( intersects.length > 0 ) {      const intersection = intersects[ 0 ];     const object = intersection.object;      prepareAnimationData( object, this.center );      this.animating = true;      return true;     } else {      return false;     }    };    this.setLabels = function ( labelX, labelY, labelZ ) {     options.labelX = labelX;    options.labelY = labelY;    options.labelZ = labelZ;     updateLabels();    };    this.setLabelStyle = function ( font, color, radius ) {     options.font = font;    options.color = color;    options.radius = radius;     updateLabels();    };    this.update = function ( delta ) {     const step = delta * turnRate;     // animate position by doing a slerp and then scaling the position on the unit sphere     q1.rotateTowards( q2, step );    camera.position.set( 0, 0, 1 ).applyQuaternion( q1 ).multiplyScalar( radius ).add( this.center );     // animate orientation     camera.quaternion.rotateTowards( targetQuaternion, step );     if ( q1.angleTo( q2 ) === 0 ) {      this.animating = false;     }    };    this.dispose = function () {     geometry.dispose();     xAxis.material.dispose();    yAxis.material.dispose();    zAxis.material.dispose();     posXAxisHelper.material.map.dispose();    posYAxisHelper.material.map.dispose();    posZAxisHelper.material.map.dispose();    negXAxisHelper.material.map.dispose();    negYAxisHelper.material.map.dispose();    negZAxisHelper.material.map.dispose();     posXAxisHelper.material.dispose();    posYAxisHelper.material.dispose();    posZAxisHelper.material.dispose();    negXAxisHelper.material.dispose();    negYAxisHelper.material.dispose();    negZAxisHelper.material.dispose();    };    function prepareAnimationData( object, focusPoint ) {     switch ( object.userData.type ) {      case 'posX':      targetPosition.set( 1, 0, 0 );      targetQuaternion.setFromEuler( new Euler( 0, Math.PI * 0.5, 0 ) );      break;      case 'posY':      targetPosition.set( 0, 1, 0 );      targetQuaternion.setFromEuler( new Euler( - Math.PI * 0.5, 0, 0 ) );      break;      case 'posZ':      targetPosition.set( 0, 0, 1 );      targetQuaternion.setFromEuler( new Euler() );      break;      case 'negX':      targetPosition.set( - 1, 0, 0 );      targetQuaternion.setFromEuler( new Euler( 0, - Math.PI * 0.5, 0 ) );      break;      case 'negY':      targetPosition.set( 0, - 1, 0 );      targetQuaternion.setFromEuler( new Euler( Math.PI * 0.5, 0, 0 ) );      break;      case 'negZ':      targetPosition.set( 0, 0, - 1 );      targetQuaternion.setFromEuler( new Euler( 0, Math.PI, 0 ) );      break;      default:      console.error( 'ViewHelper: Invalid axis.' );     }     //     radius = camera.position.distanceTo( focusPoint );    targetPosition.multiplyScalar( radius ).add( focusPoint );     dummy.position.copy( focusPoint );     dummy.lookAt( camera.position );    q1.copy( dummy.quaternion );     dummy.lookAt( targetPosition );    q2.copy( dummy.quaternion );    }    function getAxisMaterial( color ) {     return new MeshBasicMaterial( { color: color, toneMapped: false } );    }    function getSpriteMaterial( color, text ) {     const { font = '24px Arial', color: labelColor = '#000000', radius = 14 } = options;     const canvas = document.createElement( 'canvas' );    canvas.width = 64;    canvas.height = 64;     const context = canvas.getContext( '2d' );    context.beginPath();    context.arc( 32, 32, radius, 0, 2 * Math.PI );    context.closePath();    context.fillStyle = color.getStyle();    context.fill();     if ( text ) {      context.font = font;     context.textAlign = 'center';     context.fillStyle = labelColor;     context.fillText( text, 32, 41 );     }     const texture = new CanvasTexture( canvas );    texture.colorSpace = SRGBColorSpace;     return new SpriteMaterial( { map: texture, toneMapped: false } );    }    function updateLabels() {     posXAxisHelper.material.map.dispose();    posYAxisHelper.material.map.dispose();    posZAxisHelper.material.map.dispose();     posXAxisHelper.material.dispose();    posYAxisHelper.material.dispose();    posZAxisHelper.material.dispose();     posXAxisHelper.material = getSpriteMaterial( color1, options.labelX );    posYAxisHelper.material = getSpriteMaterial( color2, options.labelY );    posZAxisHelper.material = getSpriteMaterial( color3, options.labelZ );    }   }  }  export { ViewHelper }; 
^..^ FILENAME ^..^
addons|interactive|HTMLMesh.js
^..^ CONTENTS ^..^
import {  CanvasTexture,  LinearFilter,  Mesh,  MeshBasicMaterial,  PlaneGeometry,  SRGBColorSpace,  Color } from 'three';  class HTMLMesh extends Mesh {   constructor( dom ) {    const texture = new HTMLTexture( dom );    const geometry = new PlaneGeometry( texture.image.width * 0.001, texture.image.height * 0.001 );   const material = new MeshBasicMaterial( { map: texture, toneMapped: false, transparent: true } );    super( geometry, material );    function onEvent( event ) {     material.map.dispatchDOMEvent( event );    }    this.addEventListener( 'mousedown', onEvent );   this.addEventListener( 'mousemove', onEvent );   this.addEventListener( 'mouseup', onEvent );   this.addEventListener( 'click', onEvent );    this.dispose = function () {     geometry.dispose();    material.dispose();     material.map.dispose();     canvases.delete( dom );     this.removeEventListener( 'mousedown', onEvent );    this.removeEventListener( 'mousemove', onEvent );    this.removeEventListener( 'mouseup', onEvent );    this.removeEventListener( 'click', onEvent );    };   }  }  class HTMLTexture extends CanvasTexture {   constructor( dom ) {    super( html2canvas( dom ) );    this.dom = dom;    this.anisotropy = 16;   this.colorSpace = SRGBColorSpace;   this.minFilter = LinearFilter;   this.magFilter = LinearFilter;    // Create an observer on the DOM, and run html2canvas update in the next loop   const observer = new MutationObserver( () => {     if ( ! this.scheduleUpdate ) {      // ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer     this.scheduleUpdate = setTimeout( () => this.update(), 16 );     }    } );    const config = { attributes: true, childList: true, subtree: true, characterData: true };   observer.observe( dom, config );    this.observer = observer;   }   dispatchDOMEvent( event ) {    if ( event.data ) {     htmlevent( this.dom, event.type, event.data.x, event.data.y );    }   }   update() {    this.image = html2canvas( this.dom );   this.needsUpdate = true;    this.scheduleUpdate = null;   }   dispose() {    if ( this.observer ) {     this.observer.disconnect();    }    this.scheduleUpdate = clearTimeout( this.scheduleUpdate );    super.dispose();   }  }   //  const canvases = new WeakMap();  function html2canvas( element ) {   const range = document.createRange();  const color = new Color();   function Clipper( context ) {    const clips = [];   let isClipping = false;    function doClip() {     if ( isClipping ) {      isClipping = false;     context.restore();     }     if ( clips.length === 0 ) return;     let minX = - Infinity, minY = - Infinity;    let maxX = Infinity, maxY = Infinity;     for ( let i = 0; i < clips.length; i ++ ) {      const clip = clips[ i ];      minX = Math.max( minX, clip.x );     minY = Math.max( minY, clip.y );     maxX = Math.min( maxX, clip.x + clip.width );     maxY = Math.min( maxY, clip.y + clip.height );     }     context.save();    context.beginPath();    context.rect( minX, minY, maxX - minX, maxY - minY );    context.clip();     isClipping = true;    }    return {     add: function ( clip ) {      clips.push( clip );     doClip();     },     remove: function () {      clips.pop();     doClip();     }    };   }   function drawText( style, x, y, string ) {    if ( string !== '' ) {     if ( style.textTransform === 'uppercase' ) {      string = string.toUpperCase();     }     context.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;    context.textBaseline = 'top';    context.fillStyle = style.color;    context.fillText( string, x, y + parseFloat( style.fontSize ) * 0.1 );    }   }   function buildRectPath( x, y, w, h, r ) {    if ( w < 2 * r ) r = w / 2;   if ( h < 2 * r ) r = h / 2;    context.beginPath();   context.moveTo( x + r, y );   context.arcTo( x + w, y, x + w, y + h, r );   context.arcTo( x + w, y + h, x, y + h, r );   context.arcTo( x, y + h, x, y, r );   context.arcTo( x, y, x + w, y, r );   context.closePath();   }   function drawBorder( style, which, x, y, width, height ) {    const borderWidth = style[ which + 'Width' ];   const borderStyle = style[ which + 'Style' ];   const borderColor = style[ which + 'Color' ];    if ( borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)' ) {     context.strokeStyle = borderColor;    context.lineWidth = parseFloat( borderWidth );    context.beginPath();    context.moveTo( x, y );    context.lineTo( x + width, y + height );    context.stroke();    }   }   function drawElement( element, style ) {    // Do not render invisible elements, comments and scripts.   if ( element.nodeType === Node.COMMENT_NODE || element.nodeName === 'SCRIPT' || ( element.style && element.style.display === 'none' ) ) {     return;    }    let x = 0, y = 0, width = 0, height = 0;    if ( element.nodeType === Node.TEXT_NODE ) {     // text     range.selectNode( element );     const rect = range.getBoundingClientRect();     x = rect.left - offset.left - 0.5;    y = rect.top - offset.top - 0.5;    width = rect.width;    height = rect.height;     drawText( style, x, y, element.nodeValue.trim() );    } else if ( element instanceof HTMLCanvasElement ) {     // Canvas element     const rect = element.getBoundingClientRect();     x = rect.left - offset.left - 0.5;    y = rect.top - offset.top - 0.5;            context.save();    const dpr = window.devicePixelRatio;    context.scale( 1 / dpr, 1 / dpr );    context.drawImage( element, x, y );    context.restore();    } else if ( element instanceof HTMLImageElement ) {     const rect = element.getBoundingClientRect();     x = rect.left - offset.left - 0.5;    y = rect.top - offset.top - 0.5;    width = rect.width;    height = rect.height;     context.drawImage( element, x, y, width, height );    } else {     const rect = element.getBoundingClientRect();     x = rect.left - offset.left - 0.5;    y = rect.top - offset.top - 0.5;    width = rect.width;    height = rect.height;     style = window.getComputedStyle( element );     // Get the border of the element used for fill and border     buildRectPath( x, y, width, height, parseFloat( style.borderRadius ) );     const backgroundColor = style.backgroundColor;     if ( backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)' ) {      context.fillStyle = backgroundColor;     context.fill();     }     // If all the borders match then stroke the round rectangle     const borders = [ 'borderTop', 'borderLeft', 'borderBottom', 'borderRight' ];     let match = true;    let prevBorder = null;     for ( const border of borders ) {      if ( prevBorder !== null ) {       match = ( style[ border + 'Width' ] === style[ prevBorder + 'Width' ] ) &&      ( style[ border + 'Color' ] === style[ prevBorder + 'Color' ] ) &&      ( style[ border + 'Style' ] === style[ prevBorder + 'Style' ] );      }      if ( match === false ) break;      prevBorder = border;     }     if ( match === true ) {      // They all match so stroke the rectangle from before allows for border-radius      const width = parseFloat( style.borderTopWidth );      if ( style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)' ) {       context.strokeStyle = style.borderTopColor;      context.lineWidth = width;      context.stroke();      }     } else {      // Otherwise draw individual borders      drawBorder( style, 'borderTop', x, y, width, 0 );     drawBorder( style, 'borderLeft', x, y, 0, height );     drawBorder( style, 'borderBottom', x, y + height, width, 0 );     drawBorder( style, 'borderRight', x + width, y, 0, height );     }     if ( element instanceof HTMLInputElement ) {      let accentColor = style.accentColor;      if ( accentColor === undefined || accentColor === 'auto' ) accentColor = style.color;      color.set( accentColor );      const luminance = Math.sqrt( 0.299 * ( color.r ** 2 ) + 0.587 * ( color.g ** 2 ) + 0.114 * ( color.b ** 2 ) );     const accentTextColor = luminance < 0.5 ? 'white' : '#111111';      if ( element.type === 'radio' ) {       buildRectPath( x, y, width, height, height );       context.fillStyle = 'white';      context.strokeStyle = accentColor;      context.lineWidth = 1;      context.fill();      context.stroke();       if ( element.checked ) {        buildRectPath( x + 2, y + 2, width - 4, height - 4, height );        context.fillStyle = accentColor;       context.strokeStyle = accentTextColor;       context.lineWidth = 2;       context.fill();       context.stroke();       }      }      if ( element.type === 'checkbox' ) {       buildRectPath( x, y, width, height, 2 );       context.fillStyle = element.checked ? accentColor : 'white';      context.strokeStyle = element.checked ? accentTextColor : accentColor;      context.lineWidth = 1;      context.stroke();      context.fill();       if ( element.checked ) {        const currentTextAlign = context.textAlign;        context.textAlign = 'center';        const properties = {        color: accentTextColor,        fontFamily: style.fontFamily,        fontSize: height + 'px',        fontWeight: 'bold'       };        drawText( properties, x + ( width / 2 ), y, '?"' );        context.textAlign = currentTextAlign;       }      }      if ( element.type === 'range' ) {       const [ min, max, value ] = [ 'min', 'max', 'value' ].map( property => parseFloat( element[ property ] ) );      const position = ( ( value - min ) / ( max - min ) ) * ( width - height );       buildRectPath( x, y + ( height / 4 ), width, height / 2, height / 4 );      context.fillStyle = accentTextColor;      context.strokeStyle = accentColor;      context.lineWidth = 1;      context.fill();      context.stroke();       buildRectPath( x, y + ( height / 4 ), position + ( height / 2 ), height / 2, height / 4 );      context.fillStyle = accentColor;      context.fill();       buildRectPath( x + position, y, height, height, height / 2 );      context.fillStyle = accentColor;      context.fill();      }      if ( element.type === 'color' || element.type === 'text' || element.type === 'number' ) {       clipper.add( { x: x, y: y, width: width, height: height } );       drawText( style, x + parseInt( style.paddingLeft ), y + parseInt( style.paddingTop ), element.value );       clipper.remove();      }     }    }    /*   // debug   context.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );   context.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );   */    const isClipping = style.overflow === 'auto' || style.overflow === 'hidden';    if ( isClipping ) clipper.add( { x: x, y: y, width: width, height: height } );    for ( let i = 0; i < element.childNodes.length; i ++ ) {     drawElement( element.childNodes[ i ], style );    }    if ( isClipping ) clipper.remove();   }   const offset = element.getBoundingClientRect();   let canvas = canvases.get( element );   if ( canvas === undefined ) {    canvas = document.createElement( 'canvas' );   canvas.width = offset.width;   canvas.height = offset.height;   canvases.set( element, canvas );   }   const context = canvas.getContext( '2d'/*, { alpha: false }*/ );   const clipper = new Clipper( context );   // console.time( 'drawElement' );   context.clearRect( 0, 0, canvas.width, canvas.height );   drawElement( element );   // console.timeEnd( 'drawElement' );   return canvas;  }  function htmlevent( element, event, x, y ) {   const mouseEventInit = {   clientX: ( x * element.offsetWidth ) + element.offsetLeft,   clientY: ( y * element.offsetHeight ) + element.offsetTop,   view: element.ownerDocument.defaultView  };   window.dispatchEvent( new MouseEvent( event, mouseEventInit ) );   const rect = element.getBoundingClientRect();   x = x * rect.width + rect.left;  y = y * rect.height + rect.top;   function traverse( element ) {    if ( element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE ) {     const rect = element.getBoundingClientRect();     if ( x > rect.left && x < rect.right && y > rect.top && y < rect.bottom ) {      element.dispatchEvent( new MouseEvent( event, mouseEventInit ) );      if ( element instanceof HTMLInputElement && element.type === 'range' && ( event === 'mousedown' || event === 'click' ) ) {       const [ min, max ] = [ 'min', 'max' ].map( property => parseFloat( element[ property ] ) );       const width = rect.width;      const offsetX = x - rect.x;      const proportion = offsetX / width;      element.value = min + ( max - min ) * proportion;      element.dispatchEvent( new InputEvent( 'input', { bubbles: true } ) );      }     }     for ( let i = 0; i < element.childNodes.length; i ++ ) {      traverse( element.childNodes[ i ] );     }    }   }   traverse( element );  }  export { HTMLMesh }; 
^..^ FILENAME ^..^
addons|interactive|InteractiveGroup.js
^..^ CONTENTS ^..^
import {  Group,  Raycaster,  Vector2 } from 'three';  const _pointer = new Vector2(); const _event = { type: '', data: _pointer };  const _raycaster = new Raycaster();  class InteractiveGroup extends Group {   listenToPointerEvents( renderer, camera ) {    const scope = this;   const raycaster = new Raycaster();    const element = renderer.domElement;    function onPointerEvent( event ) {     event.stopPropagation();     const rect = renderer.domElement.getBoundingClientRect();     _pointer.x = ( event.clientX - rect.left ) / rect.width * 2 - 1;    _pointer.y = - ( event.clientY - rect.top ) / rect.height * 2 + 1;     raycaster.setFromCamera( _pointer, camera );     const intersects = raycaster.intersectObjects( scope.children, false );     if ( intersects.length > 0 ) {      const intersection = intersects[ 0 ];      const object = intersection.object;     const uv = intersection.uv;      _event.type = event.type;     _event.data.set( uv.x, 1 - uv.y );      object.dispatchEvent( _event );     }    }    element.addEventListener( 'pointerdown', onPointerEvent );   element.addEventListener( 'pointerup', onPointerEvent );   element.addEventListener( 'pointermove', onPointerEvent );   element.addEventListener( 'mousedown', onPointerEvent );   element.addEventListener( 'mouseup', onPointerEvent );   element.addEventListener( 'mousemove', onPointerEvent );   element.addEventListener( 'click', onPointerEvent );   }   listenToXRControllerEvents( controller ) {    const scope = this;    // TODO: Dispatch pointerevents too    const events = {    'move': 'mousemove',    'select': 'click',    'selectstart': 'mousedown',    'selectend': 'mouseup'   };    function onXRControllerEvent( event ) {     const controller = event.target;     _raycaster.setFromXRController( controller );     const intersections = _raycaster.intersectObjects( scope.children, false );     if ( intersections.length > 0 ) {      const intersection = intersections[ 0 ];      const object = intersection.object;     const uv = intersection.uv;      _event.type = events[ event.type ];     _event.data.set( uv.x, 1 - uv.y );      object.dispatchEvent( _event );     }    }    controller.addEventListener( 'move', onXRControllerEvent );   controller.addEventListener( 'select', onXRControllerEvent );   controller.addEventListener( 'selectstart', onXRControllerEvent );   controller.addEventListener( 'selectend', onXRControllerEvent );   }  }  export { InteractiveGroup }; 
^..^ FILENAME ^..^
addons|interactive|SelectionBox.js
^..^ CONTENTS ^..^
import {  Frustum,  Vector3,  Matrix4,  Quaternion, } from 'three';  /**  * This is a class to check whether objects are in a selection area in 3D space  */  const _frustum = new Frustum(); const _center = new Vector3();  const _tmpPoint = new Vector3();  const _vecNear = new Vector3(); const _vecTopLeft = new Vector3(); const _vecTopRight = new Vector3(); const _vecDownRight = new Vector3(); const _vecDownLeft = new Vector3();  const _vecFarTopLeft = new Vector3(); const _vecFarTopRight = new Vector3(); const _vecFarDownRight = new Vector3(); const _vecFarDownLeft = new Vector3();  const _vectemp1 = new Vector3(); const _vectemp2 = new Vector3(); const _vectemp3 = new Vector3();  const _matrix = new Matrix4(); const _quaternion = new Quaternion(); const _scale = new Vector3();  class SelectionBox {   constructor( camera, scene, deep = Number.MAX_VALUE ) {    this.camera = camera;   this.scene = scene;   this.startPoint = new Vector3();   this.endPoint = new Vector3();   this.collection = [];   this.instances = {};   this.deep = deep;   }   select( startPoint, endPoint ) {    this.startPoint = startPoint || this.startPoint;   this.endPoint = endPoint || this.endPoint;   this.collection = [];    this.updateFrustum( this.startPoint, this.endPoint );   this.searchChildInFrustum( _frustum, this.scene );    return this.collection;   }   updateFrustum( startPoint, endPoint ) {    startPoint = startPoint || this.startPoint;   endPoint = endPoint || this.endPoint;    // Avoid invalid frustum    if ( startPoint.x === endPoint.x ) {     endPoint.x += Number.EPSILON;    }    if ( startPoint.y === endPoint.y ) {     endPoint.y += Number.EPSILON;    }    this.camera.updateProjectionMatrix();   this.camera.updateMatrixWorld();    if ( this.camera.isPerspectiveCamera ) {     _tmpPoint.copy( startPoint );    _tmpPoint.x = Math.min( startPoint.x, endPoint.x );    _tmpPoint.y = Math.max( startPoint.y, endPoint.y );    endPoint.x = Math.max( startPoint.x, endPoint.x );    endPoint.y = Math.min( startPoint.y, endPoint.y );     _vecNear.setFromMatrixPosition( this.camera.matrixWorld );    _vecTopLeft.copy( _tmpPoint );    _vecTopRight.set( endPoint.x, _tmpPoint.y, 0 );    _vecDownRight.copy( endPoint );    _vecDownLeft.set( _tmpPoint.x, endPoint.y, 0 );     _vecTopLeft.unproject( this.camera );    _vecTopRight.unproject( this.camera );    _vecDownRight.unproject( this.camera );    _vecDownLeft.unproject( this.camera );     _vectemp1.copy( _vecTopLeft ).sub( _vecNear );    _vectemp2.copy( _vecTopRight ).sub( _vecNear );    _vectemp3.copy( _vecDownRight ).sub( _vecNear );    _vectemp1.normalize();    _vectemp2.normalize();    _vectemp3.normalize();     _vectemp1.multiplyScalar( this.deep );    _vectemp2.multiplyScalar( this.deep );    _vectemp3.multiplyScalar( this.deep );    _vectemp1.add( _vecNear );    _vectemp2.add( _vecNear );    _vectemp3.add( _vecNear );     const planes = _frustum.planes;     planes[ 0 ].setFromCoplanarPoints( _vecNear, _vecTopLeft, _vecTopRight );    planes[ 1 ].setFromCoplanarPoints( _vecNear, _vecTopRight, _vecDownRight );    planes[ 2 ].setFromCoplanarPoints( _vecDownRight, _vecDownLeft, _vecNear );    planes[ 3 ].setFromCoplanarPoints( _vecDownLeft, _vecTopLeft, _vecNear );    planes[ 4 ].setFromCoplanarPoints( _vecTopRight, _vecDownRight, _vecDownLeft );    planes[ 5 ].setFromCoplanarPoints( _vectemp3, _vectemp2, _vectemp1 );    planes[ 5 ].normal.multiplyScalar( - 1 );    } else if ( this.camera.isOrthographicCamera ) {     const left = Math.min( startPoint.x, endPoint.x );    const top = Math.max( startPoint.y, endPoint.y );    const right = Math.max( startPoint.x, endPoint.x );    const down = Math.min( startPoint.y, endPoint.y );     _vecTopLeft.set( left, top, - 1 );    _vecTopRight.set( right, top, - 1 );    _vecDownRight.set( right, down, - 1 );    _vecDownLeft.set( left, down, - 1 );     _vecFarTopLeft.set( left, top, 1 );    _vecFarTopRight.set( right, top, 1 );    _vecFarDownRight.set( right, down, 1 );    _vecFarDownLeft.set( left, down, 1 );     _vecTopLeft.unproject( this.camera );    _vecTopRight.unproject( this.camera );    _vecDownRight.unproject( this.camera );    _vecDownLeft.unproject( this.camera );     _vecFarTopLeft.unproject( this.camera );    _vecFarTopRight.unproject( this.camera );    _vecFarDownRight.unproject( this.camera );    _vecFarDownLeft.unproject( this.camera );     const planes = _frustum.planes;     planes[ 0 ].setFromCoplanarPoints( _vecTopLeft, _vecFarTopLeft, _vecFarTopRight );    planes[ 1 ].setFromCoplanarPoints( _vecTopRight, _vecFarTopRight, _vecFarDownRight );    planes[ 2 ].setFromCoplanarPoints( _vecFarDownRight, _vecFarDownLeft, _vecDownLeft );    planes[ 3 ].setFromCoplanarPoints( _vecFarDownLeft, _vecFarTopLeft, _vecTopLeft );    planes[ 4 ].setFromCoplanarPoints( _vecTopRight, _vecDownRight, _vecDownLeft );    planes[ 5 ].setFromCoplanarPoints( _vecFarDownRight, _vecFarTopRight, _vecFarTopLeft );    planes[ 5 ].normal.multiplyScalar( - 1 );    } else {     console.error( 'THREE.SelectionBox: Unsupported camera type.' );    }   }   searchChildInFrustum( frustum, object ) {    if ( object.isMesh || object.isLine || object.isPoints ) {     if ( object.isInstancedMesh ) {      this.instances[ object.uuid ] = [];      for ( let instanceId = 0; instanceId < object.count; instanceId ++ ) {       object.getMatrixAt( instanceId, _matrix );      _matrix.decompose( _center, _quaternion, _scale );      _center.applyMatrix4( object.matrixWorld );       if ( frustum.containsPoint( _center ) ) {        this.instances[ object.uuid ].push( instanceId );       }      }     } else {      if ( object.geometry.boundingSphere === null ) object.geometry.computeBoundingSphere();      _center.copy( object.geometry.boundingSphere.center );      _center.applyMatrix4( object.matrixWorld );      if ( frustum.containsPoint( _center ) ) {       this.collection.push( object );      }     }    }    if ( object.children.length > 0 ) {     for ( let x = 0; x < object.children.length; x ++ ) {      this.searchChildInFrustum( frustum, object.children[ x ] );     }    }   }  }  export { SelectionBox }; 
^..^ FILENAME ^..^
addons|interactive|SelectionHelper.js
^..^ CONTENTS ^..^
import { Vector2 } from 'three';  class SelectionHelper {   constructor( renderer, cssClassName ) {    this.element = document.createElement( 'div' );   this.element.classList.add( cssClassName );   this.element.style.pointerEvents = 'none';    this.renderer = renderer;    this.startPoint = new Vector2();   this.pointTopLeft = new Vector2();   this.pointBottomRight = new Vector2();    this.isDown = false;   this.enabled = true;    this.onPointerDown = function ( event ) {     if ( this.enabled === false ) return;     this.isDown = true;    this.onSelectStart( event );    }.bind( this );    this.onPointerMove = function ( event ) {     if ( this.enabled === false ) return;     if ( this.isDown ) {      this.onSelectMove( event );     }    }.bind( this );    this.onPointerUp = function ( ) {     if ( this.enabled === false ) return;     this.isDown = false;    this.onSelectOver();    }.bind( this );    this.renderer.domElement.addEventListener( 'pointerdown', this.onPointerDown );   this.renderer.domElement.addEventListener( 'pointermove', this.onPointerMove );   this.renderer.domElement.addEventListener( 'pointerup', this.onPointerUp );   }   dispose() {    this.renderer.domElement.removeEventListener( 'pointerdown', this.onPointerDown );   this.renderer.domElement.removeEventListener( 'pointermove', this.onPointerMove );   this.renderer.domElement.removeEventListener( 'pointerup', this.onPointerUp );   }   onSelectStart( event ) {    this.element.style.display = 'none';    this.renderer.domElement.parentElement.appendChild( this.element );    this.element.style.left = event.clientX + 'px';   this.element.style.top = event.clientY + 'px';   this.element.style.width = '0px';   this.element.style.height = '0px';    this.startPoint.x = event.clientX;   this.startPoint.y = event.clientY;   }   onSelectMove( event ) {    this.element.style.display = 'block';    this.pointBottomRight.x = Math.max( this.startPoint.x, event.clientX );   this.pointBottomRight.y = Math.max( this.startPoint.y, event.clientY );   this.pointTopLeft.x = Math.min( this.startPoint.x, event.clientX );   this.pointTopLeft.y = Math.min( this.startPoint.y, event.clientY );    this.element.style.left = this.pointTopLeft.x + 'px';   this.element.style.top = this.pointTopLeft.y + 'px';   this.element.style.width = ( this.pointBottomRight.x - this.pointTopLeft.x ) + 'px';   this.element.style.height = ( this.pointBottomRight.y - this.pointTopLeft.y ) + 'px';   }   onSelectOver() {    this.element.parentElement.removeChild( this.element );   }  }  export { SelectionHelper }; 
^..^ FILENAME ^..^
addons|lights|LightProbeGenerator.js
^..^ CONTENTS ^..^
import {  Color,  LightProbe,  LinearSRGBColorSpace,  SphericalHarmonics3,  Vector3,  SRGBColorSpace,  NoColorSpace,  HalfFloatType,  DataUtils,  WebGLCoordinateSystem } from 'three';  class LightProbeGenerator {   // https://www.ppsloan.org/publications/StupidSH36.pdf  static fromCubeTexture( cubeTexture ) {    let totalWeight = 0;    const coord = new Vector3();    const dir = new Vector3();    const color = new Color();    const shBasis = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];    const sh = new SphericalHarmonics3();   const shCoefficients = sh.coefficients;    for ( let faceIndex = 0; faceIndex < 6; faceIndex ++ ) {     const image = cubeTexture.image[ faceIndex ];     const width = image.width;    const height = image.height;     const canvas = document.createElement( 'canvas' );     canvas.width = width;    canvas.height = height;     const context = canvas.getContext( '2d' );     context.drawImage( image, 0, 0, width, height );     const imageData = context.getImageData( 0, 0, width, height );     const data = imageData.data;     const imageWidth = imageData.width; // assumed to be square     const pixelSize = 2 / imageWidth;     for ( let i = 0, il = data.length; i < il; i += 4 ) { // RGBA assumed      // pixel color     color.setRGB( data[ i ] / 255, data[ i + 1 ] / 255, data[ i + 2 ] / 255 );      // convert to linear color space     convertColorToLinear( color, cubeTexture.colorSpace );      // pixel coordinate on unit cube      const pixelIndex = i / 4;      const col = - 1 + ( pixelIndex % imageWidth + 0.5 ) * pixelSize;      const row = 1 - ( Math.floor( pixelIndex / imageWidth ) + 0.5 ) * pixelSize;      switch ( faceIndex ) {       case 0: coord.set( - 1, row, - col ); break;       case 1: coord.set( 1, row, col ); break;       case 2: coord.set( - col, 1, - row ); break;       case 3: coord.set( - col, - 1, row ); break;       case 4: coord.set( - col, row, 1 ); break;       case 5: coord.set( col, row, - 1 ); break;      }      // weight assigned to this pixel      const lengthSq = coord.lengthSq();      const weight = 4 / ( Math.sqrt( lengthSq ) * lengthSq );      totalWeight += weight;      // direction vector to this pixel     dir.copy( coord ).normalize();      // evaluate SH basis functions in direction dir     SphericalHarmonics3.getBasisAt( dir, shBasis );      // accummuulate     for ( let j = 0; j < 9; j ++ ) {       shCoefficients[ j ].x += shBasis[ j ] * color.r * weight;      shCoefficients[ j ].y += shBasis[ j ] * color.g * weight;      shCoefficients[ j ].z += shBasis[ j ] * color.b * weight;      }     }    }    // normalize   const norm = ( 4 * Math.PI ) / totalWeight;    for ( let j = 0; j < 9; j ++ ) {     shCoefficients[ j ].x *= norm;    shCoefficients[ j ].y *= norm;    shCoefficients[ j ].z *= norm;    }    return new LightProbe( sh );   }   static async fromCubeRenderTarget( renderer, cubeRenderTarget ) {    const flip = renderer.coordinateSystem === WebGLCoordinateSystem ? -1 : 1;    // The renderTarget must be set to RGBA in order to make readRenderTargetPixels works   let totalWeight = 0;    const coord = new Vector3();    const dir = new Vector3();    const color = new Color();    const shBasis = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];    const sh = new SphericalHarmonics3();   const shCoefficients = sh.coefficients;    const dataType = cubeRenderTarget.texture.type;   const imageWidth = cubeRenderTarget.width; // assumed to be square    let data;    if ( renderer.isWebGLRenderer ) {     if ( dataType === HalfFloatType ) {      data = new Uint16Array( imageWidth * imageWidth * 4 );     } else {      // assuming UnsignedByteType      data = new Uint8Array( imageWidth * imageWidth * 4 );     }    }    for ( let faceIndex = 0; faceIndex < 6; faceIndex ++ ) {     if ( renderer.isWebGLRenderer ) {      await renderer.readRenderTargetPixelsAsync( cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex );     } else {      data = await renderer.readRenderTargetPixelsAsync( cubeRenderTarget, 0, 0, imageWidth, imageWidth, 0, faceIndex );     }     const pixelSize = 2 / imageWidth;     for ( let i = 0, il = data.length; i < il; i += 4 ) { // RGBA assumed      let r, g, b;      if ( dataType === HalfFloatType ) {       r = DataUtils.fromHalfFloat( data[ i ] );      g = DataUtils.fromHalfFloat( data[ i + 1 ] );      b = DataUtils.fromHalfFloat( data[ i + 2 ] );      } else {       r = data[ i ] / 255;      g = data[ i + 1 ] / 255;      b = data[ i + 2 ] / 255;      }      // pixel color     color.setRGB( r, g, b );      // convert to linear color space     convertColorToLinear( color, cubeRenderTarget.texture.colorSpace );      // pixel coordinate on unit cube      const pixelIndex = i / 4;      const col = ( 1 - ( pixelIndex % imageWidth + 0.5 ) * pixelSize ) * flip;      const row = 1 - ( Math.floor( pixelIndex / imageWidth ) + 0.5 ) * pixelSize;      switch ( faceIndex ) {       case 0: coord.set( - 1 * flip, row, col * flip ); break;       case 1: coord.set( 1 * flip, row, - col * flip ); break;       case 2: coord.set( col, 1, - row ); break;       case 3: coord.set( col, - 1, row ); break;       case 4: coord.set( col, row, 1 ); break;       case 5: coord.set( - col, row, - 1 ); break;      }      // weight assigned to this pixel      const lengthSq = coord.lengthSq();      const weight = 4 / ( Math.sqrt( lengthSq ) * lengthSq );      totalWeight += weight;      // direction vector to this pixel     dir.copy( coord ).normalize();      // evaluate SH basis functions in direction dir     SphericalHarmonics3.getBasisAt( dir, shBasis );      // accummuulate     for ( let j = 0; j < 9; j ++ ) {       shCoefficients[ j ].x += shBasis[ j ] * color.r * weight;      shCoefficients[ j ].y += shBasis[ j ] * color.g * weight;      shCoefficients[ j ].z += shBasis[ j ] * color.b * weight;      }     }    }    // normalize   const norm = ( 4 * Math.PI ) / totalWeight;    for ( let j = 0; j < 9; j ++ ) {     shCoefficients[ j ].x *= norm;    shCoefficients[ j ].y *= norm;    shCoefficients[ j ].z *= norm;    }    return new LightProbe( sh );   }  }  function convertColorToLinear( color, colorSpace ) {   switch ( colorSpace ) {    case SRGBColorSpace:     color.convertSRGBToLinear();    break;    case LinearSRGBColorSpace:   case NoColorSpace:     break;    default:     console.warn( 'WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported color space.' );    break;   }   return color;  }  export { LightProbeGenerator }; 
^..^ FILENAME ^..^
addons|lights|RectAreaLightTexturesLib.js
^..^ CONTENTS ^..^
import {  ClampToEdgeWrapping,  DataTexture,  DataUtils,  FloatType,  HalfFloatType,  LinearFilter,  NearestFilter,  RGBAFormat,  UVMapping } from 'three';  /**  * Uniforms library for RectAreaLight shared webgl shaders  *  * NOTE: This is a temporary location for the BRDF approximation texture data  *       based off of Eric Heitz's work (see citation below).  BRDF data for  *       RectAreaLight is currently approximated using a precomputed texture  *       of roughly 80kb in size.  The hope is to find a better way to include  *       the large texture data before including the full RectAreaLight implementation  *       in the main build files.  *  * TODO: figure out a way to compress the LTC BRDF data  */  // Real-Time Polygonal-Light Shading with Linearly Transformed Cosines // by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt // code: https://github.com/selfshadow/ltc_code/  class RectAreaLightTexturesLib {   static init() {    // source: https://github.com/selfshadow/ltc_code/tree/master/fit/results/ltc.js    const LTC_MAT_1 = [ 1, 0, 0, 2e-05, 1, 0, 0, 0.000503905, 1, 0, 0, 0.00201562, 1, 0, 0, 0.00453516, 1, 0, 0, 0.00806253, 1, 0, 0, 0.0125978, 1, 0, 0, 0.018141, 1, 0, 0, 0.0246924, 1, 0, 0, 0.0322525, 1, 0, 0, 0.0408213, 1, 0, 0, 0.0503999, 1, 0, 0, 0.0609894, 1, 0, 0, 0.0725906, 1, 0, 0, 0.0852058, 1, 0, 0, 0.0988363, 1, 0, 0, 0.113484, 1, 0, 0, 0.129153, 1, 0, 0, 0.145839, 1, 0, 0, 0.163548, 1, 0, 0, 0.182266, 1, 0, 0, 0.201942, 1, 0, 0, 0.222314, 1, 0, 0, 0.241906, 1, 0, 0, 0.262314, 1, 0, 0, 0.285754, 1, 0, 0, 0.310159, 1, 0, 0, 0.335426, 1, 0, 0, 0.361341, 1, 0, 0, 0.387445, 1, 0, 0, 0.412784, 1, 0, 0, 0.438197, 1, 0, 0, 0.466966, 1, 0, 0, 0.49559, 1, 0, 0, 0.523448, 1, 0, 0, 0.549938, 1, 0, 0, 0.57979, 1, 0, 0, 0.608746, 1, 0, 0, 0.636185, 1, 0, 0, 0.664748, 1, 0, 0, 0.69313, 1, 0, 0, 0.71966, 1, 0, 0, 0.747662, 1, 0, 0, 0.774023, 1, 0, 0, 0.799775, 1, 0, 0, 0.825274, 1, 0, 0, 0.849156, 1, 0, 0, 0.873248, 1, 0, 0, 0.89532, 1, 0, 0, 0.917565, 1, 0, 0, 0.937863, 1, 0, 0, 0.958139, 1, 0, 0, 0.976563, 1, 0, 0, 0.994658, 1, 0, 0, 1.0112, 1, 0, 0, 1.02712, 1, 0, 0, 1.04189, 1, 0, 0, 1.05568, 1, 0, 0, 1.06877, 1, 0, 0, 1.08058, 1, 0, 0, 1.09194, 1, 0, 0, 1.10191, 1, 0, 0, 1.11161, 1, 0, 0, 1.1199, 1, 0, 0, 1.12813, 0.999547, - 4.48815e-07, 0.0224417, 1.99902e-05, 0.999495, - 1.13079e-05, 0.0224406, 0.000503651, 0.999496, - 4.52317e-05, 0.0224406, 0.00201461, 0.999496, - 0.000101772, 0.0224406, 0.00453287, 0.999495, - 0.000180928, 0.0224406, 0.00805845, 0.999497, - 0.000282702, 0.0224406, 0.0125914, 0.999496, - 0.000407096, 0.0224406, 0.0181319, 0.999498, - 0.000554114, 0.0224406, 0.02468, 0.999499, - 0.000723768, 0.0224406, 0.0322363, 0.999495, - 0.000916058, 0.0224405, 0.0408009, 0.999499, - 0.00113101, 0.0224408, 0.050375, 0.999494, - 0.00136863, 0.0224405, 0.0609586, 0.999489, - 0.00162896, 0.0224401, 0.0725537, 0.999489, - 0.00191201, 0.0224414, 0.0851619, 0.999498, - 0.00221787, 0.0224413, 0.0987867, 0.999492, - 0.00254642, 0.0224409, 0.113426, 0.999507, - 0.00289779, 0.0224417, 0.129088, 0.999494, - 0.0032716, 0.0224386, 0.145767, 0.999546, - 0.0036673, 0.0224424, 0.163472, 0.999543, - 0.00408166, 0.0224387, 0.182182, 0.999499, - 0.00450056, 0.0224338, 0.201843, 0.999503, - 0.00483661, 0.0224203, 0.222198, 0.999546, - 0.00452928, 0.022315, 0.241714, 0.999508, - 0.00587403, 0.0224329, 0.262184, 0.999509, - 0.00638806, 0.0224271, 0.285609, 0.999501, - 0.00691028, 0.0224166, 0.309998, 0.999539, - 0.00741979, 0.0223989, 0.335262, 0.999454, - 0.00786282, 0.0223675, 0.361154, 0.999529, - 0.00811928, 0.0222828, 0.387224, 0.999503, - 0.00799941, 0.0221063, 0.41252, 0.999561, - 0.00952753, 0.0223057, 0.438006, 0.999557, - 0.0099134, 0.0222065, 0.466735, 0.999541, - 0.0100935, 0.0220402, 0.495332, 0.999562, - 0.00996821, 0.0218067, 0.523197, 0.999556, - 0.0105031, 0.0217096, 0.550223, 0.999561, - 0.0114191, 0.0217215, 0.579498, 0.999588, - 0.0111818, 0.0213357, 0.608416, 0.999633, - 0.0107725, 0.0208689, 0.635965, 0.999527, - 0.0121671, 0.0210149, 0.664476, 0.999508, - 0.0116005, 0.020431, 0.692786, 0.999568, - 0.0115604, 0.0199791, 0.719709, 0.999671, - 0.0121117, 0.0197415, 0.74737, 0.999688, - 0.0110769, 0.0188846, 0.773692, 0.99962, - 0.0122368, 0.0188452, 0.799534, 0.999823, - 0.0110325, 0.0178001, 0.825046, 0.999599, - 0.0114923, 0.0174221, 0.849075, 0.999619, - 0.0105923, 0.0164345, 0.872999, 0.999613, - 0.0105988, 0.0158227, 0.895371, 0.99964, - 0.00979861, 0.0148131, 0.917364, 0.99977, - 0.00967238, 0.0140721, 0.938002, 0.999726, - 0.00869175, 0.0129543, 0.957917, 0.99973, - 0.00866872, 0.0122329, 0.976557, 0.999773, - 0.00731956, 0.0108958, 0.994459, 0.999811, - 0.00756027, 0.0102715, 1.01118, 0.999862, - 0.00583732, 0.00878781, 1.02701, 0.999835, - 0.00631438, 0.00827529, 1.04186, 0.999871, - 0.00450785, 0.00674583, 1.05569, 0.999867, - 0.00486079, 0.00621041, 1.06861, 0.999939, - 0.00322072, 0.00478301, 1.08064, 0.999918, - 0.00318199, 0.00406395, 1.09181, 1.00003, - 0.00193348, 0.00280682, 1.10207, 0.999928, - 0.00153729, 0.00198741, 1.11152, 0.999933, - 0.000623666, 0.000917714, 1.12009, 1, - 1.02387e-06, 9.07581e-07, 1.12813, 0.997866, - 8.96716e-07, 0.0448334, 1.99584e-05, 0.997987, - 2.25945e-05, 0.0448389, 0.000502891, 0.997987, - 9.03781e-05, 0.0448388, 0.00201156, 0.997985, - 0.000203351, 0.0448388, 0.00452602, 0.997986, - 0.000361514, 0.0448388, 0.00804629, 0.997987, - 0.00056487, 0.0448389, 0.0125724, 0.997988, - 0.000813423, 0.0448389, 0.0181045, 0.997984, - 0.00110718, 0.0448387, 0.0246427, 0.997985, - 0.00144616, 0.0448388, 0.0321875, 0.997987, - 0.00183038, 0.044839, 0.0407392, 0.997983, - 0.00225987, 0.0448387, 0.0502986, 0.997991, - 0.00273467, 0.0448389, 0.0608667, 0.997984, - 0.00325481, 0.0448384, 0.0724444, 0.998002, - 0.00382043, 0.044839, 0.0850348, 0.997997, - 0.00443145, 0.0448396, 0.0986372, 0.998007, - 0.00508796, 0.0448397, 0.113255, 0.998008, - 0.00578985, 0.04484, 0.128891, 0.998003, - 0.00653683, 0.0448384, 0.145548, 0.997983, - 0.00732713, 0.0448358, 0.163221, 0.997985, - 0.00815454, 0.0448358, 0.181899, 0.998005, - 0.00898985, 0.0448286, 0.201533, 0.998026, - 0.00964404, 0.0447934, 0.221821, 0.998055, - 0.00922677, 0.044611, 0.241282, 0.99804, - 0.0117361, 0.0448245, 0.261791, 0.998048, - 0.0127628, 0.0448159, 0.285181, 0.998088, - 0.0138055, 0.0447996, 0.30954, 0.998058, - 0.0148206, 0.0447669, 0.334751, 0.998099, - 0.0156998, 0.044697, 0.36061, 0.998116, - 0.0161976, 0.0445122, 0.386603, 0.998195, - 0.015945, 0.0441711, 0.411844, 0.998168, - 0.0183947, 0.0444255, 0.43773, 0.998184, - 0.0197913, 0.0443809, 0.466009, 0.998251, - 0.0201426, 0.0440689, 0.494574, 0.998305, - 0.0198847, 0.0435632, 0.522405, 0.998273, - 0.0210577, 0.043414, 0.549967, 0.998254, - 0.0227901, 0.0433943, 0.578655, 0.998349, - 0.0223108, 0.0426529, 0.60758, 0.99843, - 0.0223088, 0.042, 0.635524, 0.998373, - 0.0241141, 0.0418987, 0.663621, 0.998425, - 0.0231446, 0.0408118, 0.691906, 0.998504, - 0.0233684, 0.0400565, 0.719339, 0.998443, - 0.0241652, 0.0394634, 0.74643, 0.99848, - 0.0228715, 0.0380002, 0.773086, 0.998569, - 0.023519, 0.0372322, 0.798988, 0.998619, - 0.0223108, 0.0356468, 0.824249, 0.998594, - 0.0223105, 0.034523, 0.848808, 0.998622, - 0.0213426, 0.0328887, 0.87227, 0.998669, - 0.0207912, 0.0314374, 0.895157, 0.998705, - 0.0198416, 0.0296925, 0.916769, 0.998786, - 0.0189168, 0.0279634, 0.937773, 0.998888, - 0.0178811, 0.0261597, 0.957431, 0.99906, - 0.0166845, 0.0242159, 0.976495, 0.999038, - 0.0155464, 0.0222638, 0.994169, 0.999237, - 0.0141349, 0.0201967, 1.01112, 0.999378, - 0.0129324, 0.0181744, 1.02692, 0.999433, - 0.0113192, 0.0159898, 1.04174, 0.999439, - 0.0101244, 0.0140385, 1.05559, 0.999614, - 0.00837456, 0.0117826, 1.06852, 0.999722, - 0.00721769, 0.00983745, 1.08069, 0.999817, - 0.00554067, 0.00769002, 1.09176, 0.99983, - 0.00426961, 0.005782, 1.10211, 0.999964, - 0.00273904, 0.00374503, 1.11152, 1.00001, - 0.00136739, 0.00187176, 1.12031, 0.999946, 3.93227e-05, - 2.8919e-05, 1.12804, 0.995847, - 1.3435e-06, 0.0671785, 1.9916e-05, 0.995464, - 3.38387e-05, 0.0671527, 0.000501622, 0.99547, - 0.000135355, 0.0671531, 0.00200649, 0.995471, - 0.00030455, 0.0671532, 0.00451461, 0.99547, - 0.000541423, 0.0671531, 0.008026, 0.995471, - 0.00084598, 0.0671531, 0.0125407, 0.99547, - 0.00121823, 0.0671531, 0.0180589, 0.99547, - 0.00165817, 0.0671531, 0.0245806, 0.995463, - 0.00216583, 0.0671526, 0.0321062, 0.995468, - 0.00274127, 0.0671527, 0.0406366, 0.995474, - 0.00338447, 0.0671534, 0.0501717, 0.995473, - 0.00409554, 0.0671533, 0.0607131, 0.995478, - 0.00487451, 0.0671531, 0.0722618, 0.995476, - 0.00572148, 0.0671532, 0.0848191, 0.995477, - 0.00663658, 0.0671539, 0.0983882, 0.995498, - 0.00761986, 0.0671541, 0.112972, 0.995509, - 0.00867094, 0.0671542, 0.128568, 0.995509, - 0.00978951, 0.0671531, 0.145183, 0.995503, - 0.0109725, 0.0671491, 0.162808, 0.995501, - 0.012211, 0.0671465, 0.181441, 0.99553, - 0.0134565, 0.0671371, 0.201015, 0.99555, - 0.014391, 0.0670831, 0.221206, 0.99558, - 0.014351, 0.0668883, 0.240813, 0.995577, - 0.0173997, 0.0671055, 0.261257, 0.995602, - 0.0191111, 0.0671178, 0.284467, 0.995623, - 0.0206705, 0.0670946, 0.308765, 0.995658, - 0.022184, 0.0670472, 0.333905, 0.995705, - 0.0234832, 0.0669417, 0.359677, 0.995719, - 0.0241933, 0.0666714, 0.385554, 0.995786, - 0.0243539, 0.066266, 0.410951, 0.995887, - 0.0271866, 0.0664367, 0.437163, 0.995944, - 0.0296012, 0.0664931, 0.464842, 0.996004, - 0.0301045, 0.0660105, 0.49332, 0.996128, - 0.0298311, 0.0652694, 0.521131, 0.996253, - 0.0316426, 0.0650739, 0.549167, 0.996244, - 0.0339043, 0.0649433, 0.57737, 0.996309, - 0.033329, 0.0638926, 0.606073, 0.996417, - 0.0338935, 0.0630849, 0.634527, 0.996372, - 0.0353104, 0.0625083, 0.66256, 0.996542, - 0.0348942, 0.0611986, 0.690516, 0.996568, - 0.0351614, 0.060069, 0.718317, 0.996711, - 0.0354317, 0.0588522, 0.74528, 0.996671, - 0.0349513, 0.0571902, 0.772061, 0.996865, - 0.0345622, 0.0555321, 0.798089, 0.996802, - 0.0342566, 0.0537816, 0.823178, 0.996992, - 0.0330862, 0.0516095, 0.847949, 0.996944, - 0.0324666, 0.0495537, 0.871431, 0.997146, - 0.0309544, 0.0470302, 0.894357, 0.997189, - 0.0299372, 0.0446043, 0.916142, 0.997471, - 0.0281389, 0.0418812, 0.937193, 0.997515, - 0.0268702, 0.0391823, 0.957, 0.997812, - 0.0247166, 0.0361338, 0.975936, 0.998027, - 0.0233525, 0.0333945, 0.99391, 0.998233, - 0.0209839, 0.0301917, 1.01075, 0.998481, - 0.0194309, 0.027271, 1.02669, 0.998859, - 0.0169728, 0.0240162, 1.04173, 0.99894, - 0.0152322, 0.0210517, 1.05551, 0.999132, - 0.0127497, 0.0178632, 1.06856, 0.999369, - 0.0108282, 0.014787, 1.08054, 0.999549, - 0.00845886, 0.0116185, 1.09185, 0.999805, - 0.0063937, 0.00867209, 1.10207, 0.99985, - 0.00414582, 0.00566823, 1.1117, 0.999912, - 0.00207443, 0.00277562, 1.12022, 1.00001, 8.70226e-05, - 5.3766e-05, 1.12832, 0.991943, - 1.78672e-06, 0.0893382, 1.98384e-05, 0.991952, - 4.50183e-05, 0.089339, 0.000499849, 0.991956, - 0.000180074, 0.0893394, 0.0019994, 0.991955, - 0.000405167, 0.0893393, 0.00449867, 0.991953, - 0.000720298, 0.0893391, 0.00799764, 0.991955, - 0.00112548, 0.0893393, 0.0124964, 0.991957, - 0.0016207, 0.0893395, 0.0179951, 0.991958, - 0.00220601, 0.0893396, 0.0244939, 0.991947, - 0.00288137, 0.0893385, 0.0319929, 0.991962, - 0.00364693, 0.0893399, 0.0404933, 0.991965, - 0.00450264, 0.0893399, 0.049995, 0.99198, - 0.00544862, 0.0893411, 0.0604995, 0.99197, - 0.00648491, 0.0893397, 0.0720074, 0.991976, - 0.00761164, 0.089341, 0.0845207, 0.99198, - 0.00882891, 0.0893405, 0.0980413, 0.991982, - 0.0101367, 0.0893396, 0.112571, 0.992008, - 0.011535, 0.0893415, 0.128115, 0.992026, - 0.0130228, 0.0893414, 0.144672, 0.992064, - 0.0145966, 0.0893418, 0.162241, 0.992041, - 0.0162421, 0.0893359, 0.180801, 0.992086, - 0.0178888, 0.0893214, 0.200302, 0.992157, - 0.0190368, 0.0892401, 0.220332, 0.992181, - 0.0195584, 0.0890525, 0.240144, 0.992175, - 0.0227257, 0.0892153, 0.260728, 0.99221, - 0.0254195, 0.089304, 0.283473, 0.99222, - 0.0274883, 0.0892703, 0.307673, 0.992317, - 0.0294905, 0.0892027, 0.332729, 0.992374, - 0.0311861, 0.0890577, 0.358387, 0.992505, - 0.0320656, 0.0886994, 0.384102, 0.992568, - 0.0329715, 0.0883198, 0.409767, 0.992675, - 0.036006, 0.0883602, 0.436145, 0.992746, - 0.0392897, 0.0884591, 0.463217, 0.992873, - 0.0399337, 0.0878287, 0.491557, 0.992934, - 0.040231, 0.0870108, 0.519516, 0.993091, - 0.0422013, 0.0865857, 0.547741, 0.993259, - 0.0443503, 0.0861937, 0.575792, 0.993455, - 0.0446368, 0.0851187, 0.604233, 0.993497, - 0.0454299, 0.0840576, 0.632925, 0.993694, - 0.0463296, 0.0829671, 0.660985, 0.993718, - 0.0470619, 0.0817185, 0.688714, 0.993973, - 0.0468838, 0.0800294, 0.716743, 0.994207, - 0.046705, 0.0781286, 0.74377, 0.994168, - 0.0469698, 0.0763337, 0.77042, 0.9945, - 0.0456816, 0.0738184, 0.796659, 0.994356, - 0.0455518, 0.0715545, 0.821868, 0.994747, - 0.0439488, 0.0686085, 0.846572, 0.994937, - 0.0430056, 0.065869, 0.870435, 0.995142, - 0.0413414, 0.0626446, 0.893272, 0.995451, - 0.0396521, 0.05929, 0.915376, 0.995445, - 0.0378453, 0.0558503, 0.936196, 0.995967, - 0.0355219, 0.0520949, 0.956376, 0.996094, - 0.0335146, 0.048377, 0.975327, 0.996622, - 0.030682, 0.0442575, 0.993471, 0.996938, - 0.0285504, 0.0404693, 1.01052, 0.997383, - 0.0253399, 0.0360903, 1.02637, 0.997714, - 0.0231651, 0.0322176, 1.04139, 0.998249, - 0.0198138, 0.0278433, 1.05542, 0.998596, - 0.0174337, 0.0238759, 1.06846, 0.998946, - 0.0141349, 0.0195944, 1.08056, 0.99928, - 0.0115603, 0.0156279, 1.09181, 0.999507, - 0.00839065, 0.0114607, 1.10213, 0.999697, - 0.005666, 0.00763325, 1.11169, 0.999869, - 0.00269902, 0.00364946, 1.12042, 1.00001, 6.23836e-05, - 3.19288e-05, 1.12832, 0.987221, - 2.22675e-06, 0.111332, 1.97456e-05, 0.98739, - 5.61116e-05, 0.111351, 0.000497563, 0.987448, - 0.000224453, 0.111357, 0.00199031, 0.987441, - 0.000505019, 0.111357, 0.0044782, 0.987442, - 0.000897816, 0.111357, 0.00796129, 0.987442, - 0.00140284, 0.111357, 0.0124396, 0.987444, - 0.00202012, 0.111357, 0.0179132, 0.987442, - 0.00274964, 0.111357, 0.0243824, 0.987446, - 0.00359147, 0.111357, 0.0318474, 0.987435, - 0.00454562, 0.111356, 0.0403086, 0.987461, - 0.00561225, 0.111358, 0.0497678, 0.987458, - 0.00679125, 0.111358, 0.0602239, 0.987443, - 0.0080828, 0.111356, 0.0716792, 0.987476, - 0.0094872, 0.111358, 0.0841364, 0.98749, - 0.0110044, 0.111361, 0.097597, 0.987508, - 0.0126344, 0.111362, 0.112062, 0.987494, - 0.0143767, 0.111357, 0.127533, 0.987526, - 0.0162307, 0.111359, 0.144015, 0.987558, - 0.0181912, 0.111361, 0.161502, 0.987602, - 0.0202393, 0.111355, 0.179979, 0.987692, - 0.022273, 0.111346, 0.199386, 0.987702, - 0.0235306, 0.111215, 0.219183, 0.987789, - 0.0247628, 0.111061, 0.239202, 0.987776, - 0.0280668, 0.111171, 0.259957, 0.987856, - 0.0316751, 0.111327, 0.282198, 0.987912, - 0.0342468, 0.111282, 0.306294, 0.988, - 0.0367205, 0.111198, 0.331219, 0.988055, - 0.0387766, 0.110994, 0.356708, 0.988241, - 0.0397722, 0.110547, 0.382234, 0.988399, - 0.0416076, 0.110198, 0.408227, 0.988539, - 0.0448192, 0.110137, 0.434662, 0.988661, - 0.0483793, 0.110143, 0.461442, 0.988967, - 0.0495895, 0.109453, 0.489318, 0.989073, - 0.0506797, 0.108628, 0.517516, 0.989274, - 0.0526953, 0.108003, 0.545844, 0.989528, - 0.054578, 0.107255, 0.573823, 0.989709, - 0.0561503, 0.106294, 0.601944, 0.989991, - 0.056866, 0.104896, 0.630855, 0.990392, - 0.0572914, 0.103336, 0.658925, 0.990374, - 0.0586224, 0.10189, 0.686661, 0.990747, - 0.0584764, 0.099783, 0.714548, 0.991041, - 0.0582662, 0.0974309, 0.74186, 0.991236, - 0.0584118, 0.0951678, 0.768422, 0.991585, - 0.0573055, 0.0921581, 0.794817, 0.991984, - 0.0564241, 0.0891167, 0.820336, 0.9921, - 0.0553608, 0.085805, 0.84493, 0.992749, - 0.0533816, 0.0820354, 0.868961, 0.99288, - 0.0518661, 0.0782181, 0.891931, 0.993511, - 0.0492492, 0.0738935, 0.914186, 0.993617, - 0.0471956, 0.0696402, 0.93532, 0.99411, - 0.044216, 0.0649659, 0.95543, 0.994595, - 0.0416654, 0.0603177, 0.974685, 0.994976, - 0.0384314, 0.0553493, 0.992807, 0.995579, - 0.0353491, 0.0503942, 1.00996, 0.996069, - 0.0319787, 0.0452123, 1.02606, 0.996718, - 0.028472, 0.0400112, 1.04114, 0.997173, - 0.0250789, 0.0349456, 1.05517, 0.997818, - 0.0213326, 0.029653, 1.0683, 0.998318, - 0.0178509, 0.024549, 1.0805, 0.998853, - 0.0141118, 0.0194197, 1.09177, 0.999218, - 0.0105914, 0.0143869, 1.1022, 0.999594, - 0.00693474, 0.00943517, 1.11175, 0.99975, - 0.00340478, 0.00464051, 1.12056, 1.00001, 0.000109172, - 0.000112821, 1.12853, 0.983383, - 2.66524e-06, 0.133358, 1.96534e-05, 0.981942, - 6.71009e-05, 0.133162, 0.000494804, 0.981946, - 0.000268405, 0.133163, 0.00197923, 0.981944, - 0.000603912, 0.133163, 0.00445326, 0.981941, - 0.00107362, 0.133162, 0.00791693, 0.981946, - 0.00167755, 0.133163, 0.0123703, 0.981944, - 0.00241569, 0.133162, 0.0178135, 0.981945, - 0.00328807, 0.133163, 0.0242466, 0.981945, - 0.00429472, 0.133162, 0.03167, 0.981955, - 0.00543573, 0.133164, 0.0400846, 0.981951, - 0.00671105, 0.133163, 0.0494901, 0.981968, - 0.00812092, 0.133165, 0.0598886, 0.981979, - 0.00966541, 0.133166, 0.0712811, 0.981996, - 0.0113446, 0.133168, 0.083669, 0.982014, - 0.0131585, 0.133169, 0.0970533, 0.982011, - 0.0151073, 0.133167, 0.111438, 0.982062, - 0.0171906, 0.133172, 0.126826, 0.9821, - 0.0194067, 0.133175, 0.143215, 0.982149, - 0.0217502, 0.133176, 0.160609, 0.982163, - 0.0241945, 0.133173, 0.178981, 0.982247, - 0.0265907, 0.133148, 0.198249, 0.982291, - 0.027916, 0.132974, 0.217795, 0.982396, - 0.0299663, 0.132868, 0.238042, 0.982456, - 0.0334544, 0.132934, 0.258901, 0.982499, - 0.0378636, 0.133137, 0.280639, 0.982617, - 0.0409274, 0.133085, 0.304604, 0.98274, - 0.0438523, 0.132985, 0.329376, 0.982944, - 0.0462288, 0.132728, 0.354697, 0.98308, - 0.0475995, 0.132228, 0.380102, 0.983391, - 0.0501901, 0.131924, 0.406256, 0.983514, - 0.0535899, 0.131737, 0.432735, 0.98373, - 0.0571858, 0.131567, 0.459359, 0.984056, - 0.0592353, 0.130932, 0.486637, 0.984234, - 0.0610488, 0.130092, 0.51509, 0.984748, - 0.0630758, 0.12923, 0.543461, 0.985073, - 0.0647398, 0.128174, 0.571376, 0.985195, - 0.0671941, 0.127133, 0.599414, 0.985734, - 0.0681345, 0.125576, 0.628134, 0.986241, - 0.0686089, 0.123639, 0.656399, 0.986356, - 0.0698511, 0.121834, 0.684258, 0.986894, - 0.0700931, 0.119454, 0.711818, 0.987382, - 0.0698321, 0.116718, 0.739511, 0.988109, - 0.0693975, 0.113699, 0.766267, 0.988363, - 0.0689584, 0.110454, 0.792456, 0.989112, - 0.0672353, 0.106602, 0.81813, 0.989241, - 0.0662034, 0.10267, 0.842889, 0.990333, - 0.0638938, 0.0981381, 0.867204, 0.990591, - 0.0618534, 0.0935388, 0.89038, 0.991106, - 0.0593117, 0.088553, 0.912576, 0.991919, - 0.0562676, 0.0832187, 0.934118, 0.992111, - 0.0534085, 0.0778302, 0.954254, 0.992997, - 0.0495459, 0.0720453, 0.973722, 0.993317, - 0.0463707, 0.0663458, 0.991949, 0.994133, - 0.0421245, 0.0601883, 1.00936, 0.994705, - 0.0384977, 0.0542501, 1.02559, 0.995495, - 0.0340956, 0.0479862, 1.04083, 0.996206, - 0.030105, 0.041887, 1.05497, 0.996971, - 0.0256095, 0.0355355, 1.06824, 0.997796, - 0.0213932, 0.0293655, 1.08056, 0.998272, - 0.0169612, 0.0232926, 1.09182, 0.998857, - 0.0126756, 0.0172786, 1.10219, 0.99939, - 0.00832486, 0.0113156, 1.11192, 0.999752, - 0.00410826, 0.00557892, 1.12075, 1, 0.000150957, - 0.000119101, 1.12885, 0.975169, - 3.09397e-06, 0.154669, 1.95073e-05, 0.975439, - 7.79608e-05, 0.154712, 0.000491534, 0.975464, - 0.000311847, 0.154716, 0.00196617, 0.975464, - 0.000701656, 0.154716, 0.00442387, 0.975462, - 0.0012474, 0.154715, 0.0078647, 0.975461, - 0.00194906, 0.154715, 0.0122886, 0.975464, - 0.00280667, 0.154715, 0.0176959, 0.975468, - 0.00382025, 0.154716, 0.0240867, 0.975471, - 0.00498985, 0.154716, 0.0314612, 0.975472, - 0.00631541, 0.154717, 0.0398199, 0.975486, - 0.00779719, 0.154718, 0.0491639, 0.975489, - 0.00943505, 0.154718, 0.0594932, 0.975509, - 0.0112295, 0.154721, 0.0708113, 0.97554, - 0.0131802, 0.154724, 0.0831176, 0.975557, - 0.0152876, 0.154726, 0.096415, 0.975585, - 0.0175512, 0.154728, 0.110705, 0.975605, - 0.0199713, 0.154729, 0.125992, 0.975645, - 0.0225447, 0.154729, 0.142272, 0.975711, - 0.0252649, 0.154735, 0.159549, 0.975788, - 0.0280986, 0.154736, 0.177805, 0.975872, - 0.0308232, 0.154704, 0.196911, 0.975968, - 0.0324841, 0.154525, 0.216324, 0.976063, - 0.0351281, 0.154432, 0.236628, 0.976157, - 0.0388618, 0.15446, 0.257539, 0.976204, - 0.0437704, 0.154665, 0.278975, 0.976358, - 0.047514, 0.154652, 0.302606, 0.976571, - 0.0508638, 0.154535, 0.327204, 0.976725, - 0.0534995, 0.154221, 0.352276, 0.977013, - 0.0555547, 0.153737, 0.377696, 0.977294, - 0.0586728, 0.153403, 0.403855, 0.977602, - 0.0622715, 0.15312, 0.430333, 0.977932, - 0.0658166, 0.152755, 0.456855, 0.978241, - 0.0689877, 0.152233, 0.483668, 0.978602, - 0.0712805, 0.15132, 0.512097, 0.979234, - 0.0732775, 0.150235, 0.540455, 0.97977, - 0.075163, 0.148978, 0.568486, 0.979995, - 0.0778026, 0.147755, 0.596524, 0.98078, - 0.0791854, 0.146019, 0.624825, 0.981628, - 0.0799666, 0.143906, 0.653403, 0.982067, - 0.0808532, 0.141561, 0.681445, 0.98271, - 0.0816024, 0.139025, 0.708918, 0.983734, - 0.0812511, 0.135764, 0.736594, 0.98431, - 0.0806201, 0.132152, 0.763576, 0.985071, - 0.0801605, 0.12846, 0.789797, 0.98618, - 0.0784208, 0.124084, 0.815804, 0.986886, - 0.0766643, 0.1193, 0.840869, 0.987485, - 0.0747744, 0.114236, 0.864952, 0.988431, - 0.0716701, 0.108654, 0.888431, 0.988886, - 0.0691609, 0.102994, 0.910963, 0.990024, - 0.0654048, 0.0967278, 0.932629, 0.990401, - 0.0619765, 0.090384, 0.95313, 0.991093, - 0.0579296, 0.0837885, 0.972587, 0.992018, - 0.0536576, 0.0770171, 0.991184, 0.992536, - 0.0493719, 0.0701486, 1.00863, 0.993421, - 0.0444813, 0.062953, 1.02494, 0.993928, - 0.040008, 0.0560455, 1.04017, 0.994994, - 0.0347982, 0.04856, 1.05463, 0.995866, - 0.0301017, 0.0416152, 1.06807, 0.996916, - 0.0248225, 0.0342597, 1.08039, 0.997766, - 0.0199229, 0.0271668, 1.09177, 0.998479, - 0.0147422, 0.0201387, 1.10235, 0.99921, - 0.00980173, 0.0131944, 1.11206, 0.999652, - 0.0047426, 0.00640712, 1.12104, 0.999998, 8.91673e-05, - 0.00010379, 1.12906, 0.967868, - 3.51885e-06, 0.175947, 1.93569e-05, 0.968001, - 8.86733e-05, 0.175972, 0.000487782, 0.96801, - 0.000354697, 0.175973, 0.00195115, 0.968012, - 0.000798063, 0.175974, 0.00439006, 0.968011, - 0.00141879, 0.175973, 0.00780461, 0.968011, - 0.00221686, 0.175973, 0.0121948, 0.968016, - 0.00319231, 0.175974, 0.0175607, 0.968019, - 0.00434515, 0.175974, 0.0239027, 0.968018, - 0.00567538, 0.175974, 0.0312208, 0.968033, - 0.00718308, 0.175977, 0.0395158, 0.968049, - 0.00886836, 0.175979, 0.0487885, 0.968047, - 0.0107312, 0.175978, 0.0590394, 0.968072, - 0.0127719, 0.175981, 0.0702705, 0.968108, - 0.0149905, 0.175986, 0.0824836, 0.968112, - 0.0173866, 0.175985, 0.0956783, 0.968173, - 0.0199611, 0.175993, 0.109862, 0.96827, - 0.0227128, 0.176008, 0.125033, 0.968292, - 0.025639, 0.17601, 0.141193, 0.968339, - 0.0287299, 0.176007, 0.158336, 0.968389, - 0.0319399, 0.176001, 0.176441, 0.968501, - 0.034941, 0.175962, 0.195359, 0.968646, - 0.0370812, 0.175793, 0.214686, 0.968789, - 0.0402329, 0.175708, 0.234973, 0.96886, - 0.0442601, 0.1757, 0.255871, 0.969013, - 0.049398, 0.175876, 0.277238, 0.969242, - 0.0539932, 0.17594, 0.300326, 0.969419, - 0.0577299, 0.175781, 0.324702, 0.969763, - 0.0605643, 0.175432, 0.349527, 0.970093, - 0.0634488, 0.174992, 0.374976, 0.970361, - 0.0670589, 0.174611, 0.401097, 0.970825, - 0.0708246, 0.174226, 0.427496, 0.971214, - 0.0742871, 0.173684, 0.453858, 0.971622, - 0.0782608, 0.173186, 0.480637, 0.972175, - 0.0813151, 0.172288, 0.508655, 0.972944, - 0.0832678, 0.170979, 0.536973, 0.973595, - 0.0855964, 0.169573, 0.565138, 0.974345, - 0.0882163, 0.168152, 0.593222, 0.975233, - 0.0901671, 0.166314, 0.621201, 0.976239, - 0.0912111, 0.163931, 0.649919, 0.977289, - 0.0916959, 0.161106, 0.678011, 0.978076, - 0.0927061, 0.158272, 0.705717, 0.979533, - 0.0925562, 0.15475, 0.733228, 0.980335, - 0.0918159, 0.150638, 0.760454, 0.981808, - 0.0908508, 0.146201, 0.786918, 0.983061, - 0.0896172, 0.141386, 0.812953, 0.984148, - 0.0871588, 0.135837, 0.838281, 0.985047, - 0.0850624, 0.130135, 0.862594, 0.986219, - 0.0818541, 0.123882, 0.88633, 0.987043, - 0.0784523, 0.117126, 0.908952, 0.988107, - 0.0749601, 0.110341, 0.930744, 0.988955, - 0.0703548, 0.102885, 0.951728, 0.989426, - 0.0662798, 0.0954167, 0.971166, 0.990421, - 0.0610834, 0.0876331, 0.989984, 0.991032, - 0.0562936, 0.0797785, 1.00765, 0.992041, - 0.0508154, 0.0718166, 1.02434, 0.992794, - 0.0454045, 0.0637125, 1.03976, 0.993691, - 0.0398194, 0.0555338, 1.05418, 0.994778, - 0.0341482, 0.0473388, 1.06772, 0.995915, - 0.028428, 0.0391016, 1.08028, 0.997109, - 0.022642, 0.0309953, 1.09185, 0.998095, - 0.0168738, 0.0230288, 1.10247, 0.998985, - 0.0111274, 0.0150722, 1.11229, 0.999581, - 0.00543881, 0.00740605, 1.12131, 1.00003, 0.000162239, - 0.000105549, 1.12946, 0.959505, - 3.93734e-06, 0.196876, 1.91893e-05, 0.959599, - 9.92157e-05, 0.196895, 0.000483544, 0.959641, - 0.000396868, 0.196903, 0.0019342, 0.959599, - 0.000892948, 0.196895, 0.00435193, 0.959603, - 0.00158747, 0.196896, 0.0077368, 0.959604, - 0.00248042, 0.196896, 0.0120888, 0.959605, - 0.00357184, 0.196896, 0.0174082, 0.959605, - 0.00486169, 0.196896, 0.0236949, 0.959613, - 0.00635008, 0.196897, 0.0309497, 0.959619, - 0.00803696, 0.196898, 0.0391725, 0.959636, - 0.00992255, 0.196901, 0.0483649, 0.959634, - 0.0120067, 0.1969, 0.0585266, 0.959675, - 0.0142898, 0.196906, 0.0696609, 0.959712, - 0.0167717, 0.196911, 0.0817678, 0.959752, - 0.0194524, 0.196918, 0.0948494, 0.959807, - 0.0223321, 0.196925, 0.10891, 0.959828, - 0.0254091, 0.196924, 0.123947, 0.959906, - 0.0286815, 0.196934, 0.139968, 0.960005, - 0.0321371, 0.196944, 0.156968, 0.960071, - 0.0357114, 0.196936, 0.17491, 0.960237, - 0.0389064, 0.196882, 0.193597, 0.960367, - 0.041623, 0.196731, 0.21285, 0.960562, - 0.0452655, 0.196654, 0.233075, 0.960735, - 0.0496207, 0.196643, 0.253941, 0.960913, - 0.0549379, 0.196774, 0.275278, 0.961121, - 0.0603414, 0.196893, 0.297733, 0.96139, - 0.0644244, 0.196717, 0.321877, 0.961818, - 0.067556, 0.196314, 0.346476, 0.962175, - 0.0712709, 0.195917, 0.371907, 0.96255, - 0.0752848, 0.1955, 0.397916, 0.963164, - 0.0792073, 0.195026, 0.424229, 0.963782, - 0.0828225, 0.194424, 0.450637, 0.964306, - 0.0873119, 0.193831, 0.477288, 0.964923, - 0.0911051, 0.192973, 0.504716, 0.966048, - 0.093251, 0.19151, 0.533053, 0.967024, - 0.0958983, 0.190013, 0.561366, 0.968038, - 0.09835, 0.188253, 0.589464, 0.969152, - 0.100754, 0.186257, 0.617433, 0.970557, - 0.102239, 0.183775, 0.645801, 0.972104, - 0.102767, 0.180645, 0.674278, 0.973203, - 0.103492, 0.177242, 0.702004, 0.975123, - 0.103793, 0.17345, 0.729529, 0.97641, - 0.102839, 0.168886, 0.756712, 0.978313, - 0.101687, 0.163892, 0.783801, 0.980036, - 0.100314, 0.158439, 0.809671, 0.981339, - 0.097836, 0.152211, 0.835402, 0.982794, - 0.0950006, 0.145679, 0.860081, 0.984123, - 0.0920994, 0.138949, 0.883757, 0.984918, - 0.0878641, 0.131283, 0.90685, 0.985999, - 0.083939, 0.123464, 0.928786, 0.987151, - 0.0791234, 0.115324, 0.94983, 0.987827, - 0.0739332, 0.106854, 0.96962, 0.988806, - 0.0688088, 0.0982691, 0.98861, 0.989588, - 0.0628962, 0.0893456, 1.00667, 0.990438, - 0.0573146, 0.0805392, 1.02344, 0.991506, - 0.0509433, 0.0713725, 1.03933, 0.992492, - 0.0448724, 0.0623732, 1.05378, 0.993663, - 0.0383497, 0.0530838, 1.06747, 0.994956, - 0.0319593, 0.0439512, 1.08007, 0.99634, - 0.025401, 0.0347803, 1.09182, 0.99761, - 0.0189687, 0.0257954, 1.1025, 0.99863, - 0.0124441, 0.0169893, 1.11247, 0.99947, - 0.00614003, 0.00829498, 1.12151, 1.00008, 0.000216624, - 0.000146107, 1.12993, 0.950129, - 4.34955e-06, 0.217413, 1.90081e-05, 0.950264, - 0.00010957, 0.217444, 0.00047884, 0.9503, - 0.000438299, 0.217451, 0.00191543, 0.950246, - 0.000986124, 0.21744, 0.00430951, 0.950246, - 0.00175311, 0.21744, 0.00766137, 0.950245, - 0.00273923, 0.21744, 0.011971, 0.950253, - 0.00394453, 0.217441, 0.0172385, 0.950258, - 0.00536897, 0.217442, 0.0234641, 0.950267, - 0.00701262, 0.217444, 0.030648, 0.950277, - 0.00887551, 0.217446, 0.038791, 0.950284, - 0.0109576, 0.217446, 0.0478931, 0.950312, - 0.0132591, 0.217451, 0.0579568, 0.950334, - 0.01578, 0.217454, 0.0689821, 0.950378, - 0.0185204, 0.217462, 0.0809714, 0.950417, - 0.0214803, 0.217467, 0.0939265, 0.950488, - 0.0246594, 0.217479, 0.10785, 0.950534, - 0.0280565, 0.217483, 0.122743, 0.950633, - 0.0316685, 0.217498, 0.138611, 0.950698, - 0.0354787, 0.217499, 0.155442, 0.950844, - 0.0394003, 0.217507, 0.173208, 0.950999, - 0.0426812, 0.217419, 0.191605, 0.951221, - 0.0461302, 0.217317, 0.21084, 0.951412, - 0.0502131, 0.217238, 0.230945, 0.951623, - 0.0549183, 0.21722, 0.251745, 0.951867, - 0.0604493, 0.217306, 0.273001, 0.952069, - 0.0665189, 0.217466, 0.294874, 0.952459, - 0.0709179, 0.217266, 0.318732, 0.952996, - 0.0746112, 0.216891, 0.34318, 0.953425, - 0.0789252, 0.216503, 0.36849, 0.953885, - 0.0833293, 0.216042, 0.394373, 0.954617, - 0.087371, 0.215469, 0.420505, 0.955429, - 0.0914054, 0.214802, 0.446907, 0.956068, - 0.0961671, 0.214146, 0.473522, 0.957094, - 0.10048, 0.213286, 0.50052, 0.958372, - 0.103248, 0.211796, 0.528715, 0.959654, - 0.106033, 0.21016, 0.557065, 0.961305, - 0.108384, 0.208149, 0.585286, 0.962785, - 0.111122, 0.206024, 0.613334, 0.964848, - 0.112981, 0.203442, 0.641334, 0.966498, - 0.113717, 0.19996, 0.669955, 0.968678, - 0.114121, 0.196105, 0.698094, 0.970489, - 0.114524, 0.191906, 0.725643, 0.972903, - 0.113792, 0.186963, 0.752856, 0.974701, - 0.112406, 0.181343, 0.780013, 0.976718, - 0.110685, 0.175185, 0.806268, 0.978905, - 0.108468, 0.168535, 0.832073, 0.980267, - 0.105061, 0.161106, 0.857149, 0.981967, - 0.101675, 0.153387, 0.881145, 0.983063, - 0.0974492, 0.145199, 0.904255, 0.984432, - 0.0925815, 0.136527, 0.926686, 0.985734, - 0.0877983, 0.127584, 0.947901, 0.986228, - 0.081884, 0.118125, 0.968111, 0.98719, - 0.0761208, 0.108594, 0.98719, 0.988228, - 0.0698196, 0.0989996, 1.00559, 0.989046, - 0.0632739, 0.0890074, 1.02246, 0.990242, - 0.056522, 0.0790832, 1.03841, 0.991252, - 0.0495272, 0.0689182, 1.05347, 0.992542, - 0.0425373, 0.0588592, 1.06724, 0.994096, - 0.0353198, 0.0486833, 1.08009, 0.995593, - 0.028235, 0.0385977, 1.09177, 0.99711, - 0.0209511, 0.0286457, 1.10274, 0.998263, - 0.0139289, 0.0188497, 1.11262, 0.999254, - 0.0067359, 0.009208, 1.12191, 0.999967, 0.000141846, - 6.57764e-05, 1.13024, 0.935608, - 4.74692e-06, 0.236466, 1.87817e-05, 0.93996, - 0.00011971, 0.237568, 0.000473646, 0.939959, - 0.000478845, 0.237567, 0.0018946, 0.939954, - 0.0010774, 0.237566, 0.00426284, 0.939956, - 0.00191538, 0.237566, 0.00757842, 0.939954, - 0.00299277, 0.237566, 0.0118413, 0.93996, - 0.00430961, 0.237567, 0.0170518, 0.939969, - 0.00586589, 0.237569, 0.02321, 0.939982, - 0.00766166, 0.237572, 0.0303164, 0.939987, - 0.00969686, 0.237572, 0.0383711, 0.939997, - 0.0119715, 0.237574, 0.0473751, 0.940031, - 0.0144858, 0.237581, 0.0573298, 0.940073, - 0.0172399, 0.237589, 0.0682366, 0.94012, - 0.0202335, 0.237598, 0.080097, 0.940162, - 0.0234663, 0.237604, 0.0929116, 0.940237, - 0.0269387, 0.237615, 0.106686, 0.940328, - 0.0306489, 0.237632, 0.121421, 0.940419, - 0.0345917, 0.237645, 0.137115, 0.940522, - 0.0387481, 0.237654, 0.153766, 0.940702, - 0.0429906, 0.237661, 0.17133, 0.940871, - 0.0465089, 0.237561, 0.189502, 0.941103, - 0.050531, 0.23748, 0.208616, 0.941369, - 0.0550657, 0.237423, 0.228595, 0.941641, - 0.0601337, 0.237399, 0.249287, 0.941903, - 0.0658804, 0.237443, 0.270467, 0.942224, - 0.0722674, 0.237597, 0.292024, 0.942633, - 0.0771788, 0.237419, 0.315272, 0.943172, - 0.0815623, 0.237068, 0.339579, 0.943691, - 0.0863973, 0.236682, 0.364717, 0.944382, - 0.0911536, 0.236213, 0.390435, 0.945392, - 0.0952967, 0.235562, 0.416425, 0.946185, - 0.0998948, 0.234832, 0.442772, 0.947212, - 0.104796, 0.234114, 0.469347, 0.948778, - 0.10928, 0.233222, 0.496162, 0.950149, - 0.113081, 0.231845, 0.523978, 0.951989, - 0.115893, 0.230005, 0.552295, 0.953921, - 0.11846, 0.227862, 0.580569, 0.955624, - 0.12115, 0.225439, 0.608698, 0.958234, - 0.123373, 0.222635, 0.636696, 0.960593, - 0.124519, 0.219093, 0.665208, 0.963201, - 0.124736, 0.214749, 0.693557, 0.965642, - 0.125012, 0.210059, 0.721334, 0.968765, - 0.124661, 0.204935, 0.748613, 0.971753, - 0.122996, 0.198661, 0.776224, 0.973751, - 0.120998, 0.191823, 0.802461, 0.976709, - 0.118583, 0.184359, 0.828399, 0.977956, - 0.115102, 0.176437, 0.853693, 0.979672, - 0.111077, 0.167681, 0.877962, 0.981816, - 0.10688, 0.158872, 0.901564, 0.98238, - 0.101469, 0.149398, 0.924057, 0.983964, - 0.0960013, 0.139436, 0.945751, 0.984933, - 0.0899626, 0.12943, 0.966272, 0.985694, - 0.0832973, 0.11894, 0.985741, 0.986822, - 0.0767082, 0.108349, 1.00407, 0.987725, - 0.0693614, 0.0976026, 1.02154, 0.98877, - 0.06211, 0.086652, 1.03757, 0.990129, - 0.0544143, 0.0756182, 1.05296, 0.991337, - 0.046744, 0.0645753, 1.06683, 0.992978, - 0.0387931, 0.0534683, 1.0798, 0.994676, - 0.030973, 0.0424137, 1.09181, 0.99645, - 0.0230311, 0.0314035, 1.10286, 0.997967, - 0.0152065, 0.0206869, 1.11291, 0.99922, - 0.00744837, 0.010155, 1.12237, 1.00002, 0.000240209, - 7.52767e-05, 1.13089, 0.922948, - 5.15351e-06, 0.255626, 1.86069e-05, 0.928785, - 0.000129623, 0.257244, 0.000468009, 0.928761, - 0.00051849, 0.257237, 0.00187202, 0.928751, - 0.0011666, 0.257235, 0.00421204, 0.928751, - 0.00207395, 0.257234, 0.0074881, 0.928754, - 0.00324055, 0.257235, 0.0117002, 0.92876, - 0.00466639, 0.257236, 0.0168486, 0.928763, - 0.00635149, 0.257237, 0.0229334, 0.928774, - 0.00829584, 0.257239, 0.029955, 0.928791, - 0.0104995, 0.257243, 0.0379139, 0.928804, - 0.0129623, 0.257245, 0.0468108, 0.928847, - 0.0156846, 0.257255, 0.0566473, 0.92889, - 0.0186661, 0.257263, 0.0674246, 0.928924, - 0.0219067, 0.257268, 0.0791433, 0.928989, - 0.0254066, 0.257282, 0.0918076, 0.92909, - 0.0291651, 0.257301, 0.105419, 0.92918, - 0.0331801, 0.257316, 0.119978, 0.92929, - 0.0374469, 0.257332, 0.135491, 0.929453, - 0.041939, 0.257357, 0.151948, 0.929586, - 0.0464612, 0.257347, 0.169275, 0.929858, - 0.0503426, 0.257269, 0.187257, 0.930125, - 0.0548409, 0.257199, 0.206204, 0.930403, - 0.0598063, 0.257149, 0.22601, 0.930726, - 0.0652437, 0.257122, 0.246561, 0.931098, - 0.0712376, 0.257153, 0.267618, 0.931396, - 0.0777506, 0.257237, 0.288993, 0.931947, - 0.0832374, 0.257124, 0.311527, 0.932579, - 0.0883955, 0.25683, 0.335697, 0.933194, - 0.0937037, 0.256444, 0.360634, 0.934013, - 0.0987292, 0.255939, 0.386126, 0.935307, - 0.103215, 0.255282, 0.412018, 0.936374, - 0.108234, 0.254538, 0.438292, 0.93776, - 0.113234, 0.253728, 0.464805, 0.939599, - 0.118013, 0.25275, 0.491464, 0.941036, - 0.122661, 0.251404, 0.518751, 0.94337, - 0.125477, 0.249435, 0.547133, 0.945318, - 0.128374, 0.247113, 0.575456, 0.947995, - 0.130996, 0.244441, 0.60372, 0.950818, - 0.133438, 0.241352, 0.63174, 0.954378, - 0.135004, 0.237849, 0.659971, 0.957151, - 0.135313, 0.233188, 0.688478, 0.960743, - 0.13521, 0.228001, 0.716767, 0.964352, - 0.135007, 0.222249, 0.744349, 0.967273, - 0.133523, 0.21542, 0.771786, 0.969767, - 0.131155, 0.208039, 0.798639, 0.973195, - 0.128492, 0.200076, 0.824774, 0.975557, - 0.125094, 0.191451, 0.850222, 0.977692, - 0.120578, 0.18184, 0.874761, 0.98026, - 0.115882, 0.172102, 0.898497, 0.981394, - 0.110372, 0.161859, 0.921636, 0.982386, - 0.10415, 0.15108, 0.943467, 0.983783, - 0.0978128, 0.140407, 0.964045, 0.98422, - 0.0906171, 0.129058, 0.98398, 0.985447, - 0.0832921, 0.117614, 1.00276, 0.986682, - 0.0754412, 0.10585, 1.02047, 0.987326, - 0.0673885, 0.0940943, 1.03678, 0.988707, - 0.0592565, 0.0822093, 1.05218, 0.990185, - 0.050717, 0.070192, 1.06652, 0.991866, - 0.0423486, 0.0582081, 1.07965, 0.993897, - 0.0336118, 0.0460985, 1.09188, 0.995841, - 0.0252178, 0.0342737, 1.10307, 0.997605, - 0.0164893, 0.0224829, 1.11324, 0.999037, - 0.00817112, 0.0110647, 1.12262, 1.00003, 0.000291686, - 0.000168673, 1.13139, 0.915304, - 5.52675e-06, 0.275999, 1.83285e-05, 0.91668, - 0.000139285, 0.276414, 0.000461914, 0.916664, - 0.00055713, 0.276409, 0.00184763, 0.916653, - 0.00125354, 0.276406, 0.00415715, 0.916651, - 0.00222851, 0.276405, 0.00739053, 0.916655, - 0.00348205, 0.276406, 0.0115478, 0.916653, - 0.00501414, 0.276405, 0.0166291, 0.916667, - 0.00682478, 0.276409, 0.0226346, 0.91668, - 0.00891398, 0.276412, 0.0295648, 0.91669, - 0.0112817, 0.276413, 0.0374199, 0.916727, - 0.013928, 0.276422, 0.0462016, 0.916759, - 0.0168528, 0.276429, 0.0559101, 0.916793, - 0.0200558, 0.276436, 0.0665466, 0.916849, - 0.0235373, 0.276448, 0.0781139, 0.916964, - 0.0272973, 0.276474, 0.0906156, 0.917047, - 0.0313344, 0.276491, 0.104051, 0.917152, - 0.0356465, 0.276511, 0.118424, 0.917286, - 0.0402271, 0.276533, 0.133736, 0.917469, - 0.0450408, 0.276564, 0.149978, 0.917686, - 0.0497872, 0.276563, 0.167057, 0.917953, - 0.0540937, 0.276493, 0.184846, 0.918228, - 0.0590709, 0.276437, 0.203614, 0.918572, - 0.0644277, 0.276398, 0.223212, 0.918918, - 0.0702326, 0.276362, 0.243584, 0.919356, - 0.076484, 0.276383, 0.264465, 0.919842, - 0.0830808, 0.276434, 0.285701, 0.920451, - 0.0892972, 0.276407, 0.307559, 0.921113, - 0.095016, 0.276128, 0.331501, 0.921881, - 0.100771, 0.275754, 0.356207, 0.923027, - 0.106029, 0.275254, 0.381477, 0.924364, - 0.111029, 0.274595, 0.40722, 0.925818, - 0.116345, 0.273841, 0.433385, 0.92746, - 0.121424, 0.272913, 0.459848, 0.929167, - 0.12657, 0.271837, 0.486493, 0.931426, - 0.131581, 0.270575, 0.513432, 0.934001, - 0.135038, 0.268512, 0.541502, 0.936296, - 0.138039, 0.266135, 0.569658, 0.939985, - 0.140687, 0.263271, 0.598375, 0.943516, - 0.143247, 0.260058, 0.626563, 0.94782, - 0.145135, 0.256138, 0.654711, 0.951023, - 0.145733, 0.251154, 0.683285, 0.955338, - 0.145554, 0.245562, 0.711831, 0.959629, - 0.145008, 0.239265, 0.739573, 0.963123, - 0.144003, 0.232064, 0.767027, 0.966742, - 0.141289, 0.224036, 0.794359, 0.969991, - 0.138247, 0.215305, 0.820361, 0.973403, - 0.134786, 0.206051, 0.846548, 0.975317, - 0.129966, 0.195914, 0.871541, 0.977647, - 0.12471, 0.185184, 0.895313, 0.980137, - 0.119086, 0.174161, 0.918398, 0.981031, - 0.112297, 0.162792, 0.940679, 0.982037, - 0.105372, 0.150952, 0.961991, 0.983164, - 0.097821, 0.138921, 0.981913, 0.983757, - 0.0897245, 0.126611, 1.00109, 0.985036, - 0.0815974, 0.114228, 1.01902, 0.986289, - 0.0727725, 0.101389, 1.03604, 0.987329, - 0.0639323, 0.0886476, 1.05149, 0.989193, - 0.0548109, 0.0756837, 1.06619, 0.990716, - 0.045687, 0.0627581, 1.07948, 0.992769, - 0.0364315, 0.0498337, 1.09172, 0.99524, - 0.0271761, 0.0370305, 1.1033, 0.997154, - 0.0179609, 0.0243959, 1.11353, 0.998845, - 0.00878063, 0.0119567, 1.12319, 1.00002, 0.000259038, - 0.000108146, 1.13177, 0.903945, - 5.91681e-06, 0.295126, 1.81226e-05, 0.903668, - 0.000148672, 0.295037, 0.000455367, 0.903677, - 0.000594683, 0.29504, 0.00182145, 0.903673, - 0.00133805, 0.295039, 0.00409831, 0.903666, - 0.00237872, 0.295036, 0.00728584, 0.903668, - 0.00371676, 0.295037, 0.0113842, 0.903679, - 0.00535212, 0.29504, 0.0163936, 0.903684, - 0.00728479, 0.295041, 0.0223141, 0.903698, - 0.00951473, 0.295044, 0.0291462, 0.903718, - 0.0120419, 0.295049, 0.0368904, 0.903754, - 0.0148664, 0.295058, 0.0455477, 0.903801, - 0.017988, 0.29507, 0.0551194, 0.903851, - 0.0214064, 0.295082, 0.0656058, 0.903921, - 0.0251219, 0.295097, 0.0770109, 0.904002, - 0.0291337, 0.295116, 0.0893354, 0.904111, - 0.033441, 0.29514, 0.102583, 0.904246, - 0.0380415, 0.295169, 0.116755, 0.904408, - 0.0429258, 0.295202, 0.131853, 0.904637, - 0.0480468, 0.295245, 0.147869, 0.904821, - 0.0529208, 0.295214, 0.164658, 0.905163, - 0.0577748, 0.295185, 0.182274, 0.905469, - 0.0631763, 0.295143, 0.200828, 0.905851, - 0.068917, 0.295112, 0.2202, 0.906322, - 0.0750861, 0.295104, 0.240372, 0.906761, - 0.0815855, 0.295086, 0.261082, 0.90735, - 0.0882138, 0.295095, 0.282123, 0.908087, - 0.095082, 0.295139, 0.303563, 0.908826, - 0.101488, 0.29492, 0.327028, 0.909832, - 0.107577, 0.294577, 0.351464, 0.911393, - 0.113033, 0.294115, 0.376497, 0.912804, - 0.118629, 0.293446, 0.402115, 0.914081, - 0.124232, 0.292581, 0.428111, 0.91637, - 0.129399, 0.29166, 0.454442, 0.91814, - 0.134892, 0.290422, 0.481024, 0.921179, - 0.140069, 0.289194, 0.507924, 0.924544, - 0.144431, 0.287421, 0.535557, 0.927995, - 0.147498, 0.284867, 0.563984, 0.931556, - 0.150197, 0.281722, 0.5923, 0.935777, - 0.152711, 0.278207, 0.620832, 0.940869, - 0.154836, 0.274148, 0.649069, 0.945994, - 0.155912, 0.269057, 0.677746, 0.949634, - 0.155641, 0.262799, 0.706293, 0.955032, - 0.154809, 0.256097, 0.734278, 0.95917, - 0.153678, 0.248618, 0.761751, 0.962931, - 0.151253, 0.239794, 0.789032, 0.966045, - 0.147625, 0.230281, 0.815422, 0.96971, - 0.143964, 0.220382, 0.841787, 0.972747, - 0.139464, 0.209846, 0.867446, 0.975545, - 0.133459, 0.198189, 0.892004, 0.978381, - 0.127424, 0.186362, 0.915458, 0.979935, - 0.120506, 0.173964, 0.937948, 0.980948, - 0.11282, 0.161429, 0.959732, 0.982234, - 0.104941, 0.148557, 0.980118, 0.982767, - 0.0962905, 0.135508, 0.999463, 0.983544, - 0.0873625, 0.122338, 1.01756, 0.984965, - 0.0783447, 0.108669, 1.03492, 0.986233, - 0.0684798, 0.0949911, 1.05087, 0.987796, - 0.0590867, 0.0811386, 1.0656, 0.989885, - 0.0489145, 0.0673099, 1.0794, 0.991821, - 0.0391, 0.0535665, 1.09174, 0.99448, - 0.029087, 0.0397529, 1.10341, 0.996769, - 0.019114, 0.0261463, 1.11383, 0.998641, - 0.00947007, 0.0128731, 1.1237, 0.999978, 0.000446316, - 0.000169093, 1.13253, 0.888362, - 6.27064e-06, 0.312578, 1.78215e-05, 0.889988, - 0.000157791, 0.313148, 0.000448451, 0.889825, - 0.000631076, 0.313092, 0.00179356, 0.88984, - 0.00141994, 0.313097, 0.00403554, 0.889828, - 0.0025243, 0.313092, 0.00717429, 0.889831, - 0.00394421, 0.313093, 0.0112099, 0.889831, - 0.00567962, 0.313093, 0.0161425, 0.889844, - 0.00773051, 0.313096, 0.0219724, 0.889858, - 0.0100968, 0.3131, 0.0286999, 0.889882, - 0.0127786, 0.313106, 0.0363256, 0.889918, - 0.0157757, 0.313116, 0.0448509, 0.889967, - 0.0190878, 0.313129, 0.0542758, 0.89003, - 0.022715, 0.313145, 0.0646032, 0.890108, - 0.0266566, 0.313165, 0.0758339, 0.890218, - 0.0309131, 0.313193, 0.0879729, 0.890351, - 0.0354819, 0.313226, 0.101019, 0.89051, - 0.0403613, 0.313263, 0.114979, 0.890672, - 0.0455385, 0.313294, 0.129848, 0.890882, - 0.0509444, 0.313333, 0.145616, 0.891189, - 0.0559657, 0.313324, 0.162122, 0.891457, - 0.0613123, 0.313281, 0.179524, 0.891856, - 0.0671488, 0.313281, 0.197855, 0.892312, - 0.0732732, 0.313268, 0.216991, 0.892819, - 0.0797865, 0.313263, 0.236924, 0.893369, - 0.0865269, 0.313247, 0.257433, 0.894045, - 0.0931592, 0.313205, 0.278215, 0.894884, - 0.100532, 0.313276, 0.299467, 0.895832, - 0.107716, 0.313205, 0.322276, 0.897043, - 0.114099, 0.312873, 0.34642, 0.898515, - 0.119941, 0.312331, 0.371187, 0.900191, - 0.126044, 0.311731, 0.396656, 0.90188, - 0.131808, 0.310859, 0.422488, 0.904359, - 0.137289, 0.309857, 0.448744, 0.906923, - 0.142991, 0.308714, 0.475239, 0.910634, - 0.148253, 0.307465, 0.501983, 0.914502, - 0.153332, 0.305774, 0.529254, 0.919046, - 0.156646, 0.303156, 0.557709, 0.923194, - 0.159612, 0.299928, 0.586267, 0.928858, - 0.162027, 0.296245, 0.614925, 0.934464, - 0.164203, 0.291832, 0.643187, 0.939824, - 0.165602, 0.286565, 0.671601, 0.944582, - 0.165383, 0.280073, 0.700213, 0.949257, - 0.164439, 0.272891, 0.728432, 0.954389, - 0.162953, 0.264771, 0.756082, 0.958595, - 0.161007, 0.255927, 0.78369, 0.962138, - 0.157243, 0.245769, 0.810769, 0.966979, - 0.152872, 0.235127, 0.836999, 0.969566, - 0.148209, 0.22347, 0.862684, 0.972372, - 0.142211, 0.211147, 0.887847, 0.975916, - 0.135458, 0.198606, 0.911843, 0.978026, - 0.128398, 0.185498, 0.934795, 0.979686, - 0.120313, 0.17171, 0.956787, 0.980748, - 0.11166, 0.158159, 0.978046, 0.981622, - 0.103035, 0.144399, 0.997693, 0.982356, - 0.0930328, 0.13001, 1.01642, 0.983308, - 0.0834627, 0.115778, 1.03366, 0.985037, - 0.0732249, 0.101327, 1.05014, 0.986493, - 0.0628145, 0.086554, 1.06507, 0.988484, - 0.0526556, 0.0720413, 1.07907, 0.991051, - 0.0415744, 0.0571151, 1.09189, 0.993523, - 0.0314275, 0.0426643, 1.10369, 0.99628, - 0.0203603, 0.0279325, 1.11423, 0.998344, - 0.0102446, 0.0138182, 1.12421, 0.999997, 0.00042612, - 0.000193628, 1.1333, 0.871555, - 6.60007e-06, 0.329176, 1.74749e-05, 0.875255, - 0.000166579, 0.330571, 0.000441051, 0.875644, - 0.000666394, 0.330718, 0.00176441, 0.875159, - 0.00149903, 0.330536, 0.00396899, 0.87516, - 0.00266493, 0.330536, 0.007056, 0.875158, - 0.00416393, 0.330535, 0.0110251, 0.87516, - 0.00599598, 0.330535, 0.0158764, 0.875163, - 0.00816108, 0.330536, 0.0216101, 0.875174, - 0.0106591, 0.330538, 0.0282266, 0.875199, - 0.0134899, 0.330545, 0.0357266, 0.875257, - 0.0166538, 0.330563, 0.0441117, 0.875304, - 0.0201501, 0.330575, 0.0533821, 0.875373, - 0.0239785, 0.330595, 0.0635395, 0.875464, - 0.0281389, 0.330619, 0.0745872, 0.875565, - 0.0326301, 0.330645, 0.0865255, 0.875691, - 0.0374516, 0.330676, 0.0993599, 0.875897, - 0.0425993, 0.330733, 0.113093, 0.876091, - 0.0480576, 0.330776, 0.127722, 0.876353, - 0.0537216, 0.330826, 0.143227, 0.876649, - 0.0589807, 0.330809, 0.159462, 0.877034, - 0.0647865, 0.330819, 0.176642, 0.877443, - 0.0709789, 0.330817, 0.194702, 0.877956, - 0.0774782, 0.330832, 0.213577, 0.878499, - 0.0843175, 0.330822, 0.233246, 0.879144, - 0.0912714, 0.330804, 0.253512, 0.879982, - 0.0980824, 0.330766, 0.274137, 0.88097, - 0.105823, 0.330864, 0.295209, 0.882051, - 0.113671, 0.330896, 0.317226, 0.883397, - 0.120303, 0.330545, 0.341068, 0.884987, - 0.12667, 0.330068, 0.365613, 0.886789, - 0.133118, 0.329418, 0.390807, 0.889311, - 0.139024, 0.328683, 0.416494, 0.891995, - 0.144971, 0.327729, 0.442618, 0.895106, - 0.150747, 0.326521, 0.469131, 0.899527, - 0.156283, 0.325229, 0.495921, 0.90504, - 0.161707, 0.32378, 0.523162, 0.909875, - 0.165661, 0.32122, 0.55092, 0.91561, - 0.168755, 0.317942, 0.579928, 0.921225, - 0.171193, 0.313983, 0.608539, 0.927308, - 0.17319, 0.309636, 0.636854, 0.933077, - 0.174819, 0.304262, 0.66523, 0.938766, - 0.175002, 0.297563, 0.693609, 0.943667, - 0.173946, 0.289613, 0.722157, 0.949033, - 0.172221, 0.281227, 0.750021, 0.953765, - 0.169869, 0.271545, 0.777466, 0.95804, - 0.166578, 0.261034, 0.804853, 0.962302, - 0.161761, 0.249434, 0.831569, 0.966544, - 0.156636, 0.237484, 0.857779, 0.969372, - 0.150784, 0.224395, 0.883051, 0.972486, - 0.143672, 0.210786, 0.907864, 0.975853, - 0.135772, 0.196556, 0.931223, 0.977975, - 0.127942, 0.182307, 0.954061, 0.979122, - 0.118347, 0.167607, 0.97531, 0.980719, - 0.109112, 0.152739, 0.995666, 0.981223, - 0.0991789, 0.137932, 1.01475, 0.98216, - 0.0883553, 0.122692, 1.03253, 0.983379, - 0.0780825, 0.107493, 1.04917, 0.985434, - 0.0665646, 0.0917791, 1.06464, 0.987332, - 0.0557714, 0.0764949, 1.07896, 0.990004, - 0.0442805, 0.060721, 1.09199, 0.992975, - 0.0331676, 0.0452284, 1.10393, 0.995811, - 0.0219547, 0.0297934, 1.11476, 0.9982, - 0.0107613, 0.0146415, 1.12484, 1.00002, 0.000248678, - 0.00014555, 1.13413, 0.859519, - 6.93595e-06, 0.347264, 1.71673e-05, 0.859843, - 0.00017503, 0.347394, 0.000433219, 0.859656, - 0.000700076, 0.347319, 0.00173277, 0.859671, - 0.00157517, 0.347325, 0.00389875, 0.859669, - 0.00280028, 0.347324, 0.00693112, 0.85967, - 0.0043754, 0.347324, 0.01083, 0.859665, - 0.00630049, 0.347321, 0.0155954, 0.859685, - 0.0085755, 0.347328, 0.0212278, 0.859694, - 0.0112003, 0.347329, 0.0277273, 0.859718, - 0.0141747, 0.347336, 0.0350946, 0.85976, - 0.0174988, 0.347348, 0.0433314, 0.85982, - 0.0211722, 0.347366, 0.0524384, 0.859892, - 0.0251941, 0.347387, 0.0624168, 0.860006, - 0.0295649, 0.347422, 0.0732708, 0.860122, - 0.0342825, 0.347453, 0.0849999, 0.860282, - 0.0393462, 0.347499, 0.0976102, 0.860482, - 0.0447513, 0.347554, 0.111104, 0.860719, - 0.0504775, 0.347614, 0.125479, 0.860998, - 0.0563577, 0.347666, 0.140703, 0.861322, - 0.0619473, 0.347662, 0.156681, 0.861724, - 0.0681277, 0.347684, 0.173597, 0.862198, - 0.0746567, 0.347709, 0.191371, 0.862733, - 0.0815234, 0.347727, 0.209976, 0.863371, - 0.0886643, 0.347744, 0.229351, 0.86414, - 0.0957908, 0.347734, 0.24934, 0.865138, - 0.102912, 0.34772, 0.269797, 0.866182, - 0.110924, 0.3478, 0.290654, 0.867436, - 0.119223, 0.347911, 0.312074, 0.869087, - 0.126197, 0.347649, 0.335438, 0.870859, - 0.133145, 0.347222, 0.359732, 0.872997, - 0.139869, 0.346645, 0.38467, 0.875939, - 0.146089, 0.345935, 0.41019, 0.879012, - 0.152334, 0.345012, 0.436218, 0.883353, - 0.15821, 0.343924, 0.462641, 0.888362, - 0.164097, 0.342636, 0.489449, 0.895026, - 0.169528, 0.341351, 0.516629, 0.900753, - 0.174408, 0.339115, 0.544109, 0.906814, - 0.17751, 0.335809, 0.572857, 0.912855, - 0.180101, 0.331597, 0.601554, 0.919438, - 0.182116, 0.32698, 0.630198, 0.925962, - 0.183494, 0.321449, 0.658404, 0.931734, - 0.184159, 0.314595, 0.686625, 0.93762, - 0.18304, 0.306462, 0.71531, 0.943858, - 0.181323, 0.297514, 0.744272, 0.948662, - 0.178683, 0.287447, 0.771462, 0.953299, - 0.175379, 0.276166, 0.798593, 0.957346, - 0.170395, 0.263758, 0.8256, 0.962565, - 0.165042, 0.251019, 0.852575, 0.966075, - 0.158655, 0.237011, 0.878316, 0.969048, - 0.151707, 0.222518, 0.90329, 0.972423, - 0.143271, 0.207848, 0.927745, 0.975833, - 0.134824, 0.192463, 0.950859, 0.977629, - 0.125444, 0.1768, 0.972947, 0.978995, - 0.114949, 0.161033, 0.993263, 0.980533, - 0.104936, 0.145523, 1.01337, 0.980745, - 0.0935577, 0.129799, 1.03128, 0.981814, - 0.0822956, 0.113486, 1.04825, 0.983943, - 0.0710082, 0.0972925, 1.06405, 0.986141, - 0.0587931, 0.0808138, 1.0785, 0.988878, - 0.0472755, 0.0644915, 1.09204, 0.992132, - 0.0349128, 0.0478128, 1.10413, 0.9953, - 0.0232407, 0.031621, 1.11527, 0.998117, - 0.0112713, 0.0154935, 1.12551, 1.00003, 0.000339743, - 0.000195763, 1.13504, 0.845441, - 7.29126e-06, 0.364305, 1.69208e-05, 0.843588, - 0.000183164, 0.363506, 0.000425067, 0.843412, - 0.00073253, 0.36343, 0.00169999, 0.843401, - 0.00164818, 0.363426, 0.00382495, 0.843399, - 0.00293008, 0.363425, 0.00679993, 0.843401, - 0.00457822, 0.363425, 0.010625, 0.843394, - 0.00659249, 0.363421, 0.0153002, 0.843398, - 0.00897282, 0.363421, 0.0208258, 0.843415, - 0.0117191, 0.363426, 0.0272024, 0.843438, - 0.0148312, 0.363432, 0.0344305, 0.843483, - 0.018309, 0.363447, 0.0425116, 0.84356, - 0.0221521, 0.363472, 0.0514471, 0.843646, - 0.0263597, 0.363499, 0.061238, 0.843743, - 0.0309315, 0.363527, 0.0718873, 0.84388, - 0.0358658, 0.363569, 0.0833969, 0.844079, - 0.0411624, 0.363631, 0.0957742, 0.844279, - 0.0468128, 0.363688, 0.109015, 0.844549, - 0.0527923, 0.363761, 0.123124, 0.844858, - 0.0588204, 0.363817, 0.138044, 0.84522, - 0.0647573, 0.36383, 0.153755, 0.845669, - 0.0713181, 0.363879, 0.170394, 0.846155, - 0.0781697, 0.363908, 0.187861, 0.846789, - 0.0853913, 0.363969, 0.206176, 0.847502, - 0.0928086, 0.363999, 0.225244, 0.8484, - 0.10005, 0.363997, 0.244926, 0.849461, - 0.107615, 0.364008, 0.265188, 0.850562, - 0.115814, 0.364055, 0.28587, 0.851962, - 0.124334, 0.364179, 0.306926, 0.854326, - 0.131995, 0.364233, 0.329605, 0.856295, - 0.139338, 0.363856, 0.35359, 0.858857, - 0.146346, 0.363347, 0.37831, 0.862428, - 0.152994, 0.362807, 0.403722, 0.866203, - 0.159463, 0.361963, 0.429537, 0.871629, - 0.165623, 0.36112, 0.456, 0.877365, - 0.171649, 0.359917, 0.482773, 0.883744, - 0.177151, 0.35848, 0.509705, 0.890693, - 0.182381, 0.356523, 0.537215, 0.897278, - 0.186076, 0.3533, 0.565493, 0.903958, - 0.188602, 0.349095, 0.594293, 0.910908, - 0.190755, 0.344215, 0.623165, 0.918117, - 0.192063, 0.338606, 0.651573, 0.924644, - 0.192758, 0.331544, 0.679869, 0.931054, - 0.192238, 0.323163, 0.708668, 0.937303, - 0.190035, 0.313529, 0.737201, 0.943387, - 0.187162, 0.303152, 0.764977, 0.948494, - 0.183876, 0.29146, 0.792683, 0.952546, - 0.178901, 0.277917, 0.819228, 0.958077, - 0.173173, 0.264753, 0.846559, 0.962462, - 0.16645, 0.25002, 0.872962, 0.966569, - 0.159452, 0.234873, 0.898729, 0.969108, - 0.15074, 0.218752, 0.923126, 0.973072, - 0.141523, 0.202673, 0.947278, 0.975452, - 0.132075, 0.186326, 0.969938, 0.977784, - 0.121257, 0.169396, 0.991325, 0.97899, - 0.110182, 0.153044, 1.01123, 0.979777, - 0.0989634, 0.136485, 1.0299, 0.980865, - 0.0865894, 0.119343, 1.04727, 0.982432, - 0.0746115, 0.102452, 1.06341, 0.984935, - 0.0621822, 0.0852423, 1.07834, 0.987776, - 0.0495694, 0.0678546, 1.092, 0.99103, - 0.0372386, 0.0506917, 1.1043, 0.99474, - 0.0244353, 0.0333316, 1.11576, 0.997768, - 0.0121448, 0.0164348, 1.12617, 1.00003, 0.00031774, - 0.000169504, 1.13598, 0.825551, - 7.56799e-06, 0.378425, 1.65099e-05, 0.82664, - 0.000190922, 0.378923, 0.000416504, 0.826323, - 0.000763495, 0.378779, 0.0016656, 0.826359, - 0.00171789, 0.378795, 0.00374768, 0.82636, - 0.00305402, 0.378795, 0.00666259, 0.826368, - 0.00477185, 0.378798, 0.0104104, 0.826364, - 0.00687131, 0.378795, 0.0149912, 0.826368, - 0.00935232, 0.378795, 0.0204054, 0.826376, - 0.0122146, 0.378797, 0.0266532, 0.826399, - 0.0154581, 0.378803, 0.0337355, 0.82646, - 0.0190825, 0.378824, 0.0416537, 0.826525, - 0.0230873, 0.378846, 0.0504091, 0.826614, - 0.0274719, 0.378876, 0.0600032, 0.82674, - 0.0322355, 0.378917, 0.0704393, 0.826888, - 0.0373766, 0.378964, 0.0817195, 0.827078, - 0.0428936, 0.379024, 0.0938492, 0.827318, - 0.0487778, 0.379099, 0.106828, 0.82764, - 0.0549935, 0.379199, 0.120659, 0.827926, - 0.0611058, 0.379227, 0.13526, 0.828325, - 0.0675054, 0.379275, 0.150713, 0.828801, - 0.0743455, 0.379332, 0.167034, 0.8294, - 0.0815523, 0.379415, 0.184209, 0.830094, - 0.0890779, 0.379495, 0.202203, 0.8309, - 0.096736, 0.379555, 0.220945, 0.831943, - 0.104135, 0.379577, 0.240306, 0.833037, - 0.112106, 0.379604, 0.260317, 0.834278, - 0.120554, 0.379668, 0.2808, 0.836192, - 0.129128, 0.3799, 0.301654, 0.838671, - 0.137541, 0.380109, 0.323502, 0.840939, - 0.14523, 0.379809, 0.347176, 0.844575, - 0.15248, 0.379593, 0.371706, 0.848379, - 0.159607, 0.37909, 0.39688, 0.853616, - 0.166267, 0.378617, 0.422702, 0.858921, - 0.172698, 0.377746, 0.448919, 0.865324, - 0.178823, 0.376749, 0.475661, 0.872207, - 0.184542, 0.375363, 0.502599, 0.880018, - 0.189836, 0.373657, 0.529914, 0.88694, - 0.194294, 0.370673, 0.557683, 0.894779, - 0.197022, 0.36662, 0.586848, 0.902242, - 0.199108, 0.36138, 0.615831, 0.909914, - 0.200398, 0.355434, 0.644478, 0.917088, - 0.20094, 0.348173, 0.672905, 0.923888, - 0.200671, 0.339482, 0.701327, 0.930495, - 0.198773, 0.32956, 0.730101, 0.937247, - 0.195394, 0.318363, 0.758383, 0.943108, - 0.191956, 0.306323, 0.786539, 0.948296, - 0.187227, 0.292576, 0.813637, 0.953472, - 0.181165, 0.278234, 0.840793, 0.958485, - 0.174119, 0.263054, 0.867712, 0.962714, - 0.166564, 0.246756, 0.893635, 0.966185, - 0.158181, 0.229945, 0.919028, 0.970146, - 0.148275, 0.212633, 0.943413, 0.973491, - 0.138157, 0.195229, 0.966627, 0.975741, - 0.127574, 0.178048, 0.988817, 0.977238, - 0.11554, 0.160312, 1.00924, 0.978411, - 0.10364, 0.142857, 1.02845, 0.979811, - 0.0913122, 0.125317, 1.04648, 0.98116, - 0.0782558, 0.107627, 1.06284, 0.983543, - 0.0655957, 0.0895862, 1.07798, 0.986789, - 0.0520411, 0.0713756, 1.092, 0.990292, - 0.0389727, 0.053228, 1.10484, 0.994187, - 0.025808, 0.0351945, 1.11642, 0.997499, - 0.0126071, 0.0173198, 1.12703, 0.999999, 0.000275604, - 0.000148602, 1.13674, 0.81075, - 7.8735e-06, 0.394456, 1.61829e-05, 0.808692, - 0.000198293, 0.393453, 0.000407564, 0.80846, - 0.000792877, 0.39334, 0.00162965, 0.808595, - 0.00178416, 0.393407, 0.00366711, 0.808597, - 0.00317182, 0.393408, 0.00651934, 0.808598, - 0.00495589, 0.393408, 0.0101866, 0.808591, - 0.00713627, 0.393403, 0.0146689, 0.808592, - 0.00971285, 0.393402, 0.0199667, 0.80861, - 0.0126855, 0.393407, 0.0260803, 0.808633, - 0.0160538, 0.393413, 0.0330107, 0.80868, - 0.0198175, 0.393429, 0.0407589, 0.808748, - 0.0239758, 0.393453, 0.0493264, 0.808854, - 0.0285286, 0.39349, 0.0587161, 0.808992, - 0.0334748, 0.39354, 0.0689304, 0.809141, - 0.0388116, 0.393588, 0.0799707, 0.809352, - 0.0445375, 0.39366, 0.0918432, 0.809608, - 0.0506427, 0.393742, 0.104549, 0.809915, - 0.0570708, 0.393834, 0.118085, 0.810253, - 0.0633526, 0.393885, 0.132377, 0.810687, - 0.0700966, 0.393953, 0.147537, 0.811233, - 0.0772274, 0.394047, 0.163543, 0.811865, - 0.0847629, 0.394148, 0.180394, 0.812648, - 0.0925663, 0.394265, 0.198051, 0.813583, - 0.100416, 0.394363, 0.216443, 0.814683, - 0.108119, 0.394402, 0.235502, 0.815948, - 0.11644, 0.394489, 0.255242, 0.817278, - 0.125036, 0.394542, 0.275441, 0.819605, - 0.133655, 0.39486, 0.296094, 0.822256, - 0.142682, 0.395248, 0.317309, 0.825349, - 0.150756, 0.395241, 0.340516, 0.829605, - 0.158392, 0.395285, 0.364819, 0.83391, - 0.165801, 0.394922, 0.389736, 0.839808, - 0.172677, 0.394691, 0.415409, 0.845708, - 0.179448, 0.394006, 0.441546, 0.853025, - 0.185746, 0.393279, 0.46832, 0.859666, - 0.191684, 0.391655, 0.495302, 0.86789, - 0.197146, 0.390068, 0.52262, 0.875845, - 0.201904, 0.38727, 0.550336, 0.882634, - 0.205023, 0.382688, 0.578825, 0.891076, - 0.207098, 0.377543, 0.608103, 0.900589, - 0.208474, 0.371752, 0.63723, 0.90791, - 0.209068, 0.364016, 0.665769, 0.915971, - 0.208655, 0.355593, 0.694428, 0.923455, - 0.20729, 0.345439, 0.723224, 0.931514, - 0.203821, 0.334099, 0.751925, 0.937885, - 0.19986, 0.321069, 0.780249, 0.943136, - 0.194993, 0.306571, 0.8077, 0.948818, - 0.189132, 0.291556, 0.83497, 0.954433, - 0.181617, 0.275745, 0.86188, 0.959078, - 0.173595, 0.258695, 0.888562, 0.962705, - 0.164855, 0.240825, 0.914008, 0.966753, - 0.155129, 0.22268, 0.939145, 0.970704, - 0.144241, 0.204542, 0.963393, 0.973367, - 0.133188, 0.185927, 0.985983, 0.975984, - 0.121146, 0.167743, 1.00704, 0.976994, - 0.108366, 0.149218, 1.02715, 0.978485, - 0.0956746, 0.13131, 1.0455, 0.980074, - 0.0820733, 0.112513, 1.06221, 0.98225, - 0.0684061, 0.0938323, 1.07782, 0.98553, - 0.0549503, 0.0749508, 1.09199, 0.989529, - 0.0407857, 0.055848, 1.10508, 0.993536, - 0.0271978, 0.0368581, 1.11684, 0.997247, - 0.0132716, 0.0181845, 1.12789, 1, 0.000431817, - 0.000198809, 1.13792, 0.785886, - 8.12608e-06, 0.405036, 1.57669e-05, 0.790388, - 0.000205278, 0.407355, 0.000398297, 0.790145, - 0.000820824, 0.407231, 0.00159263, 0.790135, - 0.00184681, 0.407226, 0.00358336, 0.790119, - 0.00328316, 0.407218, 0.00637039, 0.790126, - 0.00512988, 0.40722, 0.0099539, 0.79013, - 0.00738684, 0.407221, 0.0143339, 0.790135, - 0.0100538, 0.407221, 0.0195107, 0.790134, - 0.0131306, 0.407217, 0.0254848, 0.79016, - 0.0166169, 0.407224, 0.0322572, 0.790197, - 0.020512, 0.407236, 0.0398284, 0.790273, - 0.0248157, 0.407263, 0.0482014, 0.790381, - 0.029527, 0.407304, 0.0573777, 0.790521, - 0.0346446, 0.407355, 0.0673602, 0.790704, - 0.0401665, 0.40742, 0.0781522, 0.790925, - 0.0460896, 0.407499, 0.0897582, 0.791195, - 0.0524017, 0.407589, 0.10218, 0.791522, - 0.0590121, 0.407691, 0.11541, 0.791878, - 0.0654876, 0.407748, 0.12939, 0.792361, - 0.0725207, 0.407849, 0.144237, 0.792942, - 0.0799844, 0.407963, 0.159924, 0.79362, - 0.0877896, 0.408087, 0.176425, 0.794529, - 0.0958451, 0.408259, 0.193733, 0.795521, - 0.103827, 0.408362, 0.211756, 0.796778, - 0.111937, 0.408482, 0.230524, 0.798027, - 0.120521, 0.408547, 0.249967, 0.799813, - 0.129242, 0.408721, 0.269926, 0.802387, - 0.138048, 0.409148, 0.290338, 0.805279, - 0.147301, 0.409641, 0.311193, 0.809251, - 0.155895, 0.410154, 0.333611, 0.813733, - 0.163942, 0.410297, 0.357615, 0.819081, - 0.171666, 0.410373, 0.382339, 0.825427, - 0.178905, 0.410348, 0.407828, 0.83172, - 0.185812, 0.409486, 0.434034, 0.83877, - 0.192318, 0.408776, 0.460493, 0.845817, - 0.198249, 0.407176, 0.487346, 0.854664, - 0.204034, 0.405719, 0.514832, 0.863495, - 0.208908, 0.403282, 0.542401, 0.871883, - 0.212765, 0.399293, 0.570683, 0.88065, - 0.214911, 0.393803, 0.599947, 0.89004, - 0.216214, 0.387536, 0.62932, 0.898476, - 0.216745, 0.379846, 0.658319, 0.906738, - 0.216387, 0.370625, 0.687138, 0.914844, - 0.215053, 0.360139, 0.71601, 0.923877, - 0.212007, 0.348849, 0.745124, 0.931925, - 0.207481, 0.335639, 0.773366, 0.938054, - 0.202418, 0.320798, 0.801636, 0.943895, - 0.196507, 0.304772, 0.829055, 0.949468, - 0.189009, 0.288033, 0.856097, 0.955152, - 0.180539, 0.270532, 0.88301, 0.959403, - 0.171437, 0.251639, 0.909296, 0.963309, - 0.161661, 0.232563, 0.934868, 0.967399, - 0.150425, 0.213231, 0.959662, 0.972009, - 0.138659, 0.194247, 0.98302, 0.97433, - 0.126595, 0.174718, 1.00517, 0.975823, - 0.113205, 0.155518, 1.02566, 0.976371, - 0.0996096, 0.136709, 1.04418, 0.978705, - 0.0860754, 0.117571, 1.06146, 0.981477, - 0.0714438, 0.0980046, 1.07777, 0.984263, - 0.0572304, 0.0782181, 1.09214, 0.988423, - 0.0428875, 0.0584052, 1.10553, 0.993, - 0.0282442, 0.038522, 1.11758, 0.99704, - 0.0140183, 0.0190148, 1.12864, 0.999913, 0.000369494, - 0.000145203, 1.13901, 0.777662, - 8.4153e-06, 0.423844, 1.54403e-05, 0.770458, - 0.000211714, 0.419915, 0.00038845, 0.770716, - 0.000846888, 0.420055, 0.00155386, 0.770982, - 0.00190567, 0.420202, 0.00349653, 0.770981, - 0.00338782, 0.420201, 0.00621606, 0.77098, - 0.00529338, 0.4202, 0.00971274, 0.770983, - 0.00762223, 0.4202, 0.0139867, 0.770985, - 0.0103741, 0.420198, 0.0190381, 0.770996, - 0.0135489, 0.4202, 0.0248677, 0.771029, - 0.0171461, 0.420212, 0.0314764, 0.771052, - 0.0211647, 0.420215, 0.0388648, 0.771131, - 0.0256048, 0.420245, 0.047036, 0.771235, - 0.0304647, 0.420284, 0.0559911, 0.771383, - 0.0357436, 0.420341, 0.0657346, 0.771591, - 0.0414392, 0.420423, 0.0762694, 0.771819, - 0.0475462, 0.420506, 0.0875984, 0.772123, - 0.0540506, 0.420617, 0.099727, 0.772464, - 0.060797, 0.42072, 0.112637, 0.772855, - 0.0675393, 0.420799, 0.126313, 0.773317, - 0.0748323, 0.420893, 0.140824, 0.773981, - 0.0825681, 0.421058, 0.15617, 0.774746, - 0.0906307, 0.421226, 0.172322, 0.77566, - 0.0988982, 0.421397, 0.189253, 0.776837, - 0.106994, 0.421569, 0.206912, 0.778097, - 0.115528, 0.421704, 0.225359, 0.779588, - 0.124317, 0.421849, 0.24447, 0.781574, - 0.133139, 0.422097, 0.264156, 0.784451, - 0.142179, 0.422615, 0.284318, 0.787682, - 0.15165, 0.423269, 0.304902, 0.792433, - 0.160771, 0.424396, 0.3265, 0.797359, - 0.169166, 0.424772, 0.35014, 0.803986, - 0.177149, 0.425475, 0.374768, 0.809504, - 0.184745, 0.424996, 0.399928, 0.815885, - 0.19173, 0.424247, 0.425796, 0.823513, - 0.198525, 0.423515, 0.452287, 0.832549, - 0.204709, 0.422787, 0.479321, 0.841653, - 0.210447, 0.421187, 0.506718, 0.850401, - 0.215501, 0.418519, 0.53432, 0.859854, - 0.219752, 0.414715, 0.56242, 0.869364, - 0.222305, 0.409462, 0.591558, 0.878837, - 0.223744, 0.402926, 0.621074, 0.888636, - 0.224065, 0.395043, 0.650538, 0.898132, - 0.223742, 0.38564, 0.679538, 0.907181, - 0.222308, 0.375378, 0.708674, 0.915621, - 0.219837, 0.363212, 0.737714, 0.9239, - 0.215233, 0.349313, 0.767014, 0.931644, - 0.209592, 0.334162, 0.795133, 0.938887, - 0.203644, 0.317943, 0.823228, 0.945282, - 0.196349, 0.300581, 0.850822, 0.950758, - 0.18742, 0.282195, 0.877594, 0.956146, - 0.177879, 0.262481, 0.904564, 0.960355, - 0.167643, 0.242487, 0.930741, 0.965256, - 0.156671, 0.222668, 0.955868, 0.968029, - 0.144123, 0.201907, 0.979869, 0.97251, - 0.131305, 0.18202, 1.00291, 0.974925, - 0.118335, 0.161909, 1.02392, 0.975402, - 0.103714, 0.142129, 1.0433, 0.976987, - 0.089415, 0.122447, 1.06089, 0.979677, - 0.0748858, 0.102248, 1.07713, 0.983184, - 0.0596086, 0.0814851, 1.09218, 0.987466, - 0.0447671, 0.0609484, 1.10585, 0.992348, - 0.0295217, 0.0401835, 1.11829, 0.996674, - 0.0143917, 0.0198163, 1.12966, 1.00003, 0.000321364, - 0.000149983, 1.1402, 0.757901, - 8.69074e-06, 0.436176, 1.51011e-05, 0.751195, - 0.000217848, 0.432317, 0.000378533, 0.751178, - 0.000871373, 0.432307, 0.0015141, 0.751195, - 0.00196061, 0.432317, 0.0034068, 0.751198, - 0.00348552, 0.432318, 0.00605659, 0.751195, - 0.00544599, 0.432315, 0.00946353, 0.751207, - 0.00784203, 0.43232, 0.013628, 0.751213, - 0.0106732, 0.43232, 0.0185499, 0.751221, - 0.0139393, 0.432319, 0.0242302, 0.751244, - 0.0176398, 0.432325, 0.0306694, 0.7513, - 0.0217743, 0.432348, 0.0378698, 0.751358, - 0.0263412, 0.432367, 0.0458321, 0.751458, - 0.0313396, 0.432404, 0.0545587, 0.751608, - 0.0367682, 0.432464, 0.0640543, 0.7518, - 0.0426246, 0.43254, 0.0743222, 0.752065, - 0.0489031, 0.432645, 0.0853668, 0.752376, - 0.0555828, 0.432762, 0.0971911, 0.752715, - 0.0623861, 0.432859, 0.109768, 0.753137, - 0.069415, 0.432958, 0.123126, 0.753676, - 0.0770039, 0.433099, 0.137308, 0.754345, - 0.084971, 0.433272, 0.15229, 0.755235, - 0.0932681, 0.433504, 0.168075, 0.756186, - 0.10171, 0.433693, 0.184625, 0.757363, - 0.110019, 0.433857, 0.201897, 0.75884, - 0.11887, 0.434102, 0.220014, 0.760467, - 0.127881, 0.434306, 0.238778, 0.762969, - 0.136766, 0.434751, 0.258172, 0.765823, - 0.14612, 0.43529, 0.278062, 0.769676, - 0.15566, 0.436236, 0.298437, 0.774909, - 0.165177, 0.437754, 0.319532, 0.77994, - 0.17402, 0.438343, 0.342505, 0.785757, - 0.182201, 0.438609, 0.366693, 0.792487, - 0.190104, 0.438762, 0.391668, 0.80038, - 0.197438, 0.438795, 0.417494, 0.808494, - 0.204365, 0.438226, 0.443933, 0.817695, - 0.210714, 0.437283, 0.470929, 0.828111, - 0.216651, 0.436087, 0.498569, 0.837901, - 0.221804, 0.433717, 0.526165, 0.847813, - 0.226318, 0.430133, 0.554155, 0.858314, - 0.229297, 0.425213, 0.582822, 0.868891, - 0.230999, 0.418576, 0.612847, 0.878941, - 0.231155, 0.410405, 0.642445, 0.888809, - 0.230935, 0.400544, 0.672024, 0.898089, - 0.229343, 0.389613, 0.701366, 0.908081, - 0.226886, 0.377197, 0.730763, 0.916819, - 0.222676, 0.363397, 0.759642, 0.924968, - 0.216835, 0.347437, 0.788775, 0.932906, - 0.210245, 0.32995, 0.817135, 0.940025, - 0.202992, 0.312262, 0.844912, 0.946101, - 0.19436, 0.293313, 0.872164, 0.952835, - 0.184125, 0.273638, 0.899443, 0.957347, - 0.173657, 0.252385, 0.926389, 0.961434, - 0.162204, 0.231038, 0.951947, 0.965522, - 0.14979, 0.209834, 0.976751, 0.969412, - 0.136307, 0.188821, 1.00022, 0.973902, - 0.122527, 0.168013, 1.02229, 0.974045, - 0.108213, 0.147634, 1.04199, 0.975775, - 0.0927397, 0.12705, 1.06019, 0.978383, - 0.0778212, 0.106309, 1.07711, 0.98211, - 0.0621216, 0.0849279, 1.09245, 0.986517, - 0.0463847, 0.0633519, 1.10651, 0.991696, - 0.0309353, 0.0419698, 1.11903, 0.996349, - 0.0150914, 0.0206272, 1.13073, 1.00003, 0.000442449, - 0.000231396, 1.14146, 0.727498, - 8.85074e-06, 0.441528, 1.45832e-05, 0.730897, - 0.000223525, 0.443589, 0.000368298, 0.730796, - 0.000893996, 0.443528, 0.00147303, 0.730805, - 0.00201149, 0.443533, 0.00331433, 0.730814, - 0.00357596, 0.443538, 0.00589222, 0.730815, - 0.00558734, 0.443538, 0.00920678, 0.730822, - 0.00804544, 0.44354, 0.0132582, 0.730836, - 0.0109501, 0.443545, 0.0180468, 0.730848, - 0.0143008, 0.443546, 0.0235732, 0.730871, - 0.0180969, 0.443552, 0.0298382, 0.730915, - 0.022338, 0.443567, 0.0368438, 0.730982, - 0.0270225, 0.443591, 0.044591, 0.731076, - 0.0321491, 0.443627, 0.0530831, 0.731245, - 0.0377166, 0.443699, 0.0623243, 0.73144, - 0.0437216, 0.443777, 0.0723181, 0.7317, - 0.0501576, 0.443881, 0.0830691, 0.732034, - 0.0569942, 0.444014, 0.0945809, 0.732388, - 0.0638756, 0.444113, 0.106825, 0.732853, - 0.071203, 0.444247, 0.119859, 0.733473, - 0.0790076, 0.444442, 0.13369, 0.734195, - 0.0871937, 0.444645, 0.148304, 0.735069, - 0.095696, 0.444877, 0.163702, 0.736169, - 0.10426, 0.445133, 0.179861, 0.73747, - 0.112853, 0.44537, 0.196778, 0.738991, - 0.12199, 0.445651, 0.214496, 0.740865, - 0.131153, 0.445958, 0.232913, 0.743637, - 0.140245, 0.446548, 0.251977, 0.746797, - 0.149722, 0.447246, 0.271551, 0.751517, - 0.159341, 0.448656, 0.291774, 0.756156, - 0.169106, 0.449866, 0.312455, 0.761519, - 0.178436, 0.450919, 0.334552, 0.768295, - 0.186904, 0.451776, 0.358491, 0.776613, - 0.195117, 0.452832, 0.383446, 0.783966, - 0.202695, 0.45249, 0.408945, 0.793542, - 0.20985, 0.452587, 0.435364, 0.803192, - 0.216403, 0.451852, 0.462336, 0.813892, - 0.22251, 0.450708, 0.48987, 0.824968, - 0.227676, 0.4486, 0.517697, 0.835859, - 0.232443, 0.445156, 0.545975, 0.846825, - 0.235775, 0.440351, 0.574483, 0.858085, - 0.237897, 0.433641, 0.604246, 0.868825, - 0.238074, 0.425354, 0.634101, 0.879638, - 0.237661, 0.415383, 0.664201, 0.889966, - 0.236186, 0.404136, 0.693918, 0.899479, - 0.233599, 0.390917, 0.723481, 0.908769, - 0.229737, 0.376352, 0.75258, 0.917966, - 0.223836, 0.360372, 0.781764, 0.926304, - 0.217067, 0.342551, 0.811139, 0.934626, - 0.209309, 0.324238, 0.839585, 0.941841, - 0.20071, 0.304484, 0.867044, 0.94789, - 0.190602, 0.283607, 0.894579, 0.954196, - 0.179253, 0.262205, 0.921743, 0.958383, - 0.167646, 0.239847, 0.948026, 0.963119, - 0.155073, 0.218078, 0.973296, 0.966941, - 0.141426, 0.195899, 0.998135, 0.970836, - 0.126849, 0.174121, 1.02021, 0.973301, - 0.112296, 0.153052, 1.04085, 0.97448, - 0.0964965, 0.131733, 1.05946, 0.977045, - 0.080489, 0.10997, 1.07693, 0.980751, - 0.064844, 0.0881657, 1.09254, 0.985475, - 0.0481938, 0.0657987, 1.10697, 0.991089, - 0.0319185, 0.0435215, 1.12004, 0.996122, - 0.0158088, 0.0214779, 1.13173, 1.00001, 0.000372455, - 0.000200295, 1.14291, 0.708622, - 9.07597e-06, 0.45304, 1.41962e-05, 0.711162, - 0.000228911, 0.454662, 0.000358052, 0.709812, - 0.000914446, 0.453797, 0.00143034, 0.709865, - 0.00205819, 0.453834, 0.00321935, 0.709864, - 0.00365894, 0.453833, 0.00572331, 0.709855, - 0.00571692, 0.453826, 0.00894278, 0.709862, - 0.00823201, 0.453828, 0.012878, 0.709875, - 0.011204, 0.453832, 0.0175295, 0.709896, - 0.0146323, 0.453839, 0.0228978, 0.709925, - 0.0185163, 0.453847, 0.0289839, 0.709974, - 0.0228551, 0.453866, 0.0357894, 0.710045, - 0.0276473, 0.453892, 0.0433161, 0.710133, - 0.032891, 0.453924, 0.0515665, 0.710292, - 0.0385851, 0.453992, 0.0605458, 0.710485, - 0.0447254, 0.45407, 0.0702574, 0.710769, - 0.0513051, 0.454192, 0.0807077, 0.711106, - 0.0582733, 0.454329, 0.091896, 0.711516, - 0.0652866, 0.45446, 0.103814, 0.712071, - 0.0728426, 0.454653, 0.116508, 0.712676, - 0.0808307, 0.45484, 0.129968, 0.713476, - 0.0892216, 0.455096, 0.144206, 0.714377, - 0.0979047, 0.455346, 0.159212, 0.715579, - 0.106531, 0.455647, 0.174973, 0.716977, - 0.115492, 0.455961, 0.191504, 0.71862, - 0.124821, 0.456315, 0.208835, 0.72084, - 0.134079, 0.4568, 0.226869, 0.723786, - 0.143427, 0.457521, 0.245582, 0.727464, - 0.153061, 0.458475, 0.264957, 0.732771, - 0.162768, 0.460239, 0.284948, 0.736515, - 0.172627, 0.460899, 0.30522, 0.743519, - 0.182487, 0.463225, 0.326717, 0.750041, - 0.191295, 0.464027, 0.350113, 0.758589, - 0.199746, 0.465227, 0.374782, 0.767703, - 0.207584, 0.465877, 0.400226, 0.777484, - 0.214973, 0.465996, 0.426442, 0.788792, - 0.221796, 0.466019, 0.453688, 0.800194, - 0.228038, 0.465083, 0.481246, 0.811234, - 0.233346, 0.462506, 0.509086, 0.822859, - 0.238073, 0.459257, 0.537338, 0.835082, - 0.241764, 0.454863, 0.566108, 0.846332, - 0.244241, 0.448163, 0.595126, 0.858355, - 0.244736, 0.439709, 0.625574, 0.87034, - 0.244278, 0.429837, 0.65617, 0.881027, - 0.24255, 0.418002, 0.686029, 0.891007, - 0.239912, 0.404325, 0.716039, 0.900874, - 0.236133, 0.389222, 0.745518, 0.911072, - 0.230672, 0.373269, 0.775026, 0.920359, - 0.22356, 0.355083, 0.804521, 0.928604, - 0.215591, 0.335533, 0.834045, 0.937175, - 0.206503, 0.315278, 0.861612, 0.942825, - 0.196684, 0.293653, 0.889131, 0.949805, - 0.185116, 0.271503, 0.916853, 0.955535, - 0.172703, 0.248821, 0.943541, 0.959843, - 0.159978, 0.225591, 0.970132, 0.964393, - 0.146375, 0.202719, 0.994709, 0.968008, - 0.131269, 0.179928, 1.0186, 0.971013, - 0.11569, 0.158007, 1.03928, 0.973334, - 0.1003, 0.13624, 1.05887, 0.975775, - 0.0833352, 0.1138, 1.07652, 0.979579, - 0.0668981, 0.0913141, 1.09297, 0.984323, - 0.0500902, 0.0683051, 1.10734, 0.990351, - 0.0332377, 0.0451771, 1.12084, 0.995823, - 0.0161491, 0.0221705, 1.13296, 1.0001, 0.000234083, - 0.000108712, 1.14441, 0.683895, - 9.24677e-06, 0.46015, 1.37429e-05, 0.68833, - 0.000233383, 0.463134, 0.000346865, 0.688368, - 0.000933547, 0.463159, 0.00138748, 0.688367, - 0.00210049, 0.463159, 0.00312187, 0.688369, - 0.00373415, 0.463159, 0.00555004, 0.688377, - 0.00583449, 0.463163, 0.00867216, 0.688386, - 0.00840128, 0.463166, 0.0124884, 0.688398, - 0.0114343, 0.463169, 0.0169993, 0.688418, - 0.0149329, 0.463175, 0.0222054, 0.688453, - 0.0188964, 0.463188, 0.028108, 0.688515, - 0.0233239, 0.463214, 0.0347085, 0.68857, - 0.0282136, 0.463231, 0.0420091, 0.688679, - 0.033564, 0.463276, 0.0500132, 0.688854, - 0.0393733, 0.463356, 0.0587255, 0.689038, - 0.0456354, 0.46343, 0.0681476, 0.689321, - 0.0523433, 0.463553, 0.0782897, 0.689662, - 0.059412, 0.463693, 0.0891501, 0.690188, - 0.0665736, 0.4639, 0.100735, 0.690755, - 0.0743106, 0.464107, 0.113074, 0.691405, - 0.0824722, 0.464329, 0.126161, 0.692198, - 0.0910484, 0.464585, 0.140007, 0.693196, - 0.0998778, 0.464893, 0.154612, 0.69454, - 0.108651, 0.465285, 0.169984, 0.695921, - 0.117855, 0.465596, 0.186106, 0.697749, - 0.12734, 0.466056, 0.203034, 0.700375, - 0.136714, 0.466771, 0.220703, 0.703395, - 0.146386, 0.467579, 0.239062, 0.707904, - 0.156096, 0.469067, 0.258188, 0.711673, - 0.165904, 0.469851, 0.277759, 0.717489, - 0.175812, 0.471815, 0.297935, 0.724051, - 0.185931, 0.47389, 0.318916, 0.731965, - 0.195238, 0.47587, 0.341591, 0.741151, - 0.204021, 0.477523, 0.366062, 0.751416, - 0.212113, 0.478881, 0.391396, 0.761848, - 0.21979, 0.479226, 0.417599, 0.771886, - 0.2267, 0.478495, 0.444401, 0.783998, - 0.232991, 0.477622, 0.472084, 0.796523, - 0.238645, 0.475833, 0.500193, 0.808851, - 0.243396, 0.472568, 0.52865, 0.821191, - 0.247226, 0.467857, 0.557362, 0.834261, - 0.250102, 0.461871, 0.586768, 0.846762, - 0.251056, 0.453543, 0.617085, 0.859867, - 0.250604, 0.443494, 0.647659, 0.871948, - 0.248783, 0.431711, 0.678119, 0.882967, - 0.245855, 0.417911, 0.708399, 0.892826, - 0.242168, 0.401993, 0.738256, 0.90332, - 0.237062, 0.385371, 0.767999, 0.913633, - 0.22997, 0.366837, 0.798191, 0.922774, - 0.221687, 0.346372, 0.827756, 0.931371, - 0.212345, 0.325682, 0.856425, 0.938929, - 0.20206, 0.303665, 0.884299, 0.944821, - 0.190981, 0.280786, 0.912023, 0.951792, - 0.178065, 0.2573, 0.939669, 0.957712, - 0.164634, 0.233448, 0.96655, 0.961912, - 0.150863, 0.209504, 0.992366, 0.966382, - 0.13577, 0.18597, 1.01633, 0.969588, - 0.119593, 0.162905, 1.03843, 0.971777, - 0.103203, 0.14053, 1.05841, 0.97433, - 0.0865888, 0.117909, 1.07632, 0.978686, - 0.0690829, 0.0944101, 1.09326, 0.983281, - 0.0516568, 0.0705671, 1.10796, 0.989562, - 0.034558, 0.0468592, 1.12182, 0.995465, - 0.0167808, 0.0229846, 1.1342, 0.999991, 0.000373016, - 0.000235606, 1.1459, 0.662251, - 9.39016e-06, 0.468575, 1.32714e-05, 0.666634, - 0.000237624, 0.471675, 0.000335842, 0.666411, - 0.000950385, 0.471516, 0.00134321, 0.666399, - 0.00213833, 0.471509, 0.00302221, 0.666386, - 0.0038014, 0.471499, 0.00537283, 0.666405, - 0.00593958, 0.471511, 0.00839533, 0.666406, - 0.00855253, 0.471508, 0.0120898, 0.666428, - 0.0116401, 0.471519, 0.0164569, 0.666444, - 0.0152015, 0.471522, 0.0214971, 0.66649, - 0.0192362, 0.471543, 0.027212, 0.666537, - 0.0237428, 0.471558, 0.033603, 0.666617, - 0.0287198, 0.471591, 0.0406728, 0.666718, - 0.0341647, 0.471631, 0.0484238, 0.666889, - 0.0400759, 0.47171, 0.0568621, 0.667104, - 0.0464479, 0.471805, 0.0659915, 0.667374, - 0.0532677, 0.471923, 0.0758178, 0.667772, - 0.0603805, 0.472098, 0.0863425, 0.668371, - 0.0677392, 0.472363, 0.0975917, 0.668971, - 0.0756028, 0.472596, 0.109567, 0.669696, - 0.0839293, 0.472869, 0.122272, 0.670481, - 0.0926683, 0.473126, 0.135718, 0.6715, - 0.1016, 0.473442, 0.149914, 0.672911, - 0.110566, 0.47389, 0.164882, 0.674512, - 0.119984, 0.474354, 0.180602, 0.67651, - 0.129574, 0.474922, 0.19711, 0.679292, - 0.139106, 0.475764, 0.214371, 0.682798, - 0.148993, 0.476886, 0.232405, 0.686955, - 0.158737, 0.478179, 0.251153, 0.691406, - 0.168754, 0.479432, 0.270436, 0.697438, - 0.178703, 0.481481, 0.290374, 0.704761, - 0.188955, 0.484143, 0.311044, 0.713599, - 0.198814, 0.487007, 0.333003, 0.723194, - 0.207869, 0.488962, 0.357144, 0.732601, - 0.216189, 0.489815, 0.382169, 0.744193, - 0.22398, 0.490888, 0.408227, 0.754907, - 0.231156, 0.490355, 0.434928, 0.767403, - 0.23747, 0.489548, 0.462599, 0.78107, - 0.243503, 0.488274, 0.490908, 0.793893, - 0.248114, 0.484843, 0.519421, 0.807296, - 0.25222, 0.4803, 0.548561, 0.820529, - 0.255265, 0.474097, 0.577772, 0.833716, - 0.256741, 0.466041, 0.607782, 0.848403, - 0.25637, 0.456547, 0.638807, 0.860755, - 0.254804, 0.443946, 0.670058, 0.874012, - 0.251834, 0.430852, 0.700749, 0.885619, - 0.247867, 0.414903, 0.731446, 0.896069, - 0.242634, 0.397276, 0.761191, 0.906266, - 0.236093, 0.378535, 0.791053, 0.916759, - 0.227543, 0.358038, 0.821298, 0.92523, - 0.21783, 0.335705, 0.850747, 0.93436, - 0.207534, 0.313797, 0.879258, 0.941631, - 0.195983, 0.289671, 0.907734, 0.947564, - 0.183567, 0.265319, 0.935206, 0.953681, - 0.169345, 0.240815, 0.962739, 0.960008, - 0.154909, 0.216119, 0.989227, 0.964145, - 0.140161, 0.192096, 1.01465, 0.968171, - 0.123411, 0.167855, 1.03737, 0.969859, - 0.106525, 0.144817, 1.05767, 0.972666, - 0.0891023, 0.12149, 1.0761, 0.977055, - 0.0718094, 0.0975306, 1.09336, 0.982527, - 0.0534213, 0.0730217, 1.10878, 0.989001, - 0.0355579, 0.0483366, 1.12285, 0.99512, - 0.0176383, 0.023938, 1.13548, 1.00007, 0.000368831, - 0.000211581, 1.14744, 0.651047, - 9.60845e-06, 0.484101, 1.2922e-05, 0.644145, - 0.000241347, 0.478968, 0.000324578, 0.64396, - 0.000965142, 0.478831, 0.00129798, 0.64396, - 0.00217154, 0.47883, 0.00292046, 0.643968, - 0.00386049, 0.478835, 0.00519202, 0.643974, - 0.00603186, 0.478838, 0.0081128, 0.643977, - 0.0086854, 0.478836, 0.011683, 0.643982, - 0.0118207, 0.478834, 0.0159031, 0.644024, - 0.0154374, 0.478856, 0.0207743, 0.644059, - 0.0195343, 0.478868, 0.0262975, 0.644122, - 0.0241103, 0.478896, 0.0324747, 0.644207, - 0.0291638, 0.478933, 0.039309, 0.64432, - 0.0346919, 0.478981, 0.0468029, 0.644481, - 0.0406919, 0.479053, 0.0549614, 0.644722, - 0.047159, 0.479169, 0.0637909, 0.645013, - 0.0540748, 0.479302, 0.0732974, 0.645503, - 0.0612001, 0.479541, 0.0834898, 0.646117, - 0.0687303, 0.479829, 0.0943873, 0.646707, - 0.0767846, 0.480061, 0.105991, 0.647431, - 0.0852465, 0.480343, 0.11831, 0.64831, - 0.0940719, 0.48066, 0.131348, 0.649486, - 0.103056, 0.481083, 0.14514, 0.650864, - 0.112261, 0.481528, 0.159676, 0.652604, - 0.121852, 0.482102, 0.174979, 0.654825, - 0.131505, 0.482813, 0.191079, 0.657876, - 0.141189, 0.483876, 0.207927, 0.661339, - 0.151239, 0.48499, 0.225586, 0.665463, - 0.161091, 0.486279, 0.243947, 0.670542, - 0.171235, 0.487968, 0.262957, 0.677361, - 0.181347, 0.49053, 0.282781, 0.685672, - 0.191679, 0.493862, 0.303311, 0.694551, - 0.201781, 0.49699, 0.324607, 0.703753, - 0.211164, 0.498884, 0.347916, 0.713703, - 0.219675, 0.500086, 0.372628, 0.725911, - 0.227836, 0.501554, 0.398694, 0.73862, - 0.23533, 0.502193, 0.425529, 0.752118, - 0.241786, 0.501811, 0.453209, 0.76579, - 0.247865, 0.500185, 0.481381, 0.779568, - 0.252696, 0.497159, 0.51011, 0.793991, - 0.256802, 0.492765, 0.539322, 0.808182, - 0.259942, 0.486827, 0.569078, 0.821698, - 0.261703, 0.478386, 0.598818, 0.836009, - 0.262006, 0.468772, 0.629762, 0.849824, - 0.260333, 0.456352, 0.661366, 0.863888, - 0.257398, 0.442533, 0.69295, 0.876585, - 0.253264, 0.426573, 0.723608, 0.888665, - 0.248026, 0.408964, 0.754378, 0.899537, - 0.241487, 0.389677, 0.784761, 0.9094, - 0.233463, 0.368516, 0.814688, 0.920166, - 0.223397, 0.346624, 0.845009, 0.928899, - 0.21255, 0.322717, 0.874431, 0.937156, - 0.200869, 0.298698, 0.902922, 0.943861, - 0.188387, 0.273491, 0.931356, 0.949557, - 0.174341, 0.247866, 0.958854, 0.955862, - 0.158994, 0.222496, 0.986098, 0.961721, - 0.143664, 0.197522, 1.01229, 0.965976, - 0.127412, 0.17302, 1.03571, 0.968652, - 0.109798, 0.148954, 1.05699, 0.971084, - 0.0916787, 0.125044, 1.07587, 0.975584, - 0.0739634, 0.100577, 1.09372, 0.98122, - 0.055322, 0.0753666, 1.10948, 0.988253, - 0.0366825, 0.0498899, 1.12394, 0.99482, - 0.0180389, 0.024611, 1.13694, 1.00001, 0.000229839, - 0.000188283, 1.14919, 0.613867, - 9.64198e-06, 0.479449, 1.23452e-05, 0.621485, - 0.000244534, 0.485399, 0.000313091, 0.621429, - 0.000978202, 0.485353, 0.00125245, 0.62112, - 0.00220004, 0.485114, 0.00281687, 0.621119, - 0.0039111, 0.485112, 0.00500783, 0.621122, - 0.00611091, 0.485112, 0.00782498, 0.621133, - 0.00879922, 0.485117, 0.0112687, 0.621152, - 0.0119756, 0.485125, 0.0153394, 0.621183, - 0.0156396, 0.485139, 0.0200382, 0.621227, - 0.0197898, 0.485158, 0.0253663, 0.621298, - 0.0244253, 0.485192, 0.0313261, 0.621388, - 0.0295441, 0.485233, 0.0379204, 0.621507, - 0.0351432, 0.485286, 0.0451523, 0.621693, - 0.0412198, 0.485378, 0.0530277, 0.621933, - 0.0477673, 0.485495, 0.0615522, 0.622232, - 0.0547574, 0.485635, 0.0707316, 0.622809, - 0.0619417, 0.485943, 0.0805883, 0.623407, - 0.069625, 0.486232, 0.0911267, 0.62406, - 0.077796, 0.486516, 0.102354, 0.624835, - 0.0863731, 0.486838, 0.114279, 0.625758, - 0.095251, 0.487188, 0.126902, 0.627043, - 0.104299, 0.487695, 0.140285, 0.628438, - 0.113724, 0.488163, 0.154397, 0.630325, - 0.123417, 0.488858, 0.169267, 0.632801, - 0.133137, 0.489754, 0.184941, 0.635784, - 0.143052, 0.490815, 0.20136, 0.639406, - 0.153132, 0.492048, 0.218643, 0.643872, - 0.163143, 0.49363, 0.236615, 0.6499, - 0.17333, 0.496009, 0.255449, 0.657201, - 0.183622, 0.498994, 0.275006, 0.666221, - 0.194019, 0.502888, 0.295354, 0.674419, - 0.204192, 0.505459, 0.316244, 0.683729, - 0.21406, 0.507771, 0.33849, 0.695584, - 0.222854, 0.510245, 0.363166, 0.708583, - 0.231315, 0.512293, 0.389071, 0.721233, - 0.238911, 0.512747, 0.415737, 0.735134, - 0.245657, 0.512482, 0.443331, 0.750179, - 0.251879, 0.511526, 0.471891, 0.765073, - 0.256911, 0.508935, 0.500892, 0.779794, - 0.261144, 0.504341, 0.530294, 0.794801, - 0.264316, 0.498515, 0.560144, 0.810339, - 0.266276, 0.491015, 0.590213, 0.824818, - 0.266981, 0.481126, 0.620865, 0.839375, - 0.265778, 0.468685, 0.652687, 0.853043, - 0.262748, 0.453925, 0.684759, 0.867335, - 0.258474, 0.437912, 0.716209, 0.88037, - 0.253187, 0.419648, 0.747508, 0.891711, - 0.246476, 0.39982, 0.77797, 0.902896, - 0.238735, 0.37879, 0.808586, 0.913601, - 0.22885, 0.355891, 0.838843, 0.923019, - 0.217656, 0.331773, 0.869014, 0.933432, - 0.205539, 0.307356, 0.898512, 0.939691, - 0.192595, 0.281321, 0.9269, 0.946938, - 0.178945, 0.255441, 0.955297, 0.952372, - 0.163587, 0.229013, 0.983231, 0.95909, - 0.147214, 0.203179, 1.00971, 0.963675, - 0.13064, 0.17792, 1.03438, 0.968247, - 0.113121, 0.152898, 1.05625, 0.97001, - 0.0945824, 0.128712, 1.07598, 0.974458, - 0.0755648, 0.103349, 1.094, 0.980168, - 0.0571998, 0.0776731, 1.1104, 0.987295, - 0.0377994, 0.0514445, 1.12491, 0.994432, - 0.0186417, 0.025429, 1.13851, 0.999975, 0.000542714, - 0.000282356, 1.15108, 0.592656, - 9.80249e-06, 0.486018, 1.19532e-05, 0.598467, - 0.000247275, 0.490781, 0.000301531, 0.597934, - 0.000988317, 0.490343, 0.00120517, 0.597903, - 0.00222366, 0.490319, 0.0027116, 0.597913, - 0.00395315, 0.490327, 0.00482077, 0.597919, - 0.00617653, 0.490329, 0.00753264, 0.597936, - 0.00889375, 0.490339, 0.0108478, 0.597956, - 0.0121043, 0.490347, 0.0147668, 0.597992, - 0.0158073, 0.490365, 0.0192905, 0.598032, - 0.0200017, 0.490382, 0.0244204, 0.598109, - 0.0246865, 0.49042, 0.0301593, 0.598215, - 0.0298594, 0.490474, 0.03651, 0.59833, - 0.0355167, 0.490524, 0.0434757, 0.598525, - 0.0416559, 0.490624, 0.0510629, 0.598778, - 0.0482692, 0.490753, 0.0592781, 0.599135, - 0.0553114, 0.49094, 0.0681304, 0.599802, - 0.062542, 0.491328, 0.0776467, 0.600361, - 0.0703638, 0.491598, 0.0878184, 0.60101, - 0.0786256, 0.491882, 0.0986573, 0.601811, - 0.0872962, 0.492232, 0.11018, 0.602861, - 0.0962284, 0.492684, 0.1224, 0.604167, - 0.10538, 0.493213, 0.135354, 0.605693, - 0.114896, 0.493799, 0.149034, 0.607682, - 0.124654, 0.494576, 0.163469, 0.610672, - 0.13456, 0.4959, 0.178747, 0.613313, - 0.144581, 0.496713, 0.194723, 0.617603, - 0.154703, 0.498499, 0.211617, 0.622174, - 0.16489, 0.500188, 0.229183, 0.628855, - 0.175164, 0.503072, 0.247786, 0.636963, - 0.185565, 0.506798, 0.267116, 0.644866, - 0.195911, 0.509719, 0.28702, 0.653741, - 0.206104, 0.512776, 0.307763, 0.664942, - 0.216447, 0.516812, 0.329631, 0.67633, - 0.22552, 0.519181, 0.353515, 0.690012, - 0.234316, 0.521681, 0.379226, 0.704243, - 0.242032, 0.523129, 0.405901, 0.719396, - 0.249172, 0.523768, 0.433585, 0.734471, - 0.255543, 0.522541, 0.462085, 0.750539, - 0.260697, 0.520217, 0.491233, 0.766365, - 0.26501, 0.516293, 0.521094, 0.781677, - 0.268409, 0.509708, 0.551014, 0.797132, - 0.270399, 0.501944, 0.581463, 0.812655, - 0.271247, 0.492025, 0.612402, 0.828592, - 0.270708, 0.480424, 0.643798, 0.844044, - 0.268085, 0.465955, 0.67682, 0.857305, - 0.263459, 0.448425, 0.708496, 0.87114, - 0.258151, 0.430243, 0.74046, 0.884936, - 0.251171, 0.410578, 0.771583, 0.895772, - 0.243305, 0.38862, 0.802234, 0.906961, - 0.234037, 0.365214, 0.833179, 0.917775, - 0.222714, 0.34116, 0.86353, 0.927883, - 0.210175, 0.31572, 0.893557, 0.936617, - 0.196925, 0.289159, 0.922976, 0.943384, - 0.182788, 0.261996, 0.951606, 0.949713, - 0.167965, 0.235324, 0.979958, 0.955818, - 0.151109, 0.208408, 1.00765, 0.961344, - 0.133834, 0.182591, 1.03329, 0.965469, - 0.115987, 0.156958, 1.0557, 0.968693, - 0.09746, 0.132239, 1.07583, 0.973165, - 0.0778514, 0.106195, 1.09451, 0.979387, - 0.0585067, 0.0797669, 1.11137, 0.98671, - 0.0390409, 0.0530263, 1.12643, 0.994093, - 0.019408, 0.0263163, 1.14016, 1.00002, 0.000540029, - 0.000194487, 1.15299, 0.574483, - 9.89066e-06, 0.494533, 1.14896e-05, 0.574478, - 0.000249127, 0.494528, 0.000289403, 0.574607, - 0.000996811, 0.494637, 0.00115797, 0.574396, - 0.00224241, 0.494458, 0.00260498, 0.574377, - 0.00398632, 0.49444, 0.00463102, 0.574386, - 0.00622836, 0.494445, 0.00723623, 0.574401, - 0.0089683, 0.494453, 0.010421, 0.574419, - 0.0122056, 0.49446, 0.0141859, 0.574459, - 0.0159396, 0.494481, 0.0185322, 0.574525, - 0.0201692, 0.49452, 0.0234617, 0.574587, - 0.0248924, 0.494547, 0.0289762, 0.574697, - 0.0301074, 0.494604, 0.0350797, 0.574853, - 0.0358114, 0.494688, 0.0417767, 0.575027, - 0.041999, 0.494772, 0.0490718, 0.575294, - 0.0486618, 0.494915, 0.0569728, 0.575733, - 0.0557148, 0.495173, 0.0654955, 0.576356, - 0.0630489, 0.495537, 0.0746612, 0.576944, - 0.0709285, 0.495836, 0.0844615, 0.57765, - 0.0792723, 0.496177, 0.0949142, 0.578491, - 0.0880167, 0.496563, 0.10603, 0.579639, - 0.0969462, 0.497096, 0.117841, 0.580989, - 0.10622, 0.497684, 0.130367, 0.582587, - 0.115861, 0.498337, 0.143609, 0.584951, - 0.125605, 0.499414, 0.157625, 0.587602, - 0.135608, 0.500518, 0.172413, 0.59076, - 0.145742, 0.501767, 0.187999, 0.594992, - 0.155934, 0.503542, 0.20445, 0.600656, - 0.166303, 0.506135, 0.221764, 0.607816, - 0.176681, 0.509542, 0.24002, 0.61522, - 0.187071, 0.51263, 0.258992, 0.623702, - 0.197465, 0.516021, 0.278773, 0.634192, - 0.207816, 0.520422, 0.299377, 0.644936, - 0.218183, 0.524073, 0.320802, 0.657888, - 0.2278, 0.528049, 0.34384, 0.670666, - 0.236747, 0.52986, 0.36916, 0.685626, - 0.24484, 0.531892, 0.395867, 0.701304, - 0.252071, 0.532727, 0.423488, 0.717727, - 0.258714, 0.532146, 0.452201, 0.733914, - 0.264211, 0.529883, 0.481579, 0.750529, - 0.26859, 0.5259, 0.511558, 0.76747, - 0.272046, 0.51999, 0.542042, 0.785189, - 0.274225, 0.513083, 0.572799, 0.800954, - 0.275189, 0.502936, 0.603816, 0.816962, - 0.274946, 0.490921, 0.635461, 0.83336, - 0.272695, 0.47684, 0.6676, 0.848143, - 0.268223, 0.459405, 0.70051, 0.861818, - 0.262768, 0.440319, 0.732902, 0.876828, - 0.255872, 0.420123, 0.765084, 0.889312, - 0.247703, 0.398379, 0.796391, 0.900412, - 0.238381, 0.374496, 0.827333, 0.912251, - 0.227783, 0.349874, 0.858385, 0.921792, - 0.214832, 0.323181, 0.888652, 0.931273, - 0.200949, 0.296624, 0.917763, 0.940295, - 0.186537, 0.269211, 0.947878, 0.946812, - 0.171538, 0.241447, 0.977016, 0.953588, - 0.155254, 0.213829, 1.00501, 0.958841, - 0.137156, 0.186807, 1.03179, 0.963746, - 0.118699, 0.160706, 1.05502, 0.966468, - 0.0998358, 0.135504, 1.07568, 0.971178, - 0.0805186, 0.109131, 1.09479, 0.97831, - 0.0599348, 0.0818293, 1.1123, 0.985886, - 0.0399661, 0.0545872, 1.12771, 0.994021, - 0.0198682, 0.0269405, 1.14186, 1.00009, 0.000271022, - 0.00012989, 1.15514, 0.538716, - 9.90918e-06, 0.486732, 1.09675e-05, 0.550656, - 0.000250642, 0.497518, 0.000277412, 0.55057, - 0.00100265, 0.497441, 0.00110974, 0.550903, - 0.00225672, 0.497733, 0.00249779, 0.550568, - 0.00401046, 0.497438, 0.00443906, 0.550574, - 0.00626613, 0.49744, 0.00693637, 0.550591, - 0.0090226, 0.497449, 0.00998921, 0.550623, - 0.0122795, 0.497469, 0.0135984, 0.550667, - 0.0160361, 0.497495, 0.0177654, 0.550724, - 0.0202908, 0.497526, 0.0224915, 0.550792, - 0.0250421, 0.497557, 0.0277795, 0.550918, - 0.0302878, 0.49763, 0.0336334, 0.551058, - 0.0360241, 0.497701, 0.0400573, 0.551276, - 0.0422473, 0.497824, 0.0470585, 0.551551, - 0.0489441, 0.497977, 0.0546433, 0.552074, - 0.0559596, 0.498312, 0.0628367, 0.552681, - 0.0633978, 0.498679, 0.071646, 0.553324, - 0.0713176, 0.499031, 0.0810746, 0.554011, - 0.0797268, 0.499365, 0.091129, 0.55488, - 0.0885238, 0.499779, 0.101837, 0.556171, - 0.0974417, 0.500444, 0.113239, 0.557498, - 0.106841, 0.501025, 0.125316, 0.559299, - 0.116533, 0.501864, 0.138128, 0.561647, - 0.126298, 0.502967, 0.151695, 0.564347, - 0.136388, 0.504129, 0.16604, 0.567863, - 0.146576, 0.505713, 0.181207, 0.572569, - 0.156832, 0.507953, 0.197259, 0.578919, - 0.167323, 0.511186, 0.214258, 0.585387, - 0.177712, 0.514042, 0.232038, 0.593134, - 0.188184, 0.517484, 0.250733, 0.603295, - 0.198717, 0.522345, 0.270454, 0.613854, - 0.209177, 0.526751, 0.290807, 0.626092, - 0.219644, 0.531595, 0.312202, 0.637868, - 0.229494, 0.534721, 0.334435, 0.652458, - 0.238718, 0.538304, 0.359184, 0.666985, - 0.247061, 0.539875, 0.385637, 0.683301, - 0.254652, 0.541042, 0.41328, 0.69998, - 0.261376, 0.540735, 0.441903, 0.717824, - 0.267085, 0.539139, 0.471609, 0.734617, - 0.271465, 0.534958, 0.501446, 0.753663, - 0.27528, 0.53032, 0.532571, 0.770512, - 0.277617, 0.522134, 0.563641, 0.787356, - 0.278525, 0.51206, 0.595067, 0.806252, - 0.278512, 0.50119, 0.627226, 0.822061, - 0.277023, 0.486791, 0.659402, 0.838959, - 0.273175, 0.470467, 0.692874, 0.85379, - 0.267238, 0.450688, 0.725702, 0.868268, - 0.260327, 0.429741, 0.75832, 0.881994, - 0.251946, 0.407223, 0.790189, 0.893885, - 0.242432, 0.383214, 0.821625, 0.905118, - 0.231904, 0.357297, 0.853011, 0.916045, - 0.219545, 0.330733, 0.883773, 0.927614, - 0.205378, 0.303916, 0.914435, 0.936005, - 0.190388, 0.275941, 0.944502, 0.944533, - 0.1749, 0.247493, 0.974439, 0.950758, - 0.158588, 0.218996, 1.00286, 0.957078, - 0.141027, 0.191559, 1.0304, 0.962448, - 0.121507, 0.164457, 1.05466, 0.964993, - 0.102068, 0.138636, 1.0761, 0.970017, - 0.0822598, 0.111861, 1.09541, 0.97661, - 0.062033, 0.0843438, 1.11317, 0.985073, - 0.0409832, 0.0558496, 1.12911, 0.993515, - 0.020146, 0.0275331, 1.1438, 1.00006, 0.00027329, - 0.000107883, 1.15736, 0.525324, - 9.99341e-06, 0.498153, 1.05385e-05, 0.526513, - 0.000251605, 0.499277, 0.000265329, 0.526517, - 0.00100641, 0.499282, 0.0010613, 0.526588, - 0.00226466, 0.499337, 0.00238823, 0.526539, - 0.0040255, 0.499302, 0.00424535, 0.526547, - 0.00628954, 0.499306, 0.00663364, 0.526561, - 0.00905628, 0.499313, 0.00955337, 0.526593, - 0.0123253, 0.499334, 0.0130054, 0.526642, - 0.0160957, 0.499365, 0.0169911, 0.5267, - 0.0203661, 0.499396, 0.0215122, 0.526792, - 0.0251347, 0.499451, 0.0265718, 0.526904, - 0.0303985, 0.499511, 0.0321732, 0.527079, - 0.0361554, 0.499617, 0.0383231, 0.527285, - 0.0423982, 0.499731, 0.045026, 0.527602, - 0.0491121, 0.499924, 0.0522936, 0.528166, - 0.0561127, 0.500306, 0.0601528, 0.52879, - 0.0635988, 0.5007, 0.0686059, 0.529421, - 0.071581, 0.501048, 0.0776518, 0.530144, - 0.0799854, 0.501421, 0.0873148, 0.531062, - 0.0888032, 0.501884, 0.0976084, 0.532374, - 0.0977643, 0.50259, 0.108588, 0.533828, - 0.107197, 0.50329, 0.120234, 0.53581, - 0.116887, 0.504312, 0.132602, 0.538063, - 0.126755, 0.505365, 0.145721, 0.5409, - 0.136819, 0.506668, 0.159617, 0.544882, - 0.147117, 0.508731, 0.174369, 0.550238, - 0.157446, 0.511601, 0.190028, 0.556038, - 0.167988, 0.514431, 0.206587, 0.563031, - 0.178364, 0.517808, 0.224046, 0.571543, - 0.189007, 0.521937, 0.242503, 0.582255, - 0.199546, 0.527415, 0.261977, 0.59272, - 0.210084, 0.531682, 0.282162, 0.605648, - 0.220448, 0.537123, 0.303426, 0.61785, - 0.230593, 0.540664, 0.325323, 0.632223, - 0.240238, 0.544467, 0.348993, 0.648819, - 0.24887, 0.547594, 0.375462, 0.665825, - 0.256657, 0.54912, 0.403024, 0.683389, - 0.263711, 0.549294, 0.431773, 0.701495, - 0.269666, 0.547649, 0.461494, 0.719197, - 0.274169, 0.543786, 0.491623, 0.737906, - 0.278124, 0.538644, 0.522994, 0.756652, - 0.280632, 0.531057, 0.554775, 0.775279, - 0.281741, 0.521972, 0.586441, 0.792688, - 0.281652, 0.509613, 0.618596, 0.811894, - 0.280345, 0.496497, 0.651462, 0.827938, - 0.277128, 0.47968, 0.684023, 0.844837, - 0.271646, 0.460688, 0.718024, 0.859239, - 0.264397, 0.438872, 0.751207, 0.874088, - 0.256144, 0.41577, 0.784232, 0.887693, - 0.246311, 0.391369, 0.816191, 0.899402, - 0.235497, 0.365872, 0.847828, 0.910973, - 0.223631, 0.338618, 0.87934, 0.92204, - 0.209874, 0.310803, 0.910325, 0.930987, - 0.194265, 0.281802, 0.940695, 0.94, - 0.178125, 0.252836, 0.970958, 0.948018, - 0.161479, 0.224239, 1.00078, 0.955141, - 0.144038, 0.195857, 1.0288, 0.960513, - 0.124915, 0.168487, 1.05371, 0.963964, - 0.104284, 0.141495, 1.07596, 0.968713, - 0.0838732, 0.114437, 1.09628, 0.975524, - 0.0635579, 0.0863105, 1.11448, 0.98431, - 0.042291, 0.0574774, 1.13069, 0.992916, - 0.0209131, 0.0284343, 1.14568, 0.999926, 0.000743097, - 0.000379265, 1.15955, 0.501042, - 9.98428e-06, 0.498726, 1.00306e-05, 0.502992, - 0.000252112, 0.500665, 0.000253283, 0.502417, - 0.00100791, 0.500092, 0.00101259, 0.502965, - 0.00226919, 0.500621, 0.00227978, 0.502318, - 0.00403109, 0.499994, 0.00405011, 0.502333, - 0.00629832, 0.500005, 0.00632868, 0.502362, - 0.00906907, 0.500027, 0.00911446, 0.502369, - 0.0123423, 0.500023, 0.0124078, 0.50243, - 0.0161178, 0.500066, 0.016211, 0.502493, - 0.0203937, 0.500103, 0.0205256, 0.502592, - 0.0251684, 0.500166, 0.0253548, 0.502707, - 0.0304389, 0.50023, 0.0307029, 0.502881, - 0.0362015, 0.500335, 0.0365753, 0.503124, - 0.0424507, 0.500488, 0.0429798, 0.503443, - 0.0491582, 0.500686, 0.0499268, 0.504083, - 0.0561476, 0.501155, 0.0574541, 0.504668, - 0.0636846, 0.501524, 0.0655408, 0.505319, - 0.0716834, 0.501904, 0.0742072, 0.50609, - 0.0800925, 0.502321, 0.0834699, 0.507122, - 0.0888425, 0.502896, 0.0933603, 0.508414, - 0.097855, 0.503603, 0.10391, 0.509955, - 0.107304, 0.504416, 0.115113, 0.512061, - 0.116921, 0.505565, 0.127054, 0.514419, - 0.12689, 0.506732, 0.139709, 0.517529, - 0.136934, 0.508338, 0.153173, 0.522085, - 0.147327, 0.510987, 0.167528, 0.526986, - 0.157612, 0.513527, 0.182708, 0.533122, - 0.168213, 0.516717, 0.198881, 0.540807, - 0.178688, 0.520832, 0.215986, 0.550687, - 0.189511, 0.52632, 0.234335, 0.560567, - 0.199998, 0.531009, 0.253375, 0.571698, - 0.210652, 0.535839, 0.273499, 0.584364, - 0.220917, 0.541091, 0.294355, 0.599066, - 0.23137, 0.546875, 0.316525, 0.614148, - 0.241206, 0.551306, 0.339671, 0.631157, - 0.250379, 0.555187, 0.36531, 0.647919, - 0.258397, 0.556595, 0.392767, 0.666112, - 0.265528, 0.556949, 0.421397, 0.686158, - 0.271827, 0.556617, 0.451433, 0.704838, - 0.27674, 0.552975, 0.482131, 0.723957, - 0.280733, 0.547814, 0.513458, 0.74262, - 0.283359, 0.53997, 0.545446, 0.762009, - 0.284541, 0.530422, 0.57775, 0.781314, - 0.284507, 0.518546, 0.610434, 0.799116, - 0.283309, 0.504178, 0.643178, 0.817604, - 0.280378, 0.48843, 0.676248, 0.83459, - 0.275619, 0.469457, 0.709698, 0.850974, - 0.26856, 0.447698, 0.744245, 0.866747, - 0.260094, 0.424791, 0.777695, 0.881412, - 0.249929, 0.399913, 0.810392, 0.8936, - 0.239137, 0.37308, 0.842872, 0.905943, - 0.226818, 0.345705, 0.874677, 0.916408, - 0.213699, 0.31706, 0.906257, 0.927215, - 0.198428, 0.288444, 0.936881, 0.935625, - 0.181643, 0.258329, 0.96795, 0.944076, - 0.164386, 0.228488, 0.998216, 0.951229, - 0.146339, 0.199763, 1.02689, 0.958793, - 0.127709, 0.172153, 1.0535, 0.963219, - 0.107244, 0.144989, 1.07646, 0.967562, - 0.0857764, 0.11685, 1.09675, 0.974866, - 0.0645377, 0.0880571, 1.11576, 0.983353, - 0.0431732, 0.0587352, 1.13227, 0.992503, - 0.0218356, 0.0294181, 1.1478, 1.00003, 0.000605203, - 0.000231013, 1.16207, 0.482935, - 1.01177e-05, 0.504695, 9.68142e-06, 0.477554, - 0.000251521, 0.499071, 0.000240676, 0.477904, - 0.00100683, 0.499436, 0.00096342, 0.478368, - 0.00226636, 0.499899, 0.0021687, 0.477977, - 0.00402719, 0.499513, 0.00385384, 0.477993, - 0.00629226, 0.499525, 0.0060221, 0.478011, - 0.00906011, 0.499536, 0.00867289, 0.478051, - 0.0123305, 0.499566, 0.0118074, 0.478089, - 0.016102, 0.499587, 0.0154269, 0.478171, - 0.0203736, 0.499645, 0.0195341, 0.478254, - 0.025143, 0.499692, 0.0241318, 0.47839, - 0.0304071, 0.499779, 0.0292247, 0.478588, - 0.0361631, 0.499911, 0.0348196, 0.478812, - 0.0424023, 0.500046, 0.0409231, 0.479208, - 0.0490724, 0.500326, 0.047552, 0.479841, - 0.0560722, 0.500805, 0.0547377, 0.480392, - 0.0636125, 0.501152, 0.0624607, 0.481068, - 0.0716134, 0.501561, 0.0707473, 0.481898, - 0.0800062, 0.502054, 0.0796118, 0.483022, - 0.0886568, 0.502728, 0.0890974, 0.484332, - 0.0977553, 0.503479, 0.0992099, 0.486126, - 0.107173, 0.504546, 0.10999, 0.488066, - 0.11677, 0.50557, 0.121476, 0.490521, - 0.126725, 0.506849, 0.133672, 0.494232, - 0.136793, 0.50911, 0.146731, 0.498302, - 0.147116, 0.511345, 0.160577, 0.503565, - 0.157446, 0.514344, 0.175335, 0.510902, - 0.168121, 0.518824, 0.191207, 0.519263, - 0.178799, 0.523666, 0.208058, 0.528204, - 0.189407, 0.528296, 0.225875, 0.538854, - 0.200145, 0.533724, 0.244782, 0.551278, - 0.210701, 0.539833, 0.264753, 0.565222, - 0.221303, 0.546131, 0.285745, 0.579403, - 0.231688, 0.551496, 0.307592, 0.595469, - 0.241718, 0.556809, 0.330582, 0.610929, - 0.250992, 0.559641, 0.354995, 0.629433, - 0.259602, 0.562379, 0.382471, 0.648504, - 0.267038, 0.563676, 0.411126, 0.66756, - 0.273388, 0.562092, 0.440924, 0.689143, - 0.278788, 0.560807, 0.472118, 0.709056, - 0.282783, 0.555701, 0.503774, 0.729855, - 0.285836, 0.548698, 0.536364, 0.748954, - 0.287078, 0.538544, 0.56895, 0.768373, - 0.287133, 0.526711, 0.601991, 0.78827, - 0.285839, 0.512511, 0.635403, 0.807465, - 0.283238, 0.496323, 0.668797, 0.825194, - 0.27906, 0.477638, 0.702584, 0.842203, - 0.272286, 0.456253, 0.736393, 0.857749, - 0.263854, 0.432412, 0.77096, 0.874799, - 0.253943, 0.407806, 0.80489, 0.887497, - 0.24237, 0.38033, 0.83771, 0.89966, - 0.230278, 0.352446, 0.870376, 0.911753, - 0.21646, 0.323268, 0.902256, 0.923011, - 0.202071, 0.294314, 0.933306, 0.932375, - 0.185519, 0.264104, 0.965177, 0.940537, - 0.167604, 0.234035, 0.996303, 0.948904, - 0.149068, 0.20412, 1.0261, 0.955263, - 0.129539, 0.175431, 1.05304, 0.960303, - 0.109932, 0.148116, 1.07617, 0.965512, - 0.0880572, 0.119693, 1.09742, 0.973466, - 0.0660548, 0.0901619, 1.11721, 0.98284, - 0.0439228, 0.0599875, 1.13436, 0.992216, - 0.0219588, 0.0298975, 1.15006, 0.999946, 0.000119402, - 2.08547e-05, 1.16471, 0.447827, - 1.00414e-05, 0.491543, 9.14833e-06, 0.454778, - 0.000251257, 0.499172, 0.00022891, 0.453519, - 0.00100342, 0.497787, 0.000914184, 0.45357, - 0.00225776, 0.497847, 0.00205701, 0.453578, - 0.00401371, 0.497855, 0.00365705, 0.45357, - 0.00627107, 0.497841, 0.00571453, 0.453598, - 0.00902968, 0.497864, 0.00823019, 0.453627, - 0.0122888, 0.497882, 0.0112049, 0.453684, - 0.0160475, 0.497923, 0.0146405, 0.453764, - 0.0203044, 0.49798, 0.0185394, 0.453866, - 0.0250576, 0.498049, 0.0229054, 0.453996, - 0.0303028, 0.49813, 0.0277424, 0.454196, - 0.0360379, 0.498267, 0.0330587, 0.454457, - 0.0422521, 0.498445, 0.0388613, 0.454926, - 0.0488393, 0.498812, 0.0451767, 0.455525, - 0.0558653, 0.499272, 0.0520153, 0.456074, - 0.0633772, 0.499625, 0.0593754, 0.456752, - 0.0713606, 0.500049, 0.0672751, 0.457648, - 0.07971, 0.500615, 0.0757447, 0.458849, - 0.0883032, 0.501399, 0.0848231, 0.46029, - 0.0974095, 0.502293, 0.0945135, 0.462, - 0.106729, 0.503301, 0.104848, 0.464121, - 0.116354, 0.504533, 0.115884, 0.466889, - 0.126214, 0.506172, 0.127652, 0.470744, - 0.136324, 0.508667, 0.14024, 0.47488, - 0.146595, 0.510995, 0.153673, 0.480845, - 0.157027, 0.514832, 0.168053, 0.488262, - 0.167658, 0.519506, 0.183508, 0.496547, - 0.178343, 0.524347, 0.199948, 0.506254, - 0.188916, 0.52983, 0.217503, 0.517961, - 0.199975, 0.536357, 0.236272, 0.531484, - 0.210624, 0.543641, 0.256096, 0.545496, - 0.221227, 0.550048, 0.277085, 0.559497, - 0.231568, 0.555076, 0.298615, 0.575752, - 0.241698, 0.560541, 0.321547, 0.591999, - 0.251172, 0.564156, 0.345602, 0.610654, - 0.260178, 0.567607, 0.371851, 0.630484, - 0.268094, 0.56923, 0.40076, 0.651807, - 0.274661, 0.569779, 0.430801, 0.67239, - 0.280331, 0.566791, 0.461939, 0.693024, - 0.284501, 0.562007, 0.493854, 0.715473, - 0.287852, 0.555791, 0.526992, 0.736323, - 0.28929, 0.546345, 0.560102, 0.755771, - 0.289405, 0.534, 0.593543, 0.775424, - 0.2881, 0.519114, 0.627256, 0.795447, - 0.285562, 0.502543, 0.661464, 0.815319, - 0.281416, 0.484773, 0.695206, 0.831769, - 0.275523, 0.463445, 0.729044, 0.849464, - 0.267516, 0.440269, 0.764069, 0.866775, - 0.257584, 0.415049, 0.799089, 0.881252, - 0.245817, 0.388049, 0.831948, 0.894209, - 0.233127, 0.35889, 0.865526, 0.906922, - 0.219579, 0.329915, 0.89818, 0.919686, - 0.204491, 0.300441, 0.930013, 0.929044, - 0.188962, 0.269445, 0.962061, 0.938393, - 0.171079, 0.238402, 0.994214, 0.94661, - 0.15199, 0.208204, 1.02533, 0.953095, - 0.131953, 0.178653, 1.0529, 0.958644, - 0.111233, 0.150684, 1.0771, 0.963925, - 0.0903098, 0.122359, 1.09855, 0.971995, - 0.0680505, 0.0923342, 1.11874, 0.981658, - 0.0448512, 0.0614195, 1.13635, 0.991649, - 0.0221931, 0.0303582, 1.15238, 0.999985, 0.000393403, - 0.000111086, 1.16772, 0.396806, - 9.71563e-06, 0.457671, 8.42355e-06, 0.429186, - 0.000249421, 0.495017, 0.00021625, 0.429324, - 0.000998052, 0.495173, 0.000865322, 0.429175, - 0.00224487, 0.494999, 0.00194637, 0.429129, - 0.00399041, 0.494952, 0.00346004, 0.429153, - 0.00623476, 0.494974, 0.00540684, 0.429168, - 0.0089773, 0.494983, 0.00778714, 0.429207, - 0.0122175, 0.495012, 0.0106022, 0.429257, - 0.0159542, 0.495047, 0.0138535, 0.429338, - 0.0201864, 0.495106, 0.0175443, 0.429431, - 0.0249104, 0.495165, 0.0216774, 0.429587, - 0.0301252, 0.495279, 0.0262594, 0.429796, - 0.0358249, 0.495432, 0.0312968, 0.430065, - 0.0419972, 0.495621, 0.0367985, 0.430588, - 0.0485144, 0.496061, 0.042798, 0.43113, - 0.0555028, 0.496472, 0.0492914, 0.431743, - 0.0629852, 0.496904, 0.0562907, 0.432448, - 0.0709256, 0.497369, 0.0638056, 0.433414, - 0.0791942, 0.498032, 0.071885, 0.434638, - 0.0877346, 0.498854, 0.0805517, 0.43611, - 0.0968056, 0.499812, 0.0898047, 0.437859, - 0.106002, 0.500891, 0.0997142, 0.440017, - 0.115648, 0.502198, 0.110289, 0.443236, - 0.125427, 0.504389, 0.121644, 0.44697, - 0.135492, 0.506809, 0.133769, 0.451689, - 0.145746, 0.509858, 0.146787, 0.45811, - 0.156219, 0.514247, 0.160793, 0.465305, - 0.166834, 0.518816, 0.175791, 0.474085, - 0.177546, 0.524331, 0.191906, 0.484808, - 0.188262, 0.53104, 0.209199, 0.49732, - 0.199346, 0.538511, 0.227825, 0.509693, - 0.209951, 0.544554, 0.247269, 0.524367, - 0.220533, 0.551616, 0.267978, 0.539228, - 0.231082, 0.557368, 0.289672, 0.55644, - 0.241342, 0.563782, 0.31268, 0.574204, - 0.250964, 0.568851, 0.33651, 0.593388, - 0.260306, 0.57312, 0.362219, 0.613358, - 0.268667, 0.574916, 0.390322, 0.634512, - 0.275591, 0.575053, 0.420478, 0.65563, - 0.281328, 0.572404, 0.451614, 0.678265, - 0.285948, 0.568893, 0.484112, 0.70011, - 0.289408, 0.561878, 0.517348, 0.723005, - 0.291328, 0.55359, 0.551355, 0.743744, - 0.291418, 0.541099, 0.585109, 0.763949, - 0.290252, 0.526489, 0.619487, 0.784186, - 0.287648, 0.509496, 0.65404, 0.804304, - 0.283782, 0.491484, 0.688649, 0.823629, - 0.278067, 0.470517, 0.723133, 0.84094, - 0.270588, 0.44705, 0.757163, 0.857852, - 0.261188, 0.421252, 0.792816, 0.874934, - 0.249313, 0.394191, 0.827248, 0.888709, - 0.236492, 0.365359, 0.861074, 0.902589, - 0.222185, 0.336016, 0.894417, 0.914201, - 0.207314, 0.30527, 0.926825, 0.925978, - 0.191146, 0.274532, 0.9595, 0.93512, - 0.174135, 0.243393, 0.991583, 0.943656, - 0.155231, 0.212414, 1.02356, 0.951719, - 0.134403, 0.182005, 1.05239, 0.957164, - 0.113023, 0.153043, 1.07754, 0.962656, - 0.0914493, 0.124186, 1.09984, 0.970695, - 0.0694179, 0.0941654, 1.12, 0.980749, - 0.0466199, 0.0629671, 1.13849, 0.991205, - 0.0227032, 0.0311146, 1.15494, 0.999884, 0.000632388, - 0.000254483, 1.1706, 0.379821, - 9.57289e-06, 0.460637, 7.89337e-06, 0.405188, - 0.000247483, 0.491396, 0.000204064, 0.404796, - 0.000989434, 0.490914, 0.000815853, 0.40483, - 0.00222607, 0.490949, 0.00183559, 0.40473, - 0.00395723, 0.49084, 0.00326332, 0.404731, - 0.00618287, 0.490836, 0.00509945, 0.404768, - 0.00890258, 0.490871, 0.00734463, 0.404791, - 0.0121156, 0.490883, 0.00999992, 0.404857, - 0.0158214, 0.490938, 0.0130676, 0.404943, - 0.0200178, 0.491004, 0.0165503, 0.405059, - 0.0247027, 0.491093, 0.0204521, 0.405213, - 0.0298729, 0.491205, 0.0247788, 0.405399, - 0.0355226, 0.491333, 0.0295373, 0.405731, - 0.0416352, 0.491604, 0.034741, 0.406303, - 0.0480807, 0.492116, 0.0404255, 0.406814, - 0.0550458, 0.492506, 0.0465732, 0.407404, - 0.0624652, 0.492926, 0.0532058, 0.408149, - 0.0702958, 0.493442, 0.0603442, 0.409128, - 0.0784623, 0.494136, 0.0680297, 0.410408, - 0.087007, 0.495054, 0.0762786, 0.411813, - 0.0959639, 0.495962, 0.0851046, 0.413735, - 0.105075, 0.497257, 0.0945878, 0.416137, - 0.114646, 0.498882, 0.104725, 0.41934, - 0.124394, 0.501132, 0.11563, 0.423326, - 0.134328, 0.503883, 0.127325, 0.428419, - 0.14458, 0.50747, 0.139911, 0.43484, - 0.154979, 0.511964, 0.153481, 0.442641, - 0.165628, 0.517328, 0.168114, 0.452511, - 0.176365, 0.524258, 0.183995, 0.463473, - 0.187298, 0.531248, 0.200953, 0.475564, - 0.198244, 0.538367, 0.219176, 0.488664, - 0.208938, 0.545175, 0.238514, 0.504073, - 0.219599, 0.553227, 0.259129, 0.520832, - 0.230378, 0.560653, 0.280997, 0.538455, - 0.240703, 0.567523, 0.303821, 0.55709, - 0.250548, 0.573287, 0.327948, 0.576646, - 0.259964, 0.577795, 0.353362, 0.596705, - 0.268721, 0.580077, 0.380336, 0.618053, - 0.276054, 0.58018, 0.4101, 0.640303, - 0.282176, 0.578747, 0.44161, 0.662365, - 0.286931, 0.574294, 0.474106, 0.684542, - 0.290521, 0.567035, 0.507549, 0.707984, - 0.292672, 0.558687, 0.541853, 0.730913, - 0.293189, 0.547606, 0.576581, 0.752948, - 0.292199, 0.533471, 0.61172, 0.773452, - 0.289508, 0.516395, 0.646339, 0.794715, - 0.285716, 0.497873, 0.682131, 0.814251, - 0.280051, 0.476845, 0.716396, 0.833057, - 0.272873, 0.453449, 0.751503, 0.84959, - 0.263982, 0.427857, 0.786085, 0.867022, - 0.252745, 0.400335, 0.821355, 0.882277, - 0.239655, 0.371304, 0.85646, 0.895375, - 0.225386, 0.340397, 0.890828, 0.909347, - 0.209587, 0.310005, 0.923532, 0.921885, - 0.193433, 0.2796, 0.956419, 0.932127, - 0.176135, 0.247276, 0.989445, 0.941869, - 0.157872, 0.216186, 1.02221, 0.949735, - 0.137577, 0.185602, 1.05195, 0.956617, - 0.115285, 0.155767, 1.07822, 0.961974, - 0.0928418, 0.126103, 1.10149, 0.96972, - 0.0700592, 0.0956758, 1.12207, 0.98012, - 0.0474671, 0.0643269, 1.1408, 0.990825, - 0.0238113, 0.0320863, 1.1577, 0.999876, 0.000381574, - 8.12203e-05, 1.17403, 0.367636, - 9.61342e-06, 0.469176, 7.53287e-06, 0.380377, - 0.000244772, 0.485434, 0.000191797, 0.380416, - 0.000978857, 0.485475, 0.000767015, 0.380376, - 0.00220165, 0.485435, 0.00172522, 0.380419, - 0.00391408, 0.485487, 0.00306734, 0.380438, - 0.00611549, 0.485505, 0.00479332, 0.380462, - 0.00880558, 0.485525, 0.00690391, 0.380496, - 0.0119837, 0.485551, 0.00940039, 0.38056, - 0.0156487, 0.485605, 0.0122848, 0.38064, - 0.0197988, 0.485666, 0.0155601, 0.380767, - 0.0244324, 0.48577, 0.0192313, 0.380909, - 0.0295444, 0.485871, 0.0233032, 0.381142, - 0.0351321, 0.48606, 0.0277861, 0.381472, - 0.0411535, 0.486336, 0.0326939, 0.382015, - 0.0475408, 0.486833, 0.0380565, 0.382523, - 0.0544395, 0.487231, 0.0438615, 0.383129, - 0.061784, 0.487683, 0.0501332, 0.383952, - 0.0695085, 0.488313, 0.0568996, 0.38498, - 0.0775819, 0.489077, 0.0641952, 0.386331, - 0.0860443, 0.490113, 0.0720324, 0.387788, - 0.0948406, 0.491099, 0.0804379, 0.389808, - 0.103899, 0.492566, 0.0894899, 0.39252, - 0.113313, 0.494601, 0.0992098, 0.395493, - 0.123007, 0.496619, 0.109641, 0.399826, - 0.132859, 0.499912, 0.120919, 0.405341, - 0.143077, 0.504061, 0.133107, 0.411932, - 0.153465, 0.508905, 0.146263, 0.420591, - 0.164108, 0.515482, 0.160544, 0.43101, - 0.174893, 0.523191, 0.176123, 0.441881, - 0.185839, 0.53026, 0.192757, 0.453919, - 0.196633, 0.537295, 0.210535, 0.468715, - 0.207611, 0.546156, 0.229886, 0.485182, - 0.218517, 0.555173, 0.250543, 0.501926, - 0.229249, 0.562728, 0.27221, 0.51785, - 0.239481, 0.567494, 0.294892, 0.536947, - 0.249395, 0.573889, 0.318987, 0.557115, - 0.259, 0.578831, 0.344348, 0.577966, - 0.268075, 0.582055, 0.371223, 0.599489, - 0.276115, 0.583307, 0.399834, 0.62479, - 0.282523, 0.583902, 0.431415, 0.647504, - 0.287663, 0.57953, 0.464301, 0.670601, - 0.291538, 0.573103, 0.498123, 0.693539, - 0.293842, 0.563731, 0.532662, 0.717385, - 0.294681, 0.553169, 0.567925, 0.741533, - 0.293717, 0.539908, 0.603502, 0.762142, - 0.291156, 0.521902, 0.639074, 0.783014, - 0.28719, 0.502815, 0.674439, 0.805158, - 0.281773, 0.482598, 0.710497, 0.823646, - 0.274682, 0.458949, 0.7456, 0.841879, - 0.266184, 0.433129, 0.781085, 0.859515, - 0.255682, 0.406064, 0.816, 0.875335, - 0.242849, 0.376509, 0.851074, 0.890147, - 0.228329, 0.345502, 0.886473, 0.903144, - 0.212491, 0.31428, 0.920751, 0.916618, - 0.195695, 0.282994, 0.954606, 0.927953, - 0.178267, 0.251091, 0.988402, 0.937414, - 0.159549, 0.219107, 1.02141, 0.946823, - 0.140022, 0.18896, 1.05167, 0.954651, - 0.118154, 0.158667, 1.07819, 0.959955, - 0.0946636, 0.128808, 1.1025, 0.96858, - 0.0711792, 0.0973787, 1.12391, 0.97938, - 0.0475046, 0.0650965, 1.14322, 0.990498, - 0.024059, 0.0326267, 1.16077, 0.999844, - 5.12408e-05, 0.000112444, 1.17727, 0.316912, - 9.34977e-06, 0.425996, 6.95559e-06, 0.356423, - 0.000241372, 0.479108, 0.000179562, 0.356272, - 0.000965292, 0.478897, 0.00071811, 0.356262, - 0.00217182, 0.478894, 0.00161574, 0.356265, - 0.00386092, 0.478895, 0.00287261, 0.356278, - 0.0060324, 0.478905, 0.00448907, 0.356293, - 0.00868565, 0.478914, 0.00646572, 0.356346, - 0.0118207, 0.478965, 0.00880438, 0.356395, - 0.0154355, 0.479001, 0.0115066, 0.356484, - 0.019529, 0.479075, 0.0145762, 0.356609, - 0.0240991, 0.47918, 0.018018, 0.356766, - 0.0291413, 0.479305, 0.0218379, 0.357009, - 0.0346498, 0.479512, 0.0260454, 0.357424, - 0.0405462, 0.479909, 0.0306657, 0.357899, - 0.0468825, 0.480337, 0.0357054, 0.358424, - 0.0536887, 0.480771, 0.0411728, 0.359041, - 0.0609416, 0.481242, 0.0470841, 0.359903, - 0.0685239, 0.481943, 0.0534831, 0.360932, - 0.0764883, 0.482741, 0.0603795, 0.362196, - 0.0848364, 0.483688, 0.0678028, 0.363847, - 0.0935002, 0.484947, 0.0758086, 0.365972, - 0.102471, 0.486588, 0.0844173, 0.368741, - 0.111751, 0.488787, 0.0937199, 0.372146, - 0.121334, 0.491405, 0.103732, 0.377114, - 0.131147, 0.495604, 0.114608, 0.38226, - 0.141213, 0.499436, 0.126345, 0.389609, - 0.151632, 0.505334, 0.139116, 0.397925, - 0.162073, 0.51168, 0.152995, 0.407824, - 0.172819, 0.518876, 0.168071, 0.420014, - 0.183929, 0.527639, 0.184495, 0.434266, - 0.195032, 0.537588, 0.20232, 0.447352, - 0.205792, 0.544379, 0.221189, 0.463726, - 0.216704, 0.553422, 0.241616, 0.481406, - 0.227531, 0.562074, 0.263298, 0.498707, - 0.238017, 0.568227, 0.286116, 0.518039, - 0.247936, 0.574473, 0.3101, 0.538277, - 0.257437, 0.579191, 0.335401, 0.561166, - 0.266829, 0.584807, 0.362246, 0.583189, - 0.275329, 0.586476, 0.390609, 0.606024, - 0.28234, 0.585578, 0.420998, 0.632419, - 0.287924, 0.584496, 0.454357, 0.656128, - 0.291972, 0.577766, 0.488233, 0.679953, - 0.29456, 0.56875, 0.523248, 0.704654, - 0.295816, 0.558388, 0.559168, 0.729016, - 0.295157, 0.544826, 0.595326, 0.752062, - 0.292779, 0.528273, 0.631864, 0.773138, - 0.288681, 0.508482, 0.667793, 0.794869, - 0.283358, 0.487341, 0.704035, 0.815101, - 0.27608, 0.46354, 0.739925, 0.834212, - 0.26767, 0.438672, 0.775539, 0.852368, - 0.257397, 0.411239, 0.810895, 0.870207, - 0.245689, 0.3829, 0.846472, 0.884063, - 0.231452, 0.351496, 0.881788, 0.898284, - 0.215561, 0.31895, 0.917438, 0.912964, - 0.198208, 0.287367, 0.952422, 0.924666, - 0.180426, 0.254487, 0.987551, 0.934429, - 0.161525, 0.222226, 1.02142, 0.943485, - 0.141197, 0.191143, 1.05218, 0.9521, - 0.120085, 0.161112, 1.07937, 0.957876, - 0.0975881, 0.130982, 1.10403, 0.966943, - 0.0726842, 0.0990553, 1.12616, 0.978313, - 0.0483705, 0.0662818, 1.14619, 0.990048, - 0.0239072, 0.0329243, 1.16413, 0.999984, 0.000461885, - 7.72859e-05, 1.18099, 0.321287, - 9.35049e-06, 0.455413, 6.59662e-06, 0.332595, - 0.000237513, 0.471437, 0.000167562, 0.332729, - 0.000949964, 0.471618, 0.000670192, 0.332305, - 0.00213618, 0.471028, 0.00150712, 0.332326, - 0.00379765, 0.471055, 0.00267959, 0.332344, - 0.00593353, 0.471072, 0.00418751, 0.332356, - 0.00854349, 0.471077, 0.00603172, 0.332403, - 0.0116268, 0.471121, 0.00821362, 0.332461, - 0.0151824, 0.47117, 0.0107357, 0.332552, - 0.0192088, 0.471251, 0.0136014, 0.332657, - 0.0237024, 0.47133, 0.0168152, 0.332835, - 0.0286615, 0.471487, 0.0203853, 0.333083, - 0.0340765, 0.471708, 0.0243212, 0.333547, - 0.0398563, 0.47219, 0.0286518, 0.333989, - 0.0460916, 0.472587, 0.0333763, 0.334532, - 0.0527897, 0.473054, 0.0385084, 0.335167, - 0.0599284, 0.473568, 0.0440638, 0.33608, - 0.0673514, 0.474362, 0.0500962, 0.337146, - 0.0752237, 0.475231, 0.0566022, 0.338462, - 0.083418, 0.476282, 0.0636272, 0.34014, - 0.0919382, 0.477615, 0.0712153, 0.342341, - 0.100741, 0.479404, 0.079417, 0.345088, - 0.109905, 0.481618, 0.0882631, 0.349049, - 0.119369, 0.485081, 0.0978851, 0.353939, - 0.129033, 0.489317, 0.108336, 0.359893, - 0.139038, 0.494309, 0.119698, 0.366945, - 0.149411, 0.499983, 0.132024, 0.375814, - 0.159843, 0.507185, 0.145558, 0.387112, - 0.170664, 0.516392, 0.160433, 0.40023, - 0.181897, 0.526519, 0.176648, 0.412555, - 0.192785, 0.53423, 0.193922, 0.427023, - 0.203663, 0.542741, 0.212662, 0.443685, - 0.214695, 0.552066, 0.232944, 0.461499, - 0.225561, 0.560762, 0.254495, 0.480975, - 0.236257, 0.569421, 0.277531, 0.501, - 0.24639, 0.576101, 0.301724, 0.521691, - 0.256101, 0.581493, 0.327112, 0.543478, - 0.265289, 0.585221, 0.353917, 0.566094, - 0.273938, 0.587614, 0.381941, 0.589578, - 0.281679, 0.587991, 0.41172, 0.614583, - 0.287655, 0.585928, 0.444148, 0.641813, - 0.292228, 0.582092, 0.478617, 0.666189, - 0.295172, 0.57398, 0.51397, 0.690475, - 0.29648, 0.561676, 0.550118, 0.715543, - 0.296203, 0.548758, 0.586933, 0.740405, - 0.293999, 0.532792, 0.62384, 0.762183, - 0.28998, 0.512735, 0.660723, 0.786069, - 0.28478, 0.492402, 0.69807, 0.806812, - 0.277568, 0.469058, 0.734422, 0.826987, - 0.268951, 0.443017, 0.770946, 0.844588, - 0.259049, 0.415501, 0.80699, 0.863725, - 0.2471, 0.387328, 0.842107, 0.879137, - 0.234157, 0.356108, 0.878078, 0.894634, - 0.218719, 0.324315, 0.914058, 0.909162, - 0.201293, 0.291813, 0.949922, 0.92072, - 0.18267, 0.258474, 0.985337, 0.93158, - 0.163212, 0.225593, 1.0205, 0.941238, - 0.142771, 0.193986, 1.05273, 0.949293, - 0.120956, 0.163392, 1.08075, 0.956226, - 0.0985743, 0.132934, 1.10559, 0.96546, - 0.075118, 0.101255, 1.12823, 0.977403, - 0.0497921, 0.0675441, 1.149, 0.989648, - 0.0241574, 0.0334681, 1.16765, 1.00001, 0.0005762, - 0.000184807, 1.18519, 0.303474, - 9.16603e-06, 0.4542, 6.1243e-06, 0.308894, - 0.000232869, 0.462306, 0.000155592, 0.309426, - 0.000931661, 0.463093, 0.000622499, 0.308643, - 0.0020949, 0.461933, 0.00139979, 0.308651, - 0.0037242, 0.461941, 0.00248874, 0.308662, - 0.00581873, 0.46195, 0.00388933, 0.308687, - 0.00837818, 0.461974, 0.00560247, 0.308728, - 0.0114016, 0.462011, 0.00762948, 0.308789, - 0.0148884, 0.462067, 0.00997326, 0.308882, - 0.0188369, 0.462151, 0.0126375, 0.309007, - 0.0232436, 0.462263, 0.0156271, 0.30918, - 0.0281054, 0.462417, 0.0189498, 0.309442, - 0.0334065, 0.462667, 0.0226167, 0.309901, - 0.0390589, 0.463162, 0.0266614, 0.310331, - 0.0452042, 0.463555, 0.0310715, 0.310858, - 0.0517735, 0.464019, 0.0358698, 0.311576, - 0.0587359, 0.464669, 0.0410848, 0.312436, - 0.0660383, 0.465406, 0.0467453, 0.313526, - 0.0737266, 0.466339, 0.0528718, 0.314903, - 0.0817574, 0.467504, 0.0595039, 0.316814, - 0.090167, 0.469226, 0.0666888, 0.318965, - 0.0987555, 0.470981, 0.0744658, 0.322077, - 0.107792, 0.473814, 0.082912, 0.325947, - 0.117098, 0.477241, 0.0920846, 0.331008, - 0.126602, 0.48184, 0.102137, 0.337893, - 0.136619, 0.488334, 0.113135, 0.345106, - 0.146838, 0.494415, 0.12511, 0.355111, - 0.157357, 0.503275, 0.138356, 0.365095, - 0.167955, 0.510966, 0.152686, 0.378344, - 0.179157, 0.521508, 0.16856, 0.391599, - 0.190143, 0.530455, 0.18561, 0.407786, - 0.20123, 0.541275, 0.204308, 0.425294, - 0.212456, 0.551784, 0.224623, 0.444021, - 0.223568, 0.561493, 0.246172, 0.463418, - 0.234154, 0.569886, 0.268979, 0.484077, - 0.244546, 0.577116, 0.293411, 0.505513, - 0.254301, 0.582914, 0.318936, 0.527672, - 0.263564, 0.587208, 0.345856, 0.550565, - 0.272332, 0.589277, 0.374054, 0.573656, - 0.280011, 0.588426, 0.403276, 0.59827, - 0.286924, 0.587504, 0.43474, 0.624731, - 0.291994, 0.583401, 0.468767, 0.652396, - 0.295159, 0.576997, 0.504411, 0.67732, - 0.296954, 0.565863, 0.54114, 0.703147, - 0.296877, 0.552316, 0.57816, 0.728715, - 0.295147, 0.536773, 0.616124, 0.752448, - 0.291275, 0.51771, 0.653885, 0.775169, - 0.285905, 0.496087, 0.691537, 0.799307, - 0.279064, 0.474232, 0.729251, 0.819482, - 0.270294, 0.447676, 0.766267, 0.837659, - 0.260032, 0.419656, 0.802616, 0.856903, - 0.248497, 0.391328, 0.838583, 0.873325, - 0.235252, 0.360285, 0.874711, 0.889788, - 0.221126, 0.329215, 0.91077, 0.904486, - 0.204304, 0.296392, 0.94653, 0.917711, - 0.185562, 0.262159, 0.983828, 0.928969, - 0.165635, 0.229142, 1.01955, 0.939707, - 0.14442, 0.19673, 1.05317, 0.948167, - 0.122147, 0.165095, 1.0823, 0.955222, - 0.099098, 0.13451, 1.10791, 0.964401, - 0.0755332, 0.102476, 1.1312, 0.976605, - 0.0513817, 0.0689667, 1.15218, 0.989085, - 0.0258499, 0.034506, 1.17129, 0.999908, 0.000617773, - 0.000271268, 1.18961, 0.285803, - 9.05752e-06, 0.452348, 5.72272e-06, 0.284689, - 0.00022732, 0.450581, 0.000143626, 0.285263, - 0.000910214, 0.451482, 0.000575099, 0.285302, - 0.00204784, 0.451553, 0.00129395, 0.285318, - 0.00364057, 0.451574, 0.0023006, 0.28533, - 0.00568813, 0.451585, 0.00359547, 0.285361, - 0.00819001, 0.451618, 0.00517934, 0.285397, - 0.0111458, 0.45165, 0.007054, 0.285447, - 0.0145536, 0.451688, 0.00922167, 0.285527, - 0.0184127, 0.451758, 0.0116869, 0.285688, - 0.0227207, 0.451929, 0.0144555, 0.28584, - 0.0274712, 0.452055, 0.0175341, 0.286136, - 0.0326278, 0.452369, 0.0209406, 0.286574, - 0.0381792, 0.452853, 0.0246965, 0.287012, - 0.0441879, 0.453272, 0.0287996, 0.287542, - 0.0506096, 0.453752, 0.033268, 0.288299, - 0.0573634, 0.454488, 0.0381504, 0.289186, - 0.0645458, 0.455294, 0.0434447, 0.290302, - 0.0720405, 0.456301, 0.0491973, 0.291776, - 0.0799046, 0.457648, 0.0554453, 0.29372, - 0.088117, 0.459483, 0.0622311, 0.296052, - 0.0965328, 0.461571, 0.0695992, 0.299563, - 0.105409, 0.465085, 0.077658, 0.30335, - 0.114553, 0.468506, 0.0864176, 0.309167, - 0.123917, 0.474423, 0.0961078, 0.31529, - 0.13381, 0.47995, 0.106643, 0.324163, - 0.144021, 0.488592, 0.118322, 0.333272, - 0.154382, 0.496461, 0.131133, 0.344224, - 0.165015, 0.50562, 0.145208, 0.357733, - 0.176168, 0.516719, 0.16073, 0.373046, - 0.187468, 0.528513, 0.177807, 0.38788, - 0.198488, 0.537713, 0.196072, 0.405133, - 0.209545, 0.547999, 0.21605, 0.423845, - 0.220724, 0.55759, 0.237484, 0.443777, - 0.231518, 0.566246, 0.26039, 0.464824, - 0.242035, 0.574326, 0.284835, 0.486635, - 0.251898, 0.58037, 0.310518, 0.51012, - 0.261304, 0.58568, 0.337678, 0.535301, - 0.270384, 0.590197, 0.366242, 0.559193, - 0.27841, 0.590569, 0.395873, 0.583544, - 0.285325, 0.588161, 0.426857, 0.608834, - 0.291113, 0.584249, 0.459477, 0.635753, - 0.294882, 0.57763, 0.494734, 0.664367, - 0.297088, 0.569479, 0.532023, 0.689688, - 0.297364, 0.555064, 0.569629, 0.715732, - 0.295949, 0.539522, 0.608124, 0.741307, - 0.292259, 0.521613, 0.646231, 0.764949, - 0.287063, 0.49969, 0.684938, 0.788599, - 0.28012, 0.476747, 0.723548, 0.81048, - 0.27153, 0.45116, 0.761135, 0.831372, - 0.261289, 0.424101, 0.798916, 0.850092, - 0.249559, 0.39443, 0.835952, 0.867777, - 0.236348, 0.363849, 0.871606, 0.884632, - 0.221569, 0.332477, 0.907843, 0.90047, - 0.20618, 0.300667, 0.944187, 0.914524, - 0.188771, 0.266552, 0.981371, 0.926892, - 0.168362, 0.232349, 1.01841, 0.937951, - 0.146761, 0.199359, 1.05308, 0.947236, - 0.123813, 0.1675, 1.0839, 0.954367, - 0.099984, 0.136166, 1.11047, 0.963907, - 0.0759278, 0.103808, 1.13414, 0.976218, - 0.0511367, 0.0697061, 1.15575, 0.988772, - 0.0267415, 0.0352529, 1.17531, 0.999888, - 0.000520778, 0.000289926, 1.19389, 0.263546, - 8.83274e-06, 0.441896, 5.26783e-06, 0.262352, - 0.000221849, 0.439889, 0.000132311, 0.262325, - 0.000886683, 0.439848, 0.000528824, 0.26228, - 0.00199476, 0.439765, 0.00118975, 0.262372, - 0.00354671, 0.439922, 0.00211568, 0.26239, - 0.00554141, 0.439941, 0.00330652, 0.262412, - 0.00797888, 0.439961, 0.00476346, 0.262453, - 0.0108584, 0.440002, 0.00648818, 0.262528, - 0.0141788, 0.440085, 0.0084835, 0.262615, - 0.017938, 0.440166, 0.0107533, 0.262744, - 0.0221346, 0.440291, 0.0133044, 0.262939, - 0.026762, 0.440493, 0.0161445, 0.263277, - 0.0317573, 0.440889, 0.0192974, 0.26368, - 0.0371832, 0.441338, 0.0227699, 0.264106, - 0.0430371, 0.441753, 0.0265698, 0.264624, - 0.0493035, 0.442227, 0.0307178, 0.265378, - 0.0558669, 0.442985, 0.0352616, 0.266253, - 0.0628718, 0.443795, 0.0401968, 0.267478, - 0.0701569, 0.445008, 0.04559, 0.269062, - 0.077845, 0.446599, 0.0514539, 0.270926, - 0.0857941, 0.448349, 0.0578382, 0.273693, - 0.0940773, 0.451221, 0.0648363, 0.276746, - 0.102704, 0.454097, 0.0724389, 0.281693, - 0.111735, 0.459517, 0.0808744, 0.287335, - 0.121004, 0.46531, 0.0901551, 0.29448, - 0.130734, 0.472605, 0.100371, 0.30257, - 0.140777, 0.480251, 0.111644, 0.312465, - 0.15111, 0.489444, 0.124111, 0.324856, - 0.16189, 0.500919, 0.137979, 0.33774, - 0.172946, 0.511317, 0.153163, 0.35255, - 0.184152, 0.522684, 0.169817, 0.367786, - 0.19522, 0.53248, 0.187886, 0.385474, - 0.20632, 0.543326, 0.207634, 0.404976, - 0.217744, 0.554109, 0.229165, 0.425203, - 0.228691, 0.563395, 0.252068, 0.446704, - 0.239299, 0.571565, 0.276471, 0.468951, - 0.249348, 0.577935, 0.302323, 0.493487, - 0.258933, 0.584309, 0.329882, 0.517861, - 0.268009, 0.58773, 0.358525, 0.543309, - 0.276238, 0.589612, 0.388585, 0.569704, - 0.28356, 0.589294, 0.419787, 0.594871, - 0.289497, 0.585137, 0.452114, 0.622555, - 0.294452, 0.580356, 0.486466, 0.651167, - 0.296918, 0.57185, 0.523079, 0.677332, - 0.297647, 0.558428, 0.5611, 0.703718, - 0.296321, 0.542232, 0.599592, 0.730262, - 0.293339, 0.524541, 0.639138, 0.754304, - 0.288036, 0.502691, 0.677978, 0.778051, - 0.281018, 0.479212, 0.716537, 0.801557, - 0.272414, 0.454071, 0.75586, 0.822559, - 0.262419, 0.425952, 0.794477, 0.843051, - 0.250702, 0.397313, 0.832664, 0.86232, - 0.237264, 0.366534, 0.869876, 0.879044, - 0.222716, 0.334816, 0.906973, 0.896362, - 0.206827, 0.303143, 0.943558, 0.910342, - 0.189659, 0.269699, 0.979759, 0.924119, - 0.171108, 0.236411, 1.01718, 0.935374, - 0.149579, 0.202224, 1.05289, 0.944295, - 0.126295, 0.16989, 1.08496, 0.952227, - 0.101511, 0.138089, 1.11256, 0.962041, - 0.0766392, 0.105053, 1.1375, 0.97528, - 0.0511967, 0.070329, 1.15983, 0.988476, - 0.025463, 0.0351268, 1.17987, 0.999962, 2.86808e-05, 1.45564e-05, 1.19901, 0.227089, - 8.41413e-06, 0.404216, 4.72707e-06, 0.239725, - 0.000215083, 0.426708, 0.000120833, 0.239904, - 0.000860718, 0.427028, 0.000483555, 0.239911, - 0.00193661, 0.427039, 0.00108806, 0.239914, - 0.00344276, 0.42704, 0.00193457, 0.239933, - 0.00537907, 0.427064, 0.00302363, 0.239944, - 0.00774482, 0.427065, 0.00435604, 0.239993, - 0.01054, 0.427122, 0.00593398, 0.240052, - 0.0137626, 0.427179, 0.00775987, 0.240148, - 0.0174115, 0.427279, 0.00983854, 0.240278, - 0.021484, 0.42741, 0.0121763, 0.240472, - 0.0259729, 0.427618, 0.0147827, 0.240839, - 0.0308131, 0.428086, 0.0176837, 0.241201, - 0.0360893, 0.428482, 0.0208775, 0.241626, - 0.0417723, 0.428907, 0.0243821, 0.242207, - 0.0478337, 0.42952, 0.0282228, 0.24298, - 0.0542199, 0.430332, 0.0324333, 0.243881, - 0.0610015, 0.431222, 0.0370252, 0.245123, - 0.0680874, 0.432512, 0.0420535, 0.24667, - 0.0755482, 0.434088, 0.0475414, 0.248779, - 0.0832873, 0.436323, 0.0535542, 0.251665, - 0.0913546, 0.439509, 0.0601716, 0.255305, - 0.0998489, 0.443478, 0.0674282, 0.260049, - 0.108576, 0.448713, 0.0754673, 0.266192, - 0.117754, 0.455524, 0.084339, 0.273158, - 0.127294, 0.4627, 0.0941683, 0.282131, - 0.137311, 0.472068, 0.10515, 0.293332, - 0.147736, 0.483565, 0.117402, 0.304667, - 0.158357, 0.493702, 0.130824, 0.317785, - 0.169274, 0.504708, 0.145724, 0.333245, - 0.180595, 0.517107, 0.16215, 0.349843, - 0.191892, 0.528849, 0.180149, 0.367944, - 0.203168, 0.540301, 0.199746, 0.387579, - 0.214443, 0.551514, 0.221047, 0.408247, - 0.225624, 0.560906, 0.243981, 0.43014, - 0.236422, 0.56959, 0.268513, 0.452669, - 0.24654, 0.576098, 0.294409, 0.476196, - 0.256157, 0.580925, 0.322002, 0.501157, - 0.265289, 0.584839, 0.351052, 0.527632, - 0.273671, 0.587614, 0.3812, 0.555754, - 0.281254, 0.589119, 0.412994, 0.581682, - 0.287448, 0.585204, 0.445498, 0.608196, - 0.292614, 0.579006, 0.479505, 0.635661, - 0.296068, 0.571297, 0.514643, 0.664999, - 0.297395, 0.560855, 0.552213, 0.691039, - 0.296645, 0.544525, 0.591365, 0.7179, - 0.293785, 0.526535, 0.630883, 0.744059, - 0.289089, 0.50545, 0.670932, 0.76863, - 0.282239, 0.482514, 0.710904, 0.793273, - 0.273688, 0.457246, 0.750259, 0.814731, - 0.26328, 0.428872, 0.78948, 0.835603, - 0.251526, 0.399384, 0.828597, 0.85489, - 0.238339, 0.368811, 0.866892, 0.872828, - 0.223607, 0.336617, 0.90563, 0.889462, - 0.207538, 0.303997, 0.943538, 0.904929, - 0.190297, 0.270812, 0.980591, 0.919101, - 0.172034, 0.237453, 1.01935, 0.930536, - 0.152058, 0.204431, 1.05498, 0.941223, - 0.129515, 0.172495, 1.08717, 0.94982, - 0.104263, 0.140175, 1.11551, 0.960592, - 0.0781944, 0.106465, 1.14098, 0.974629, - 0.051688, 0.0711592, 1.16418, 0.98811, - 0.0253929, 0.0354432, 1.18465, 1.00004, 0.000804378, - 0.000330876, 1.20462, 0.214668, - 8.21282e-06, 0.406619, 4.33582e-06, 0.218053, - 0.000208144, 0.413025, 0.000109887, 0.217987, - 0.000832212, 0.412901, 0.000439362, 0.217971, - 0.00187246, 0.412876, 0.000988623, 0.217968, - 0.00332855, 0.41286, 0.00175772, 0.217985, - 0.00520055, 0.412882, 0.00274729, 0.218014, - 0.00748814, 0.412916, 0.00395842, 0.218054, - 0.0101901, 0.412957, 0.00539274, 0.218106, - 0.0133057, 0.413005, 0.00705348, 0.218217, - 0.0168342, 0.413139, 0.00894581, 0.218338, - 0.0207707, 0.413258, 0.0110754, 0.21855, - 0.0251001, 0.413509, 0.0134551, 0.218913, - 0.0297861, 0.413992, 0.0161081, 0.219265, - 0.0348956, 0.414383, 0.0190307, 0.219696, - 0.0403909, 0.414839, 0.0222458, 0.220329, - 0.0462003, 0.415567, 0.025792, 0.220989, - 0.0524208, 0.41621, 0.0296637, 0.222027, - 0.058948, 0.417385, 0.0339323, 0.223301, - 0.0658208, 0.418779, 0.0386055, 0.224988, - 0.0730347, 0.420665, 0.0437355, 0.227211, - 0.0805274, 0.423198, 0.0493844, 0.230131, - 0.088395, 0.426566, 0.0556135, 0.233908, - 0.0966208, 0.43091, 0.0624829, 0.239092, - 0.105223, 0.437148, 0.0701636, 0.245315, - 0.11424, 0.444302, 0.0786949, 0.253166, - 0.12368, 0.453262, 0.0882382, 0.262374, - 0.133569, 0.463211, 0.0988682, 0.273145, - 0.143836, 0.474271, 0.110727, 0.285512, - 0.154577, 0.4863, 0.123945, 0.299512, - 0.165501, 0.498817, 0.138581, 0.314287, - 0.176698, 0.510341, 0.154676, 0.331083, - 0.188066, 0.522583, 0.172459, 0.349615, - 0.199597, 0.534879, 0.191979, 0.369318, - 0.210843, 0.546083, 0.21309, 0.390377, - 0.222068, 0.5562, 0.235998, 0.412411, - 0.233059, 0.564704, 0.260518, 0.435715, - 0.24357, 0.572314, 0.286795, 0.461196, - 0.253356, 0.579395, 0.314559, 0.485587, - 0.262362, 0.581985, 0.343581, 0.511908, - 0.270895, 0.584347, 0.374367, 0.539798, - 0.278452, 0.58505, 0.406015, 0.567974, - 0.284877, 0.583344, 0.439168, 0.594303, - 0.290124, 0.577348, 0.473005, 0.622951, - 0.294183, 0.570751, 0.508534, 0.652404, - 0.296389, 0.561541, 0.544764, 0.679291, - 0.296605, 0.546426, 0.582927, 0.706437, - 0.294095, 0.528599, 0.622681, 0.734485, - 0.28978, 0.508676, 0.663567, 0.758841, - 0.283363, 0.484768, 0.704092, 0.78537, - 0.275015, 0.460434, 0.745101, 0.807315, - 0.264689, 0.432166, 0.784712, 0.8271, - 0.252597, 0.401807, 0.824241, 0.849191, - 0.239154, 0.371458, 0.863803, 0.867046, - 0.224451, 0.338873, 0.903063, 0.8852, - 0.208342, 0.306175, 0.942763, 0.901771, - 0.190684, 0.272759, 0.981559, 0.915958, - 0.172105, 0.239306, 1.02048, 0.928046, - 0.152214, 0.206071, 1.05765, 0.939961, - 0.130247, 0.17367, 1.08999, 0.948711, - 0.10672, 0.142201, 1.11829, 0.959305, - 0.0808688, 0.108454, 1.14467, 0.973009, - 0.0539145, 0.0728109, 1.16839, 0.987631, - 0.0262947, 0.0360625, 1.19004, 0.999978, 0.00132758, - 0.000559424, 1.21058, 0.193925, - 7.93421e-06, 0.391974, 3.92537e-06, 0.196746, - 0.000200315, 0.397675, 9.91033e-05, 0.19667, - 0.000801099, 0.397521, 0.000396342, 0.196633, - 0.00180246, 0.397445, 0.000891829, 0.196654, - 0.00320443, 0.397482, 0.00158582, 0.196659, - 0.00500647, 0.39748, 0.00247867, 0.196683, - 0.0072086, 0.397506, 0.00357167, 0.196728, - 0.00981001, 0.397562, 0.00486675, 0.196792, - 0.0128096, 0.397633, 0.00636707, 0.19689, - 0.0162055, 0.397746, 0.00807752, 0.197017, - 0.0199943, 0.397884, 0.0100052, 0.19729, - 0.024139, 0.39827, 0.0121691, 0.197583, - 0.0286671, 0.398639, 0.0145755, 0.197927, - 0.0335858, 0.399034, 0.0172355, 0.198383, - 0.0388806, 0.399554, 0.0201718, 0.199002, - 0.0444736, 0.400289, 0.0234194, 0.199739, - 0.0504583, 0.401111, 0.026984, 0.200784, - 0.056729, 0.402349, 0.0309217, 0.202075, - 0.0633643, 0.403841, 0.0352496, 0.203898, - 0.0703247, 0.406076, 0.0400313, 0.206199, - 0.0775565, 0.408841, 0.0453282, 0.209252, - 0.085184, 0.41259, 0.0511794, 0.213638, - 0.0931994, 0.418288, 0.0577459, 0.21881, - 0.101617, 0.424681, 0.0650508, 0.225642, - 0.11052, 0.433429, 0.0732759, 0.233717, - 0.119772, 0.442897, 0.0824683, 0.242823, - 0.129505, 0.452888, 0.0927484, 0.254772, - 0.139906, 0.466407, 0.104417, 0.266603, - 0.150402, 0.477413, 0.117211, 0.28073, - 0.161395, 0.490519, 0.131598, 0.295399, - 0.172465, 0.50201, 0.147407, 0.312705, - 0.183982, 0.515311, 0.165031, 0.331335, - 0.195532, 0.52786, 0.184336, 0.351037, - 0.206971, 0.5392, 0.205361, 0.372175, - 0.218117, 0.54941, 0.228043, 0.394548, - 0.229327, 0.558642, 0.25267, 0.419598, - 0.240052, 0.567861, 0.279071, 0.443922, - 0.249937, 0.573332, 0.306882, 0.471495, - 0.259407, 0.58013, 0.33661, 0.496769, - 0.267749, 0.580564, 0.367328, 0.524951, - 0.275524, 0.581696, 0.399753, 0.55318, - 0.282148, 0.579885, 0.433134, 0.581577, - 0.287533, 0.575471, 0.467534, 0.609231, - 0.291612, 0.567445, 0.502943, 0.637478, - 0.293911, 0.557657, 0.53871, 0.667795, - 0.295096, 0.546535, 0.576568, 0.694272, - 0.294073, 0.529561, 0.614929, 0.722937, - 0.290386, 0.510561, 0.655909, 0.749682, - 0.284481, 0.487846, 0.697663, 0.774754, - 0.276188, 0.462487, 0.738515, 0.799301, - 0.266215, 0.43481, 0.779802, 0.820762, - 0.254116, 0.404879, 0.820045, 0.843231, - 0.240393, 0.374559, 0.860294, 0.861857, - 0.225503, 0.341582, 0.900965, 0.880815, - 0.209382, 0.308778, 0.941727, 0.89766, - 0.19155, 0.275232, 0.980916, 0.912926, - 0.172346, 0.240938, 1.02162, 0.926391, - 0.151799, 0.207223, 1.0597, 0.938429, - 0.129968, 0.17484, 1.09291, 0.947834, - 0.10651, 0.142984, 1.12248, 0.958432, - 0.0824098, 0.109902, 1.149, 0.972402, - 0.0565242, 0.0744454, 1.1733, 0.987191, - 0.028427, 0.0373794, 1.19538, 0.999975, 3.85685e-05, - 4.203e-05, 1.21676, 0.178114, - 7.66075e-06, 0.385418, 3.54027e-06, 0.176074, - 0.000191966, 0.381002, 8.87135e-05, 0.17601, - 0.000767549, 0.380861, 0.000354715, 0.17598, - 0.00172696, 0.380798, 0.000798168, 0.175994, - 0.00307012, 0.380824, 0.00141928, 0.176017, - 0.00479684, 0.380858, 0.00221859, 0.176019, - 0.00690648, 0.380839, 0.00319714, 0.176072, - 0.00939888, 0.380913, 0.0043572, 0.176131, - 0.0122726, 0.380979, 0.005702, 0.176239, - 0.0155264, 0.38112, 0.00723689, 0.176371, - 0.0191551, 0.381272, 0.00896907, 0.176638, - 0.023117, 0.381669, 0.0109194, 0.176912, - 0.0274633, 0.382015, 0.0130903, 0.177279, - 0.032173, 0.382476, 0.0154949, 0.17774, - 0.0372219, 0.383041, 0.0181669, 0.178344, - 0.0426132, 0.38378, 0.0211209, 0.179153, - 0.0483309, 0.384773, 0.0243899, 0.180197, - 0.0543447, 0.386076, 0.0280062, 0.181581, - 0.0607122, 0.387809, 0.032004, 0.18344, - 0.0673855, 0.390205, 0.036453, 0.186139, - 0.0743989, 0.393944, 0.0414162, 0.189432, - 0.0817731, 0.39832, 0.0469394, 0.193795, - 0.0895464, 0.404188, 0.0531442, 0.199641, - 0.0978264, 0.4121, 0.0601374, 0.206679, - 0.106499, 0.421425, 0.0680078, 0.214865, - 0.115654, 0.431504, 0.076919, 0.224406, - 0.125268, 0.442526, 0.0868835, 0.235876, - 0.135475, 0.455465, 0.0981875, 0.248335, - 0.146023, 0.4681, 0.110759, 0.262868, - 0.157016, 0.482069, 0.124885, 0.278962, - 0.168245, 0.496182, 0.140645, 0.295082, - 0.17958, 0.507401, 0.157838, 0.313738, - 0.191227, 0.520252, 0.17695, 0.333573, - 0.202718, 0.531708, 0.197817, 0.356433, - 0.214424, 0.544509, 0.220785, 0.378853, - 0.225492, 0.55373, 0.245306, 0.402717, - 0.236236, 0.561348, 0.271593, 0.428375, - 0.246568, 0.568538, 0.299776, 0.454724, - 0.255941, 0.573462, 0.329433, 0.482291, - 0.264511, 0.576356, 0.360598, 0.509706, - 0.272129, 0.576446, 0.393204, 0.538805, - 0.278979, 0.575298, 0.427227, 0.568919, - 0.284528, 0.572154, 0.462157, 0.596804, - 0.288801, 0.564691, 0.497997, 0.625987, - 0.291334, 0.555134, 0.534467, 0.656414, - 0.292722, 0.545051, 0.571736, 0.683916, - 0.292185, 0.528813, 0.610158, 0.711809, - 0.290043, 0.51106, 0.649061, 0.739547, - 0.285246, 0.490103, 0.690081, 0.766914, - 0.277647, 0.465523, 0.732554, 0.791375, - 0.267603, 0.437718, 0.773982, 0.814772, - 0.256109, 0.40882, 0.81609, 0.836691, - 0.242281, 0.377823, 0.856849, 0.856984, - 0.227155, 0.34496, 0.898363, 0.876332, - 0.210395, 0.311335, 0.939471, 0.894988, - 0.192612, 0.277703, 0.980799, 0.911113, - 0.173236, 0.243019, 1.02215, 0.924092, - 0.152258, 0.209037, 1.06139, 0.936828, - 0.129575, 0.175909, 1.09635, 0.946869, - 0.10594, 0.143852, 1.12707, 0.958284, - 0.081318, 0.110289, 1.15419, 0.972325, - 0.0556133, 0.0747232, 1.17909, 0.986878, - 0.0297899, 0.0383149, 1.20163, 0.999936, - 0.00197169, 0.000912402, 1.22338, 0.151174, - 7.20365e-06, 0.351531, 3.09789e-06, 0.155594, - 0.00018279, 0.361806, 7.8608e-05, 0.156099, - 0.000731569, 0.362982, 0.000314615, 0.156053, - 0.00164578, 0.362869, 0.000707845, 0.156093, - 0.0029261, 0.362961, 0.00125884, 0.156099, - 0.00457155, 0.362959, 0.00196783, 0.15612, - 0.00658224, 0.362982, 0.00283622, 0.156168, - 0.00895774, 0.363048, 0.00386625, 0.156221, - 0.0116962, 0.363101, 0.00506109, 0.156324, - 0.0147973, 0.363241, 0.00642675, 0.156476, - 0.0182503, 0.363448, 0.00797175, 0.156731, - 0.0220266, 0.36384, 0.00971484, 0.156994, - 0.026176, 0.364179, 0.0116575, 0.157341, - 0.0306701, 0.36462, 0.0138207, 0.157867, - 0.0354591, 0.365364, 0.0162356, 0.15846, - 0.0406141, 0.366111, 0.0189092, 0.159308, - 0.0460519, 0.367248, 0.021885, 0.160426, - 0.0518096, 0.368767, 0.0252004, 0.161877, - 0.0578906, 0.370745, 0.0288825, 0.163995, - 0.0642812, 0.373831, 0.0330139, 0.16655, - 0.0710067, 0.377366, 0.0376283, 0.170237, - 0.0781522, 0.382799, 0.0428493, 0.175096, - 0.0857172, 0.389915, 0.0487324, 0.181069, - 0.0938025, 0.398487, 0.0554214, 0.188487, - 0.102363, 0.408799, 0.0630189, 0.197029, - 0.111343, 0.419991, 0.071634, 0.206684, - 0.120812, 0.431455, 0.0812797, 0.218698, - 0.131033, 0.445746, 0.0923651, 0.230726, - 0.141373, 0.457471, 0.104545, 0.245516, - 0.152387, 0.472388, 0.118449, 0.261551, - 0.163628, 0.486671, 0.133923, 0.277437, - 0.174814, 0.49762, 0.150849, 0.296662, - 0.186713, 0.51162, 0.169924, 0.31795, - 0.198513, 0.525435, 0.190848, 0.339422, - 0.210119, 0.536267, 0.213504, 0.362143, - 0.221354, 0.545982, 0.237947, 0.387198, - 0.23224, 0.555364, 0.264427, 0.412349, - 0.24257, 0.561489, 0.292519, 0.439274, - 0.252284, 0.566903, 0.322561, 0.466779, - 0.261023, 0.569614, 0.353952, 0.496011, - 0.26899, 0.571589, 0.387278, 0.524964, - 0.275498, 0.570325, 0.421356, 0.556518, - 0.281449, 0.568792, 0.457314, 0.584363, - 0.285526, 0.560268, 0.493199, 0.614214, - 0.28844, 0.55205, 0.530276, 0.645684, - 0.289777, 0.541906, 0.56855, 0.673446, - 0.289722, 0.526464, 0.606927, 0.701924, - 0.287792, 0.509872, 0.645945, 0.73037, - 0.284315, 0.490649, 0.685564, 0.757405, - 0.278804, 0.467964, 0.726511, 0.784025, - 0.269543, 0.441468, 0.768601, 0.808255, - 0.258117, 0.41216, 0.811321, 0.830739, - 0.244728, 0.380606, 0.853496, 0.851914, - 0.229428, 0.348111, 0.895374, 0.872586, - 0.212508, 0.314732, 0.937674, 0.891581, - 0.194025, 0.280338, 0.979869, 0.907641, - 0.174711, 0.245203, 1.02253, 0.922233, - 0.153509, 0.21077, 1.06371, 0.935878, - 0.130418, 0.177399, 1.09972, 0.946338, - 0.105558, 0.144507, 1.13124, 0.957265, - 0.080059, 0.110508, 1.15973, 0.971668, - 0.0539766, 0.0742311, 1.18515, 0.9866, - 0.0277101, 0.0375224, 1.20858, 1.00021, - 0.000515531, 0.000135226, 1.23135, 0.137468, - 6.86011e-06, 0.345041, 2.73315e-06, 0.13703, - 0.000173378, 0.343936, 6.90761e-05, 0.136986, - 0.000693048, 0.34383, 0.000276126, 0.136964, - 0.00155931, 0.343761, 0.000621337, 0.137003, - 0.00277211, 0.343863, 0.00110494, 0.137012, - 0.00433103, 0.343868, 0.00172744, 0.137043, - 0.00623606, 0.343916, 0.00249022, 0.13709, - 0.0084868, 0.343986, 0.00339559, 0.137145, - 0.0110814, 0.344045, 0.00444687, 0.137242, - 0.0140187, 0.344177, 0.00565007, 0.137431, - 0.0172713, 0.344491, 0.00701868, 0.137644, - 0.0208605, 0.344805, 0.00856042, 0.13791, - 0.024792, 0.345172, 0.0102863, 0.138295, - 0.0290461, 0.345734, 0.0122185, 0.138764, - 0.0335957, 0.346371, 0.0143771, 0.139415, - 0.038467, 0.347298, 0.0167894, 0.140272, - 0.0436176, 0.348527, 0.0194895, 0.141457, - 0.0491016, 0.350276, 0.0225043, 0.14303, - 0.0548764, 0.352646, 0.0258962, 0.145289, - 0.0610096, 0.356206, 0.0297168, 0.148502, - 0.0674777, 0.361488, 0.0340562, 0.152188, - 0.074345, 0.367103, 0.0389534, 0.157359, - 0.0817442, 0.375247, 0.0445541, 0.16379, - 0.0896334, 0.385064, 0.0509535, 0.171376, - 0.098005, 0.396082, 0.0582611, 0.179901, - 0.106817, 0.407418, 0.06654, 0.189892, - 0.116239, 0.420031, 0.075994, 0.201838, - 0.12627, 0.434321, 0.0867239, 0.214311, - 0.136701, 0.447631, 0.0987517, 0.228902, - 0.147616, 0.462046, 0.112353, 0.245107, - 0.158871, 0.476942, 0.127605, 0.262292, - 0.170261, 0.490285, 0.144469, 0.281215, - 0.182017, 0.503783, 0.163282, 0.301058, - 0.193729, 0.515505, 0.183873, 0.322752, - 0.205512, 0.52682, 0.206466, 0.347547, - 0.217214, 0.539473, 0.231194, 0.370969, - 0.227966, 0.546625, 0.257288, 0.397533, - 0.238555, 0.55472, 0.285789, 0.42398, - 0.248278, 0.559468, 0.315746, 0.452928, - 0.257422, 0.564095, 0.347724, 0.482121, - 0.265306, 0.565426, 0.380922, 0.510438, - 0.272043, 0.563205, 0.415639, 0.541188, - 0.277614, 0.561087, 0.451702, 0.571667, - 0.281927, 0.554922, 0.48845, 0.602432, - 0.285015, 0.546838, 0.526442, 0.634126, - 0.286512, 0.537415, 0.564896, 0.662816, - 0.286388, 0.522906, 0.604037, 0.692411, - 0.284734, 0.507003, 0.643795, 0.720946, - 0.281297, 0.488398, 0.68298, 0.748293, - 0.276262, 0.466353, 0.723466, 0.776931, - 0.269978, 0.443573, 0.764565, 0.801065, - 0.260305, 0.415279, 0.805838, 0.825843, - 0.247426, 0.384773, 0.849985, 0.84807, - 0.232437, 0.352555, 0.893174, 0.869122, - 0.215806, 0.318642, 0.936564, 0.888963, - 0.197307, 0.28381, 0.980253, 0.905547, - 0.177203, 0.247888, 1.02463, 0.918554, - 0.155542, 0.212904, 1.06714, 0.931395, - 0.131948, 0.1787, 1.10451, 0.941749, - 0.106723, 0.145902, 1.13694, 0.954551, - 0.0804939, 0.111193, 1.1666, 0.970279, - 0.0534239, 0.0744697, 1.19249, 0.986117, - 0.0257452, 0.0368788, 1.21665, 0.999938, 0.00190634, - 0.0010291, 1.23981, 0.118493, - 6.47439e-06, 0.32272, 2.3772e-06, 0.118765, - 0.000163023, 0.323456, 5.98573e-05, 0.118772, - 0.00065212, 0.323477, 0.000239447, 0.118843, - 0.00146741, 0.323657, 0.000538881, 0.118804, - 0.00260846, 0.323553, 0.00095826, 0.118826, - 0.00407576, 0.323595, 0.00149845, 0.118846, - 0.00586826, 0.323617, 0.00216047, 0.118886, - 0.00798578, 0.32367, 0.00294679, 0.118947, - 0.0104273, 0.323753, 0.00386124, 0.119055, - 0.0131909, 0.323922, 0.00490999, 0.119241, - 0.0162444, 0.324251, 0.00610804, 0.11944, - 0.0196339, 0.324544, 0.00745805, 0.119739, - 0.0233378, 0.325026, 0.00897805, 0.12011, - 0.0273179, 0.325586, 0.0106895, 0.120571, - 0.0316143, 0.326231, 0.0126073, 0.12124, - 0.0361939, 0.327264, 0.0147654, 0.122162, - 0.0410511, 0.328733, 0.0172001, 0.123378, - 0.0462233, 0.330659, 0.0199375, 0.125183, - 0.0517109, 0.333754, 0.0230498, 0.127832, - 0.0575652, 0.338507, 0.026597, 0.130909, - 0.0637441, 0.343666, 0.0306345, 0.135221, - 0.0704302, 0.351063, 0.035273, 0.14082, - 0.0776364, 0.360604, 0.0406137, 0.146781, - 0.0852293, 0.369638, 0.0466788, 0.155121, - 0.0935351, 0.3827, 0.0537628, 0.16398, - 0.102234, 0.39522, 0.0617985, 0.173926, - 0.111465, 0.40793, 0.07097, 0.185137, - 0.121296, 0.42105, 0.0813426, 0.19826, - 0.13169, 0.435735, 0.0931596, 0.212938, - 0.142614, 0.450932, 0.106547, 0.229046, - 0.153884, 0.465726, 0.121575, 0.246246, - 0.165382, 0.479461, 0.138286, 0.264637, - 0.176806, 0.492106, 0.15666, 0.284959, - 0.188793, 0.504774, 0.17728, 0.308157, - 0.200763, 0.518805, 0.19988, 0.330951, - 0.21239, 0.528231, 0.224293, 0.3549, - 0.223521, 0.536376, 0.250541, 0.381502, - 0.234169, 0.544846, 0.278902, 0.409529, - 0.244077, 0.551717, 0.309227, 0.437523, - 0.253363, 0.55517, 0.341426, 0.467624, - 0.261659, 0.557772, 0.37518, 0.497268, - 0.268498, 0.556442, 0.41007, 0.528294, - 0.274018, 0.553915, 0.446445, 0.559053, - 0.278169, 0.549153, 0.483779, 0.589329, - 0.281229, 0.539878, 0.522249, 0.622503, - 0.282902, 0.53162, 0.561754, 0.652382, - 0.282815, 0.518119, 0.601544, 0.681847, - 0.281247, 0.502187, 0.641574, 0.712285, - 0.277986, 0.484824, 0.682633, 0.740094, - 0.273017, 0.463483, 0.723426, 0.768478, - 0.266692, 0.441299, 0.763747, 0.794556, - 0.258358, 0.415238, 0.805565, 0.819408, - 0.248807, 0.386912, 0.847254, 0.843411, - 0.236214, 0.356165, 0.891091, 0.862397, - 0.219794, 0.320562, 0.936174, 0.883113, - 0.201768, 0.285322, 0.982562, 0.90023, - 0.181672, 0.249713, 1.02862, 0.915192, - 0.159279, 0.214546, 1.07163, 0.928458, - 0.134725, 0.180285, 1.10995, 0.94069, - 0.10913, 0.147119, 1.14354, 0.953409, - 0.0821315, 0.112492, 1.17372, 0.969537, - 0.0542677, 0.0752014, 1.20043, 0.985612, - 0.0259096, 0.0370361, 1.22528, 0.999835, 0.00298198, - 0.00151801, 1.24959, 0.10097, - 6.02574e-06, 0.300277, 2.02619e-06, 0.101577, - 0.000152164, 0.302077, 5.11662e-05, 0.101572, - 0.000608889, 0.302066, 0.000204751, 0.101566, - 0.00136997, 0.302047, 0.000460753, 0.101592, - 0.00243557, 0.302114, 0.000819497, 0.101608, - 0.0038053, 0.30214, 0.00128154, 0.101627, - 0.00547906, 0.30216, 0.0018483, 0.101669, - 0.00745647, 0.302224, 0.00252223, 0.101732, - 0.00973615, 0.302318, 0.00330716, 0.101844, - 0.0123097, 0.302513, 0.00421061, 0.102025, - 0.0151681, 0.30285, 0.00524481, 0.102224, - 0.0183334, 0.303166, 0.0064154, 0.102515, - 0.0217819, 0.303654, 0.00774063, 0.102886, - 0.0255067, 0.304243, 0.0092398, 0.103395, - 0.029514, 0.305089, 0.0109339, 0.104109, - 0.0337912, 0.306301, 0.0128561, 0.105074, - 0.0383565, 0.30798, 0.0150338, 0.10654, - 0.0432132, 0.310726, 0.0175228, 0.108478, - 0.0484244, 0.314351, 0.0203648, 0.111015, - 0.0539339, 0.319032, 0.0236325, 0.114682, - 0.0598885, 0.32605, 0.0274188, 0.11911, - 0.0663375, 0.334109, 0.0317905, 0.124736, - 0.0733011, 0.344013, 0.0368502, 0.131479, - 0.0807744, 0.355358, 0.0427104, 0.139283, - 0.0888204, 0.367614, 0.0494788, 0.148054, - 0.0973394, 0.380072, 0.0572367, 0.159037, - 0.10665, 0.395678, 0.0662704, 0.169794, - 0.116221, 0.40795, 0.0763192, 0.18314, - 0.126632, 0.423546, 0.087956, 0.197515, - 0.137383, 0.438213, 0.101042, 0.213514, - 0.148641, 0.453248, 0.115827, 0.23065, - 0.160117, 0.46688, 0.132283, 0.249148, - 0.171807, 0.479962, 0.150644, 0.270219, - 0.183695, 0.494618, 0.171073, 0.292338, - 0.195574, 0.506937, 0.193378, 0.314999, - 0.207205, 0.516463, 0.217585, 0.340991, - 0.218955, 0.528123, 0.24428, 0.367982, - 0.229917, 0.537025, 0.272784, 0.39432, - 0.239737, 0.541627, 0.302742, 0.423364, - 0.249048, 0.546466, 0.335112, 0.453751, - 0.257329, 0.549466, 0.369032, 0.48416, - 0.264623, 0.549503, 0.404577, 0.515262, - 0.270411, 0.547008, 0.441337, 0.547036, - 0.274581, 0.542249, 0.479162, 0.576614, - 0.277266, 0.533015, 0.517904, 0.611143, - 0.279144, 0.525512, 0.558508, 0.640989, - 0.279001, 0.51154, 0.598995, 0.671182, - 0.277324, 0.495641, 0.639935, 0.700848, - 0.273908, 0.477526, 0.681017, 0.729862, - 0.269063, 0.457955, 0.722764, 0.758273, - 0.262282, 0.434846, 0.764349, 0.784121, - 0.254281, 0.409203, 0.806206, 0.809798, - 0.24505, 0.382694, 0.848617, 0.834953, - 0.233861, 0.354034, 0.892445, 0.856817, - 0.221308, 0.321764, 0.936263, 0.877609, - 0.205996, 0.288118, 0.982401, 0.897489, - 0.186702, 0.253277, 1.02975, 0.913792, - 0.164618, 0.217963, 1.07488, 0.92785, - 0.140023, 0.183221, 1.11487, 0.940378, - 0.11328, 0.149385, 1.14947, 0.95273, - 0.0853958, 0.114152, 1.1807, 0.969059, - 0.0568698, 0.0769845, 1.20912, 0.985574, - 0.0276502, 0.0381186, 1.23498, 0.999943, 0.00239052, - 0.00126861, 1.25987, 0.0852715, - 5.60067e-06, 0.279021, 1.71162e-06, 0.0854143, - 0.000140871, 0.279483, 4.30516e-05, 0.0854191, - 0.000563385, 0.2795, 0.000172184, 0.0854188, - 0.00126753, 0.279493, 0.000387464, 0.0854229, - 0.00225337, 0.279501, 0.00068918, 0.0854443, - 0.00352086, 0.279549, 0.00107803, 0.0854697, - 0.00506962, 0.279591, 0.00155536, 0.0855093, - 0.00689873, 0.279652, 0.00212354, 0.0855724, - 0.00900821, 0.279752, 0.00278703, 0.0856991, - 0.0113799, 0.280011, 0.0035551, 0.085855, - 0.0140314, 0.280297, 0.00443449, 0.0860682, - 0.016963, 0.280682, 0.00543636, 0.086344, - 0.0201438, 0.281159, 0.0065788, 0.0867426, - 0.0235999, 0.281886, 0.00787977, 0.087239, - 0.0273069, 0.282745, 0.0093606, 0.0879815, - 0.031269, 0.284139, 0.011056, 0.0891258, - 0.035531, 0.28647, 0.0130065, 0.0906909, - 0.0400947, 0.289708, 0.0152495, 0.0927624, - 0.0449638, 0.293904, 0.0178454, 0.0958376, - 0.0502427, 0.300471, 0.0208915, 0.0995827, - 0.0559514, 0.30806, 0.0244247, 0.104526, - 0.0622152, 0.317874, 0.0285721, 0.110532, - 0.0690046, 0.329332, 0.0334227, 0.117385, - 0.0763068, 0.341217, 0.0390466, 0.12522, - 0.084184, 0.353968, 0.0455786, 0.134037, - 0.0925248, 0.366797, 0.0530773, 0.144014, - 0.101487, 0.380209, 0.0617424, 0.156013, - 0.111273, 0.395956, 0.071777, 0.168872, - 0.121431, 0.41053, 0.0830905, 0.183089, - 0.132105, 0.425073, 0.0959341, 0.198763, - 0.143286, 0.439833, 0.110448, 0.216159, - 0.154841, 0.454507, 0.126769, 0.234859, - 0.166588, 0.468368, 0.14495, 0.255879, - 0.178626, 0.482846, 0.165233, 0.27677, - 0.190218, 0.493489, 0.187217, 0.301184, - 0.202227, 0.506549, 0.211659, 0.325852, - 0.213764, 0.5158, 0.237922, 0.352824, - 0.22487, 0.525442, 0.26632, 0.380882, - 0.235246, 0.532487, 0.296691, 0.410137, - 0.244847, 0.537703, 0.329179, 0.439787, - 0.253122, 0.540361, 0.363135, 0.472291, - 0.260517, 0.542734, 0.399222, 0.501856, - 0.266519, 0.538826, 0.436352, 0.534816, - 0.270905, 0.535152, 0.474505, 0.565069, - 0.273826, 0.525979, 0.513988, 0.597154, - 0.275333, 0.516394, 0.554852, 0.630473, - 0.275314, 0.506206, 0.596592, 0.660574, - 0.273323, 0.489769, 0.638117, 0.692015, - 0.270008, 0.472578, 0.680457, 0.720647, - 0.265001, 0.452134, 0.723008, 0.750528, - 0.258311, 0.430344, 0.765954, 0.777568, - 0.250046, 0.405624, 0.809012, 0.80387, - 0.240114, 0.378339, 0.852425, 0.828439, - 0.228737, 0.349877, 0.895346, 0.851472, - 0.216632, 0.318968, 0.940695, 0.873906, - 0.202782, 0.287489, 0.987235, 0.89467, - 0.187059, 0.254394, 1.03348, 0.912281, - 0.168818, 0.221294, 1.07812, 0.927358, - 0.146494, 0.18675, 1.11928, 0.940385, - 0.120009, 0.152322, 1.15609, 0.952672, - 0.0917183, 0.117514, 1.18875, 0.968496, - 0.0620321, 0.0797405, 1.21821, 0.985236, - 0.0314945, 0.0402383, 1.24523, 0.99998, - 0.000575153, 0.000110644, 1.27133, 0.0702429, - 5.12222e-06, 0.255273, 1.40947e-06, 0.0702981, - 0.000128826, 0.255469, 3.54488e-05, 0.0703691, - 0.000515562, 0.255727, 0.000141874, 0.0703805, - 0.00116, 0.255754, 0.00031929, 0.0703961, - 0.00206224, 0.255813, 0.000567999, 0.0704102, - 0.00322223, 0.255839, 0.00088871, 0.0704298, - 0.00463928, 0.255863, 0.00128272, 0.0704759, - 0.00631375, 0.255953, 0.00175283, 0.0705434, - 0.00824317, 0.256079, 0.00230342, 0.0706693, - 0.010412, 0.25636, 0.0029443, 0.0708189, - 0.0128439, 0.256647, 0.00368031, 0.0710364, - 0.0155177, 0.257084, 0.00452614, 0.0713223, - 0.0184374, 0.257637, 0.00549706, 0.0717182, - 0.0216002, 0.258416, 0.00661246, 0.072321, - 0.0249966, 0.259699, 0.00790147, 0.0731446, - 0.0286566, 0.261475, 0.0093884, 0.0743352, - 0.0325888, 0.264132, 0.0111186, 0.0760676, - 0.036843, 0.26815, 0.013145, 0.078454, - 0.0414292, 0.273636, 0.0155251, 0.0818618, - 0.0464634, 0.281653, 0.0183525, 0.0857382, - 0.0519478, 0.289992, 0.0216642, 0.0908131, - 0.0579836, 0.30066, 0.0255956, 0.0967512, - 0.0645124, 0.312204, 0.0301954, 0.103717, - 0.0716505, 0.325001, 0.0356017, 0.111596, - 0.0793232, 0.338129, 0.041896, 0.120933, - 0.087645, 0.352853, 0.0492447, 0.130787, - 0.096492, 0.366192, 0.0576749, 0.142311, - 0.105973, 0.380864, 0.0673969, 0.155344, - 0.116182, 0.396575, 0.0785899, 0.169535, - 0.126815, 0.411443, 0.0912377, 0.185173, - 0.138015, 0.426256, 0.105607, 0.201755, - 0.149325, 0.439607, 0.121551, 0.221334, - 0.161207, 0.455467, 0.139608, 0.241461, - 0.173162, 0.469096, 0.159591, 0.26294, - 0.18504, 0.481014, 0.18156, 0.286776, - 0.196881, 0.493291, 0.205781, 0.311596, - 0.208311, 0.503556, 0.231819, 0.338667, - 0.219671, 0.513268, 0.260274, 0.366021, - 0.230451, 0.519414, 0.290862, 0.395875, - 0.240131, 0.526766, 0.323196, 0.425564, - 0.248566, 0.52905, 0.357071, 0.457094, - 0.256195, 0.530796, 0.393262, 0.488286, - 0.262331, 0.528703, 0.430797, 0.522291, - 0.267141, 0.52727, 0.470231, 0.554172, - 0.270411, 0.519848, 0.510477, 0.586427, - 0.271986, 0.510307, 0.551594, 0.619638, - 0.27192, 0.499158, 0.593849, 0.650656, - 0.269817, 0.483852, 0.636314, 0.68284, - 0.266267, 0.467515, 0.679679, 0.714356, - 0.26113, 0.44931, 0.723884, 0.742717, - 0.254067, 0.425789, 0.767245, 0.770894, - 0.245652, 0.401144, 0.811819, 0.797358, - 0.235554, 0.374224, 0.856315, 0.823377, - 0.223896, 0.346167, 0.901077, 0.847456, - 0.210865, 0.316056, 0.946502, 0.870697, - 0.196574, 0.284503, 0.993711, 0.891068, - 0.180814, 0.251628, 1.04134, 0.909267, - 0.163314, 0.219065, 1.08609, 0.925653, - 0.143304, 0.186446, 1.12702, 0.940017, - 0.121322, 0.153416, 1.16371, 0.952398, - 0.0973872, 0.120334, 1.19712, 0.967568, - 0.0698785, 0.08352, 1.22791, 0.984772, - 0.0390031, 0.0439209, 1.25672, 1.00026, - 0.0070087, 0.00315668, 1.28428, 0.0556653, - 4.59654e-06, 0.227325, 1.12556e-06, 0.0565238, - 0.000116382, 0.230826, 2.84985e-05, 0.0565717, - 0.000465666, 0.231026, 0.000114036, 0.0565859, - 0.00104773, 0.231079, 0.000256656, 0.0565761, - 0.00186255, 0.231025, 0.00045663, 0.0565913, - 0.00291002, 0.231058, 0.000714664, 0.0566108, - 0.00418998, 0.231085, 0.00103224, 0.0566532, - 0.00570206, 0.231169, 0.00141202, 0.0567473, - 0.00743666, 0.231417, 0.00186018, 0.0568567, - 0.00940298, 0.231661, 0.00238264, 0.0569859, - 0.0115991, 0.231895, 0.00298699, 0.0572221, - 0.0140096, 0.232456, 0.00368957, 0.057519, - 0.0166508, 0.233096, 0.00450303, 0.0579534, - 0.01951, 0.234094, 0.00544945, 0.0585922, - 0.0225991, 0.235629, 0.00655564, 0.0595647, - 0.0259416, 0.238106, 0.00785724, 0.0609109, - 0.0295661, 0.241557, 0.00939127, 0.0628751, - 0.0335126, 0.246652, 0.0112198, 0.0656908, - 0.0378604, 0.254091, 0.0134168, 0.0691347, - 0.0426543, 0.262666, 0.0160374, 0.0732165, - 0.0478967, 0.272029, 0.0191514, 0.0782863, - 0.0536716, 0.283007, 0.0228597, 0.0843973, - 0.0600683, 0.295732, 0.0272829, 0.0913598, - 0.0670095, 0.308779, 0.032484, 0.0994407, - 0.0745516, 0.322886, 0.0385886, 0.108189, - 0.082712, 0.336408, 0.0457133, 0.118574, - 0.0914927, 0.351692, 0.0539832, 0.129989, - 0.100854, 0.366502, 0.0635162, 0.142722, - 0.110837, 0.381675, 0.0744386, 0.156654, - 0.121353, 0.3963, 0.0868483, 0.172151, - 0.132414, 0.411477, 0.100963, 0.188712, - 0.143809, 0.42508, 0.116795, 0.208093, - 0.155765, 0.441328, 0.134715, 0.227936, - 0.167608, 0.454328, 0.154396, 0.249495, - 0.179579, 0.467235, 0.176179, 0.27362, - 0.191488, 0.480248, 0.200193, 0.296371, - 0.202618, 0.487886, 0.225775, 0.324234, - 0.214133, 0.499632, 0.25441, 0.353049, - 0.225212, 0.509532, 0.285077, 0.381785, - 0.234875, 0.514265, 0.317047, 0.414038, - 0.244205, 0.521282, 0.351874, 0.445251, - 0.252145, 0.522931, 0.388279, 0.476819, - 0.258433, 0.520947, 0.425825, 0.509209, - 0.263411, 0.517669, 0.465104, 0.542759, - 0.266732, 0.512841, 0.505741, 0.574822, - 0.268263, 0.503317, 0.547611, 0.609324, - 0.268489, 0.493035, 0.590953, 0.641772, - 0.266941, 0.478816, 0.63488, 0.674049, - 0.263297, 0.462863, 0.679072, 0.705071, - 0.257618, 0.442931, 0.723487, 0.734709, - 0.250625, 0.421299, 0.768708, 0.763704, - 0.24179, 0.397085, 0.814375, 0.791818, - 0.231115, 0.370577, 0.859907, 0.817439, - 0.21922, 0.34232, 0.906715, 0.843202, - 0.205658, 0.312627, 0.953943, 0.866639, - 0.190563, 0.280933, 1.00185, 0.888129, - 0.173978, 0.248393, 1.05105, 0.907239, - 0.155485, 0.216007, 1.09704, 0.923893, - 0.134782, 0.183233, 1.13857, 0.938882, - 0.11249, 0.150376, 1.17539, 0.952464, - 0.0890706, 0.117177, 1.20924, 0.968529, - 0.0646523, 0.0813095, 1.24055, 0.984763, - 0.038606, 0.0439378, 1.27018, 1.00053, - 0.01238, 0.00598668, 1.29873, 0.0437928, - 4.09594e-06, 0.204012, 8.79224e-07, 0.0440166, - 0.000103395, 0.205049, 2.21946e-05, 0.0440529, - 0.000413633, 0.205225, 8.87981e-05, 0.0440493, - 0.000930594, 0.2052, 0.000199858, 0.0439884, - 0.00165352, 0.204901, 0.000355495, 0.0440716, - 0.0025849, 0.205255, 0.000556983, 0.0440968, - 0.00372222, 0.205311, 0.000805326, 0.0441359, - 0.00506478, 0.205391, 0.00110333, 0.0442231, - 0.00660384, 0.205638, 0.00145768, 0.0443254, - 0.00835246, 0.205877, 0.00187275, 0.0444832, - 0.0102992, 0.20627, 0.00235938, 0.0447001, - 0.0124449, 0.206796, 0.0029299, 0.0450168, - 0.0147935, 0.207593, 0.0036005, 0.0454816, - 0.017336, 0.208819, 0.00439246, 0.0462446, - 0.0201156, 0.211036, 0.00533864, 0.0473694, - 0.0231568, 0.214388, 0.00646984, 0.0490191, - 0.0264941, 0.219357, 0.00783856, 0.0512776, - 0.030184, 0.226061, 0.00950182, 0.0541279, - 0.0342661, 0.234094, 0.0115156, 0.0578989, - 0.0388539, 0.244297, 0.0139687, 0.0620835, - 0.0438735, 0.254457, 0.0169015, 0.0673497, - 0.04951, 0.266706, 0.0204554, 0.0731759, - 0.0556263, 0.278753, 0.0246606, 0.0803937, - 0.0624585, 0.29309, 0.0297126, 0.0879287, - 0.0697556, 0.305856, 0.0355868, 0.0970669, - 0.0778795, 0.321059, 0.0425768, 0.106508, - 0.0863541, 0.333873, 0.05056, 0.11776, - 0.0955935, 0.349008, 0.0598972, 0.130081, - 0.105438, 0.363776, 0.0706314, 0.144454, - 0.115899, 0.380112, 0.0828822, 0.1596, - 0.126827, 0.394843, 0.0967611, 0.176097, - 0.138161, 0.409033, 0.112381, 0.194726, - 0.149904, 0.424257, 0.129952, 0.213944, - 0.161675, 0.436945, 0.149333, 0.235516, - 0.173659, 0.450176, 0.170892, 0.260564, - 0.185963, 0.466305, 0.194984, 0.285183, - 0.197582, 0.477328, 0.220805, 0.311095, - 0.208697, 0.486566, 0.248694, 0.338924, - 0.219519, 0.494811, 0.279015, 0.369757, - 0.229766, 0.504065, 0.311725, 0.3996, - 0.238879, 0.507909, 0.345844, 0.430484, - 0.246802, 0.509805, 0.381749, 0.46413, - 0.253924, 0.511436, 0.420251, 0.497077, - 0.259319, 0.508787, 0.459957, 0.530434, - 0.263297, 0.50394, 0.501356, 0.565725, - 0.265619, 0.49804, 0.544252, 0.599254, - 0.265842, 0.487346, 0.587856, 0.631251, - 0.263978, 0.472975, 0.631969, 0.663972, - 0.26043, 0.457135, 0.677471, 0.697724, - 0.255358, 0.439844, 0.723744, 0.727725, - 0.248308, 0.417872, 0.770653, 0.756417, - 0.239181, 0.39273, 0.817357, 0.785419, - 0.22814, 0.367839, 0.864221, 0.81266, - 0.215681, 0.339449, 0.912701, 0.839391, - 0.201623, 0.309279, 0.962419, 0.86366, - 0.185624, 0.278029, 1.0122, 0.885028, - 0.16797, 0.245294, 1.06186, 0.904639, - 0.148336, 0.212689, 1.10934, 0.922048, - 0.12637, 0.179616, 1.15063, 0.936952, - 0.102928, 0.146749, 1.18885, 0.951895, - 0.0785268, 0.112733, 1.22352, 0.967198, - 0.0530153, 0.0760056, 1.25681, 0.984405, - 0.02649, 0.0383183, 1.28762, 1.00021, 0.00070019, - 0.00020039, 1.31656, 0.0325964, - 3.55447e-06, 0.176706, 6.55682e-07, 0.0329333, - 8.99174e-05, 0.178527, 1.65869e-05, 0.0329181, - 0.000359637, 0.178453, 6.63498e-05, 0.0329085, - 0.000808991, 0.178383, 0.000149332, 0.0329181, - 0.00143826, 0.178394, 0.000265873, 0.0329425, - 0.00224678, 0.178517, 0.000416597, 0.0329511, - 0.00323575, 0.17849, 0.000603299, 0.033011, - 0.00439875, 0.178695, 0.000829422, 0.0330733, - 0.00574059, 0.178843, 0.00109908, 0.0331857, - 0.00725896, 0.179176, 0.00141933, 0.0333445, - 0.00895289, 0.179618, 0.0017999, 0.0335674, - 0.0108219, 0.180238, 0.00225316, 0.033939, - 0.0128687, 0.181417, 0.00279765, 0.0345239, - 0.015114, 0.183395, 0.0034564, 0.0354458, - 0.017596, 0.186616, 0.00425864, 0.0368313, - 0.0203524, 0.191547, 0.00524936, 0.0386115, - 0.0234105, 0.197508, 0.00647033, 0.0410303, - 0.0268509, 0.205395, 0.00798121, 0.0442245, - 0.0307481, 0.215365, 0.0098557, 0.0478659, - 0.0350863, 0.225595, 0.0121417, 0.0522416, - 0.0399506, 0.236946, 0.0149385, 0.0574513, - 0.045357, 0.249442, 0.0183189, 0.0631208, - 0.0512863, 0.261222, 0.0223644, 0.0701124, - 0.0579273, 0.275418, 0.0272418, 0.0777331, - 0.0650652, 0.288989, 0.0329458, 0.0862709, - 0.0728813, 0.302546, 0.0396819, 0.096103, - 0.081363, 0.317164, 0.04757, 0.106976, - 0.0904463, 0.331733, 0.0567012, 0.119175, - 0.100105, 0.34661, 0.067202, 0.132919, - 0.110375, 0.362249, 0.0792588, 0.147727, - 0.121115, 0.376978, 0.0928672, 0.163618, - 0.132299, 0.390681, 0.108228, 0.182234, - 0.143887, 0.406571, 0.125502, 0.201809, - 0.155827, 0.42042, 0.144836, 0.225041, - 0.168357, 0.438411, 0.166706, 0.247621, - 0.18004, 0.450368, 0.189909, 0.27097, - 0.191536, 0.460083, 0.215251, 0.296658, - 0.203024, 0.469765, 0.243164, 0.325892, - 0.214056, 0.481837, 0.273388, 0.35406, - 0.224104, 0.487474, 0.305344, 0.384372, - 0.233489, 0.492773, 0.339741, 0.41749, - 0.241874, 0.498451, 0.376287, 0.45013, - 0.248834, 0.499632, 0.414195, 0.481285, - 0.254658, 0.495233, 0.454077, 0.519183, - 0.259367, 0.496401, 0.496352, 0.551544, - 0.261818, 0.487686, 0.538798, 0.587349, - 0.262964, 0.479453, 0.583626, 0.621679, - 0.262128, 0.467709, 0.629451, 0.654991, - 0.258998, 0.452123, 0.67566, 0.686873, - 0.254119, 0.433495, 0.723248, 0.719801, - 0.246946, 0.413657, 0.771156, 0.750355, - 0.237709, 0.390366, 0.81989, 0.780033, - 0.226549, 0.364947, 0.868601, 0.809254, - 0.214186, 0.337256, 0.920034, 0.836576, - 0.199639, 0.307395, 0.971706, 0.861774, - 0.183169, 0.275431, 1.02479, 0.885707, - 0.165111, 0.243431, 1.07837, 0.904742, - 0.144363, 0.210921, 1.12783, 0.915604, - 0.121305, 0.17647, 1.17254, 0.930959, - 0.0962119, 0.143106, 1.21012, 0.948404, - 0.069969, 0.108112, 1.24474, 0.967012, - 0.0427586, 0.0708478, 1.27718, 0.984183, - 0.0147043, 0.032335, 1.3083, 0.999577, 0.0142165, - 0.00726867, 1.3382, 0.0229227, - 2.99799e-06, 0.148623, 4.62391e-07, 0.0232194, - 7.58796e-05, 0.15054, 1.17033e-05, 0.0232315, - 0.000303636, 0.15063, 4.68397e-05, 0.0232354, - 0.000683189, 0.150624, 0.000105472, 0.0232092, - 0.0012136, 0.150445, 0.000187744, 0.0232523, - 0.00189765, 0.150679, 0.000294847, 0.0232828, - 0.00273247, 0.150789, 0.000428013, 0.0233371, - 0.00371287, 0.150995, 0.000591134, 0.0234015, - 0.00484794, 0.15118, 0.000787642, 0.023514, - 0.00612877, 0.151562, 0.00102547, 0.023679, - 0.00756125, 0.152116, 0.00131351, 0.0239559, - 0.00914651, 0.153162, 0.00166594, 0.0244334, - 0.010904, 0.155133, 0.00210182, 0.025139, - 0.0128615, 0.158035, 0.00264406, 0.0262598, - 0.0150628, 0.162751, 0.00332923, 0.0277875, - 0.0175532, 0.168944, 0.00419773, 0.0298472, - 0.0203981, 0.176835, 0.00530034, 0.0325444, - 0.023655, 0.186686, 0.00669777, 0.0355581, - 0.0272982, 0.196248, 0.00842661, 0.0392841, - 0.0314457, 0.207352, 0.0105854, 0.0436815, - 0.0361157, 0.219279, 0.0132458, 0.0485272, - 0.0412932, 0.230728, 0.0164736, 0.0541574, - 0.0470337, 0.242994, 0.0203715, 0.0609479, - 0.0535002, 0.257042, 0.0250953, 0.0685228, - 0.0605409, 0.27102, 0.0306856, 0.0768042, - 0.0680553, 0.28406, 0.037193, 0.0864844, - 0.0765011, 0.299186, 0.0449795, 0.0969415, - 0.0852674, 0.3132, 0.0538316, 0.108478, - 0.0947333, 0.327138, 0.0641149, 0.121705, - 0.10481, 0.342345, 0.0759185, 0.136743, - 0.115474, 0.358472, 0.0894116, 0.152986, - 0.126536, 0.374067, 0.104562, 0.170397, - 0.138061, 0.388267, 0.121632, 0.191392, - 0.150203, 0.406467, 0.140996, 0.211566, - 0.161751, 0.418641, 0.161696, 0.233567, - 0.173407, 0.430418, 0.184557, 0.257769, - 0.185397, 0.44277, 0.210092, 0.28531, - 0.197048, 0.457191, 0.237827, 0.311726, - 0.20784, 0.464712, 0.267253, 0.340537, - 0.218345, 0.472539, 0.299332, 0.372921, - 0.228306, 0.482331, 0.333988, 0.402924, - 0.236665, 0.484378, 0.369722, 0.434475, - 0.244097, 0.484717, 0.407836, 0.469736, - 0.250547, 0.487093, 0.448465, 0.505045, - 0.25511, 0.485575, 0.490263, 0.540262, - 0.258444, 0.481225, 0.534495, 0.576347, - 0.259903, 0.473481, 0.579451, 0.608656, - 0.259572, 0.4603, 0.625604, 0.646679, - 0.257908, 0.450341, 0.674511, 0.679902, - 0.253663, 0.431561, 0.723269, 0.714159, - 0.247419, 0.412684, 0.773263, 0.745345, - 0.239122, 0.389388, 0.824182, 0.778248, - 0.228837, 0.365361, 0.876634, 0.807208, - 0.216197, 0.337667, 0.92945, 0.835019, - 0.201772, 0.307197, 0.985261, 0.860261, - 0.185291, 0.274205, 1.04299, 0.877601, - 0.165809, 0.240178, 1.09816, 0.898211, - 0.143897, 0.207571, 1.14694, 0.915789, - 0.119513, 0.174904, 1.19008, 0.931831, - 0.0932919, 0.141423, 1.2297, 0.949244, - 0.0656528, 0.105603, 1.26553, 0.967527, - 0.0370262, 0.0679551, 1.29986, 0.984139, - 0.00730117, 0.0283133, 1.33252, 0.999713, 0.0234648, - 0.0121785, 1.36397, 0.0152135, - 2.45447e-06, 0.122795, 3.04092e-07, 0.0151652, - 6.15778e-05, 0.122399, 7.6292e-06, 0.0151181, - 0.000245948, 0.122023, 3.04802e-05, 0.0151203, - 0.000553394, 0.12203, 6.86634e-05, 0.015125, - 0.000983841, 0.122037, 0.000122463, 0.0151427, - 0.00153774, 0.12214, 0.000192706, 0.0151708, - 0.0022103, 0.122237, 0.000281219, 0.0152115, - 0.00300741, 0.12238, 0.000390804, 0.0152877, - 0.00392494, 0.1227, 0.000526317, 0.015412, - 0.00496597, 0.123244, 0.00069443, 0.0156201, - 0.00613314, 0.124228, 0.00090547, 0.0159658, - 0.00744113, 0.125945, 0.0011732, 0.0165674, - 0.00892546, 0.129098, 0.00151888, 0.017487, - 0.010627, 0.133865, 0.00197007, 0.018839, - 0.0126043, 0.140682, 0.0025637, 0.020554, - 0.0148814, 0.148534, 0.00333637, 0.0226727, - 0.0175123, 0.157381, 0.00433738, 0.0251879, - 0.0205266, 0.166685, 0.00561664, 0.0283635, - 0.0240319, 0.177796, 0.00725563, 0.0318694, - 0.0279432, 0.188251, 0.00928811, 0.0361044, - 0.0324313, 0.200038, 0.011835, 0.0406656, - 0.0373527, 0.210685, 0.0149146, 0.0463846, - 0.0430132, 0.224182, 0.0187254, 0.0525696, - 0.0491013, 0.23634, 0.0232283, 0.0598083, - 0.0559175, 0.250013, 0.0286521, 0.0679437, - 0.0633657, 0.263981, 0.0350634, 0.0771181, - 0.0714602, 0.278072, 0.0425882, 0.0881273, - 0.0803502, 0.29511, 0.0514487, 0.0996628, - 0.0896903, 0.309976, 0.0615766, 0.112702, - 0.099644, 0.325611, 0.0732139, 0.126488, - 0.109829, 0.339321, 0.0862324, 0.142625, - 0.120859, 0.35574, 0.101275, 0.15953, - 0.131956, 0.369845, 0.117892, 0.176991, - 0.143145, 0.38146, 0.136205, 0.199715, - 0.155292, 0.40052, 0.157252, 0.220787, - 0.167066, 0.412055, 0.179966, 0.243697, - 0.178396, 0.423133, 0.204418, 0.272106, - 0.190433, 0.439524, 0.232141, 0.297637, - 0.201265, 0.447041, 0.261109, 0.325273, - 0.211834, 0.454488, 0.292627, 0.357219, - 0.221889, 0.465004, 0.326669, 0.387362, - 0.230729, 0.468527, 0.362426, 0.423131, - 0.23924, 0.475836, 0.401533, 0.45543, - 0.246067, 0.475017, 0.441902, 0.493393, - 0.251557, 0.478017, 0.484239, 0.526253, - 0.255571, 0.4709, 0.528586, 0.560554, - 0.257752, 0.463167, 0.574346, 0.599306, - 0.258076, 0.456452, 0.621655, 0.634541, - 0.256471, 0.443725, 0.670492, 0.668907, - 0.253283, 0.428719, 0.721943, 0.705619, - 0.247562, 0.411348, 0.772477, 0.739034, - 0.240626, 0.388939, 0.8264, 0.771408, - 0.231493, 0.36425, 0.881702, 0.803312, - 0.220125, 0.337321, 0.9385, 0.828457, - 0.206645, 0.305364, 0.997437, 0.854819, - 0.190664, 0.273715, 1.05693, 0.878666, - 0.171429, 0.242218, 1.11251, 0.898404, - 0.149235, 0.209556, 1.16398, 0.917416, - 0.12435, 0.176863, 1.21014, 0.933133, - 0.0972703, 0.142775, 1.25178, 0.95066, - 0.0683607, 0.106735, 1.29028, 0.968589, - 0.0378724, 0.0681609, 1.32703, 0.984776, - 0.00605712, 0.0273966, 1.36158, 0.99994, 0.0263276, - 0.0138124, 1.3943, 0.00867437, - 1.86005e-06, 0.0928979, 1.73682e-07, 0.00864003, - 4.66389e-05, 0.0925237, 4.35505e-06, 0.00864593, - 0.000186594, 0.0925806, 1.74322e-05, 0.00864095, - 0.000419639, 0.0924903, 3.92862e-05, 0.00863851, - 0.000746272, 0.0924589, 7.02598e-05, 0.00868531, - 0.00116456, 0.0929, 0.000111188, 0.00869667, - 0.00167711, 0.0928529, 0.000163867, 0.00874332, - 0.00228051, 0.0930914, 0.00023104, 0.00882709, - 0.00297864, 0.0935679, 0.00031741, 0.00898874, - 0.00377557, 0.0946165, 0.000430186, 0.00929346, - 0.00469247, 0.0967406, 0.000580383, 0.00978271, - 0.00575491, 0.100084, 0.000783529, 0.0105746, - 0.00701514, 0.105447, 0.00106304, 0.0116949, - 0.00851797, 0.112494, 0.00144685, 0.0130419, - 0.0102757, 0.119876, 0.00196439, 0.0148375, - 0.012381, 0.129034, 0.00266433, 0.0168725, - 0.01482, 0.137812, 0.00358364, 0.0193689, - 0.0176563, 0.147696, 0.00478132, 0.0222691, - 0.0209211, 0.157795, 0.00631721, 0.0256891, - 0.0246655, 0.168431, 0.00826346, 0.0294686, - 0.0288597, 0.178587, 0.0106714, 0.0340412, - 0.0336441, 0.190251, 0.0136629, 0.0393918, - 0.039033, 0.202999, 0.0173272, 0.0453947, - 0.0450087, 0.215655, 0.0217448, 0.0521936, - 0.0515461, 0.228686, 0.0269941, 0.0600279, - 0.058817, 0.242838, 0.033272, 0.0692398, - 0.0667228, 0.258145, 0.0406457, 0.0793832, - 0.0752401, 0.273565, 0.0492239, 0.0902297, - 0.0841851, 0.287735, 0.0590105, 0.102014, - 0.0936479, 0.301161, 0.0702021, 0.116054, - 0.103967, 0.317438, 0.0832001, 0.13191, - 0.114622, 0.334166, 0.0977951, 0.148239, - 0.125452, 0.348192, 0.113985, 0.165809, - 0.136453, 0.361094, 0.131928, 0.184616, - 0.147648, 0.373534, 0.151811, 0.207491, - 0.159607, 0.39101, 0.174476, 0.230106, - 0.171119, 0.402504, 0.198798, 0.257036, - 0.182906, 0.418032, 0.225796, 0.281172, - 0.193605, 0.425468, 0.254027, 0.312034, - 0.204771, 0.440379, 0.285713, 0.340402, - 0.214988, 0.445406, 0.319196, 0.370231, - 0.224711, 0.44968, 0.35537, 0.407105, - 0.233516, 0.460747, 0.393838, 0.439037, - 0.240801, 0.460624, 0.433747, 0.47781, - 0.24762, 0.465957, 0.477234, 0.510655, - 0.251823, 0.460054, 0.52044, 0.550584, - 0.255552, 0.459172, 0.567853, 0.585872, - 0.257036, 0.450311, 0.615943, 0.620466, - 0.257535, 0.437763, 0.667693, 0.660496, - 0.255248, 0.426639, 0.718988, 0.695578, - 0.251141, 0.409185, 0.772503, 0.732176, - 0.244718, 0.39015, 0.827023, 0.760782, - 0.236782, 0.362594, 0.885651, 0.79422, - 0.225923, 0.33711, 0.943756, 0.824521, - 0.213855, 0.308272, 1.00874, 0.854964, - 0.197723, 0.278529, 1.06764, 0.878065, - 0.179209, 0.246208, 1.12836, 0.899834, - 0.157569, 0.21329, 1.18318, 0.918815, - 0.133206, 0.181038, 1.23161, 0.934934, - 0.106545, 0.146993, 1.27644, 0.952115, - 0.0780574, 0.111175, 1.31842, 0.96906, - 0.0478279, 0.0728553, 1.35839, 0.985178, - 0.0160014, 0.032579, 1.39697, 1.00039, 0.0173126, - 0.0095256, 1.43312, 0.00384146, - 1.24311e-06, 0.0613583, 7.78271e-08, 0.00390023, - 3.14043e-05, 0.0622919, 1.96626e-06, 0.00389971, - 0.000125622, 0.0622632, 7.87379e-06, 0.00389491, - 0.000282352, 0.0620659, 1.778e-05, 0.00391618, - 0.000502512, 0.0624687, 3.20918e-05, 0.00392662, - 0.000784458, 0.0625113, 5.15573e-05, 0.00396053, - 0.00112907, 0.0628175, 7.78668e-05, 0.00401911, - 0.00153821, 0.0633286, 0.000113811, 0.00414994, - 0.0020208, 0.0646443, 0.00016445, 0.00441223, - 0.00260007, 0.0673886, 0.000237734, 0.00484427, - 0.0033097, 0.0716528, 0.000345929, 0.00549109, - 0.00418966, 0.0774998, 0.000505987, 0.00636293, - 0.00527331, 0.0844758, 0.000739208, 0.00746566, - 0.00660428, 0.0921325, 0.00107347, 0.00876625, - 0.00818826, 0.0997067, 0.00153691, 0.0103125, - 0.0100811, 0.107433, 0.00217153, 0.0123309, - 0.0123643, 0.117088, 0.00303427, 0.0146274, - 0.0150007, 0.126438, 0.00416018, 0.0172295, - 0.0180531, 0.135672, 0.00561513, 0.0204248, - 0.0215962, 0.146244, 0.007478, 0.0241597, - 0.0256234, 0.157481, 0.00981046, 0.0284693, - 0.0302209, 0.169125, 0.0127148, 0.033445, - 0.0353333, 0.181659, 0.0162453, 0.0391251, - 0.0410845, 0.1944, 0.0205417, 0.0454721, - 0.0473451, 0.207082, 0.0256333, 0.0530983, - 0.0542858, 0.221656, 0.0317036, 0.0615356, - 0.0618384, 0.236036, 0.0388319, 0.0703363, - 0.0697631, 0.248398, 0.046974, 0.0810391, - 0.0784757, 0.263611, 0.0565246, 0.0920144, - 0.0873488, 0.275857, 0.0671724, 0.105584, - 0.0973652, 0.292555, 0.0798105, 0.119506, - 0.107271, 0.306333, 0.0935945, 0.134434, - 0.117608, 0.318888, 0.109106, 0.153399, - 0.128938, 0.337552, 0.127074, 0.171258, - 0.139944, 0.349955, 0.14643, 0.191059, - 0.151288, 0.361545, 0.168, 0.215069, - 0.163018, 0.378421, 0.192082, 0.237838, - 0.174226, 0.38879, 0.217838, 0.266965, - 0.186063, 0.405857, 0.246931, 0.292827, - 0.196909, 0.414146, 0.277505, 0.324352, - 0.207473, 0.426955, 0.310711, 0.354427, - 0.217713, 0.433429, 0.346794, 0.389854, - 0.227183, 0.443966, 0.385237, 0.420749, - 0.235131, 0.44471, 0.424955, 0.459597, - 0.242786, 0.451729, 0.468446, 0.495316, - 0.248767, 0.45072, 0.513422, 0.534903, - 0.253351, 0.450924, 0.560618, 0.572369, - 0.256277, 0.445266, 0.609677, 0.612383, - 0.2576, 0.438798, 0.660995, 0.644037, - 0.256931, 0.421693, 0.713807, 0.686749, - 0.254036, 0.4109, 0.767616, 0.719814, - 0.249785, 0.390151, 0.82533, 0.754719, - 0.244283, 0.367847, 0.888311, 0.792022, - 0.235076, 0.345013, 0.948177, 0.822404, - 0.225061, 0.316193, 1.01661, 0.853084, - 0.211113, 0.287013, 1.08075, 0.879871, - 0.19449, 0.255424, 1.14501, 0.901655, - 0.174023, 0.222879, 1.20203, 0.919957, - 0.1509, 0.18989, 1.25698, 0.938412, - 0.124923, 0.15606, 1.30588, 0.953471, - 0.0968139, 0.120512, 1.3529, 0.970451, - 0.066734, 0.0828515, 1.3986, 0.985522, - 0.034734, 0.0424458, 1.44148, 1.00099, - 0.00102222, 0.000678929, 1.48398, 0.000965494, - 6.27338e-07, 0.0306409, 1.97672e-08, 0.00099168, - 1.58573e-05, 0.0314638, 4.99803e-07, 0.000991068, - 6.34012e-05, 0.031363, 2.00682e-06, 0.000974567, - 0.00014144, 0.03036, 4.57312e-06, 0.000998079, - 0.000252812, 0.031496, 8.60131e-06, 0.00102243, - 0.000396506, 0.0319955, 1.48288e-05, 0.00107877, - 0.000577593, 0.0331376, 2.49141e-05, 0.00121622, - 0.000816816, 0.0359396, 4.23011e-05, 0.0014455, - 0.00113761, 0.0399652, 7.24613e-05, 0.00178791, - 0.00156959, 0.0450556, 0.000123929, 0.00225668, - 0.00214064, 0.0508025, 0.000208531, 0.00285627, - 0.00287655, 0.0568443, 0.000341969, 0.0035991, - 0.00380271, 0.0630892, 0.000544158, 0.00455524, - 0.00496264, 0.0702204, 0.000842423, 0.00569143, - 0.0063793, 0.0773426, 0.00126704, 0.00716928, - 0.00813531, 0.0860839, 0.00186642, 0.00885307, - 0.0101946, 0.0944079, 0.00267014, 0.0109316, - 0.0126386, 0.103951, 0.00374033, 0.0133704, - 0.0154876, 0.113786, 0.0051304, 0.0161525, - 0.0187317, 0.123477, 0.00688858, 0.0194267, - 0.0224652, 0.133986, 0.00910557, 0.0230967, - 0.0265976, 0.143979, 0.0118074, 0.0273627, - 0.0312848, 0.154645, 0.0151266, 0.0323898, - 0.0365949, 0.166765, 0.0191791, 0.0379225, - 0.0422914, 0.177932, 0.0239236, 0.0447501, - 0.0487469, 0.19167, 0.0296568, 0.0519391, - 0.0556398, 0.203224, 0.0362924, 0.0599464, - 0.0631646, 0.215652, 0.0440585, 0.0702427, - 0.0714308, 0.232089, 0.0531619, 0.0806902, - 0.0800605, 0.245258, 0.0634564, 0.0923194, - 0.0892815, 0.258609, 0.0752481, 0.106938, - 0.09931, 0.276654, 0.0888914, 0.121238, - 0.109575, 0.289847, 0.104055, 0.138817, - 0.120461, 0.307566, 0.121266, 0.15595, - 0.131209, 0.320117, 0.139944, 0.178418, - 0.143049, 0.339677, 0.161591, 0.197875, - 0.154074, 0.349886, 0.184303, 0.224368, - 0.166307, 0.369352, 0.210669, 0.252213, - 0.178051, 0.386242, 0.238895, 0.277321, - 0.189335, 0.395294, 0.269182, 0.310332, - 0.200683, 0.412148, 0.302508, 0.338809, - 0.210856, 0.418266, 0.337264, 0.372678, - 0.220655, 0.428723, 0.374881, 0.405632, - 0.230053, 0.433887, 0.415656, 0.442293, - 0.237993, 0.439911, 0.457982, 0.477256, - 0.244897, 0.440175, 0.502831, 0.515592, - 0.250657, 0.441079, 0.550277, 0.550969, - 0.255459, 0.435219, 0.601102, 0.592883, - 0.257696, 0.432882, 0.651785, 0.629092, - 0.259894, 0.421054, 0.708961, 0.672033, - 0.258592, 0.41177, 0.763806, 0.709147, - 0.256525, 0.395267, 0.824249, 0.745367, - 0.254677, 0.375013, 0.8951, 0.784715, - 0.247892, 0.353906, 0.959317, 0.818107, - 0.240162, 0.327801, 1.03153, 0.847895, - 0.229741, 0.298821, 1.10601, 0.879603, - 0.213084, 0.269115, 1.164, 0.902605, - 0.195242, 0.236606, 1.22854, 0.922788, - 0.174505, 0.203442, 1.29017, 0.944831, - 0.150169, 0.169594, 1.34157, 0.959656, - 0.124099, 0.135909, 1.3956, 0.972399, - 0.0960626, 0.0990563, 1.45128, 0.986549, - 0.0657097, 0.0602348, 1.50312, 1.00013, - 0.0333558, 0.0186694, 1.55364, 6.19747e-06, - 1e-07, 0.00778326, 7.96756e-11, 2.37499e-08, - 9.99999e-08, 2.82592e-05, 1.14596e-10, 1.00292e-06, - 1.66369e-06, 0.000250354, 6.77492e-09, 3.50752e-06, - 6.37769e-06, 0.000357289, 6.31655e-08, 8.26445e-06, - 1.74689e-05, 0.000516179, 3.1851e-07, 2.42481e-05, - 4.50868e-05, 0.0010223, 1.30577e-06, 4.55631e-05, - 8.9044e-05, 0.00144302, 3.74587e-06, 9.71222e-05, - 0.000178311, 0.00241912, 1.02584e-05, 0.000171403, - 0.000313976, 0.00354938, 2.36481e-05, 0.000292747, - 0.000520026, 0.00513765, 4.96014e-05, 0.000789827, - 0.00118187, 0.0238621, 0.000139056, 0.00114093, - 0.00171827, 0.0286691, 0.000244093, 0.00176119, - 0.00249667, 0.0368565, 0.000420623, 0.0022233, - 0.00333742, 0.0400469, 0.00065673, 0.00343382, - 0.00481976, 0.0535751, 0.00109323, 0.00427602, - 0.00600755, 0.057099, 0.00155268, 0.00461435, - 0.00737637, 0.0551084, 0.00215031, 0.00695698, - 0.00971401, 0.0715767, 0.00316529, 0.00867619, - 0.0120943, 0.0793314, 0.00436995, 0.0106694, - 0.0148202, 0.0869391, 0.0058959, 0.0140351, - 0.0183501, 0.101572, 0.00798757, 0.0168939, - 0.022006, 0.11018, 0.0104233, 0.020197, - 0.0261568, 0.119041, 0.0134167, 0.0254702, - 0.0312778, 0.135404, 0.0173009, 0.0298384, - 0.0362469, 0.1437, 0.0215428, 0.035159, - 0.042237, 0.15512, 0.0268882, 0.0427685, - 0.0488711, 0.17128, 0.033235, 0.0494848, - 0.0557997, 0.181813, 0.0404443, 0.0592394, - 0.0635578, 0.198745, 0.0490043, 0.0681463, - 0.071838, 0.210497, 0.0588239, 0.0804753, - 0.0809297, 0.228864, 0.0702835, 0.0942205, - 0.0906488, 0.247008, 0.0834012, 0.106777, - 0.100216, 0.258812, 0.0975952, 0.124471, - 0.110827, 0.278617, 0.114162, 0.138389, - 0.121193, 0.287049, 0.131983, 0.159543, - 0.13253, 0.307151, 0.152541, 0.176432, - 0.143611, 0.31564, 0.174673, 0.201723, - 0.15548, 0.33538, 0.199842, 0.229721, - 0.167166, 0.355256, 0.227097, 0.250206, - 0.178238, 0.360047, 0.256014, 0.282118, - 0.189905, 0.378761, 0.28855, 0.312821, - 0.201033, 0.39181, 0.323348, 0.341482, - 0.211584, 0.397716, 0.360564, 0.377368, - 0.221314, 0.410141, 0.400004, 0.418229, - 0.230474, 0.423485, 0.442371, 0.444881, - 0.239443, 0.418874, 0.488796, 0.488899, - 0.245987, 0.427545, 0.535012, 0.520317, - 0.253948, 0.422147, 0.589678, 0.568566, - 0.256616, 0.42719, 0.637683, 0.599607, - 0.26376, 0.415114, 0.703363, 0.64222, - 0.268687, 0.408715, 0.771363, 0.685698, - 0.2694, 0.399722, 0.83574, 0.732327, - 0.266642, 0.388651, 0.897764, 0.769873, - 0.267712, 0.369198, 0.983312, 0.806733, - 0.263479, 0.346802, 1.06222, 0.843466, - 0.254575, 0.321368, 1.13477, 0.873008, - 0.242749, 0.29211, 1.20712, 0.908438, - 0.22725, 0.262143, 1.27465, 0.936321, - 0.207621, 0.228876, 1.33203, 0.950353, - 0.187932, 0.19484, 1.40439, 0.96442, - 0.165154, 0.163178, 1.4732, 0.979856, - 0.139302, 0.127531, 1.53574, 0.982561, - 0.11134, 0.0903457, 1.59982, 0.996389, - 0.0808124, 0.0489007, 1.6577 ];    const LTC_MAT_2 = [ 1, 0, 0, 0, 1, 7.91421e-31, 0, 0, 1, 1.04392e-24, 0, 0, 1, 3.49405e-21, 0, 0, 1, 1.09923e-18, 0, 0, 1, 9.47414e-17, 0, 0, 1, 3.59627e-15, 0, 0, 1, 7.72053e-14, 0, 0, 1, 1.08799e-12, 0, 0, 1, 1.10655e-11, 0, 0, 1, 8.65818e-11, 0, 0, 0.999998, 5.45037e-10, 0, 0, 0.999994, 2.85095e-09, 0, 0, 0.999989, 1.26931e-08, 0, 0, 0.999973, 4.89938e-08, 0, 0, 0.999947, 1.66347e-07, 0, 0, 0.999894, 5.02694e-07, 0, 0, 0.999798, 1.36532e-06, 0, 0, 0.999617, 3.35898e-06, 0, 0, 0.999234, 7.52126e-06, 0, 0, 0.998258, 1.52586e-05, 0, 0, 0.99504, 2.66207e-05, 0, 0, 0.980816, 2.36802e-05, 0, 0, 0.967553, 2.07684e-06, 0, 0, 0.966877, 4.03733e-06, 0, 0, 0.965752, 7.41174e-06, 0, 0, 0.96382, 1.27746e-05, 0, 0, 0.960306, 2.02792e-05, 0, 0, 0.953619, 2.80232e-05, 0, 0, 0.941103, 2.78816e-05, 0, 0, 0.926619, 1.60221e-05, 0, 0, 0.920983, 2.35164e-05, 0, 0, 0.912293, 3.11924e-05, 0, 0.0158731, 0.899277, 3.48118e-05, 0, 0.0476191, 0.880884, 2.6041e-05, 0, 0.0793651, 0.870399, 3.38726e-05, 0, 0.111111, 0.856138, 3.92906e-05, 0, 0.142857, 0.837436, 3.72874e-05, 0, 0.174603, 0.820973, 3.92558e-05, 0, 0.206349, 0.803583, 4.34658e-05, 0, 0.238095, 0.782168, 4.0256e-05, 0, 0.269841, 0.764107, 4.48159e-05, 0, 0.301587, 0.743092, 4.57627e-05, 0, 0.333333, 0.721626, 4.55314e-05, 0, 0.365079, 0.700375, 4.77335e-05, 0, 0.396825, 0.677334, 4.61072e-05, 0, 0.428571, 0.655702, 4.84393e-05, 0, 0.460317, 0.632059, 4.64583e-05, 0, 0.492064, 0.610125, 4.83923e-05, 0, 0.52381, 0.58653, 4.64342e-05, 0, 0.555556, 0.564508, 4.77033e-05, 0, 0.587302, 0.541405, 4.59263e-05, 0, 0.619048, 0.519556, 4.6412e-05, 0, 0.650794, 0.497292, 4.48913e-05, 0, 0.68254, 0.475898, 4.45789e-05, 0, 0.714286, 0.454722, 4.33496e-05, 0, 0.746032, 0.434042, 4.23054e-05, 0, 0.777778, 0.414126, 4.13737e-05, 0, 0.809524, 0.394387, 3.97265e-05, 0, 0.84127, 0.375841, 3.90709e-05, 0, 0.873016, 0.357219, 3.69938e-05, 0, 0.904762, 0.340084, 3.65618e-05, 0, 0.936508, 0.322714, 3.42533e-05, 0, 0.968254, 0.306974, 3.39596e-05, 0, 1, 1, 1.01524e-18, 0, 0, 1, 1.0292e-18, 0, 0, 1, 1.30908e-18, 0, 0, 1, 4.73331e-18, 0, 0, 1, 6.25319e-17, 0, 0, 1, 1.07932e-15, 0, 0, 1, 1.63779e-14, 0, 0, 1, 2.03198e-13, 0, 0, 1, 2.04717e-12, 0, 0, 0.999999, 1.68995e-11, 0, 0, 0.999998, 1.15855e-10, 0, 0, 0.999996, 6.6947e-10, 0, 0, 0.999991, 3.30863e-09, 0, 0, 0.999983, 1.41737e-08, 0, 0, 0.999968, 5.32626e-08, 0, 0, 0.99994, 1.77431e-07, 0, 0, 0.999891, 5.28835e-07, 0, 0, 0.999797, 1.42169e-06, 0, 0, 0.999617, 3.47057e-06, 0, 0, 0.999227, 7.7231e-06, 0, 0, 0.998239, 1.55753e-05, 0, 0, 0.994937, 2.68495e-05, 0, 0, 0.980225, 2.13742e-05, 0, 0, 0.967549, 2.1631e-06, 0, 0, 0.966865, 4.17989e-06, 0, 0, 0.965739, 7.63341e-06, 0, 0, 0.963794, 1.30892e-05, 0, 0, 0.960244, 2.06456e-05, 0, 0, 0.953495, 2.82016e-05, 0, 0.000148105, 0.940876, 2.71581e-05, 0, 0.002454, 0.926569, 1.64159e-05, 0, 0.00867491, 0.920905, 2.39521e-05, 0, 0.01956, 0.912169, 3.15127e-05, 0, 0.035433, 0.899095, 3.46626e-05, 0, 0.056294, 0.882209, 2.90223e-05, 0, 0.0818191, 0.870272, 3.42992e-05, 0, 0.111259, 0.855977, 3.94164e-05, 0, 0.142857, 0.837431, 3.72343e-05, 0, 0.174603, 0.820826, 3.96691e-05, 0, 0.206349, 0.803408, 4.35395e-05, 0, 0.238095, 0.782838, 4.19579e-05, 0, 0.269841, 0.763941, 4.50953e-05, 0, 0.301587, 0.742904, 4.55847e-05, 0, 0.333333, 0.721463, 4.58833e-05, 0, 0.365079, 0.700197, 4.77159e-05, 0, 0.396825, 0.677501, 4.70641e-05, 0, 0.428571, 0.655527, 4.84732e-05, 0, 0.460317, 0.6324, 4.76834e-05, 0, 0.492064, 0.609964, 4.84213e-05, 0, 0.52381, 0.586839, 4.75541e-05, 0, 0.555556, 0.564353, 4.76951e-05, 0, 0.587302, 0.541589, 4.67611e-05, 0, 0.619048, 0.519413, 4.63493e-05, 0, 0.650794, 0.497337, 4.53994e-05, 0, 0.68254, 0.475797, 4.45308e-05, 0, 0.714286, 0.454659, 4.35787e-05, 0, 0.746032, 0.434065, 4.24839e-05, 0, 0.777778, 0.414018, 4.1436e-05, 0, 0.809524, 0.39455, 4.01902e-05, 0, 0.84127, 0.375742, 3.90813e-05, 0, 0.873016, 0.357501, 3.77116e-05, 0, 0.904762, 0.339996, 3.6535e-05, 0, 0.936508, 0.323069, 3.51265e-05, 0, 0.968254, 0.306897, 3.39112e-05, 0, 1, 1, 1.0396e-15, 0, 0, 1, 1.04326e-15, 0, 0, 1, 1.10153e-15, 0, 0, 1, 1.44668e-15, 0, 0, 1, 3.4528e-15, 0, 0, 1, 1.75958e-14, 0, 0, 1, 1.2627e-13, 0, 0, 1, 9.36074e-13, 0, 0, 1, 6.45742e-12, 0, 0, 0.999998, 4.01228e-11, 0, 0, 0.999997, 2.22338e-10, 0, 0, 0.999995, 1.0967e-09, 0, 0, 0.999991, 4.82132e-09, 0, 0, 0.999981, 1.89434e-08, 0, 0, 0.999967, 6.67716e-08, 0, 0, 0.999938, 2.12066e-07, 0, 0, 0.999886, 6.0977e-07, 0, 0, 0.999792, 1.59504e-06, 0, 0, 0.999608, 3.81191e-06, 0, 0, 0.999209, 8.33727e-06, 0, 0, 0.998179, 1.65288e-05, 0, 0, 0.994605, 2.74387e-05, 0, 0, 0.979468, 1.67316e-05, 0, 0, 0.967529, 2.42877e-06, 0, 0, 0.966836, 4.61696e-06, 0, 0, 0.96569, 8.30977e-06, 0, 0, 0.963706, 1.40427e-05, 0, 2.44659e-06, 0.960063, 2.17353e-05, 0, 0.000760774, 0.953113, 2.86606e-05, 0, 0.00367261, 0.940192, 2.47691e-05, 0, 0.00940263, 0.927731, 1.95814e-05, 0, 0.018333, 0.920669, 2.52531e-05, 0, 0.0306825, 0.911799, 3.24277e-05, 0, 0.0465556, 0.89857, 3.40982e-05, 0, 0.0659521, 0.883283, 3.19622e-05, 0, 0.0887677, 0.86989, 3.5548e-05, 0, 0.114784, 0.855483, 3.97143e-05, 0, 0.143618, 0.837987, 3.91665e-05, 0, 0.174606, 0.820546, 4.11306e-05, 0, 0.206349, 0.802878, 4.36753e-05, 0, 0.238095, 0.783402, 4.44e-05, 0, 0.269841, 0.763439, 4.58726e-05, 0, 0.301587, 0.742925, 4.67097e-05, 0, 0.333333, 0.721633, 4.78887e-05, 0, 0.365079, 0.69985, 4.81251e-05, 0, 0.396825, 0.67783, 4.91811e-05, 0, 0.428571, 0.655126, 4.88199e-05, 0, 0.460318, 0.632697, 4.96025e-05, 0, 0.492064, 0.609613, 4.8829e-05, 0, 0.52381, 0.587098, 4.92754e-05, 0, 0.555556, 0.564119, 4.82625e-05, 0, 0.587302, 0.541813, 4.82807e-05, 0, 0.619048, 0.519342, 4.71552e-05, 0, 0.650794, 0.497514, 4.66765e-05, 0, 0.68254, 0.475879, 4.55582e-05, 0, 0.714286, 0.454789, 4.46007e-05, 0, 0.746032, 0.434217, 4.35382e-05, 0, 0.777778, 0.414086, 4.21753e-05, 0, 0.809524, 0.394744, 4.12093e-05, 0, 0.84127, 0.375782, 3.96634e-05, 0, 0.873016, 0.357707, 3.86419e-05, 0, 0.904762, 0.340038, 3.70345e-05, 0, 0.936508, 0.323284, 3.59725e-05, 0, 0.968254, 0.306954, 3.436e-05, 0, 1, 1, 5.99567e-14, 0, 0, 1, 6.00497e-14, 0, 0, 1, 6.14839e-14, 0, 0, 1, 6.86641e-14, 0, 0, 1, 9.72658e-14, 0, 0, 1, 2.21271e-13, 0, 0, 1, 8.33195e-13, 0, 0, 1, 4.03601e-12, 0, 0, 0.999999, 2.06001e-11, 0, 0, 0.999998, 1.01739e-10, 0, 0, 0.999997, 4.70132e-10, 0, 0, 0.999993, 2.00436e-09, 0, 0, 0.999988, 7.83682e-09, 0, 0, 0.999979, 2.80338e-08, 0, 0, 0.999962, 9.17033e-08, 0, 0, 0.999933, 2.74514e-07, 0, 0, 0.999881, 7.53201e-07, 0, 0, 0.999783, 1.89826e-06, 0, 0, 0.999594, 4.40279e-06, 0, 0, 0.999178, 9.3898e-06, 0, 0, 0.998073, 1.81265e-05, 0, 0, 0.993993, 2.80487e-05, 0, 0, 0.979982, 1.49422e-05, 0, 0, 0.968145, 3.78481e-06, 0, 0, 0.966786, 5.3771e-06, 0, 0, 0.965611, 9.47508e-06, 0, 3.88934e-05, 0.963557, 1.56616e-05, 0, 0.0009693, 0.959752, 2.35144e-05, 0, 0.00370329, 0.952461, 2.91568e-05, 0, 0.00868428, 0.940193, 2.40102e-05, 0, 0.0161889, 0.929042, 2.31235e-05, 0, 0.0263948, 0.920266, 2.73968e-05, 0, 0.0394088, 0.911178, 3.37915e-05, 0, 0.0552818, 0.897873, 3.33629e-05, 0, 0.0740138, 0.884053, 3.51405e-05, 0, 0.0955539, 0.869455, 3.78034e-05, 0, 0.119795, 0.854655, 3.99378e-05, 0, 0.14656, 0.838347, 4.19108e-05, 0, 0.175573, 0.820693, 4.40831e-05, 0, 0.206388, 0.802277, 4.45599e-05, 0, 0.238095, 0.783634, 4.72691e-05, 0, 0.269841, 0.763159, 4.76984e-05, 0, 0.301587, 0.742914, 4.91487e-05, 0, 0.333333, 0.721662, 5.02312e-05, 0, 0.365079, 0.699668, 5.02817e-05, 0, 0.396825, 0.677839, 5.1406e-05, 0, 0.428571, 0.655091, 5.11095e-05, 0, 0.460317, 0.632665, 5.16067e-05, 0, 0.492064, 0.609734, 5.12255e-05, 0, 0.52381, 0.587043, 5.10263e-05, 0, 0.555556, 0.564298, 5.0565e-05, 0, 0.587302, 0.541769, 4.97951e-05, 0, 0.619048, 0.519529, 4.92698e-05, 0, 0.650794, 0.497574, 4.82066e-05, 0, 0.68254, 0.476028, 4.73689e-05, 0, 0.714286, 0.454961, 4.61941e-05, 0, 0.746032, 0.434341, 4.50618e-05, 0, 0.777778, 0.414364, 4.38355e-05, 0, 0.809524, 0.394832, 4.24196e-05, 0, 0.84127, 0.376109, 4.12563e-05, 0, 0.873016, 0.35779, 3.96226e-05, 0, 0.904762, 0.340379, 3.84886e-05, 0, 0.936508, 0.323385, 3.68214e-05, 0, 0.968254, 0.307295, 3.56636e-05, 0, 1, 1, 1.06465e-12, 0, 0, 1, 1.06555e-12, 0, 0, 1, 1.07966e-12, 0, 0, 1, 1.14601e-12, 0, 0, 1, 1.37123e-12, 0, 0, 1, 2.1243e-12, 0, 0, 0.999999, 4.89653e-12, 0, 0, 0.999999, 1.60283e-11, 0, 0, 0.999998, 6.2269e-11, 0, 0, 0.999997, 2.51859e-10, 0, 0, 0.999996, 9.96192e-10, 0, 0, 0.999992, 3.74531e-09, 0, 0, 0.999986, 1.32022e-08, 0, 0, 0.999975, 4.33315e-08, 0, 0, 0.999959, 1.31956e-07, 0, 0, 0.999927, 3.72249e-07, 0, 0, 0.999871, 9.72461e-07, 0, 0, 0.999771, 2.35343e-06, 0, 0, 0.999572, 5.2768e-06, 0, 0, 0.999133, 1.09237e-05, 0, 0, 0.997912, 2.03675e-05, 0, 0, 0.993008, 2.79396e-05, 0, 0, 0.980645, 1.39604e-05, 0, 0, 0.970057, 6.46596e-06, 0, 0, 0.966717, 6.5089e-06, 0, 4.74145e-05, 0.965497, 1.11863e-05, 0, 0.00089544, 0.96334, 1.79857e-05, 0, 0.0032647, 0.959294, 2.59045e-05, 0, 0.0075144, 0.951519, 2.92327e-05, 0, 0.0138734, 0.940517, 2.49769e-05, 0, 0.0224952, 0.93014, 2.6803e-05, 0, 0.0334828, 0.91972, 3.03656e-05, 0, 0.0468973, 0.910294, 3.53323e-05, 0, 0.0627703, 0.897701, 3.51002e-05, 0, 0.0811019, 0.884522, 3.88104e-05, 0, 0.10186, 0.869489, 4.12932e-05, 0, 0.124985, 0.853983, 4.15781e-05, 0, 0.150372, 0.838425, 4.54066e-05, 0, 0.177868, 0.820656, 4.71624e-05, 0, 0.207245, 0.801875, 4.75243e-05, 0, 0.238143, 0.783521, 5.05621e-05, 0, 0.269841, 0.763131, 5.0721e-05, 0, 0.301587, 0.74261, 5.23293e-05, 0, 0.333333, 0.72148, 5.28699e-05, 0, 0.365079, 0.699696, 5.38677e-05, 0, 0.396825, 0.677592, 5.39255e-05, 0, 0.428571, 0.65525, 5.46367e-05, 0, 0.460317, 0.632452, 5.41348e-05, 0, 0.492064, 0.609903, 5.44976e-05, 0, 0.52381, 0.586928, 5.36201e-05, 0, 0.555556, 0.564464, 5.35185e-05, 0, 0.587302, 0.541801, 5.24949e-05, 0, 0.619048, 0.519681, 5.1812e-05, 0, 0.650794, 0.497685, 5.07687e-05, 0, 0.68254, 0.47622, 4.96243e-05, 0, 0.714286, 0.455135, 4.85714e-05, 0, 0.746032, 0.4346, 4.71847e-05, 0, 0.777778, 0.414564, 4.59294e-05, 0, 0.809524, 0.395165, 4.44705e-05, 0, 0.84127, 0.376333, 4.30772e-05, 0, 0.873016, 0.358197, 4.16229e-05, 0, 0.904762, 0.34064, 4.01019e-05, 0, 0.936508, 0.323816, 3.86623e-05, 0, 0.968254, 0.307581, 3.70933e-05, 0, 1, 1, 9.91541e-12, 0, 0, 1, 9.92077e-12, 0, 0, 1, 1.00041e-11, 0, 0, 1, 1.0385e-11, 0, 0, 1, 1.15777e-11, 0, 0, 1, 1.50215e-11, 0, 0, 0.999999, 2.54738e-11, 0, 0, 0.999999, 5.98822e-11, 0, 0, 0.999998, 1.79597e-10, 0, 0, 0.999997, 6.02367e-10, 0, 0, 0.999994, 2.06835e-09, 0, 0, 0.99999, 6.94952e-09, 0, 0, 0.999984, 2.23363e-08, 0, 0, 0.999972, 6.78578e-08, 0, 0, 0.999952, 1.93571e-07, 0, 0, 0.999919, 5.16594e-07, 0, 0, 0.99986, 1.28739e-06, 0, 0, 0.999753, 2.99298e-06, 0, 0, 0.999546, 6.48258e-06, 0, 0, 0.999074, 1.29985e-05, 0, 0, 0.997671, 2.32176e-05, 0, 0, 0.991504, 2.56701e-05, 0, 0, 0.981148, 1.31141e-05, 0, 0, 0.971965, 8.69048e-06, 0, 2.80182e-05, 0.966624, 8.08301e-06, 0, 0.000695475, 0.965344, 1.35235e-05, 0, 0.00265522, 0.963048, 2.10592e-05, 0, 0.00622975, 0.958673, 2.87473e-05, 0, 0.0116234, 0.950262, 2.81379e-05, 0, 0.018976, 0.940836, 2.71089e-05, 0, 0.0283844, 0.930996, 3.0926e-05, 0, 0.0399151, 0.919848, 3.48359e-05, 0, 0.0536063, 0.909136, 3.66092e-05, 0, 0.0694793, 0.897554, 3.84162e-05, 0, 0.0875342, 0.884691, 4.30971e-05, 0, 0.107749, 0.869414, 4.47803e-05, 0, 0.130087, 0.853462, 4.52858e-05, 0, 0.154481, 0.838187, 4.95769e-05, 0, 0.180833, 0.820381, 5.02709e-05, 0, 0.209005, 0.801844, 5.22713e-05, 0, 0.238791, 0.783061, 5.41505e-05, 0, 0.269869, 0.763205, 5.53712e-05, 0, 0.301587, 0.742362, 5.64909e-05, 0, 0.333333, 0.721393, 5.72646e-05, 0, 0.365079, 0.699676, 5.81012e-05, 0, 0.396825, 0.677395, 5.8096e-05, 0, 0.428571, 0.655208, 5.85766e-05, 0, 0.460317, 0.632451, 5.83602e-05, 0, 0.492064, 0.609839, 5.80234e-05, 0, 0.52381, 0.587093, 5.77161e-05, 0, 0.555556, 0.564467, 5.68447e-05, 0, 0.587302, 0.542043, 5.63166e-05, 0, 0.619048, 0.519826, 5.5156e-05, 0, 0.650794, 0.497952, 5.41682e-05, 0, 0.68254, 0.476477, 5.28971e-05, 0, 0.714286, 0.455412, 5.14952e-05, 0, 0.746032, 0.434926, 5.02222e-05, 0, 0.777778, 0.4149, 4.85779e-05, 0, 0.809524, 0.395552, 4.72242e-05, 0, 0.84127, 0.376712, 4.54891e-05, 0, 0.873016, 0.358622, 4.40924e-05, 0, 0.904762, 0.341048, 4.22984e-05, 0, 0.936508, 0.324262, 4.08582e-05, 0, 0.968254, 0.308013, 3.90839e-05, 0, 1, 1, 6.13913e-11, 0, 0, 1, 6.14145e-11, 0, 0, 1, 6.17708e-11, 0, 0, 1, 6.33717e-11, 0, 0, 1, 6.81648e-11, 0, 0, 1, 8.08291e-11, 0, 0, 1, 1.14608e-10, 0, 0, 0.999998, 2.10507e-10, 0, 0, 0.999997, 4.99595e-10, 0, 0, 0.999995, 1.39897e-09, 0, 0, 0.999994, 4.19818e-09, 0, 0, 0.999988, 1.27042e-08, 0, 0, 0.999979, 3.75153e-08, 0, 0, 0.999965, 1.06206e-07, 0, 0, 0.999945, 2.85381e-07, 0, 0, 0.999908, 7.23611e-07, 0, 0, 0.999846, 1.7255e-06, 0, 0, 0.999733, 3.86104e-06, 0, 0, 0.999511, 8.08493e-06, 0, 0, 0.998993, 1.56884e-05, 0, 0, 0.997326, 2.65538e-05, 0, 0, 0.989706, 2.06466e-05, 0, 0, 0.981713, 1.30756e-05, 0, 7.0005e-06, 0.973636, 1.06473e-05, 0, 0.000464797, 0.966509, 1.0194e-05, 0, 0.00201743, 0.965149, 1.65881e-05, 0, 0.00497549, 0.962669, 2.49147e-05, 0, 0.00953262, 0.95786, 3.17449e-05, 0, 0.0158211, 0.949334, 2.81045e-05, 0, 0.0239343, 0.941041, 3.03263e-05, 0, 0.0339372, 0.931575, 3.56754e-05, 0, 0.0458738, 0.920102, 3.97075e-05, 0, 0.059772, 0.908002, 3.84886e-05, 0, 0.075645, 0.897269, 4.3027e-05, 0, 0.0934929, 0.884559, 4.79925e-05, 0, 0.113302, 0.869161, 4.8246e-05, 0, 0.135045, 0.853342, 5.09505e-05, 0, 0.158678, 0.837633, 5.42846e-05, 0, 0.184136, 0.820252, 5.54139e-05, 0, 0.211325, 0.801872, 5.81412e-05, 0, 0.240113, 0.782418, 5.85535e-05, 0, 0.270306, 0.7631, 6.10923e-05, 0, 0.301594, 0.742183, 6.13678e-05, 0, 0.333333, 0.721098, 6.27275e-05, 0, 0.365079, 0.699512, 6.29413e-05, 0, 0.396825, 0.677372, 6.36351e-05, 0, 0.428571, 0.655059, 6.33555e-05, 0, 0.460317, 0.632567, 6.36513e-05, 0, 0.492064, 0.609784, 6.28965e-05, 0, 0.52381, 0.587237, 6.25546e-05, 0, 0.555556, 0.564525, 6.15825e-05, 0, 0.587302, 0.542181, 6.05048e-05, 0, 0.619048, 0.520017, 5.96329e-05, 0, 0.650794, 0.498204, 5.81516e-05, 0, 0.68254, 0.476742, 5.69186e-05, 0, 0.714286, 0.455803, 5.53833e-05, 0, 0.746032, 0.435251, 5.37807e-05, 0, 0.777778, 0.415374, 5.22025e-05, 0, 0.809524, 0.395921, 5.03421e-05, 0, 0.84127, 0.377253, 4.88211e-05, 0, 0.873016, 0.359021, 4.68234e-05, 0, 0.904762, 0.341637, 4.53269e-05, 0, 0.936508, 0.3247, 4.33014e-05, 0, 0.968254, 0.308625, 4.18007e-05, 0, 1, 1, 2.86798e-10, 0, 0, 1, 2.86877e-10, 0, 0, 1, 2.88094e-10, 0, 0, 1, 2.93506e-10, 0, 0, 1, 3.09262e-10, 0, 0, 0.999999, 3.48593e-10, 0, 0, 0.999999, 4.44582e-10, 0, 0, 0.999998, 6.88591e-10, 0, 0, 0.999996, 1.34391e-09, 0, 0, 0.999993, 3.17438e-09, 0, 0, 0.999989, 8.35609e-09, 0, 0, 0.999983, 2.28677e-08, 0, 0, 0.999974, 6.23361e-08, 0, 0, 0.999959, 1.65225e-07, 0, 0, 0.999936, 4.19983e-07, 0, 0, 0.999896, 1.01546e-06, 0, 0, 0.99983, 2.32376e-06, 0, 0, 0.999709, 5.0156e-06, 0, 0, 0.999469, 1.0167e-05, 0, 0, 0.998886, 1.90775e-05, 0, 0, 0.996819, 3.00511e-05, 0, 0, 0.988837, 1.85092e-05, 0, 1.68222e-07, 0.982178, 1.34622e-05, 0, 0.000259622, 0.975017, 1.25961e-05, 0, 0.00142595, 0.967101, 1.3507e-05, 0, 0.00382273, 0.964905, 2.05003e-05, 0, 0.00764164, 0.96218, 2.9546e-05, 0, 0.0130121, 0.956821, 3.43738e-05, 0, 0.0200253, 0.948829, 3.05063e-05, 0, 0.0287452, 0.941092, 3.46487e-05, 0, 0.039218, 0.931883, 4.12061e-05, 0, 0.0514748, 0.920211, 4.44651e-05, 0, 0.0655351, 0.907307, 4.31252e-05, 0, 0.0814082, 0.89684, 4.90382e-05, 0, 0.0990939, 0.884119, 5.3334e-05, 0, 0.118583, 0.869148, 5.4114e-05, 0, 0.139856, 0.853377, 5.78536e-05, 0, 0.162882, 0.836753, 5.92285e-05, 0, 0.187615, 0.820063, 6.22787e-05, 0, 0.213991, 0.801694, 6.45492e-05, 0, 0.241918, 0.782116, 6.5353e-05, 0, 0.271267, 0.762673, 6.74344e-05, 0, 0.301847, 0.742133, 6.82788e-05, 0, 0.333333, 0.720779, 6.91959e-05, 0, 0.365079, 0.699386, 6.96817e-05, 0, 0.396826, 0.67732, 6.99583e-05, 0, 0.428572, 0.654888, 6.98447e-05, 0, 0.460318, 0.632499, 6.94063e-05, 0, 0.492064, 0.609825, 6.91612e-05, 0, 0.52381, 0.587287, 6.81576e-05, 0, 0.555556, 0.564743, 6.74138e-05, 0, 0.587302, 0.542409, 6.61617e-05, 0, 0.619048, 0.520282, 6.47785e-05, 0, 0.650794, 0.498506, 6.33836e-05, 0, 0.68254, 0.477102, 6.15905e-05, 0, 0.714286, 0.456167, 6.01013e-05, 0, 0.746032, 0.435728, 5.81457e-05, 0, 0.777778, 0.415809, 5.64215e-05, 0, 0.809524, 0.396517, 5.44997e-05, 0, 0.84127, 0.377737, 5.25061e-05, 0, 0.873016, 0.359698, 5.06831e-05, 0, 0.904762, 0.342164, 4.8568e-05, 0, 0.936508, 0.325417, 4.67826e-05, 0, 0.968254, 0.309186, 4.46736e-05, 0, 1, 1, 1.09018e-09, 0, 0, 1, 1.0904e-09, 0, 0, 1, 1.09393e-09, 0, 0, 1, 1.1095e-09, 0, 0, 1, 1.154e-09, 0, 0, 1, 1.26089e-09, 0, 0, 0.999999, 1.5059e-09, 0, 0, 0.999997, 2.07899e-09, 0, 0, 0.999994, 3.48164e-09, 0, 0, 0.999993, 7.05728e-09, 0, 0, 0.999987, 1.63692e-08, 0, 0, 0.999981, 4.06033e-08, 0, 0, 0.999969, 1.0245e-07, 0, 0, 0.999953, 2.55023e-07, 0, 0, 0.999925, 6.1511e-07, 0, 0, 0.999881, 1.42218e-06, 0, 0, 0.99981, 3.13086e-06, 0, 0, 0.99968, 6.53119e-06, 0, 0, 0.999418, 1.2832e-05, 0, 0, 0.998748, 2.32497e-05, 0, 0, 0.996066, 3.29522e-05, 0, 0, 0.988379, 1.79613e-05, 0, 0.000108799, 0.982567, 1.43715e-05, 0, 0.000921302, 0.976097, 1.48096e-05, 0, 0.00280738, 0.968475, 1.78905e-05, 0, 0.00596622, 0.964606, 2.53921e-05, 0, 0.0105284, 0.961564, 3.48623e-05, 0, 0.0165848, 0.955517, 3.57612e-05, 0, 0.0242, 0.948381, 3.43493e-05, 0, 0.03342, 0.941095, 4.05849e-05, 0, 0.0442777, 0.931923, 4.75394e-05, 0, 0.0567958, 0.91996, 4.84328e-05, 0, 0.0709879, 0.907419, 5.02146e-05, 0, 0.086861, 0.89618, 5.61654e-05, 0, 0.104415, 0.88337, 5.87612e-05, 0, 0.123643, 0.869046, 6.18057e-05, 0, 0.144531, 0.853278, 6.57392e-05, 0, 0.167057, 0.836091, 6.6303e-05, 0, 0.191188, 0.819644, 7.04445e-05, 0, 0.216878, 0.801246, 7.14071e-05, 0, 0.244062, 0.782031, 7.40093e-05, 0, 0.272649, 0.762066, 7.4685e-05, 0, 0.302509, 0.741964, 7.66647e-05, 0, 0.333442, 0.720554, 7.66328e-05, 0, 0.365079, 0.699098, 7.77857e-05, 0, 0.396826, 0.677189, 7.74633e-05, 0, 0.428572, 0.65484, 7.76235e-05, 0, 0.460318, 0.632496, 7.70316e-05, 0, 0.492064, 0.609908, 7.62669e-05, 0, 0.52381, 0.587312, 7.53972e-05, 0, 0.555556, 0.564938, 7.39994e-05, 0, 0.587302, 0.542577, 7.28382e-05, 0, 0.619048, 0.52062, 7.1112e-05, 0, 0.650794, 0.498819, 6.94004e-05, 0, 0.68254, 0.477555, 6.75575e-05, 0, 0.714286, 0.456568, 6.53449e-05, 0, 0.746032, 0.436278, 6.36068e-05, 0, 0.777778, 0.41637, 6.13466e-05, 0, 0.809524, 0.397144, 5.94177e-05, 0, 0.84127, 0.378412, 5.70987e-05, 0, 0.873016, 0.360376, 5.50419e-05, 0, 0.904762, 0.342906, 5.27422e-05, 0, 0.936508, 0.326136, 5.06544e-05, 0, 0.968254, 0.30997, 4.84307e-05, 0, 1, 1, 3.54014e-09, 0, 0, 1, 3.54073e-09, 0, 0, 1, 3.54972e-09, 0, 0, 1, 3.58929e-09, 0, 0, 1, 3.70093e-09, 0, 0, 0.999999, 3.96194e-09, 0, 0, 0.999998, 4.53352e-09, 0, 0, 0.999997, 5.78828e-09, 0, 0, 0.999994, 8.63812e-09, 0, 0, 0.999991, 1.53622e-08, 0, 0, 0.999985, 3.16356e-08, 0, 0, 0.999977, 7.12781e-08, 0, 0, 0.999964, 1.66725e-07, 0, 0, 0.999945, 3.90501e-07, 0, 0, 0.999912, 8.95622e-07, 0, 0, 0.999866, 1.98428e-06, 0, 0, 0.999786, 4.21038e-06, 0, 0, 0.999647, 8.50239e-06, 0, 0, 0.999356, 1.62059e-05, 0, 0, 0.998563, 2.82652e-05, 0, 0, 0.994928, 3.36309e-05, 0, 2.44244e-05, 0.987999, 1.78458e-05, 0, 0.000523891, 0.982893, 1.59162e-05, 0, 0.00194729, 0.977044, 1.78056e-05, 0, 0.00451099, 0.969972, 2.30624e-05, 0, 0.00835132, 0.964237, 3.13922e-05, 0, 0.013561, 0.960791, 4.06145e-05, 0, 0.0202056, 0.954292, 3.72796e-05, 0, 0.0283321, 0.948052, 4.03199e-05, 0, 0.0379739, 0.940938, 4.79537e-05, 0, 0.0491551, 0.931689, 5.45292e-05, 0, 0.0618918, 0.91987, 5.4038e-05, 0, 0.0761941, 0.907665, 5.89909e-05, 0, 0.0920672, 0.895281, 6.42651e-05, 0, 0.109511, 0.882621, 6.59707e-05, 0, 0.12852, 0.86873, 7.09973e-05, 0, 0.149085, 0.853008, 7.42221e-05, 0, 0.171189, 0.835944, 7.61754e-05, 0, 0.194809, 0.818949, 7.97052e-05, 0, 0.21991, 0.800951, 8.12434e-05, 0, 0.246447, 0.781847, 8.38075e-05, 0, 0.274352, 0.761649, 8.4501e-05, 0, 0.303535, 0.74152, 8.60258e-05, 0, 0.333857, 0.720495, 8.66233e-05, 0, 0.365104, 0.698742, 8.68326e-05, 0, 0.396826, 0.677096, 8.7133e-05, 0, 0.428572, 0.654782, 8.63497e-05, 0, 0.460318, 0.632335, 8.60206e-05, 0, 0.492064, 0.610031, 8.49337e-05, 0, 0.52381, 0.587457, 8.38279e-05, 0, 0.555556, 0.56513, 8.2309e-05, 0, 0.587302, 0.542877, 8.03542e-05, 0, 0.619048, 0.5209, 7.86928e-05, 0, 0.650794, 0.499291, 7.65171e-05, 0, 0.68254, 0.477971, 7.44753e-05, 0, 0.714286, 0.457221, 7.2209e-05, 0, 0.746032, 0.436803, 6.97448e-05, 0, 0.777778, 0.417083, 6.75333e-05, 0, 0.809524, 0.397749, 6.48058e-05, 0, 0.84127, 0.379177, 6.25759e-05, 0, 0.873016, 0.361061, 5.98584e-05, 0, 0.904762, 0.343713, 5.75797e-05, 0, 0.936508, 0.326894, 5.49999e-05, 0, 0.968254, 0.310816, 5.27482e-05, 0, 1, 1, 1.0153e-08, 0, 0, 1, 1.01544e-08, 0, 0, 1, 1.01751e-08, 0, 0, 1, 1.02662e-08, 0, 0, 1, 1.0521e-08, 0, 0, 0.999999, 1.11049e-08, 0, 0, 0.999999, 1.23408e-08, 0, 0, 0.999996, 1.4924e-08, 0, 0, 0.999992, 2.04471e-08, 0, 0, 0.999989, 3.26539e-08, 0, 0, 0.99998, 6.03559e-08, 0, 0, 0.999971, 1.23936e-07, 0, 0, 0.999955, 2.69058e-07, 0, 0, 0.999933, 5.93604e-07, 0, 0, 0.999901, 1.29633e-06, 0, 0, 0.999847, 2.75621e-06, 0, 0, 0.999761, 5.64494e-06, 0, 0, 0.999607, 1.10485e-05, 0, 0, 0.999282, 2.04388e-05, 0, 0, 0.99831, 3.41084e-05, 0, 2.2038e-07, 0.993288, 2.94949e-05, 0, 0.000242388, 0.987855, 1.92736e-05, 0, 0.0012503, 0.983167, 1.82383e-05, 0, 0.0032745, 0.977908, 2.18633e-05, 0, 0.00646321, 0.971194, 2.90662e-05, 0, 0.0109133, 0.963867, 3.86401e-05, 0, 0.0166927, 0.95982, 4.62827e-05, 0, 0.0238494, 0.953497, 4.20705e-05, 0, 0.0324178, 0.947621, 4.77743e-05, 0, 0.0424225, 0.940611, 5.68258e-05, 0, 0.0538808, 0.931174, 6.18061e-05, 0, 0.0668047, 0.919919, 6.27098e-05, 0, 0.0812014, 0.907856, 6.94714e-05, 0, 0.0970745, 0.894509, 7.35008e-05, 0, 0.114424, 0.881954, 7.63369e-05, 0, 0.133246, 0.868309, 8.21896e-05, 0, 0.153534, 0.852511, 8.3769e-05, 0, 0.175275, 0.835821, 8.81615e-05, 0, 0.198453, 0.817981, 8.96368e-05, 0, 0.223042, 0.800504, 9.30906e-05, 0, 0.249009, 0.78141, 9.45056e-05, 0, 0.276304, 0.761427, 9.63605e-05, 0, 0.304862, 0.74094, 9.68088e-05, 0, 0.334584, 0.720233, 9.81481e-05, 0, 0.365322, 0.698592, 9.79122e-05, 0, 0.396826, 0.676763, 9.81057e-05, 0, 0.428571, 0.654808, 9.73956e-05, 0, 0.460318, 0.632326, 9.62619e-05, 0, 0.492064, 0.610049, 9.52996e-05, 0, 0.52381, 0.58763, 9.33334e-05, 0, 0.555556, 0.565261, 9.17573e-05, 0, 0.587302, 0.543244, 8.96636e-05, 0, 0.619048, 0.521273, 8.73304e-05, 0, 0.650794, 0.499818, 8.52648e-05, 0, 0.68254, 0.478536, 8.23961e-05, 0, 0.714286, 0.457826, 7.9939e-05, 0, 0.746032, 0.437549, 7.7126e-05, 0, 0.777778, 0.41776, 7.43043e-05, 0, 0.809524, 0.39863, 7.16426e-05, 0, 0.84127, 0.379954, 6.86456e-05, 0, 0.873016, 0.362025, 6.60514e-05, 0, 0.904762, 0.344581, 6.30755e-05, 0, 0.936508, 0.327909, 6.05439e-05, 0, 0.968254, 0.311736, 5.76345e-05, 0, 1, 1, 2.63344e-08, 0, 0, 1, 2.63373e-08, 0, 0, 1, 2.63815e-08, 0, 0, 1, 2.65753e-08, 0, 0, 1, 2.71132e-08, 0, 0, 0.999999, 2.83279e-08, 0, 0, 0.999997, 3.0833e-08, 0, 0, 0.999995, 3.58711e-08, 0, 0, 0.999992, 4.61266e-08, 0, 0, 0.999985, 6.7574e-08, 0, 0, 0.999977, 1.1358e-07, 0, 0, 0.999966, 2.13657e-07, 0, 0, 0.999948, 4.31151e-07, 0, 0, 0.999923, 8.96656e-07, 0, 0, 0.999884, 1.86603e-06, 0, 0, 0.999826, 3.81115e-06, 0, 0, 0.999732, 7.54184e-06, 0, 0, 0.999561, 1.43192e-05, 0, 0, 0.999191, 2.57061e-05, 0, 0, 0.997955, 4.05724e-05, 0, 7.44132e-05, 0.992228, 2.76537e-05, 0, 0.000716477, 0.987638, 2.08885e-05, 0, 0.0022524, 0.983395, 2.15226e-05, 0, 0.00484816, 0.978614, 2.70795e-05, 0, 0.00860962, 0.972389, 3.65282e-05, 0, 0.0136083, 0.964392, 4.74747e-05, 0, 0.0198941, 0.95861, 5.09141e-05, 0, 0.0275023, 0.952806, 4.8963e-05, 0, 0.0364584, 0.94712, 5.71119e-05, 0, 0.04678, 0.940104, 6.71704e-05, 0, 0.0584799, 0.930398, 6.87586e-05, 0, 0.0715665, 0.919866, 7.38161e-05, 0, 0.086045, 0.907853, 8.13235e-05, 0, 0.101918, 0.894078, 8.34582e-05, 0, 0.119186, 0.881177, 8.92093e-05, 0, 0.137845, 0.867575, 9.44548e-05, 0, 0.157891, 0.852107, 9.69607e-05, 0, 0.179316, 0.835502, 0.000101456, 0, 0.202106, 0.81756, 0.000103256, 0, 0.226243, 0.79984, 0.000106954, 0, 0.251704, 0.780998, 0.000108066, 0, 0.278451, 0.761132, 0.000110111, 0, 0.306436, 0.740429, 0.000110459, 0, 0.335586, 0.719836, 0.000111219, 0, 0.365796, 0.698467, 0.00011145, 0, 0.3969, 0.676446, 0.000110393, 0, 0.428571, 0.654635, 0.000110035, 0, 0.460318, 0.632411, 0.000108548, 0, 0.492064, 0.609986, 0.000106963, 0, 0.52381, 0.587872, 0.000105238, 0, 0.555556, 0.565528, 0.000102665, 0, 0.587302, 0.543563, 0.000100543, 0, 0.619048, 0.52176, 9.76182e-05, 0, 0.650794, 0.500188, 9.47099e-05, 0, 0.68254, 0.479204, 9.19929e-05, 0, 0.714286, 0.458413, 8.86139e-05, 0, 0.746032, 0.438314, 8.57839e-05, 0, 0.777778, 0.418573, 8.2411e-05, 0, 0.809524, 0.39947, 7.92211e-05, 0, 0.84127, 0.380892, 7.59546e-05, 0, 0.873016, 0.362953, 7.27571e-05, 0, 0.904762, 0.345601, 6.95738e-05, 0, 0.936508, 0.328895, 6.64907e-05, 0, 0.968254, 0.312808, 6.34277e-05, 0, 1, 1, 6.28647e-08, 0, 0, 1, 6.28705e-08, 0, 0, 1, 6.29587e-08, 0, 0, 1, 6.33441e-08, 0, 0, 0.999999, 6.44087e-08, 0, 0, 0.999998, 6.67856e-08, 0, 0, 0.999997, 7.15889e-08, 0, 0, 0.999995, 8.09577e-08, 0, 0, 0.999989, 9.92764e-08, 0, 0, 0.999983, 1.35834e-07, 0, 0, 0.999974, 2.10482e-07, 0, 0, 0.999959, 3.65215e-07, 0, 0, 0.999939, 6.86693e-07, 0, 0, 0.999911, 1.3472e-06, 0, 0, 0.999868, 2.6731e-06, 0, 0, 0.999804, 5.24756e-06, 0, 0, 0.9997, 1.00403e-05, 0, 0, 0.99951, 1.85019e-05, 0, 0, 0.999078, 3.22036e-05, 0, 6.20676e-06, 0.997428, 4.70002e-05, 0, 0.000341552, 0.99162, 2.87123e-05, 0, 0.00143727, 0.987479, 2.34706e-05, 0, 0.00349201, 0.983582, 2.60083e-05, 0, 0.0066242, 0.979186, 3.37927e-05, 0, 0.0109113, 0.97325, 4.54689e-05, 0, 0.0164064, 0.965221, 5.73759e-05, 0, 0.0231463, 0.957262, 5.44114e-05, 0, 0.0311571, 0.952211, 5.87006e-05, 0, 0.0404572, 0.946631, 6.92256e-05, 0, 0.0510592, 0.939391, 7.87819e-05, 0, 0.0629723, 0.929795, 7.92368e-05, 0, 0.0762025, 0.91965, 8.75075e-05, 0, 0.090753, 0.907737, 9.50903e-05, 0, 0.106626, 0.893899, 9.72963e-05, 0, 0.123822, 0.880239, 0.00010459, 0, 0.142337, 0.866562, 0.000107689, 0, 0.16217, 0.85164, 0.000113081, 0, 0.183314, 0.835021, 0.000116636, 0, 0.20576, 0.817311, 0.000120074, 0, 0.229496, 0.798845, 0.000121921, 0, 0.254502, 0.780479, 0.00012475, 0, 0.280753, 0.760694, 0.000125255, 0, 0.308212, 0.740142, 0.000126719, 0, 0.336825, 0.719248, 0.00012636, 0, 0.366517, 0.698209, 0.000126712, 0, 0.397167, 0.676398, 0.000125769, 0, 0.428578, 0.654378, 0.000124432, 0, 0.460318, 0.632484, 0.000123272, 0, 0.492064, 0.610113, 0.00012085, 0, 0.52381, 0.587931, 0.000118411, 0, 0.555556, 0.565872, 0.00011569, 0, 0.587302, 0.543814, 0.000112521, 0, 0.619048, 0.522265, 0.000109737, 0, 0.650794, 0.500835, 0.000106228, 0, 0.68254, 0.479818, 0.000102591, 0, 0.714286, 0.459258, 9.91288e-05, 0, 0.746032, 0.439061, 9.52325e-05, 0, 0.777778, 0.419552, 9.1895e-05, 0, 0.809524, 0.400399, 8.79051e-05, 0, 0.84127, 0.381976, 8.44775e-05, 0, 0.873016, 0.364009, 8.06316e-05, 0, 0.904762, 0.346761, 7.71848e-05, 0, 0.936508, 0.330049, 7.35429e-05, 0, 0.968254, 0.314018, 7.02103e-05, 0, 1, 1, 1.39968e-07, 0, 0, 1, 1.39979e-07, 0, 0, 1, 1.40145e-07, 0, 0, 1, 1.4087e-07, 0, 0, 0.999999, 1.42865e-07, 0, 0, 0.999998, 1.47279e-07, 0, 0, 0.999997, 1.56057e-07, 0, 0, 0.999992, 1.7276e-07, 0, 0, 0.999989, 2.04352e-07, 0, 0, 0.99998, 2.6494e-07, 0, 0, 0.999969, 3.83435e-07, 0, 0, 0.999953, 6.18641e-07, 0, 0, 0.999929, 1.08755e-06, 0, 0, 0.999898, 2.01497e-06, 0, 0, 0.999849, 3.81346e-06, 0, 0, 0.999778, 7.19815e-06, 0, 0, 0.999661, 1.33215e-05, 0, 0, 0.999451, 2.38313e-05, 0, 0, 0.998936, 4.01343e-05, 0, 0.000113724, 0.99662, 5.17346e-05, 0, 0.000820171, 0.991094, 3.04323e-05, 0, 0.00238143, 0.987487, 2.81757e-05, 0, 0.00493527, 0.983731, 3.20048e-05, 0, 0.00856859, 0.979647, 4.23905e-05, 0, 0.0133393, 0.973837, 5.62935e-05, 0, 0.0192863, 0.96584, 6.77442e-05, 0, 0.0264369, 0.956309, 6.23073e-05, 0, 0.03481, 0.951523, 7.04131e-05, 0, 0.0444184, 0.946003, 8.36594e-05, 0, 0.0552713, 0.938454, 9.11736e-05, 0, 0.0673749, 0.929279, 9.38264e-05, 0, 0.0807329, 0.919239, 0.000103754, 0, 0.0953479, 0.907293, 0.000109928, 0, 0.111221, 0.893936, 0.000115257, 0, 0.128352, 0.879674, 0.000122265, 0, 0.14674, 0.865668, 0.000125733, 0, 0.166382, 0.850998, 0.000132305, 0, 0.187276, 0.834498, 0.000134844, 0, 0.209413, 0.816903, 0.000139276, 0, 0.232786, 0.798235, 0.000140984, 0, 0.257382, 0.779724, 0.00014378, 0, 0.283181, 0.760251, 0.000144623, 0, 0.310156, 0.739808, 0.000145228, 0, 0.338269, 0.718762, 0.00014539, 0, 0.367461, 0.697815, 0.000144432, 0, 0.397646, 0.67631, 0.000143893, 0, 0.428685, 0.654278, 0.000141846, 0, 0.460318, 0.632347, 0.00013935, 0, 0.492064, 0.610296, 0.000137138, 0, 0.52381, 0.588039, 0.000133806, 0, 0.555556, 0.566218, 0.000130755, 0, 0.587302, 0.544346, 0.000127128, 0, 0.619048, 0.522701, 0.000123002, 0, 0.650794, 0.501542, 0.000119443, 0, 0.68254, 0.480508, 0.000115055, 0, 0.714286, 0.460092, 0.000111032, 0, 0.746032, 0.440021, 0.000106635, 0, 0.777778, 0.420446, 0.000102162, 0, 0.809524, 0.401512, 9.8184e-05, 0, 0.84127, 0.38299, 9.36497e-05, 0, 0.873016, 0.365232, 8.9813e-05, 0, 0.904762, 0.347865, 8.53073e-05, 0, 0.936508, 0.331342, 8.17068e-05, 0, 0.968254, 0.315202, 7.73818e-05, 0, 1, 1, 2.9368e-07, 0, 0, 1, 2.937e-07, 0, 0, 1, 2.93998e-07, 0, 0, 1, 2.95298e-07, 0, 0, 0.999999, 2.98865e-07, 0, 0, 0.999998, 3.067e-07, 0, 0, 0.999995, 3.22082e-07, 0, 0, 0.999992, 3.50767e-07, 0, 0, 0.999986, 4.03538e-07, 0, 0, 0.999976, 5.01372e-07, 0, 0, 0.999964, 6.8562e-07, 0, 0, 0.999945, 1.0374e-06, 0, 0, 0.999919, 1.71269e-06, 0, 0, 0.999882, 3.00175e-06, 0, 0, 0.999829, 5.42144e-06, 0, 0, 0.999749, 9.84182e-06, 0, 0, 0.99962, 1.76213e-05, 0, 0, 0.999382, 3.05995e-05, 0, 1.38418e-05, 0.998751, 4.96686e-05, 0, 0.000389844, 0.995344, 5.10733e-05, 0, 0.00150343, 0.990768, 3.45829e-05, 0, 0.00352451, 0.987464, 3.42841e-05, 0, 0.00655379, 0.983846, 3.99072e-05, 0, 0.0106554, 0.980007, 5.33219e-05, 0, 0.0158723, 0.974494, 6.96992e-05, 0, 0.0222333, 0.96622, 7.76754e-05, 0, 0.029758, 0.956273, 7.47718e-05, 0, 0.0384596, 0.950952, 8.64611e-05, 0, 0.0483473, 0.945215, 0.000100464, 0, 0.0594266, 0.937287, 0.000103729, 0, 0.0717019, 0.928649, 0.000111665, 0, 0.0851752, 0.918791, 0.00012353, 0, 0.0998479, 0.906685, 0.000127115, 0, 0.115721, 0.893706, 0.00013628, 0, 0.132794, 0.879248, 0.000142427, 0, 0.151067, 0.864685, 0.000148091, 0, 0.170538, 0.850032, 0.000153517, 0, 0.191204, 0.833853, 0.000157322, 0, 0.213063, 0.816353, 0.000161086, 0, 0.236107, 0.797834, 0.000164111, 0, 0.260329, 0.778831, 0.000165446, 0, 0.285714, 0.759756, 0.000167492, 0, 0.312243, 0.739419, 0.000166928, 0, 0.339887, 0.718491, 0.000167, 0, 0.368604, 0.697392, 0.000165674, 0, 0.398329, 0.676102, 0.000163815, 0, 0.428961, 0.654243, 0.000162003, 0, 0.460331, 0.632176, 0.000158831, 0, 0.492064, 0.610407, 0.000155463, 0, 0.52381, 0.588394, 0.000152062, 0, 0.555556, 0.56645, 0.000147665, 0, 0.587302, 0.5449, 0.00014375, 0, 0.619048, 0.523276, 0.000138905, 0, 0.650794, 0.502179, 0.000134189, 0, 0.68254, 0.481359, 0.000129392, 0, 0.714286, 0.46092, 0.000124556, 0, 0.746032, 0.441084, 0.00011957, 0, 0.777778, 0.421517, 0.000114652, 0, 0.809524, 0.402721, 0.000109688, 0, 0.84127, 0.384222, 0.000104667, 0, 0.873016, 0.366534, 9.99633e-05, 0, 0.904762, 0.349205, 9.50177e-05, 0, 0.936508, 0.332702, 9.07301e-05, 0, 0.968254, 0.316599, 8.59769e-05, 0, 1, 1, 5.85473e-07, 0, 0, 1, 5.85507e-07, 0, 0, 1, 5.8602e-07, 0, 0, 0.999999, 5.88259e-07, 0, 0, 0.999999, 5.94381e-07, 0, 0, 0.999998, 6.07754e-07, 0, 0, 0.999995, 6.33729e-07, 0, 0, 0.99999, 6.8137e-07, 0, 0, 0.999984, 7.67003e-07, 0, 0, 0.999973, 9.21212e-07, 0, 0, 0.999959, 1.20218e-06, 0, 0, 0.999936, 1.72024e-06, 0, 0, 0.999907, 2.68088e-06, 0, 0, 0.999866, 4.45512e-06, 0, 0, 0.999806, 7.68481e-06, 0, 0, 0.999716, 1.342e-05, 0, 0, 0.999576, 2.32473e-05, 0, 0, 0.9993, 3.91694e-05, 0, 0.000129917, 0.998498, 6.08429e-05, 0, 0.000845035, 0.994132, 4.89743e-05, 0, 0.00237616, 0.99031, 3.84644e-05, 0, 0.00484456, 0.987409, 4.21768e-05, 0, 0.00832472, 0.983981, 5.04854e-05, 0, 0.0128643, 0.980268, 6.71028e-05, 0, 0.0184947, 0.974875, 8.52749e-05, 0, 0.025237, 0.966063, 8.5531e-05, 0, 0.0331046, 0.956779, 9.00588e-05, 0, 0.0421067, 0.950259, 0.00010577, 0, 0.0522487, 0.944239, 0.000119458, 0, 0.0635343, 0.936341, 0.000122164, 0, 0.0759654, 0.928047, 0.000134929, 0, 0.0895434, 0.918065, 0.000145544, 0, 0.104269, 0.906267, 0.000150531, 0, 0.120142, 0.893419, 0.000161652, 0, 0.137163, 0.878758, 0.00016593, 0, 0.15533, 0.863699, 0.000174014, 0, 0.174645, 0.848876, 0.000177877, 0, 0.195106, 0.833032, 0.000184049, 0, 0.21671, 0.815557, 0.000186088, 0, 0.239454, 0.797323, 0.00019054, 0, 0.263332, 0.778124, 0.000191765, 0, 0.288336, 0.758929, 0.000192535, 0, 0.314451, 0.738979, 0.000192688, 0, 0.341658, 0.718213, 0.000191522, 0, 0.369924, 0.696947, 0.000190491, 0, 0.399202, 0.675807, 0.000187913, 0, 0.429416, 0.654147, 0.000184451, 0, 0.460447, 0.63229, 0.000181442, 0, 0.492064, 0.610499, 0.000177139, 0, 0.523809, 0.588747, 0.000172596, 0, 0.555555, 0.566783, 0.000167457, 0, 0.587301, 0.545359, 0.000162518, 0, 0.619048, 0.523984, 0.000156818, 0, 0.650794, 0.502917, 0.000151884, 0, 0.68254, 0.482294, 0.000145514, 0, 0.714286, 0.461945, 0.000140199, 0, 0.746032, 0.442133, 0.000134101, 0, 0.777778, 0.422705, 0.000128374, 0, 0.809524, 0.403916, 0.000122996, 0, 0.84127, 0.38554, 0.000116808, 0, 0.873016, 0.367909, 0.000111973, 0, 0.904762, 0.350651, 0.000105938, 0, 0.936508, 0.334208, 0.000101355, 0, 0.968254, 0.318123, 9.57629e-05, 0, 1, 1, 1.11633e-06, 0, 0, 1, 1.11639e-06, 0, 0, 1, 1.11725e-06, 0, 0, 1, 1.12096e-06, 0, 0, 0.999999, 1.1311e-06, 0, 0, 0.999997, 1.15315e-06, 0, 0, 0.999995, 1.1956e-06, 0, 0, 0.999989, 1.27239e-06, 0, 0, 0.999981, 1.40772e-06, 0, 0, 0.999969, 1.64541e-06, 0, 0, 0.999952, 2.06607e-06, 0, 0, 0.999928, 2.81783e-06, 0, 0, 0.999895, 4.16835e-06, 0, 0, 0.999848, 6.58728e-06, 0, 0, 0.999781, 1.08648e-05, 0, 0, 0.999682, 1.82579e-05, 0, 0, 0.999523, 3.06003e-05, 0, 1.59122e-05, 0.999205, 4.99862e-05, 0, 0.000391184, 0.998131, 7.3306e-05, 0, 0.00147534, 0.993334, 5.13229e-05, 0, 0.0034227, 0.99016, 4.67783e-05, 0, 0.00632232, 0.987321, 5.23413e-05, 0, 0.0102295, 0.984099, 6.4267e-05, 0, 0.0151794, 0.980432, 8.43042e-05, 0, 0.0211947, 0.974976, 0.000102819, 0, 0.0282899, 0.966429, 9.96234e-05, 0, 0.0364739, 0.957633, 0.000111074, 0, 0.0457522, 0.949422, 0.000128644, 0, 0.0561278, 0.943045, 0.000140076, 0, 0.0676023, 0.935448, 0.000146349, 0, 0.0801762, 0.927225, 0.000161854, 0, 0.0938499, 0.917033, 0.000169135, 0, 0.108623, 0.905762, 0.000179987, 0, 0.124496, 0.892879, 0.000189832, 0, 0.141469, 0.878435, 0.000195881, 0, 0.159541, 0.863114, 0.00020466, 0, 0.178713, 0.84776, 0.000209473, 0, 0.198985, 0.832084, 0.000214861, 0, 0.220355, 0.814915, 0.000217695, 0, 0.242823, 0.796711, 0.000220313, 0, 0.266385, 0.777603, 0.00022313, 0, 0.291036, 0.757991, 0.000222471, 0, 0.316767, 0.738371, 0.000222869, 0, 0.343563, 0.717872, 0.000221243, 0, 0.371402, 0.696619, 0.000218089, 0, 0.400248, 0.675379, 0.00021562, 0, 0.430047, 0.65411, 0.00021169, 0, 0.460709, 0.63241, 0.000206947, 0, 0.492079, 0.61046, 0.000201709, 0, 0.52381, 0.58903, 0.000196753, 0, 0.555556, 0.567267, 0.000189637, 0, 0.587302, 0.545886, 0.000184735, 0, 0.619048, 0.524714, 0.000177257, 0, 0.650794, 0.503789, 0.000171424, 0, 0.68254, 0.483204, 0.000164688, 0, 0.714286, 0.462976, 0.000157172, 0, 0.746032, 0.443294, 0.000151341, 0, 0.777778, 0.423988, 0.000143737, 0, 0.809524, 0.405325, 0.000138098, 0, 0.84127, 0.386981, 0.000130698, 0, 0.873016, 0.369436, 0.000125276, 0, 0.904762, 0.35219, 0.000118349, 0, 0.936508, 0.335804, 0.00011312, 0, 0.968254, 0.319749, 0.000106687, 0, 1, 1, 2.04685e-06, 0, 0, 1, 2.04694e-06, 0, 0, 1, 2.04831e-06, 0, 0, 0.999999, 2.05428e-06, 0, 0, 0.999999, 2.07056e-06, 0, 0, 0.999997, 2.10581e-06, 0, 0, 0.999993, 2.1732e-06, 0, 0, 0.999987, 2.29365e-06, 0, 0, 0.999979, 2.50243e-06, 0, 0, 0.999965, 2.86127e-06, 0, 0, 0.999947, 3.48028e-06, 0, 0, 0.999918, 4.55588e-06, 0, 0, 0.999881, 6.43303e-06, 0, 0, 0.999828, 9.70064e-06, 0, 0, 0.999753, 1.53233e-05, 0, 0, 0.999642, 2.4793e-05, 0, 0, 0.999464, 4.02032e-05, 0, 0.000122947, 0.999089, 6.35852e-05, 0, 0.000807414, 0.997567, 8.57026e-05, 0, 0.00227206, 0.992903, 5.94912e-05, 0, 0.00462812, 0.990011, 5.78515e-05, 0, 0.00794162, 0.987192, 6.5399e-05, 0, 0.0122534, 0.98418, 8.19675e-05, 0, 0.0175888, 0.980491, 0.000105514, 0, 0.0239635, 0.974779, 0.000121532, 0, 0.031387, 0.96675, 0.000119144, 0, 0.0398644, 0.958248, 0.000136125, 0, 0.0493982, 0.948884, 0.000155408, 0, 0.0599896, 0.941673, 0.000162281, 0, 0.0716382, 0.934521, 0.000176754, 0, 0.0843437, 0.926205, 0.000192873, 0, 0.0981056, 0.916089, 0.000200038, 0, 0.112923, 0.904963, 0.000213624, 0, 0.128796, 0.892089, 0.000221834, 0, 0.145725, 0.878028, 0.000232619, 0, 0.163709, 0.86249, 0.000238632, 0, 0.182749, 0.846587, 0.000247002, 0, 0.202847, 0.830988, 0.000250702, 0, 0.224001, 0.814165, 0.000255562, 0, 0.246214, 0.796135, 0.000257505, 0, 0.269482, 0.777052, 0.000258625, 0, 0.293805, 0.757201, 0.000258398, 0, 0.319176, 0.737655, 0.000256714, 0, 0.345587, 0.717477, 0.000255187, 0, 0.373021, 0.696433, 0.000251792, 0, 0.401454, 0.675084, 0.000247223, 0, 0.430844, 0.653907, 0.000242213, 0, 0.461125, 0.632561, 0.000237397, 0, 0.492187, 0.610658, 0.000229313, 0, 0.52381, 0.589322, 0.000224402, 0, 0.555556, 0.567857, 0.000216116, 0, 0.587302, 0.54652, 0.000209124, 0, 0.619048, 0.525433, 0.000201601, 0, 0.650794, 0.504679, 0.000192957, 0, 0.68254, 0.484203, 0.000186052, 0, 0.714286, 0.464203, 0.000177672, 0, 0.746032, 0.444549, 0.000170005, 0, 0.777778, 0.425346, 0.000162401, 0, 0.809524, 0.406706, 0.0001544, 0, 0.84127, 0.388576, 0.000147437, 0, 0.873016, 0.37094, 0.000139493, 0, 0.904762, 0.353996, 0.000133219, 0, 0.936508, 0.337391, 0.000125573, 0, 0.968254, 0.321648, 0.000119867, 0, 1, 1, 3.62511e-06, 0, 0, 1, 3.62525e-06, 0, 0, 1, 3.62739e-06, 0, 0, 0.999999, 3.63673e-06, 0, 0, 0.999998, 3.66214e-06, 0, 0, 0.999996, 3.71698e-06, 0, 0, 0.999992, 3.82116e-06, 0, 0, 0.999986, 4.00554e-06, 0, 0, 0.999976, 4.32058e-06, 0, 0, 0.999961, 4.85194e-06, 0, 0, 0.999938, 5.74808e-06, 0, 0, 0.999908, 7.26643e-06, 0, 0, 0.999865, 9.84707e-06, 0, 0, 0.999807, 1.42217e-05, 0, 0, 0.999723, 2.15581e-05, 0, 0, 0.999602, 3.36114e-05, 0, 1.19113e-05, 0.999398, 5.27353e-05, 0, 0.000355813, 0.998946, 8.05809e-05, 0, 0.00137768, 0.996647, 9.42908e-05, 0, 0.00322469, 0.992298, 6.68733e-05, 0, 0.00597897, 0.989802, 7.16564e-05, 0, 0.00968903, 0.987019, 8.21355e-05, 0, 0.0143845, 0.984219, 0.000104555, 0, 0.0200831, 0.980425, 0.000131245, 0, 0.0267948, 0.974241, 0.000139613, 0, 0.034525, 0.967006, 0.000145931, 0, 0.0432757, 0.95893, 0.000167153, 0, 0.0530471, 0.949157, 0.000188146, 0, 0.0638386, 0.94062, 0.000194625, 0, 0.0756487, 0.933509, 0.000213721, 0, 0.0884762, 0.925088, 0.000229616, 0, 0.10232, 0.915178, 0.000239638, 0, 0.117178, 0.904093, 0.000254814, 0, 0.133051, 0.891337, 0.000263685, 0, 0.149939, 0.877326, 0.000274789, 0, 0.167841, 0.861794, 0.000280534, 0, 0.18676, 0.845758, 0.000289534, 0, 0.206696, 0.829792, 0.000294446, 0, 0.22765, 0.813037, 0.000296877, 0, 0.249625, 0.795285, 0.000300217, 0, 0.27262, 0.776323, 0.000299826, 0, 0.296636, 0.756673, 0.000299787, 0, 0.321671, 0.736856, 0.000297867, 0, 0.347718, 0.716883, 0.000294052, 0, 0.374768, 0.696089, 0.000289462, 0, 0.402804, 0.67505, 0.000285212, 0, 0.431796, 0.653509, 0.00027653, 0, 0.461695, 0.63258, 0.000271759, 0, 0.49242, 0.61104, 0.000262811, 0, 0.523822, 0.589567, 0.000255151, 0, 0.555556, 0.568322, 0.000246434, 0, 0.587302, 0.547235, 0.000237061, 0, 0.619048, 0.52616, 0.000228343, 0, 0.650794, 0.505716, 0.000219236, 0, 0.68254, 0.485274, 0.000209595, 0, 0.714286, 0.465411, 0.000201011, 0, 0.746032, 0.445854, 0.00019109, 0, 0.777778, 0.426911, 0.000182897, 0, 0.809524, 0.408222, 0.000173569, 0, 0.84127, 0.390307, 0.000165496, 0, 0.873016, 0.372624, 0.000156799, 0, 0.904762, 0.355804, 0.00014917, 0, 0.936508, 0.33924, 0.000140907, 0, 0.968254, 0.323534, 0.000134062, 0, 1, 1, 6.22487e-06, 0, 0, 1, 6.2251e-06, 0, 0, 1, 6.22837e-06, 0, 0, 0.999999, 6.24259e-06, 0, 0, 0.999998, 6.28127e-06, 0, 0, 0.999996, 6.36451e-06, 0, 0, 0.999991, 6.5218e-06, 0, 0, 0.999984, 6.79782e-06, 0, 0, 0.999973, 7.26361e-06, 0, 0, 0.999955, 8.03644e-06, 0, 0, 0.999931, 9.31397e-06, 0, 0, 0.999896, 1.14299e-05, 0, 0, 0.999847, 1.49402e-05, 0, 0, 0.999784, 2.07461e-05, 0, 0, 0.999692, 3.02493e-05, 0, 0, 0.999554, 4.54957e-05, 0, 9.97275e-05, 0.999326, 6.90762e-05, 0, 0.000724813, 0.998757, 0.000101605, 0, 0.0020972, 0.995367, 9.58745e-05, 0, 0.00432324, 0.99209, 8.32808e-05, 0, 0.00746347, 0.989517, 8.87601e-05, 0, 0.0115534, 0.987008, 0.00010564, 0, 0.0166134, 0.98421, 0.000133179, 0, 0.0226552, 0.98021, 0.000161746, 0, 0.0296838, 0.973676, 0.000161821, 0, 0.0377016, 0.967052, 0.000178635, 0, 0.0467079, 0.959385, 0.000206765, 0, 0.0567013, 0.949461, 0.00022476, 0, 0.0676796, 0.939578, 0.00023574, 0, 0.0796403, 0.932416, 0.00025893, 0, 0.0925812, 0.923759, 0.000271228, 0, 0.106501, 0.914223, 0.000289165, 0, 0.121397, 0.902942, 0.000301156, 0, 0.13727, 0.890419, 0.000313852, 0, 0.15412, 0.876639, 0.000324408, 0, 0.171946, 0.861316, 0.00033249, 0, 0.190751, 0.84496, 0.000338497, 0, 0.210537, 0.828427, 0.000345861, 0, 0.231305, 0.811871, 0.000347863, 0, 0.253057, 0.794397, 0.000350225, 0, 0.275797, 0.775726, 0.000349915, 0, 0.299525, 0.75617, 0.000347297, 0, 0.324242, 0.736091, 0.000344232, 0, 0.349947, 0.716213, 0.000340835, 0, 0.376633, 0.695736, 0.000332369, 0, 0.404289, 0.674961, 0.000327943, 0, 0.432895, 0.653518, 0.000318533, 0, 0.462415, 0.632574, 0.000310391, 0, 0.492788, 0.61134, 0.000300755, 0, 0.523909, 0.590017, 0.000290506, 0, 0.555556, 0.568752, 0.000280446, 0, 0.587302, 0.548061, 0.000269902, 0, 0.619048, 0.52711, 0.000258815, 0, 0.650794, 0.506682, 0.000248481, 0, 0.68254, 0.486524, 0.000237141, 0, 0.714286, 0.466812, 0.000226872, 0, 0.746032, 0.44732, 0.000216037, 0, 0.777778, 0.428473, 0.000205629, 0, 0.809524, 0.409921, 0.000195691, 0, 0.84127, 0.392028, 0.000185457, 0, 0.873016, 0.374606, 0.000176436, 0, 0.904762, 0.357601, 0.000166508, 0, 0.936508, 0.341348, 0.000158385, 0, 0.968254, 0.32542, 0.000149203, 0, 1, 1, 1.03967e-05, 0, 0, 1, 1.0397e-05, 0, 0, 1, 1.04019e-05, 0, 0, 0.999999, 1.04231e-05, 0, 0, 0.999998, 1.04806e-05, 0, 0, 0.999995, 1.06042e-05, 0, 0, 0.999991, 1.08366e-05, 0, 0, 0.999982, 1.12415e-05, 0, 0, 0.999968, 1.19174e-05, 0, 0, 0.99995, 1.30227e-05, 0, 0, 0.999922, 1.48176e-05, 0, 0, 0.999884, 1.77303e-05, 0, 0, 0.99983, 2.24564e-05, 0, 0, 0.999758, 3.00966e-05, 0, 0, 0.999654, 4.23193e-05, 0, 5.49083e-06, 0.999503, 6.14848e-05, 0, 0.000296087, 0.999237, 9.03576e-05, 0, 0.00123144, 0.998491, 0.0001271, 0, 0.00295954, 0.994594, 0.000107754, 0, 0.00555829, 0.99178, 0.000103025, 0, 0.00907209, 0.989265, 0.00011154, 0, 0.0135257, 0.986998, 0.000136296, 0, 0.0189327, 0.984137, 0.000169154, 0, 0.0252993, 0.979798, 0.000196671, 0, 0.0326272, 0.97337, 0.000196678, 0, 0.0409157, 0.967239, 0.000223121, 0, 0.0501623, 0.959543, 0.000253809, 0, 0.0603638, 0.949466, 0.000265972, 0, 0.0715171, 0.939074, 0.000288372, 0, 0.0836187, 0.931118, 0.000310983, 0, 0.0966657, 0.922525, 0.000325561, 0, 0.110656, 0.912983, 0.000345725, 0, 0.125588, 0.901617, 0.0003556, 0, 0.141461, 0.889487, 0.000374012, 0, 0.158275, 0.875787, 0.000383445, 0, 0.176031, 0.860654, 0.000393972, 0, 0.19473, 0.844417, 0.000400311, 0, 0.214374, 0.82741, 0.000405004, 0, 0.234967, 0.810545, 0.000407378, 0, 0.256512, 0.793312, 0.000407351, 0, 0.279011, 0.774847, 0.000406563, 0, 0.302468, 0.755621, 0.000404903, 0, 0.326887, 0.735511, 0.000397486, 0, 0.352266, 0.715435, 0.00039357, 0, 0.378605, 0.695403, 0.000384739, 0, 0.405897, 0.674681, 0.000376108, 0, 0.43413, 0.65359, 0.000365997, 0, 0.463277, 0.632471, 0.000354957, 0, 0.493295, 0.61151, 0.000343593, 0, 0.524106, 0.59064, 0.000331841, 0, 0.555561, 0.569386, 0.000318891, 0, 0.587302, 0.548785, 0.0003072, 0, 0.619048, 0.528146, 0.00029361, 0, 0.650794, 0.507872, 0.000281709, 0, 0.68254, 0.487805, 0.000268627, 0, 0.714286, 0.468196, 0.000255887, 0, 0.746032, 0.448922, 0.000243997, 0, 0.777778, 0.430093, 0.000231662, 0, 0.809524, 0.411845, 0.000220339, 0, 0.84127, 0.393808, 0.000208694, 0, 0.873016, 0.376615, 0.000198045, 0, 0.904762, 0.359655, 0.000187375, 0, 0.936508, 0.343452, 0.000177371, 0, 0.968254, 0.32765, 0.000167525, 0, 1, 1, 1.69351e-05, 0, 0, 1, 1.69356e-05, 0, 0, 1, 1.69427e-05, 0, 0, 0.999999, 1.69736e-05, 0, 0, 0.999998, 1.70575e-05, 0, 0, 0.999995, 1.72372e-05, 0, 0, 0.99999, 1.75739e-05, 0, 0, 0.999979, 1.81568e-05, 0, 0, 0.999966, 1.91206e-05, 0, 0, 0.999944, 2.0677e-05, 0, 0, 0.999912, 2.31644e-05, 0, 0, 0.999869, 2.71268e-05, 0, 0, 0.999811, 3.34272e-05, 0, 0, 0.99973, 4.33979e-05, 0, 0, 0.999617, 5.90083e-05, 0, 6.80315e-05, 0.999445, 8.29497e-05, 0, 0.000612796, 0.999138, 0.000118019, 0, 0.00187408, 0.998095, 0.000156712, 0, 0.00395791, 0.993919, 0.000125054, 0, 0.00692144, 0.991333, 0.000126091, 0, 0.0107962, 0.989226, 0.000144912, 0, 0.0155986, 0.986954, 0.000175737, 0, 0.0213364, 0.983982, 0.000213883, 0, 0.0280114, 0.979128, 0.000234526, 0, 0.0356226, 0.973327, 0.000243725, 0, 0.0441668, 0.967416, 0.0002773, 0, 0.0536399, 0.959729, 0.000308799, 0, 0.0640376, 0.949758, 0.000322447, 0, 0.0753554, 0.939173, 0.000350021, 0, 0.0875893, 0.9296, 0.000370089, 0, 0.100736, 0.921181, 0.000391365, 0, 0.114793, 0.91164, 0.000413636, 0, 0.129759, 0.900435, 0.000427068, 0, 0.145632, 0.888183, 0.000441046, 0, 0.162412, 0.874772, 0.000454968, 0, 0.180101, 0.859566, 0.000461882, 0, 0.1987, 0.843579, 0.000471556, 0, 0.218213, 0.826453, 0.000474335, 0, 0.238641, 0.809164, 0.000477078, 0, 0.259989, 0.792179, 0.00047755, 0, 0.282262, 0.773866, 0.000472573, 0, 0.305464, 0.754944, 0.000469765, 0, 0.329599, 0.735133, 0.000462371, 0, 0.35467, 0.714858, 0.000453674, 0, 0.380678, 0.694829, 0.000443888, 0, 0.407622, 0.674453, 0.000432052, 0, 0.435493, 0.653685, 0.000420315, 0, 0.464275, 0.632666, 0.000406829, 0, 0.493938, 0.611676, 0.000392234, 0, 0.524422, 0.591193, 0.000379208, 0, 0.555624, 0.570145, 0.00036319, 0, 0.587302, 0.549566, 0.000349111, 0, 0.619048, 0.529278, 0.000334166, 0, 0.650794, 0.509026, 0.000318456, 0, 0.68254, 0.489186, 0.00030449, 0, 0.714286, 0.469662, 0.000289051, 0, 0.746032, 0.450691, 0.000275494, 0, 0.777778, 0.431841, 0.000261437, 0, 0.809524, 0.413752, 0.000247846, 0, 0.84127, 0.395951, 0.000235085, 0, 0.873016, 0.378633, 0.000222245, 0, 0.904762, 0.36194, 0.000210533, 0, 0.936508, 0.345599, 0.000198494, 0, 0.968254, 0.329999, 0.000188133, 0, 1, 1, 2.69663e-05, 0, 0, 1, 2.6967e-05, 0, 0, 1, 2.69772e-05, 0, 0, 0.999999, 2.70214e-05, 0, 0, 0.999998, 2.71415e-05, 0, 0, 0.999994, 2.7398e-05, 0, 0, 0.999988, 2.78771e-05, 0, 0, 0.999977, 2.87019e-05, 0, 0, 0.999961, 3.00544e-05, 0, 0, 0.999937, 3.22138e-05, 0, 0, 0.999904, 3.56163e-05, 0, 0, 0.999854, 4.09465e-05, 0, 0, 0.99979, 4.92651e-05, 0, 0, 0.999699, 6.21722e-05, 0, 8.8288e-07, 0.999572, 8.19715e-05, 0, 0.000223369, 0.999381, 0.000111689, 0, 0.00105414, 0.999016, 0.000153862, 0, 0.0026493, 0.997437, 0.000187667, 0, 0.00508608, 0.993545, 0.000155672, 0, 0.00840554, 0.991135, 0.000161455, 0, 0.012629, 0.989157, 0.000188241, 0, 0.0177661, 0.986874, 0.000226229, 0, 0.0238198, 0.983714, 0.000268668, 0, 0.0307887, 0.978301, 0.000277109, 0, 0.0386688, 0.973227, 0.000303446, 0, 0.0474554, 0.967317, 0.000341851, 0, 0.0571428, 0.959477, 0.000370885, 0, 0.0677256, 0.950012, 0.000392753, 0, 0.0791988, 0.939484, 0.00042781, 0, 0.0915576, 0.928135, 0.000443866, 0, 0.104798, 0.919819, 0.000472959, 0, 0.118918, 0.910049, 0.000491551, 0, 0.133915, 0.899181, 0.000512616, 0, 0.149788, 0.886881, 0.000523563, 0, 0.166537, 0.87359, 0.000540183, 0, 0.184164, 0.858613, 0.000547386, 0, 0.202669, 0.842809, 0.000554809, 0, 0.222056, 0.825727, 0.000558316, 0, 0.242329, 0.808086, 0.000557824, 0, 0.263492, 0.790728, 0.000556346, 0, 0.285551, 0.772987, 0.000552672, 0, 0.30851, 0.7541, 0.000543738, 0, 0.332376, 0.734669, 0.000536107, 0, 0.357153, 0.714411, 0.000523342, 0, 0.382845, 0.694196, 0.000512238, 0, 0.409454, 0.674252, 0.000497465, 0, 0.436977, 0.65357, 0.000481096, 0, 0.465404, 0.632999, 0.000467054, 0, 0.494713, 0.611994, 0.000448771, 0, 0.524864, 0.591604, 0.000431889, 0, 0.555779, 0.571134, 0.000415238, 0, 0.587302, 0.550528, 0.000396369, 0, 0.619048, 0.530292, 0.000379477, 0, 0.650794, 0.510364, 0.000361488, 0, 0.68254, 0.490749, 0.000343787, 0, 0.714286, 0.471266, 0.000327822, 0, 0.746032, 0.452462, 0.000310626, 0, 0.777778, 0.433907, 0.000295352, 0, 0.809524, 0.415659, 0.000279179, 0, 0.84127, 0.398138, 0.000264685, 0, 0.873016, 0.380833, 0.000249905, 0, 0.904762, 0.364247, 0.000236282, 0, 0.936508, 0.348041, 0.000222905, 0, 0.968254, 0.332389, 0.000210522, 0, 1, 1, 4.20604e-05, 0, 0, 1, 4.20614e-05, 0, 0, 1, 4.20757e-05, 0, 0, 0.999999, 4.2138e-05, 0, 0, 0.999997, 4.23067e-05, 0, 0, 0.999993, 4.26668e-05, 0, 0, 0.999986, 4.33372e-05, 0, 0, 0.999974, 4.44857e-05, 0, 0, 0.999956, 4.63554e-05, 0, 0, 0.99993, 4.93105e-05, 0, 0, 0.999892, 5.39077e-05, 0, 0, 0.999838, 6.10005e-05, 0, 0, 0.999767, 7.18822e-05, 0, 0, 0.999666, 8.84581e-05, 0, 3.65471e-05, 0.999525, 0.000113398, 0, 0.000485623, 0.999311, 0.000150043, 0, 0.00162096, 0.998865, 0.000200063, 0, 0.00355319, 0.996278, 0.000211014, 0, 0.00633818, 0.992956, 0.000189672, 0, 0.0100043, 0.991017, 0.000210262, 0, 0.0145648, 0.989055, 0.000244292, 0, 0.0200237, 0.986741, 0.000290481, 0, 0.0263798, 0.983288, 0.000334303, 0, 0.033629, 0.977784, 0.000340307, 0, 0.0417652, 0.973037, 0.000377864, 0, 0.0507821, 0.967181, 0.0004239, 0, 0.060673, 0.958971, 0.000443854, 0, 0.0714314, 0.950093, 0.000483039, 0, 0.0830518, 0.939552, 0.000517934, 0, 0.0955288, 0.927678, 0.000539449, 0, 0.108859, 0.918278, 0.000568604, 0, 0.123038, 0.908449, 0.000588505, 0, 0.138065, 0.897713, 0.000612473, 0, 0.153938, 0.885533, 0.000625575, 0, 0.170657, 0.872131, 0.00063854, 0, 0.188224, 0.857517, 0.000647034, 0, 0.20664, 0.841796, 0.00065209, 0, 0.225909, 0.824726, 0.0006544, 0, 0.246035, 0.807297, 0.000655744, 0, 0.267022, 0.789058, 0.000646716, 0, 0.288878, 0.77189, 0.000643898, 0, 0.311607, 0.753082, 0.000629973, 0, 0.335216, 0.7341, 0.000621564, 0, 0.359713, 0.714094, 0.000605171, 0, 0.385103, 0.693839, 0.000588752, 0, 0.41139, 0.673891, 0.000573294, 0, 0.438576, 0.653565, 0.000552682, 0, 0.466656, 0.633326, 0.000533446, 0, 0.495617, 0.612582, 0.000514635, 0, 0.525431, 0.59205, 0.00049303, 0, 0.556041, 0.571918, 0.000471842, 0, 0.587338, 0.551572, 0.000451713, 0, 0.619048, 0.531553, 0.000430049, 0, 0.650794, 0.51175, 0.000410445, 0, 0.68254, 0.49238, 0.000390098, 0, 0.714286, 0.473143, 0.000370033, 0, 0.746032, 0.45423, 0.000351205, 0, 0.777778, 0.435963, 0.000332049, 0, 0.809524, 0.41787, 0.000315021, 0, 0.84127, 0.400387, 0.000297315, 0, 0.873016, 0.383332, 0.000281385, 0, 0.904762, 0.366665, 0.000265397, 0, 0.936508, 0.350633, 0.000250601, 0, 0.968254, 0.334964, 0.00023589, 0, 1, 1, 6.43736e-05, 0, 0, 1, 6.4375e-05, 0, 0, 1, 6.43947e-05, 0, 0, 0.999999, 6.4481e-05, 0, 0, 0.999997, 6.47143e-05, 0, 0, 0.999994, 6.52119e-05, 0, 0, 0.999985, 6.61359e-05, 0, 0, 0.999972, 6.77116e-05, 0, 0, 0.999952, 7.02599e-05, 0, 0, 0.999922, 7.42517e-05, 0, 0, 0.99988, 8.03906e-05, 0, 0, 0.99982, 8.97315e-05, 0, 0, 0.999741, 0.000103838, 0, 0, 0.999629, 0.00012496, 0, 0.000149024, 0.999474, 0.000156161, 0, 0.000861027, 0.999229, 0.000201034, 0, 0.00231198, 0.998662, 0.000259069, 0, 0.00458147, 0.995299, 0.000245439, 0, 0.00770895, 0.992732, 0.00024498, 0, 0.0117126, 0.990847, 0.000273211, 0, 0.0165989, 0.988911, 0.000316492, 0, 0.0223674, 0.98654, 0.00037161, 0, 0.0290135, 0.982636, 0.000410352, 0, 0.0365309, 0.977346, 0.000421756, 0, 0.0449117, 0.972909, 0.000475578, 0, 0.0541481, 0.966821, 0.000522482, 0, 0.0642326, 0.958686, 0.000545008, 0, 0.075158, 0.949754, 0.000589286, 0, 0.0869181, 0.939184, 0.000619995, 0, 0.0995074, 0.927505, 0.000654266, 0, 0.112922, 0.916606, 0.000682362, 0, 0.127157, 0.906707, 0.000704286, 0, 0.142212, 0.895937, 0.000725909, 0, 0.158085, 0.883913, 0.000743939, 0, 0.174776, 0.870642, 0.000755157, 0, 0.192287, 0.856241, 0.000764387, 0, 0.210619, 0.84069, 0.000771032, 0, 0.229775, 0.823728, 0.000765906, 0, 0.249761, 0.806481, 0.000767604, 0, 0.270582, 0.787924, 0.000754385, 0, 0.292243, 0.770588, 0.000749668, 0, 0.314753, 0.751991, 0.000731613, 0, 0.338118, 0.733407, 0.000717655, 0, 0.362347, 0.713688, 0.000700604, 0, 0.387447, 0.693595, 0.000678765, 0, 0.413424, 0.673426, 0.000657042, 0, 0.440284, 0.65359, 0.000635892, 0, 0.468027, 0.633576, 0.000611569, 0, 0.496645, 0.613144, 0.000586011, 0, 0.526122, 0.592711, 0.000563111, 0, 0.556417, 0.572722, 0.000537699, 0, 0.587451, 0.552762, 0.000512556, 0, 0.619048, 0.532985, 0.000489757, 0, 0.650794, 0.513219, 0.000464139, 0, 0.68254, 0.493992, 0.000442193, 0, 0.714286, 0.47509, 0.000418629, 0, 0.746032, 0.456287, 0.000397045, 0, 0.777778, 0.438152, 0.000375504, 0, 0.809524, 0.420294, 0.00035492, 0, 0.84127, 0.402749, 0.000335327, 0, 0.873016, 0.385879, 0.000316422, 0, 0.904762, 0.369352, 0.000298333, 0, 0.936508, 0.353301, 0.000281417, 0, 0.968254, 0.337781, 0.000265203, 0, 1, 1, 9.68267e-05, 0, 0, 1, 9.68284e-05, 0, 0, 1, 9.68556e-05, 0, 0, 0.999999, 9.69733e-05, 0, 0, 0.999997, 9.72913e-05, 0, 0, 0.999993, 9.79688e-05, 0, 0, 0.999984, 9.92239e-05, 0, 0, 0.999969, 0.000101356, 0, 0, 0.999946, 0.000104784, 0, 0, 0.999913, 0.000110111, 0, 0, 0.999868, 0.000118217, 0, 0, 0.999801, 0.000130396, 0, 0, 0.999712, 0.000148523, 0, 1.24907e-05, 0.999589, 0.000175233, 0, 0.000355405, 0.999416, 0.000213999, 0, 0.0013528, 0.999136, 0.000268529, 0, 0.00312557, 0.998367, 0.000333088, 0, 0.00573045, 0.994701, 0.000304757, 0, 0.00919397, 0.992497, 0.000318031, 0, 0.0135261, 0.990608, 0.000353863, 0, 0.0187278, 0.988715, 0.000409044, 0, 0.0247947, 0.986241, 0.000472967, 0, 0.0317196, 0.981696, 0.000495104, 0, 0.039494, 0.977097, 0.000532873, 0, 0.0481087, 0.972583, 0.000594447, 0, 0.0575549, 0.966142, 0.000636867, 0, 0.0678242, 0.95823, 0.000669899, 0, 0.0789089, 0.949677, 0.000719499, 0, 0.0908023, 0.939226, 0.000750584, 0, 0.103499, 0.927501, 0.000793183, 0, 0.116993, 0.915199, 0.00081995, 0, 0.131282, 0.90498, 0.000847654, 0, 0.146364, 0.894243, 0.000868929, 0, 0.162237, 0.882154, 0.000884278, 0, 0.178902, 0.869161, 0.000898108, 0, 0.196358, 0.854751, 0.000901254, 0, 0.21461, 0.839368, 0.00090679, 0, 0.23366, 0.822874, 0.000901541, 0, 0.253512, 0.805514, 0.000897297, 0, 0.274174, 0.78716, 0.000881856, 0, 0.29565, 0.769061, 0.000870032, 0, 0.31795, 0.751, 0.000851719, 0, 0.341081, 0.732614, 0.000830671, 0, 0.365053, 0.713171, 0.000806569, 0, 0.389874, 0.693472, 0.00078338, 0, 0.415553, 0.673528, 0.000756404, 0, 0.442098, 0.653397, 0.000726872, 0, 0.469512, 0.633781, 0.000700494, 0, 0.497794, 0.613877, 0.00067105, 0, 0.526935, 0.593506, 0.000640361, 0, 0.556908, 0.573667, 0.000613502, 0, 0.587657, 0.553932, 0.000583177, 0, 0.61906, 0.534345, 0.000554375, 0, 0.650794, 0.515042, 0.000527811, 0, 0.68254, 0.495674, 0.000499367, 0, 0.714286, 0.477132, 0.00047429, 0, 0.746032, 0.458609, 0.000447726, 0, 0.777778, 0.440354, 0.000424205, 0, 0.809524, 0.422765, 0.000399549, 0, 0.84127, 0.405472, 0.000378315, 0, 0.873016, 0.388482, 0.000355327, 0, 0.904762, 0.372191, 0.000336122, 0, 0.936508, 0.356099, 0.000315247, 0, 0.968254, 0.340737, 0.00029794, 0, 1, 1, 0.000143327, 0, 0, 1, 0.00014333, 0, 0, 1, 0.000143366, 0, 0, 0.999999, 0.000143524, 0, 0, 0.999996, 0.000143952, 0, 0, 0.999991, 0.000144862, 0, 0, 0.999981, 0.000146544, 0, 0, 0.999966, 0.000149391, 0, 0, 0.999941, 0.000153946, 0, 0, 0.999905, 0.000160971, 0, 0, 0.999852, 0.000171562, 0, 0, 0.99978, 0.00018729, 0, 0, 0.999681, 0.000210386, 0, 8.26239e-05, 0.999546, 0.000243906, 0, 0.000664807, 0.999352, 0.000291739, 0, 0.00196192, 0.999027, 0.000357419, 0, 0.00405941, 0.997886, 0.000422349, 0, 0.00699664, 0.99419, 0.000385008, 0, 0.0107896, 0.99214, 0.000409775, 0, 0.0154415, 0.990274, 0.000456418, 0, 0.0209488, 0.988455, 0.000527008, 0, 0.0273037, 0.985804, 0.000597685, 0, 0.0344969, 0.98103, 0.000613124, 0, 0.0425183, 0.976674, 0.000668321, 0, 0.0513575, 0.972021, 0.000736985, 0, 0.0610046, 0.965274, 0.000773789, 0, 0.0714508, 0.958046, 0.000830852, 0, 0.0826877, 0.949333, 0.000875766, 0, 0.0947085, 0.939135, 0.000917088, 0, 0.107507, 0.927119, 0.000952244, 0, 0.121078, 0.91469, 0.000990626, 0, 0.135419, 0.903006, 0.00101304, 0, 0.150526, 0.892368, 0.00103834, 0, 0.166399, 0.880231, 0.00105002, 0, 0.183038, 0.867432, 0.00106331, 0, 0.200443, 0.853208, 0.00106783, 0, 0.218618, 0.837956, 0.00106458, 0, 0.237566, 0.821772, 0.00105945, 0, 0.257291, 0.804328, 0.00104685, 0, 0.2778, 0.786465, 0.00103178, 0, 0.2991, 0.768004, 0.00101077, 0, 0.321199, 0.74972, 0.000985504, 0, 0.344106, 0.731682, 0.000962893, 0, 0.36783, 0.712813, 0.000932146, 0, 0.392383, 0.693139, 0.00089871, 0, 0.417774, 0.673566, 0.000869678, 0, 0.444013, 0.653483, 0.000835525, 0, 0.471107, 0.633891, 0.000799853, 0, 0.49906, 0.614433, 0.000766838, 0, 0.527869, 0.594586, 0.000732227, 0, 0.557517, 0.574769, 0.000696442, 0, 0.587966, 0.555149, 0.000663935, 0, 0.61913, 0.535898, 0.000629826, 0, 0.650794, 0.516753, 0.000596486, 0, 0.68254, 0.497816, 0.000567078, 0, 0.714286, 0.479034, 0.000534399, 0, 0.746032, 0.460975, 0.000507013, 0, 0.777778, 0.442935, 0.000477421, 0, 0.809524, 0.425263, 0.000451101, 0, 0.84127, 0.408248, 0.000424964, 0, 0.873016, 0.391339, 0.00039993, 0, 0.904762, 0.37513, 0.000377619, 0, 0.936508, 0.359172, 0.000354418, 0, 0.968254, 0.343876, 0.000334823, 0, 1, 1, 0.000209042, 0, 0, 1, 0.000209045, 0, 0, 1, 0.000209093, 0, 0, 0.999999, 0.000209304, 0, 0, 0.999996, 0.000209871, 0, 0, 0.999991, 0.000211078, 0, 0, 0.999979, 0.000213304, 0, 0, 0.999963, 0.000217061, 0, 0, 0.999933, 0.000223042, 0, 0, 0.999894, 0.000232206, 0, 0, 0.999837, 0.000245901, 0, 0, 0.999756, 0.000266023, 0, 1.02927e-06, 0.999648, 0.000295204, 0, 0.000233468, 0.999499, 0.000336958, 0, 0.00108237, 0.999283, 0.000395563, 0, 0.00268832, 0.998896, 0.000473785, 0, 0.00511138, 0.997006, 0.000520008, 0, 0.00837705, 0.993819, 0.000497261, 0, 0.0124928, 0.991632, 0.000523722, 0, 0.0174561, 0.989875, 0.000587258, 0, 0.0232596, 0.988109, 0.000676329, 0, 0.0298932, 0.985155, 0.000747701, 0, 0.0373453, 0.980479, 0.000768803, 0, 0.0456045, 0.976271, 0.000841054, 0, 0.0546593, 0.971347, 0.000911469, 0, 0.0644994, 0.964528, 0.000953057, 0, 0.0751152, 0.957632, 0.00102221, 0, 0.0864981, 0.948681, 0.00106122, 0, 0.0986407, 0.938716, 0.00111857, 0, 0.111537, 0.926629, 0.00114762, 0, 0.125182, 0.914025, 0.00118995, 0, 0.139571, 0.901026, 0.00121228, 0, 0.154703, 0.890358, 0.00123946, 0, 0.170576, 0.878283, 0.0012527, 0, 0.18719, 0.865459, 0.00125536, 0, 0.204547, 0.851407, 0.00126134, 0, 0.222648, 0.836276, 0.00124759, 0, 0.241498, 0.820436, 0.00124443, 0, 0.261101, 0.803253, 0.00122071, 0, 0.281465, 0.785562, 0.00120107, 0, 0.302595, 0.76718, 0.00117762, 0, 0.324501, 0.748551, 0.00114289, 0, 0.347192, 0.730564, 0.00110872, 0, 0.370679, 0.712253, 0.00107636, 0, 0.394973, 0.692867, 0.00103646, 0, 0.420085, 0.673695, 0.000996793, 0, 0.446027, 0.653912, 0.00095675, 0, 0.47281, 0.634129, 0.000916739, 0, 0.500441, 0.615004, 0.000874401, 0, 0.528921, 0.595587, 0.000833411, 0, 0.558244, 0.575965, 0.000794556, 0, 0.588384, 0.5566, 0.00075196, 0, 0.619281, 0.537428, 0.000716381, 0, 0.650795, 0.518623, 0.000676558, 0, 0.68254, 0.499964, 0.00064074, 0, 0.714286, 0.481356, 0.000605984, 0, 0.746032, 0.463279, 0.000570256, 0, 0.777778, 0.445673, 0.000540138, 0, 0.809524, 0.428032, 0.000507299, 0, 0.84127, 0.411112, 0.000479553, 0, 0.873016, 0.394444, 0.000450737, 0, 0.904762, 0.378247, 0.000424269, 0, 0.936508, 0.362415, 0.000399111, 0, 0.968254, 0.347103, 0.000375274, 0, 1, 1, 0.000300729, 0, 0, 1, 0.000300733, 0, 0, 1, 0.000300797, 0, 0, 0.999998, 0.000301072, 0, 0, 0.999996, 0.000301817, 0, 0, 0.999989, 0.000303398, 0, 0, 0.999977, 0.000306309, 0, 0, 0.999958, 0.000311209, 0, 0, 0.999927, 0.000318975, 0, 0, 0.999884, 0.000330804, 0, 0, 0.99982, 0.00034834, 0, 0, 0.999733, 0.000373854, 0, 3.26995e-05, 0.999613, 0.000410424, 0, 0.000477174, 0.999447, 0.000462047, 0, 0.00161099, 0.999204, 0.000533322, 0, 0.00353153, 0.998725, 0.000624964, 0, 0.00627965, 0.995871, 0.000631786, 0, 0.0098693, 0.993194, 0.000632017, 0, 0.0143011, 0.991541, 0.00068923, 0, 0.019568, 0.989773, 0.000766892, 0, 0.0256593, 0.987647, 0.000863668, 0, 0.0325625, 0.984193, 0.000922089, 0, 0.0402647, 0.980016, 0.000970749, 0, 0.0487532, 0.975859, 0.00106027, 0, 0.058016, 0.970514, 0.00112239, 0, 0.0680419, 0.963625, 0.00117212, 0, 0.0788208, 0.956959, 0.00125211, 0, 0.0903439, 0.947956, 0.00129411, 0, 0.102604, 0.93809, 0.00135879, 0, 0.115594, 0.92659, 0.00139309, 0, 0.129309, 0.913829, 0.00143253, 0, 0.143745, 0.90005, 0.00145809, 0, 0.158901, 0.888129, 0.0014748, 0, 0.174774, 0.87607, 0.00148756, 0, 0.191365, 0.863461, 0.00148714, 0, 0.208674, 0.849594, 0.00148892, 0, 0.226705, 0.834531, 0.00146496, 0, 0.245461, 0.81903, 0.0014579, 0, 0.264947, 0.802122, 0.00143039, 0, 0.28517, 0.78445, 0.00139717, 0, 0.306137, 0.766434, 0.00136312, 0, 0.327857, 0.747816, 0.00132597, 0, 0.350341, 0.729519, 0.00128323, 0, 0.373598, 0.711454, 0.00123803, 0, 0.397642, 0.692699, 0.00119097, 0, 0.422485, 0.673723, 0.00114565, 0, 0.448139, 0.654386, 0.00109552, 0, 0.474619, 0.634673, 0.00104553, 0, 0.501933, 0.615554, 0.00099985, 0, 0.530089, 0.596462, 0.000948207, 0, 0.559087, 0.577385, 0.000902299, 0, 0.588913, 0.558257, 0.000856448, 0, 0.619525, 0.5392, 0.000810395, 0, 0.650826, 0.520543, 0.000768558, 0, 0.68254, 0.502206, 0.0007239, 0, 0.714286, 0.48402, 0.000685794, 0, 0.746032, 0.465779, 0.00064471, 0, 0.777778, 0.448455, 0.000609583, 0, 0.809524, 0.431091, 0.00057227, 0, 0.84127, 0.414147, 0.00054042, 0, 0.873016, 0.39765, 0.000506545, 0, 0.904762, 0.381576, 0.000477635, 0, 0.936508, 0.365881, 0.000448446, 0, 0.968254, 0.350582, 0.000421424, 0, 1, 1, 0.000427144, 0, 0, 1, 0.000427151, 0, 0, 1, 0.000427232, 0, 0, 0.999998, 0.00042759, 0, 0, 0.999995, 0.000428555, 0, 0, 0.999988, 0.000430603, 0, 0, 0.999976, 0.000434368, 0, 0, 0.999952, 0.000440688, 0, 0, 0.999919, 0.000450667, 0, 0, 0.999871, 0.00046578, 0, 0, 0.999801, 0.000488024, 0, 0, 0.999704, 0.000520092, 0, 0.000129791, 0.999572, 0.000565553, 0, 0.000821056, 0.999389, 0.000628906, 0, 0.00225241, 0.999114, 0.000714911, 0, 0.00449109, 0.998488, 0.000819218, 0, 0.00756249, 0.995234, 0.00080415, 0, 0.0114716, 0.993021, 0.000830181, 0, 0.0162131, 0.991407, 0.000902645, 0, 0.021776, 0.989625, 0.000996934, 0, 0.0281471, 0.987064, 0.00109707, 0, 0.0353118, 0.983265, 0.00114353, 0, 0.0432562, 0.979535, 0.0012272, 0, 0.0519665, 0.975224, 0.00132642, 0, 0.0614298, 0.969574, 0.00138092, 0, 0.0716348, 0.963021, 0.00145896, 0, 0.0825709, 0.956046, 0.00152834, 0, 0.094229, 0.947136, 0.00158217, 0, 0.106602, 0.937313, 0.0016347, 0, 0.119682, 0.926073, 0.00168383, 0, 0.133465, 0.913121, 0.00171627, 0, 0.147947, 0.899165, 0.00174229, 0, 0.163125, 0.885891, 0.00176137, 0, 0.178998, 0.873783, 0.00176406, 0, 0.195566, 0.861331, 0.00176156, 0, 0.21283, 0.847569, 0.00175346, 0, 0.230793, 0.832785, 0.00172753, 0, 0.249459, 0.817442, 0.00170204, 0, 0.268832, 0.800613, 0.00166576, 0, 0.28892, 0.783597, 0.00162909, 0, 0.30973, 0.76571, 0.0015826, 0, 0.331271, 0.747021, 0.00153106, 0, 0.353554, 0.728593, 0.00148036, 0, 0.37659, 0.710661, 0.00142808, 0, 0.400391, 0.692426, 0.00136906, 0, 0.424973, 0.673623, 0.00131066, 0, 0.450347, 0.65494, 0.00125569, 0, 0.476531, 0.635448, 0.00119517, 0, 0.503535, 0.616221, 0.00113828, 0, 0.531372, 0.597531, 0.0010816, 0, 0.560047, 0.578795, 0.00102673, 0, 0.589554, 0.559892, 0.000970985, 0, 0.619869, 0.541307, 0.000919773, 0, 0.650923, 0.522608, 0.000868479, 0, 0.68254, 0.504484, 0.00082137, 0, 0.714286, 0.486603, 0.000772916, 0, 0.746032, 0.468802, 0.000730353, 0, 0.777778, 0.451172, 0.000684955, 0, 0.809524, 0.434348, 0.000647565, 0, 0.84127, 0.417445, 0.000605863, 0, 0.873016, 0.401077, 0.000571885, 0, 0.904762, 0.385039, 0.000536034, 0, 0.936508, 0.369483, 0.000504227, 0, 0.968254, 0.354272, 0.000473165, 0, 1, 1, 0.000599525, 0, 0, 1, 0.000599533, 0, 0, 1, 0.000599639, 0, 0, 0.999998, 0.000600097, 0, 0, 0.999994, 0.000601336, 0, 0, 0.999987, 0.000603958, 0, 0, 0.999972, 0.000608775, 0, 0, 0.999949, 0.000616842, 0, 0, 0.999912, 0.000629534, 0, 0, 0.999857, 0.000648658, 0, 0, 0.999781, 0.000676615, 0, 5.38873e-06, 0.999674, 0.000716574, 0, 0.000308602, 0.999528, 0.000772641, 0, 0.00127003, 0.999326, 0.000849806, 0, 0.00300783, 0.999009, 0.000952682, 0, 0.00556637, 0.998112, 0.00106394, 0, 0.00895889, 0.994496, 0.00102228, 0, 0.0131827, 0.992806, 0.00108586, 0, 0.0182277, 0.991211, 0.0011759, 0, 0.0240795, 0.989415, 0.00128955, 0, 0.030723, 0.986499, 0.00139038, 0, 0.0381418, 0.982679, 0.00144539, 0, 0.046321, 0.978839, 0.00153954, 0, 0.0552459, 0.974295, 0.00164417, 0, 0.0649034, 0.968784, 0.00171517, 0, 0.0752814, 0.962324, 0.00180282, 0, 0.0863693, 0.954956, 0.00186387, 0, 0.0981578, 0.94624, 0.00193817, 0, 0.110639, 0.936517, 0.00198156, 0, 0.123806, 0.925186, 0.00203042, 0, 0.137655, 0.91252, 0.0020664, 0, 0.15218, 0.898441, 0.00207822, 0, 0.16738, 0.884394, 0.0020992, 0, 0.183253, 0.871273, 0.00208748, 0, 0.199799, 0.859057, 0.00208686, 0, 0.21702, 0.845243, 0.00205519, 0, 0.234918, 0.830723, 0.00202868, 0, 0.253496, 0.815801, 0.00199501, 0, 0.272761, 0.79914, 0.00194193, 0, 0.292719, 0.782372, 0.00188824, 0, 0.313377, 0.76482, 0.00183695, 0, 0.334745, 0.746586, 0.00177418, 0, 0.356833, 0.7281, 0.00170628, 0, 0.379654, 0.709842, 0.00164063, 0, 0.403221, 0.692019, 0.00157355, 0, 0.427548, 0.67364, 0.00150262, 0, 0.452651, 0.655277, 0.00143473, 0, 0.478545, 0.636438, 0.00136371, 0, 0.505246, 0.617364, 0.00129911, 0, 0.532768, 0.598603, 0.00123014, 0, 0.561122, 0.580195, 0.00116587, 0, 0.590309, 0.561786, 0.00110398, 0, 0.620318, 0.543377, 0.00104148, 0, 0.651102, 0.525093, 0.000983984, 0, 0.682545, 0.506791, 0.00092667, 0, 0.714286, 0.489291, 0.000874326, 0, 0.746032, 0.471811, 0.000821734, 0, 0.777778, 0.454435, 0.000774698, 0, 0.809524, 0.437493, 0.000727302, 0, 0.84127, 0.420977, 0.000684039, 0, 0.873016, 0.404729, 0.00064373, 0, 0.904762, 0.388756, 0.00060285, 0, 0.936508, 0.373344, 0.00056765, 0, 0.968254, 0.358191, 0.000531929, 0, 1, 1, 0.000832169, 0, 0, 1, 0.000832178, 0, 0, 1, 0.00083231, 0, 0, 0.999998, 0.000832893, 0, 0, 0.999995, 0.000834465, 0, 0, 0.999985, 0.000837791, 0, 0, 0.999969, 0.000843893, 0, 0, 0.999944, 0.000854086, 0, 0, 0.999903, 0.000870071, 0, 0, 0.999843, 0.000894042, 0, 0, 0.999759, 0.000928865, 0, 5.31805e-05, 0.999643, 0.000978242, 0, 0.000579365, 0.99948, 0.00104684, 0, 0.00182774, 0.999255, 0.00114012, 0, 0.00387804, 0.998885, 0.00126188, 0, 0.00675709, 0.997405, 0.00135888, 0, 0.010468, 0.99424, 0.00133626, 0, 0.0150018, 0.992458, 0.00140905, 0, 0.0203443, 0.990929, 0.00152305, 0, 0.0264786, 0.989116, 0.00165882, 0, 0.0333875, 0.985624, 0.00174128, 0, 0.0410536, 0.982003, 0.00182108, 0, 0.0494609, 0.978336, 0.00194498, 0, 0.0585941, 0.973184, 0.00202708, 0, 0.0684396, 0.9678, 0.00212166, 0, 0.0789851, 0.961348, 0.00221366, 0, 0.0902199, 0.953841, 0.00228219, 0, 0.102134, 0.94534, 0.00235662, 0, 0.114721, 0.935552, 0.00240572, 0, 0.127972, 0.924064, 0.00244405, 0, 0.141884, 0.911827, 0.00247557, 0, 0.156451, 0.897731, 0.00248374, 0, 0.171672, 0.883409, 0.00249863, 0, 0.187545, 0.868625, 0.00246688, 0, 0.20407, 0.856529, 0.00246523, 0, 0.221249, 0.842999, 0.00242368, 0, 0.239083, 0.828505, 0.00237354, 0, 0.257578, 0.813825, 0.00232588, 0, 0.276738, 0.797813, 0.00226731, 0, 0.296569, 0.781097, 0.00219704, 0, 0.31708, 0.764038, 0.00212394, 0, 0.338281, 0.746067, 0.00204786, 0, 0.360181, 0.727687, 0.00196728, 0, 0.382794, 0.709571, 0.00188779, 0, 0.406133, 0.691503, 0.00180532, 0, 0.430213, 0.673673, 0.00171849, 0, 0.45505, 0.655732, 0.00164147, 0, 0.480662, 0.637399, 0.00155858, 0, 0.507065, 0.618616, 0.00147641, 0, 0.534278, 0.60005, 0.00140125, 0, 0.562313, 0.581713, 0.00132441, 0, 0.59118, 0.563546, 0.00125014, 0, 0.620875, 0.545605, 0.00118249, 0, 0.651373, 0.527559, 0.0011116, 0, 0.682593, 0.509764, 0.00104979, 0, 0.714286, 0.49193, 0.000985977, 0, 0.746032, 0.475011, 0.000928592, 0, 0.777778, 0.457878, 0.000873466, 0, 0.809524, 0.440979, 0.000819585, 0, 0.84127, 0.424613, 0.000772365, 0, 0.873016, 0.408549, 0.000722195, 0, 0.904762, 0.392771, 0.000680014, 0, 0.936508, 0.377317, 0.000636797, 0, 0.968254, 0.362352, 0.000598318, 0, 1, 1, 0.00114313, 0, 0, 1, 0.00114314, 0, 0, 0.999999, 0.00114331, 0, 0, 0.999998, 0.00114404, 0, 0, 0.999994, 0.00114601, 0, 0, 0.999984, 0.00115019, 0, 0, 0.999967, 0.00115784, 0, 0, 0.999937, 0.0011706, 0, 0, 0.999894, 0.00119054, 0, 0, 0.999828, 0.00122031, 0, 0, 0.999735, 0.00126331, 0, 0.000169263, 0.999606, 0.00132382, 0, 0.000949167, 0.999426, 0.0014071, 0, 0.00249668, 0.999173, 0.00151895, 0, 0.00486392, 0.99873, 0.00166102, 0, 0.00806323, 0.996243, 0.0017023, 0, 0.0120895, 0.993779, 0.00172782, 0, 0.0169288, 0.9919, 0.0018108, 0, 0.0225633, 0.990524, 0.00196028, 0, 0.028974, 0.98868, 0.00212014, 0, 0.036142, 0.984663, 0.00217598, 0, 0.044049, 0.981457, 0.00230563, 0, 0.0526781, 0.977608, 0.00243966, 0, 0.0620137, 0.972215, 0.00251336, 0, 0.0720418, 0.966798, 0.0026285, 0, 0.0827499, 0.960241, 0.00271409, 0, 0.0941271, 0.952489, 0.00278381, 0, 0.106164, 0.944127, 0.00285399, 0, 0.118852, 0.934282, 0.00290994, 0, 0.132185, 0.923271, 0.00294558, 0, 0.146157, 0.910803, 0.00296269, 0, 0.160766, 0.896705, 0.00296803, 0, 0.176007, 0.88238, 0.00296637, 0, 0.19188, 0.867116, 0.00293163, 0, 0.208385, 0.853636, 0.00289418, 0, 0.225523, 0.840469, 0.00284663, 0, 0.243296, 0.82639, 0.00278594, 0, 0.261709, 0.811759, 0.00271618, 0, 0.280767, 0.796113, 0.00263187, 0, 0.300476, 0.779518, 0.00254589, 0, 0.320845, 0.763142, 0.00246003, 0, 0.341883, 0.745464, 0.00236529, 0, 0.363601, 0.727491, 0.00226536, 0, 0.386011, 0.709414, 0.00216375, 0, 0.409128, 0.691396, 0.00207127, 0, 0.432967, 0.67368, 0.00197106, 0, 0.457545, 0.656049, 0.00187022, 0, 0.482881, 0.638188, 0.00177605, 0, 0.508992, 0.620177, 0.00168482, 0, 0.535899, 0.601506, 0.00158909, 0, 0.563619, 0.58362, 0.00150583, 0, 0.592165, 0.565496, 0.00141791, 0, 0.621544, 0.54789, 0.00133693, 0, 0.651743, 0.530323, 0.00126038, 0, 0.682709, 0.512795, 0.00118556, 0, 0.714286, 0.495199, 0.00111527, 0, 0.746032, 0.478101, 0.0010489, 0, 0.777778, 0.461511, 0.000984264, 0, 0.809524, 0.444879, 0.00092591, 0, 0.84127, 0.428424, 0.000866582, 0, 0.873016, 0.412495, 0.000814463, 0, 0.904762, 0.396975, 0.000764498, 0, 0.936508, 0.381614, 0.000715967, 0, 0.968254, 0.366732, 0.000672483, 0, 1, 1, 0.00155501, 0, 0, 1, 0.00155503, 0, 0, 1, 0.00155524, 0, 0, 0.999998, 0.00155615, 0, 0, 0.999994, 0.0015586, 0, 0, 0.999983, 0.00156379, 0, 0, 0.999963, 0.0015733, 0, 0, 0.999932, 0.00158911, 0, 0, 0.999882, 0.00161376, 0, 0, 0.99981, 0.00165041, 0, 1.00875e-05, 0.999708, 0.00170304, 0, 0.000367658, 0.999565, 0.00177658, 0, 0.0014234, 0.999368, 0.00187688, 0, 0.00327939, 0.999081, 0.00200989, 0, 0.00596629, 0.99852, 0.00217177, 0, 0.0094852, 0.99549, 0.0021745, 0, 0.013824, 0.993252, 0.00222357, 0, 0.0189642, 0.991727, 0.00235022, 0, 0.0248856, 0.989951, 0.00250561, 0, 0.0315669, 0.988029, 0.00268829, 0, 0.0389882, 0.984029, 0.0027496, 0, 0.0471302, 0.980683, 0.00289793, 0, 0.0559754, 0.976554, 0.00303315, 0, 0.0655081, 0.97139, 0.00313257, 0, 0.0757138, 0.965544, 0.00323656, 0, 0.08658, 0.95912, 0.00333432, 0, 0.0980954, 0.951183, 0.0034039, 0, 0.110251, 0.942974, 0.00347515, 0, 0.123038, 0.932642, 0.00350381, 0, 0.13645, 0.922158, 0.00354519, 0, 0.150482, 0.909404, 0.00353851, 0, 0.165129, 0.896071, 0.0035435, 0, 0.18039, 0.881206, 0.00349936, 0, 0.196263, 0.866077, 0.00347256, 0, 0.212748, 0.85093, 0.003415, 0, 0.229847, 0.837703, 0.00333367, 0, 0.247561, 0.823878, 0.003249, 0, 0.265895, 0.809449, 0.00316347, 0, 0.284854, 0.794379, 0.00306351, 0, 0.304445, 0.778138, 0.0029499, 0, 0.324675, 0.761997, 0.00284099, 0, 0.345555, 0.744938, 0.00272104, 0, 0.367095, 0.727212, 0.00260715, 0, 0.389309, 0.709549, 0.00248855, 0, 0.41221, 0.691704, 0.00236783, 0, 0.435814, 0.673689, 0.00225178, 0, 0.460138, 0.656453, 0.00213765, 0, 0.485203, 0.639128, 0.00202178, 0, 0.511028, 0.621512, 0.00191443, 0, 0.537634, 0.603598, 0.00180977, 0, 0.565041, 0.58559, 0.00170456, 0, 0.593268, 0.567852, 0.00160927, 0, 0.622327, 0.5503, 0.00151395, 0, 0.652217, 0.533033, 0.00142499, 0, 0.682907, 0.515942, 0.00133955, 0, 0.714296, 0.498814, 0.0012602, 0, 0.746032, 0.481595, 0.00118188, 0, 0.777778, 0.465117, 0.00111171, 0, 0.809524, 0.448865, 0.00104091, 0, 0.84127, 0.432711, 0.000976618, 0, 0.873016, 0.416822, 0.00091859, 0, 0.904762, 0.401272, 0.000857704, 0, 0.936508, 0.386226, 0.000807172, 0, 0.968254, 0.371321, 0.00075464, 0, 1, 1, 0.00209596, 0, 0, 1, 0.00209598, 0, 0, 1, 0.00209624, 0, 0, 0.999997, 0.00209736, 0, 0, 0.999991, 0.00210039, 0, 0, 0.999979, 0.00210678, 0, 0, 0.999959, 0.00211847, 0, 0, 0.999925, 0.0021379, 0, 0, 0.99987, 0.00216809, 0, 0, 0.999791, 0.00221281, 0, 6.81487e-05, 0.999677, 0.00227669, 0, 0.000658161, 0.999521, 0.00236533, 0, 0.00200635, 0.999301, 0.00248514, 0, 0.0041779, 0.998977, 0.00264185, 0, 0.00718648, 0.998191, 0.00281695, 0, 0.0110239, 0.994801, 0.00278518, 0, 0.015672, 0.993091, 0.00288774, 0, 0.0211091, 0.991571, 0.00303931, 0, 0.0273123, 0.9897, 0.00321643, 0, 0.034259, 0.987023, 0.00337332, 0, 0.0419282, 0.983289, 0.00346146, 0, 0.0502998, 0.979892, 0.00363704, 0, 0.0593562, 0.975111, 0.00373601, 0, 0.069081, 0.970351, 0.0038842, 0, 0.0794598, 0.964131, 0.00397053, 0, 0.0904798, 0.957747, 0.00408078, 0, 0.10213, 0.949536, 0.00413533, 0, 0.1144, 0.941372, 0.00420305, 0, 0.127284, 0.931049, 0.00422815, 0, 0.140772, 0.920647, 0.00425048, 0, 0.154862, 0.908033, 0.0042281, 0, 0.169548, 0.895028, 0.00422026, 0, 0.184828, 0.879968, 0.00415042, 0, 0.200701, 0.864875, 0.00408821, 0, 0.217167, 0.84918, 0.00400909, 0, 0.234227, 0.834934, 0.00391178, 0, 0.251884, 0.821397, 0.00380066, 0, 0.270141, 0.807135, 0.00367974, 0, 0.289004, 0.792363, 0.00355172, 0, 0.308479, 0.776661, 0.003411, 0, 0.328575, 0.760705, 0.00328123, 0, 0.349301, 0.744408, 0.00314003, 0, 0.370668, 0.726994, 0.0029906, 0, 0.392689, 0.709598, 0.00285034, 0, 0.415379, 0.692112, 0.00271179, 0, 0.438754, 0.674435, 0.00257185, 0, 0.46283, 0.65676, 0.00243425, 0, 0.48763, 0.639982, 0.00230351, 0, 0.513173, 0.622983, 0.0021777, 0, 0.539482, 0.605471, 0.00204991, 0, 0.566579, 0.58796, 0.00193759, 0, 0.594488, 0.570463, 0.00181976, 0, 0.623226, 0.553058, 0.00171497, 0, 0.6528, 0.535894, 0.00161109, 0, 0.683198, 0.519089, 0.00151394, 0, 0.714354, 0.502454, 0.00142122, 0, 0.746032, 0.485681, 0.00133488, 0, 0.777778, 0.468935, 0.00124975, 0, 0.809524, 0.452951, 0.00117309, 0, 0.84127, 0.437139, 0.00110155, 0, 0.873016, 0.421446, 0.00103124, 0, 0.904762, 0.405951, 0.000966387, 0, 0.936508, 0.391003, 0.000908119, 0, 0.968254, 0.376198, 0.000848057, 0, 1, 1, 0.00280076, 0, 0, 1, 0.00280078, 0, 0, 0.999999, 0.00280109, 0, 0, 0.999997, 0.00280246, 0, 0, 0.999992, 0.00280616, 0, 0, 0.999979, 0.00281396, 0, 0, 0.999956, 0.00282822, 0, 0, 0.999916, 0.00285186, 0, 0, 0.999857, 0.0028885, 0, 0, 0.999768, 0.00294259, 0, 0.000196026, 0.999645, 0.00301946, 0, 0.00104842, 0.99947, 0.00312541, 0, 0.00270199, 0.999229, 0.00326733, 0, 0.00519449, 0.998852, 0.00344992, 0, 0.00852602, 0.997558, 0.00361052, 0, 0.0126804, 0.994417, 0.0035898, 0, 0.017635, 0.992824, 0.00372393, 0, 0.023365, 0.991344, 0.00390695, 0, 0.0298456, 0.989337, 0.00410392, 0, 0.0370529, 0.985811, 0.00420987, 0, 0.0449651, 0.982772, 0.00437488, 0, 0.0535615, 0.979001, 0.00455069, 0, 0.0628243, 0.974102, 0.00464462, 0, 0.0727368, 0.969197, 0.00480577, 0, 0.0832844, 0.962759, 0.00487818, 0, 0.0944545, 0.956207, 0.00498176, 0, 0.106236, 0.947909, 0.00503392, 0, 0.118619, 0.939596, 0.00507474, 0, 0.131595, 0.929642, 0.00509798, 0, 0.145159, 0.918807, 0.00508476, 0, 0.159305, 0.906921, 0.00505634, 0, 0.174028, 0.893312, 0.00498845, 0, 0.189327, 0.878933, 0.0049133, 0, 0.2052, 0.863986, 0.0048259, 0, 0.221647, 0.847936, 0.00470848, 0, 0.23867, 0.832253, 0.00456889, 0, 0.25627, 0.818619, 0.00442726, 0, 0.274453, 0.804788, 0.00427677, 0, 0.293222, 0.790241, 0.00411906, 0, 0.312585, 0.775162, 0.00394833, 0, 0.33255, 0.759463, 0.00377366, 0, 0.353126, 0.743598, 0.00361026, 0, 0.374324, 0.72697, 0.00343627, 0, 0.396158, 0.709646, 0.00326422, 0, 0.418641, 0.69277, 0.00309717, 0, 0.44179, 0.675371, 0.0029356, 0, 0.465624, 0.657863, 0.00277712, 0, 0.490163, 0.640772, 0.00261738, 0, 0.515429, 0.624441, 0.0024737, 0, 0.541445, 0.607497, 0.00233125, 0, 0.568236, 0.590438, 0.00218994, 0, 0.595828, 0.573224, 0.0020664, 0, 0.624242, 0.556168, 0.00193526, 0, 0.653496, 0.539232, 0.00182463, 0, 0.683588, 0.522352, 0.00170735, 0, 0.714482, 0.506172, 0.00160555, 0, 0.746032, 0.489842, 0.00150451, 0, 0.777778, 0.473463, 0.00140938, 0, 0.809524, 0.457266, 0.00132568, 0, 0.84127, 0.441609, 0.0012376, 0, 0.873016, 0.426348, 0.00116265, 0, 0.904762, 0.411002, 0.00108935, 0, 0.936508, 0.396045, 0.00101946, 0, 0.968254, 0.381448, 0.000955665, 0, 1, 1, 0.0037121, 0, 0, 1, 0.00371213, 0, 0, 1, 0.00371251, 0, 0, 0.999997, 0.00371417, 0, 0, 0.99999, 0.00371863, 0, 0, 0.999977, 0.00372807, 0, 0, 0.99995, 0.00374529, 0, 0, 0.999908, 0.0037738, 0, 0, 0.999843, 0.00381789, 0, 1.23596e-05, 0.999745, 0.00388273, 0, 0.000407442, 0.999608, 0.00397443, 0, 0.0015447, 0.999415, 0.00409998, 0, 0.00351385, 0.999143, 0.00426662, 0, 0.0063316, 0.9987, 0.00447625, 0, 0.00998679, 0.996363, 0.00455323, 0, 0.0144569, 0.994021, 0.00461052, 0, 0.0197151, 0.992372, 0.00476359, 0, 0.0257344, 0.991007, 0.00499101, 0, 0.0324882, 0.988767, 0.0051972, 0, 0.0399517, 0.984872, 0.00528407, 0, 0.0481022, 0.982004, 0.00548926, 0, 0.0569191, 0.977714, 0.00564385, 0, 0.0663839, 0.973076, 0.0057693, 0, 0.0764801, 0.967565, 0.0058924, 0, 0.0871928, 0.961384, 0.00599629, 0, 0.0985095, 0.954435, 0.00605998, 0, 0.110419, 0.946303, 0.0061133, 0, 0.122912, 0.937662, 0.00612028, 0, 0.13598, 0.927867, 0.00612209, 0, 0.149617, 0.916475, 0.00604813, 0, 0.163817, 0.90541, 0.00603088, 0, 0.178577, 0.891591, 0.00592218, 0, 0.193894, 0.877573, 0.00578854, 0, 0.209767, 0.862511, 0.00566648, 0, 0.226196, 0.846861, 0.00551481, 0, 0.243182, 0.83068, 0.00533754, 0, 0.260728, 0.815725, 0.00515487, 0, 0.278837, 0.802321, 0.0049655, 0, 0.297515, 0.787826, 0.00475421, 0, 0.316768, 0.773454, 0.00456002, 0, 0.336605, 0.758224, 0.00434727, 0, 0.357034, 0.74265, 0.00414444, 0, 0.378067, 0.726729, 0.00393738, 0, 0.399717, 0.710155, 0.00373575, 0, 0.421998, 0.693312, 0.00353736, 0, 0.444928, 0.67653, 0.00334368, 0, 0.468523, 0.659444, 0.00315981, 0, 0.492806, 0.642051, 0.00297809, 0, 0.517798, 0.625758, 0.00280592, 0, 0.543525, 0.609615, 0.00264254, 0, 0.570012, 0.592919, 0.00248459, 0, 0.597288, 0.576298, 0.00233327, 0, 0.625379, 0.559489, 0.00219519, 0, 0.654307, 0.542891, 0.00205441, 0, 0.684084, 0.526255, 0.00193385, 0, 0.714693, 0.509853, 0.00180745, 0, 0.746044, 0.494131, 0.00169817, 0, 0.777778, 0.478114, 0.0015913, 0, 0.809524, 0.462274, 0.00148981, 0, 0.84127, 0.446412, 0.00139537, 0, 0.873016, 0.431274, 0.00130984, 0, 0.904762, 0.41635, 0.00122403, 0, 0.936508, 0.401476, 0.00114809, 0, 0.968254, 0.386993, 0.00107563, 0, 1, 1, 0.00488216, 0, 0, 1, 0.0048822, 0, 0, 1, 0.00488265, 0, 0, 0.999997, 0.00488463, 0, 0, 0.999988, 0.00488999, 0, 0, 0.999974, 0.00490129, 0, 0, 0.999946, 0.00492191, 0, 0, 0.999897, 0.00495598, 0, 0, 0.999825, 0.00500855, 0, 7.44791e-05, 0.999718, 0.00508559, 0, 0.000712744, 0.999565, 0.005194, 0, 0.00215249, 0.999352, 0.00534147, 0, 0.00444576, 0.999046, 0.00553523, 0, 0.00759218, 0.998492, 0.00577016, 0, 0.0115714, 0.995564, 0.00578487, 0, 0.0163557, 0.993339, 0.00586414, 0, 0.021915, 0.991834, 0.00606002, 0, 0.0282201, 0.990496, 0.00633312, 0, 0.0352433, 0.987826, 0.00651941, 0, 0.042959, 0.98383, 0.00660842, 0, 0.0513439, 0.98109, 0.00685523, 0, 0.0603772, 0.976131, 0.00695778, 0, 0.0700402, 0.971922, 0.00714236, 0, 0.0803163, 0.965901, 0.00721437, 0, 0.0911908, 0.959606, 0.00732017, 0, 0.102651, 0.952504, 0.00735788, 0, 0.114686, 0.944365, 0.00738493, 0, 0.127286, 0.935652, 0.00737969, 0, 0.140443, 0.925813, 0.00733612, 0, 0.154151, 0.914397, 0.00723094, 0, 0.168405, 0.903257, 0.00714002, 0, 0.183201, 0.890015, 0.00700149, 0, 0.198536, 0.876014, 0.00682813, 0, 0.214409, 0.861436, 0.00665567, 0, 0.23082, 0.845752, 0.00644526, 0, 0.24777, 0.829169, 0.00621635, 0, 0.265263, 0.813435, 0.00597789, 0, 0.283301, 0.799701, 0.00575694, 0, 0.301889, 0.785726, 0.00549866, 0, 0.321035, 0.77152, 0.0052503, 0, 0.340746, 0.75683, 0.00499619, 0, 0.361032, 0.741951, 0.0047543, 0, 0.381904, 0.726367, 0.0045084, 0, 0.403374, 0.710537, 0.00426784, 0, 0.425457, 0.693965, 0.00403487, 0, 0.448169, 0.677724, 0.0038075, 0, 0.47153, 0.66117, 0.00359431, 0, 0.495561, 0.644274, 0.00338354, 0, 0.520284, 0.627449, 0.00318163, 0, 0.545725, 0.611645, 0.00299672, 0, 0.571911, 0.595614, 0.00281016, 0, 0.598873, 0.579426, 0.00264252, 0, 0.62664, 0.563016, 0.00247509, 0, 0.655239, 0.546728, 0.00232647, 0, 0.684692, 0.530539, 0.00217803, 0, 0.714999, 0.514164, 0.00204216, 0, 0.746106, 0.498344, 0.00191403, 0, 0.777778, 0.482957, 0.00179203, 0, 0.809524, 0.467336, 0.00167695, 0, 0.84127, 0.451994, 0.00157567, 0, 0.873016, 0.436514, 0.00147113, 0, 0.904762, 0.42178, 0.00138034, 0, 0.936508, 0.407271, 0.00129219, 0, 0.968254, 0.392822, 0.0012098, 0, 1, 1, 0.00637427, 0, 0, 1, 0.00637431, 0, 0, 0.999999, 0.00637485, 0, 0, 0.999996, 0.00637721, 0, 0, 0.999987, 0.00638357, 0, 0, 0.999971, 0.006397, 0, 0, 0.999939, 0.00642142, 0, 0, 0.999888, 0.00646177, 0, 0, 0.999807, 0.00652387, 0, 0.000207916, 0.999689, 0.00661454, 0, 0.00112051, 0.99952, 0.00674155, 0, 0.00287719, 0.999283, 0.00691313, 0, 0.00550145, 0.998936, 0.00713598, 0, 0.00897928, 0.998165, 0.00738501, 0, 0.0132829, 0.994847, 0.00734388, 0, 0.01838, 0.993182, 0.00749991, 0, 0.0242381, 0.991665, 0.0077246, 0, 0.030826, 0.989708, 0.00797579, 0, 0.0381152, 0.986663, 0.00813011, 0, 0.0460794, 0.983288, 0.00830365, 0, 0.0546951, 0.980104, 0.00853496, 0, 0.0639411, 0.974855, 0.00861045, 0, 0.0737988, 0.97045, 0.00879133, 0, 0.0842516, 0.964509, 0.00886377, 0, 0.0952848, 0.957594, 0.00890346, 0, 0.106886, 0.950546, 0.00893289, 0, 0.119044, 0.942225, 0.00890074, 0, 0.131749, 0.933365, 0.00886826, 0, 0.144994, 0.923202, 0.0087316, 0, 0.158772, 0.912605, 0.00863082, 0, 0.173078, 0.901099, 0.00847403, 0, 0.187908, 0.888177, 0.00825838, 0, 0.203261, 0.873955, 0.00801834, 0, 0.219134, 0.860091, 0.00779026, 0, 0.235527, 0.84434, 0.00752478, 0, 0.252443, 0.828517, 0.00724074, 0, 0.269883, 0.81239, 0.00693769, 0, 0.287851, 0.79721, 0.00664817, 0, 0.306352, 0.783489, 0.00634763, 0, 0.325393, 0.769514, 0.00604221, 0, 0.344981, 0.755419, 0.00573568, 0, 0.365126, 0.741083, 0.00544359, 0, 0.385839, 0.726059, 0.00515515, 0, 0.407132, 0.710809, 0.00487139, 0, 0.42902, 0.695052, 0.00459846, 0, 0.45152, 0.678886, 0.00433412, 0, 0.474651, 0.663042, 0.00407981, 0, 0.498433, 0.646634, 0.00384264, 0, 0.52289, 0.630117, 0.00360897, 0, 0.548048, 0.613804, 0.00338863, 0, 0.573936, 0.598338, 0.00318486, 0, 0.600584, 0.582687, 0.00298377, 0, 0.628027, 0.566809, 0.00280082, 0, 0.656295, 0.550817, 0.00262255, 0, 0.685417, 0.534937, 0.00245835, 0, 0.715406, 0.519151, 0.00230574, 0, 0.74624, 0.503118, 0.0021549, 0, 0.777778, 0.487723, 0.00202008, 0, 0.809524, 0.472725, 0.00189355, 0, 0.84127, 0.457599, 0.00177108, 0, 0.873016, 0.442558, 0.00165843, 0, 0.904762, 0.427624, 0.00155494, 0, 0.936508, 0.413171, 0.00145273, 0, 0.968254, 0.399122, 0.00136454, 0, 1, 1, 0.00826496, 0, 0, 1, 0.00826499, 0, 0, 1, 0.00826564, 0, 0, 0.999996, 0.00826842, 0, 0, 0.999987, 0.00827589, 0, 0, 0.999967, 0.00829167, 0, 0, 0.999933, 0.00832037, 0, 0, 0.999876, 0.00836768, 0, 1.09338e-05, 0.999786, 0.00844031, 0, 0.000427145, 0.999655, 0.00854603, 0, 0.0016384, 0.999468, 0.00869337, 0, 0.00372392, 0.999203, 0.008891, 0, 0.00668513, 0.998803, 0.00914387, 0, 0.0104968, 0.99748, 0.00935838, 0, 0.015125, 0.994446, 0.00933309, 0, 0.0205338, 0.99292, 0.00953084, 0, 0.0266884, 0.991414, 0.0097893, 0, 0.0335565, 0.989049, 0.0100228, 0, 0.0411086, 0.98582, 0.0101664, 0, 0.0493181, 0.982441, 0.0103582, 0, 0.0581613, 0.978595, 0.0105292, 0, 0.0676169, 0.973495, 0.0106274, 0, 0.0776661, 0.968405, 0.0107261, 0, 0.0882926, 0.962717, 0.0108234, 0, 0.0994817, 0.955478, 0.0108102, 0, 0.111221, 0.948275, 0.0107914, 0, 0.123499, 0.940006, 0.0107161, 0, 0.136308, 0.930831, 0.0106309, 0, 0.149639, 0.920648, 0.0104083, 0, 0.163485, 0.910205, 0.0102312, 0, 0.177843, 0.898445, 0.0100051, 0, 0.192707, 0.885986, 0.00971928, 0, 0.208077, 0.872204, 0.00940747, 0, 0.22395, 0.858436, 0.0091085, 0, 0.240326, 0.843454, 0.00876595, 0, 0.257208, 0.827437, 0.00839794, 0, 0.274596, 0.811488, 0.00803692, 0, 0.292496, 0.796039, 0.00767352, 0, 0.310911, 0.781083, 0.0073097, 0, 0.329849, 0.767642, 0.00694032, 0, 0.349316, 0.753901, 0.00657476, 0, 0.369323, 0.740131, 0.00622699, 0, 0.38988, 0.725845, 0.0058838, 0, 0.410999, 0.710991, 0.00555586, 0, 0.432696, 0.696002, 0.00523089, 0, 0.454987, 0.680461, 0.00492494, 0, 0.47789, 0.664875, 0.00463464, 0, 0.501426, 0.649273, 0.00435422, 0, 0.52562, 0.63302, 0.0040875, 0, 0.550498, 0.61705, 0.00384075, 0, 0.576089, 0.601154, 0.00359557, 0, 0.602427, 0.586008, 0.00337636, 0, 0.629544, 0.570699, 0.00316019, 0, 0.657479, 0.555166, 0.00296033, 0, 0.686264, 0.539645, 0.00277552, 0, 0.715924, 0.524159, 0.00259499, 0, 0.746459, 0.508682, 0.00243257, 0, 0.777789, 0.493163, 0.00227851, 0, 0.809524, 0.478004, 0.00213083, 0, 0.84127, 0.46347, 0.00199502, 0, 0.873016, 0.448778, 0.00186967, 0, 0.904762, 0.434105, 0.00174732, 0, 0.936508, 0.419576, 0.00163861, 0, 0.968254, 0.405541, 0.00153341, 0, 1, 1, 0.0106462, 0, 0, 1, 0.0106462, 0, 0, 0.999999, 0.010647, 0, 0, 0.999995, 0.0106502, 0, 0, 0.999985, 0.0106589, 0, 0, 0.999964, 0.0106773, 0, 0, 0.999925, 0.0107106, 0, 0, 0.999861, 0.0107655, 0, 7.12986e-05, 0.999763, 0.0108497, 0, 0.000743959, 0.999616, 0.0109716, 0, 0.00227361, 0.999408, 0.0111408, 0, 0.0046983, 0.999112, 0.0113659, 0, 0.00800158, 0.998637, 0.0116475, 0, 0.0121493, 0.996223, 0.0117231, 0, 0.0171023, 0.994006, 0.0118064, 0, 0.0228218, 0.992444, 0.0120254, 0, 0.0292711, 0.991028, 0.0123314, 0, 0.036417, 0.98803, 0.0124954, 0, 0.0442295, 0.984816, 0.0126538, 0, 0.0526815, 0.981399, 0.0128537, 0, 0.0617492, 0.977085, 0.0129694, 0, 0.0714114, 0.972154, 0.013091, 0, 0.0816495, 0.966617, 0.0131166, 0, 0.0924472, 0.960628, 0.0131583, 0, 0.10379, 0.953295, 0.0131094, 0, 0.115665, 0.94575, 0.0129966, 0, 0.128062, 0.937654, 0.0128796, 0, 0.140972, 0.927716, 0.0126477, 0, 0.154387, 0.917932, 0.0123889, 0, 0.168301, 0.907719, 0.012131, 0, 0.182709, 0.89584, 0.0118013, 0, 0.197608, 0.883526, 0.0114145, 0, 0.212994, 0.870301, 0.0110075, 0, 0.228867, 0.856272, 0.0106019, 0, 0.245227, 0.842251, 0.0101938, 0, 0.262074, 0.826466, 0.00973254, 0, 0.279412, 0.810859, 0.0092846, 0, 0.297244, 0.795051, 0.00883304, 0, 0.315575, 0.780053, 0.00840272, 0, 0.334412, 0.76575, 0.00796438, 0, 0.35376, 0.752298, 0.00752526, 0, 0.373631, 0.739153, 0.00711486, 0, 0.394034, 0.725514, 0.00670361, 0, 0.414983, 0.711473, 0.00632656, 0, 0.436491, 0.696936, 0.00595206, 0, 0.458575, 0.682126, 0.00559191, 0, 0.481253, 0.667027, 0.00525362, 0, 0.504547, 0.651875, 0.00493805, 0, 0.528481, 0.636463, 0.00462848, 0, 0.553081, 0.620641, 0.00433936, 0, 0.578377, 0.604931, 0.00407, 0, 0.604404, 0.589549, 0.00380864, 0, 0.631197, 0.574712, 0.00357049, 0, 0.658795, 0.559775, 0.00334466, 0, 0.687238, 0.544514, 0.00312505, 0, 0.716559, 0.529555, 0.00293199, 0, 0.746776, 0.514402, 0.00274204, 0, 0.777849, 0.499302, 0.00256647, 0, 0.809524, 0.484114, 0.00239901, 0, 0.84127, 0.469308, 0.00225148, 0, 0.873016, 0.455133, 0.00210178, 0, 0.904762, 0.440939, 0.0019727, 0, 0.936508, 0.426627, 0.00184382, 0, 0.968254, 0.412509, 0.00172548, 0, 1, 1, 0.013628, 0, 0, 1, 0.0136281, 0, 0, 0.999999, 0.0136289, 0, 0, 0.999995, 0.0136327, 0, 0, 0.999983, 0.0136427, 0, 0, 0.99996, 0.0136638, 0, 0, 0.999917, 0.0137022, 0, 0, 0.999846, 0.0137652, 0, 0.000204597, 0.999736, 0.0138615, 0, 0.00116837, 0.999573, 0.0140007, 0, 0.00303325, 0.99934, 0.0141927, 0, 0.00580613, 0.999004, 0.0144457, 0, 0.00945626, 0.998407, 0.0147489, 0, 0.0139421, 0.995464, 0.014731, 0, 0.0192202, 0.993328, 0.0148283, 0, 0.0252495, 0.991799, 0.0150797, 0, 0.0319921, 0.990397, 0.0154316, 0, 0.0394138, 0.986835, 0.0155005, 0, 0.0474843, 0.983938, 0.0157308, 0, 0.0561763, 0.980154, 0.0158753, 0, 0.0654661, 0.975659, 0.0159581, 0, 0.0753326, 0.970171, 0.0159832, 0, 0.0857571, 0.964803, 0.0160084, 0, 0.0967236, 0.958366, 0.0159484, 0, 0.108218, 0.950613, 0.0158001, 0, 0.120227, 0.942874, 0.0155845, 0, 0.132741, 0.935005, 0.0154292, 0, 0.145751, 0.924991, 0.0150742, 0, 0.159249, 0.914814, 0.0146757, 0, 0.17323, 0.904743, 0.0143097, 0, 0.187687, 0.893216, 0.0138695, 0, 0.202619, 0.880769, 0.0133706, 0, 0.218021, 0.868136, 0.0128606, 0, 0.233894, 0.85469, 0.0123403, 0, 0.250238, 0.840593, 0.0118091, 0, 0.267052, 0.825808, 0.011253, 0, 0.284341, 0.81009, 0.0107099, 0, 0.302106, 0.79504, 0.0101636, 0, 0.320354, 0.779757, 0.00964041, 0, 0.33909, 0.764697, 0.00911896, 0, 0.358322, 0.750913, 0.00859533, 0, 0.378059, 0.738175, 0.00811592, 0, 0.398311, 0.725242, 0.00764504, 0, 0.41909, 0.711864, 0.00718885, 0, 0.440412, 0.698009, 0.00675843, 0, 0.462292, 0.683841, 0.00634984, 0, 0.484748, 0.669391, 0.00595502, 0, 0.507802, 0.654731, 0.00558671, 0, 0.531477, 0.639805, 0.00523578, 0, 0.555802, 0.624789, 0.00490834, 0, 0.580805, 0.609325, 0.00459448, 0, 0.606522, 0.593975, 0.00430342, 0, 0.63299, 0.578983, 0.00403019, 0, 0.66025, 0.564442, 0.0037707, 0, 0.688346, 0.549835, 0.0035316, 0, 0.717319, 0.535039, 0.00330255, 0, 0.7472, 0.520403, 0.00308932, 0, 0.777982, 0.505687, 0.00289335, 0, 0.809524, 0.490939, 0.00270818, 0, 0.84127, 0.476233, 0.0025343, 0, 0.873016, 0.461624, 0.00237097, 0, 0.904762, 0.447833, 0.00222065, 0, 0.936508, 0.433992, 0.00207561, 0, 0.968254, 0.420147, 0.00194955, 0, 1, 1, 0.0173415, 0, 0, 1, 0.0173416, 0, 0, 0.999999, 0.0173426, 0, 0, 0.999995, 0.0173468, 0, 0, 0.999983, 0.0173582, 0, 0, 0.999954, 0.0173822, 0, 0, 0.999908, 0.0174258, 0, 6.69501e-06, 0.999828, 0.0174973, 0, 0.000427399, 0.999705, 0.0176063, 0, 0.00171019, 0.999524, 0.0177631, 0, 0.0039248, 0.999263, 0.0179781, 0, 0.00705382, 0.998878, 0.018258, 0, 0.0110552, 0.998012, 0.0185551, 0, 0.0158812, 0.994614, 0.0184264, 0, 0.0214852, 0.993132, 0.0186385, 0, 0.0278239, 0.991563, 0.0189067, 0, 0.0348585, 0.989298, 0.0191577, 0, 0.0425544, 0.986036, 0.0192522, 0, 0.050881, 0.982558, 0.0194063, 0, 0.059811, 0.978531, 0.019486, 0, 0.0693209, 0.974198, 0.0195847, 0, 0.0793895, 0.968148, 0.0194749, 0, 0.0899984, 0.962565, 0.0194277, 0, 0.101132, 0.956041, 0.0192991, 0, 0.112775, 0.947749, 0.0189893, 0, 0.124917, 0.94018, 0.018704, 0, 0.137547, 0.93165, 0.0183458, 0, 0.150655, 0.921798, 0.0178775, 0, 0.164236, 0.911573, 0.0173618, 0, 0.178281, 0.901569, 0.0168482, 0, 0.192788, 0.890341, 0.016265, 0, 0.207752, 0.877835, 0.0156199, 0, 0.223171, 0.865472, 0.0149516, 0, 0.239044, 0.852905, 0.0143274, 0, 0.255371, 0.838906, 0.0136643, 0, 0.272153, 0.824888, 0.0129903, 0, 0.289393, 0.809977, 0.0123218, 0, 0.307093, 0.794697, 0.0116572, 0, 0.325259, 0.780028, 0.0110307, 0, 0.343896, 0.765124, 0.0104236, 0, 0.363012, 0.750411, 0.0098219, 0, 0.382617, 0.737264, 0.00924397, 0, 0.402719, 0.724799, 0.00868719, 0, 0.423332, 0.712253, 0.00816476, 0, 0.444469, 0.699267, 0.00767262, 0, 0.466146, 0.685618, 0.00719746, 0, 0.488383, 0.671736, 0.00673916, 0, 0.511199, 0.657777, 0.00631937, 0, 0.534618, 0.643497, 0.00592411, 0, 0.558668, 0.62889, 0.00553928, 0, 0.58338, 0.614299, 0.0051934, 0, 0.608787, 0.599197, 0.00485985, 0, 0.634929, 0.584175, 0.00454357, 0, 0.661849, 0.569541, 0.00425787, 0, 0.689594, 0.555193, 0.00397905, 0, 0.718211, 0.540947, 0.00372364, 0, 0.747742, 0.526593, 0.00348599, 0, 0.778205, 0.512335, 0.00326103, 0, 0.80953, 0.498017, 0.00305137, 0, 0.84127, 0.483609, 0.00285485, 0, 0.873016, 0.469368, 0.00267472, 0, 0.904762, 0.455037, 0.00249945, 0, 0.936508, 0.441493, 0.00234792, 0, 0.968254, 0.428147, 0.00219936, 0, 1, 1, 0.0219422, 0, 0, 1, 0.0219423, 0, 0, 0.999998, 0.0219434, 0, 0, 0.999993, 0.0219481, 0, 0, 0.999981, 0.021961, 0, 0, 0.999949, 0.0219879, 0, 0, 0.999896, 0.0220367, 0, 5.93194e-05, 0.999808, 0.0221167, 0, 0.00075364, 0.99967, 0.0222383, 0, 0.00237884, 0.999466, 0.0224125, 0, 0.00495612, 0.999174, 0.0226495, 0, 0.00844887, 0.998725, 0.0229525, 0, 0.0128058, 0.996979, 0.0231123, 0, 0.0179742, 0.994317, 0.0230742, 0, 0.0239047, 0.992781, 0.0232895, 0, 0.0305526, 0.991191, 0.0235734, 0, 0.0378786, 0.987787, 0.0236152, 0, 0.0458475, 0.985092, 0.0237994, 0, 0.0544287, 0.981121, 0.0238553, 0, 0.0635952, 0.976924, 0.0238706, 0, 0.0733233, 0.97218, 0.0238704, 0, 0.0835922, 0.965956, 0.0236598, 0, 0.0943839, 0.959998, 0.0234735, 0, 0.105682, 0.953245, 0.0232277, 0, 0.117474, 0.944445, 0.0226973, 0, 0.129747, 0.937087, 0.0223527, 0, 0.142491, 0.928341, 0.0218144, 0, 0.155697, 0.9184, 0.0211516, 0, 0.169358, 0.907959, 0.0204553, 0, 0.183469, 0.89808, 0.0197673, 0, 0.198024, 0.887047, 0.0189915, 0, 0.21302, 0.875221, 0.0182082, 0, 0.228455, 0.86269, 0.0173584, 0, 0.244329, 0.850735, 0.0165718, 0, 0.260639, 0.837545, 0.0157524, 0, 0.277389, 0.823639, 0.0149482, 0, 0.29458, 0.809699, 0.0141431, 0, 0.312216, 0.794797, 0.0133527, 0, 0.3303, 0.780578, 0.0126193, 0, 0.34884, 0.766019, 0.0118914, 0, 0.367842, 0.751447, 0.0111839, 0, 0.387315, 0.737275, 0.010514, 0, 0.40727, 0.724545, 0.00987277, 0, 0.427717, 0.712644, 0.00926569, 0, 0.448671, 0.700432, 0.00869029, 0, 0.470149, 0.687664, 0.00814691, 0, 0.492167, 0.674288, 0.00763012, 0, 0.514746, 0.660966, 0.00714437, 0, 0.537911, 0.647264, 0.00668457, 0, 0.561688, 0.633431, 0.00626581, 0, 0.586108, 0.619133, 0.00585593, 0, 0.611206, 0.604935, 0.00548188, 0, 0.637022, 0.590236, 0.00513288, 0, 0.663599, 0.575473, 0.0047906, 0, 0.690989, 0.561228, 0.00448895, 0, 0.719242, 0.547054, 0.00420233, 0, 0.748411, 0.533175, 0.00392869, 0, 0.778531, 0.519163, 0.00367445, 0, 0.809583, 0.505328, 0.00344097, 0, 0.84127, 0.491446, 0.00322003, 0, 0.873016, 0.477356, 0.00301283, 0, 0.904762, 0.46356, 0.00282592, 0, 0.936508, 0.449623, 0.00264956, 0, 0.968254, 0.436068, 0.00246956, 0, 1, 1, 0.0276135, 0, 0, 1, 0.0276136, 0, 0, 0.999998, 0.0276148, 0, 0, 0.999993, 0.0276201, 0, 0, 0.999976, 0.0276342, 0, 0, 0.999945, 0.027664, 0, 0, 0.999884, 0.0277179, 0, 0.00018679, 0.999784, 0.027806, 0, 0.00119607, 0.99963, 0.0279394, 0, 0.00318407, 0.999401, 0.0281295, 0, 0.00613601, 0.999066, 0.0283858, 0, 0.00999963, 0.998524, 0.0287027, 0, 0.0147164, 0.995702, 0.0286256, 0, 0.0202295, 0.993593, 0.0286733, 0, 0.0264876, 0.992067, 0.0288989, 0, 0.0334452, 0.990548, 0.0292135, 0, 0.0410621, 0.986775, 0.0291296, 0, 0.0493032, 0.984054, 0.0293099, 0, 0.0581381, 0.979481, 0.0291881, 0, 0.0675397, 0.975297, 0.0291598, 0, 0.0774848, 0.96981, 0.028954, 0, 0.0879528, 0.963524, 0.028628, 0, 0.0989258, 0.957398, 0.0283135, 0, 0.110388, 0.950088, 0.0278469, 0, 0.122327, 0.941538, 0.0271798, 0, 0.134729, 0.933332, 0.0265388, 0, 0.147587, 0.924392, 0.0257776, 0, 0.160889, 0.914581, 0.024916, 0, 0.174631, 0.904347, 0.0240242, 0, 0.188806, 0.894324, 0.0231229, 0, 0.203409, 0.883724, 0.022153, 0, 0.218437, 0.872207, 0.0211355, 0, 0.233888, 0.859927, 0.0201048, 0, 0.249761, 0.848373, 0.0191263, 0, 0.266056, 0.836023, 0.0181306, 0, 0.282774, 0.82289, 0.0171718, 0, 0.299917, 0.809324, 0.0162196, 0, 0.317488, 0.795361, 0.0152622, 0, 0.335493, 0.781253, 0.01439, 0, 0.353936, 0.767338, 0.013533, 0, 0.372825, 0.753156, 0.0127244, 0, 0.392168, 0.739122, 0.0119454, 0, 0.411976, 0.725358, 0.0112054, 0, 0.432259, 0.712949, 0.010487, 0, 0.453032, 0.701621, 0.00984032, 0, 0.47431, 0.689703, 0.00921495, 0, 0.496111, 0.677216, 0.00862492, 0, 0.518456, 0.664217, 0.00806882, 0, 0.541367, 0.65137, 0.00755922, 0, 0.564872, 0.638, 0.00705705, 0, 0.589001, 0.62453, 0.00661266, 0, 0.613789, 0.610601, 0.00618432, 0, 0.639277, 0.59676, 0.00578033, 0, 0.66551, 0.582433, 0.00540927, 0, 0.692539, 0.568026, 0.00506104, 0, 0.720422, 0.55414, 0.0047353, 0, 0.749216, 0.540178, 0.00442889, 0, 0.778974, 0.526513, 0.00414363, 0, 0.809711, 0.512954, 0.00388237, 0, 0.84127, 0.499403, 0.00362875, 0, 0.873016, 0.486026, 0.00340827, 0, 0.904762, 0.472345, 0.00318598, 0, 0.936508, 0.458828, 0.00297635, 0, 0.968254, 0.445379, 0.00279447, 0, 1, 1, 0.0345716, 0, 0, 1, 0.0345717, 0, 0, 0.999999, 0.034573, 0, 0, 0.999991, 0.0345787, 0, 0, 0.999974, 0.0345941, 0, 0, 0.999937, 0.0346263, 0, 1.88589e-06, 0.999869, 0.0346847, 0, 0.000409238, 0.999757, 0.0347798, 0, 0.0017674, 0.999582, 0.0349233, 0, 0.00413658, 0.999322, 0.0351265, 0, 0.00747408, 0.998939, 0.0353967, 0, 0.0117157, 0.998219, 0.0357018, 0, 0.0167966, 0.994974, 0.0354726, 0, 0.0226572, 0.993201, 0.0355621, 0, 0.0292445, 0.991573, 0.0357641, 0, 0.0365123, 0.989301, 0.0359252, 0, 0.0444203, 0.985712, 0.0358017, 0, 0.0529334, 0.982411, 0.0358353, 0, 0.0620214, 0.977827, 0.035617, 0, 0.0716574, 0.973278, 0.0354398, 0, 0.0818186, 0.967397, 0.0350483, 0, 0.0924846, 0.960696, 0.0344795, 0, 0.103638, 0.954349, 0.0339861, 0, 0.115263, 0.946066, 0.0331323, 0, 0.127348, 0.938012, 0.032359, 0, 0.13988, 0.929413, 0.0314413, 0, 0.152849, 0.920355, 0.0304103, 0, 0.166248, 0.910586, 0.0292785, 0, 0.18007, 0.900609, 0.0281391, 0, 0.194308, 0.890093, 0.0269103, 0, 0.208958, 0.880013, 0.0257269, 0, 0.224018, 0.869001, 0.0244671, 0, 0.239485, 0.85751, 0.0232252, 0, 0.255359, 0.84582, 0.0220117, 0, 0.271638, 0.834383, 0.0208274, 0, 0.288324, 0.822158, 0.0196628, 0, 0.305419, 0.809056, 0.0185306, 0, 0.322927, 0.795832, 0.0174174, 0, 0.340851, 0.782547, 0.0163758, 0, 0.359199, 0.7689, 0.015391, 0, 0.377975, 0.755526, 0.0144488, 0, 0.397189, 0.741681, 0.0135372, 0, 0.416851, 0.728178, 0.0126957, 0, 0.436971, 0.714642, 0.0118812, 0, 0.457564, 0.702756, 0.0111165, 0, 0.478644, 0.69175, 0.0104145, 0, 0.500229, 0.680159, 0.00974439, 0, 0.522339, 0.668073, 0.00911926, 0, 0.544997, 0.655405, 0.00851393, 0, 0.56823, 0.642921, 0.00797637, 0, 0.592068, 0.629993, 0.00745119, 0, 0.616546, 0.616828, 0.00696972, 0, 0.641705, 0.603305, 0.00652425, 0, 0.66759, 0.589833, 0.00610188, 0, 0.694255, 0.575945, 0.00570834, 0, 0.72176, 0.561745, 0.00533384, 0, 0.750168, 0.548277, 0.00500001, 0, 0.779545, 0.534467, 0.00467582, 0, 0.809933, 0.521032, 0.00438092, 0, 0.841272, 0.507877, 0.00410348, 0, 0.873016, 0.494654, 0.00383618, 0, 0.904762, 0.481592, 0.00358699, 0, 0.936508, 0.468509, 0.00337281, 0, 0.968254, 0.455293, 0.00316196, 0, 1, 1, 0.0430698, 0, 0, 1, 0.0430699, 0, 0, 0.999998, 0.0430713, 0, 0, 0.999991, 0.0430773, 0, 0, 0.99997, 0.0430936, 0, 0, 0.999928, 0.0431277, 0, 4.06396e-05, 0.999852, 0.0431893, 0, 0.000744376, 0.999724, 0.0432895, 0, 0.0024806, 0.999527, 0.0434397, 0, 0.00524779, 0.99923, 0.0436507, 0, 0.00898164, 0.998783, 0.0439255, 0, 0.0136083, 0.997507, 0.0441104, 0, 0.0190582, 0.994418, 0.0438225, 0, 0.0252694, 0.992864, 0.0439396, 0, 0.0321879, 0.991127, 0.0440962, 0, 0.039767, 0.987331, 0.0438408, 0, 0.0479667, 0.984819, 0.0438991, 0, 0.056752, 0.980384, 0.0435906, 0, 0.0660929, 0.975846, 0.0432543, 0, 0.075963, 0.970748, 0.0428293, 0, 0.0863398, 0.964303, 0.042153, 0, 0.0972035, 0.95772, 0.0414111, 0, 0.108537, 0.950747, 0.0405893, 0, 0.120325, 0.942533, 0.0394887, 0, 0.132554, 0.934045, 0.0383544, 0, 0.145215, 0.924942, 0.037057, 0, 0.158296, 0.915811, 0.0356993, 0, 0.17179, 0.90612, 0.0342401, 0, 0.185691, 0.896434, 0.0328078, 0, 0.199993, 0.886021, 0.031288, 0, 0.214691, 0.876081, 0.0297776, 0, 0.229782, 0.865608, 0.0282334, 0, 0.245265, 0.854924, 0.026749, 0, 0.261138, 0.843607, 0.02526, 0, 0.277401, 0.832456, 0.0238214, 0, 0.294056, 0.821342, 0.0224682, 0, 0.311104, 0.809303, 0.0211297, 0, 0.328548, 0.796468, 0.0198387, 0, 0.346394, 0.784046, 0.0186227, 0, 0.364645, 0.771262, 0.0174561, 0, 0.38331, 0.758118, 0.0163806, 0, 0.402396, 0.745075, 0.0153287, 0, 0.421912, 0.731926, 0.0143647, 0, 0.44187, 0.71863, 0.0134363, 0, 0.462283, 0.705414, 0.0125603, 0, 0.483165, 0.693792, 0.0117508, 0, 0.504535, 0.683108, 0.0110016, 0, 0.52641, 0.67183, 0.0102757, 0, 0.548816, 0.66015, 0.00962044, 0, 0.571776, 0.647907, 0.00898031, 0, 0.595323, 0.635734, 0.00840811, 0, 0.619489, 0.623208, 0.00786211, 0, 0.644317, 0.610438, 0.00734953, 0, 0.669852, 0.597345, 0.00687688, 0, 0.696148, 0.584138, 0.00643469, 0, 0.723267, 0.5707, 0.00602236, 0, 0.75128, 0.556966, 0.0056324, 0, 0.780258, 0.543607, 0.00528277, 0, 0.810268, 0.530213, 0.00493999, 0, 0.841311, 0.516912, 0.00462265, 0, 0.873016, 0.503916, 0.0043307, 0, 0.904762, 0.491146, 0.00406858, 0, 0.936508, 0.478439, 0.00381436, 0, 0.968254, 0.465834, 0.00358003, 0, 1, 1, 0.0534039, 0, 0, 1, 0.053404, 0, 0, 0.999998, 0.0534055, 0, 0, 0.999989, 0.0534116, 0, 0, 0.999968, 0.0534283, 0, 0, 0.999918, 0.0534633, 0, 0.000155895, 0.99983, 0.0535262, 0, 0.00120914, 0.999685, 0.0536281, 0, 0.00334944, 0.999461, 0.0537799, 0, 0.00653077, 0.999119, 0.0539902, 0, 0.0106718, 0.998582, 0.0542524, 0, 0.0156907, 0.995919, 0.0540318, 0, 0.0215147, 0.993735, 0.0538914, 0, 0.0280801, 0.992126, 0.0539557, 0, 0.0353323, 0.990266, 0.0540401, 0, 0.0432247, 0.986317, 0.0536064, 0, 0.0517172, 0.983213, 0.0534425, 0, 0.0607754, 0.978303, 0.0528622, 0, 0.0703698, 0.973665, 0.0523363, 0, 0.0804742, 0.968091, 0.0516165, 0, 0.0910667, 0.961026, 0.0505434, 0, 0.102128, 0.954333, 0.049523, 0, 0.113641, 0.946372, 0.0481698, 0, 0.125591, 0.938254, 0.0467674, 0, 0.137965, 0.929516, 0.0452341, 0, 0.150754, 0.920106, 0.0435083, 0, 0.163947, 0.910899, 0.0417399, 0, 0.177537, 0.901532, 0.0399389, 0, 0.191516, 0.891919, 0.0380901, 0, 0.205881, 0.882006, 0.0362341, 0, 0.220626, 0.871965, 0.0343444, 0, 0.235749, 0.862145, 0.0324832, 0, 0.251248, 0.852058, 0.0306681, 0, 0.267121, 0.84161, 0.0289097, 0, 0.283368, 0.830806, 0.0272079, 0, 0.299992, 0.820476, 0.0256089, 0, 0.316992, 0.809514, 0.0240394, 0, 0.334374, 0.797865, 0.0225379, 0, 0.35214, 0.785621, 0.0211235, 0, 0.370296, 0.773765, 0.0197908, 0, 0.388849, 0.761629, 0.0185235, 0, 0.407807, 0.748891, 0.0173358, 0, 0.427178, 0.736437, 0.0162305, 0, 0.446974, 0.723707, 0.0151778, 0, 0.467207, 0.710606, 0.0141791, 0, 0.487892, 0.698019, 0.0132592, 0, 0.509046, 0.686203, 0.0123887, 0, 0.530687, 0.675692, 0.0115976, 0, 0.552839, 0.664826, 0.0108325, 0, 0.575527, 0.65349, 0.0101348, 0, 0.59878, 0.641774, 0.00947756, 0, 0.622634, 0.629794, 0.00886058, 0, 0.647128, 0.617647, 0.00828526, 0, 0.672308, 0.60534, 0.00775312, 0, 0.698231, 0.592718, 0.00726033, 0, 0.724958, 0.579746, 0.00679731, 0, 0.752563, 0.566763, 0.00636111, 0, 0.781127, 0.553515, 0.00595228, 0, 0.810733, 0.540118, 0.00556876, 0, 0.841426, 0.527325, 0.00523051, 0, 0.873016, 0.514265, 0.00490712, 0, 0.904762, 0.501406, 0.00460297, 0, 0.936508, 0.488922, 0.00431247, 0, 0.968254, 0.476541, 0.0040472, 0, 1, 1, 0.0659184, 0, 0, 1, 0.0659185, 0, 0, 0.999998, 0.06592, 0, 0, 0.999988, 0.0659259, 0, 0, 0.999963, 0.0659423, 0, 0, 0.999907, 0.0659764, 0, 0.000374198, 0.999806, 0.0660376, 0, 0.00182071, 0.999639, 0.0661361, 0, 0.0043894, 0.999378, 0.0662814, 0, 0.00800055, 0.998985, 0.0664779, 0, 0.0125594, 0.998285, 0.0666914, 0, 0.0179786, 0.995071, 0.0661989, 0, 0.0241822, 0.993172, 0.0660454, 0, 0.031106, 0.991438, 0.0660105, 0, 0.0386952, 0.988428, 0.0656875, 0, 0.0469032, 0.985218, 0.0652913, 0, 0.0556905, 0.981128, 0.0647107, 0, 0.065023, 0.976015, 0.0638491, 0, 0.0748717, 0.97097, 0.062993, 0, 0.0852112, 0.964582, 0.0617927, 0, 0.0960199, 0.957383, 0.0603626, 0, 0.107279, 0.949969, 0.0588128, 0, 0.118971, 0.941843, 0.0570274, 0, 0.131084, 0.933624, 0.0551885, 0, 0.143604, 0.924543, 0.053122, 0, 0.156521, 0.914919, 0.0508897, 0, 0.169825, 0.905773, 0.0486418, 0, 0.18351, 0.896434, 0.0463364, 0, 0.197569, 0.887195, 0.0440623, 0, 0.211997, 0.877706, 0.0417799, 0, 0.226789, 0.867719, 0.03945, 0, 0.241944, 0.858587, 0.037243, 0, 0.257458, 0.849317, 0.0350956, 0, 0.273331, 0.839585, 0.0329852, 0, 0.289563, 0.829856, 0.0310028, 0, 0.306154, 0.819589, 0.0290953, 0, 0.323108, 0.809714, 0.0272738, 0, 0.340426, 0.79934, 0.0255631, 0, 0.358113, 0.788224, 0.0239175, 0, 0.376175, 0.776619, 0.0223831, 0, 0.394616, 0.76521, 0.0209298, 0, 0.413445, 0.753716, 0.0195786, 0, 0.432671, 0.741564, 0.0183001, 0, 0.452305, 0.729413, 0.0171259, 0, 0.472358, 0.717146, 0.0159933, 0, 0.492845, 0.70436, 0.0149495, 0, 0.513783, 0.69219, 0.0139681, 0, 0.535189, 0.680289, 0.0130577, 0, 0.557087, 0.669611, 0.0122198, 0, 0.5795, 0.659113, 0.0114174, 0, 0.602459, 0.648148, 0.0106729, 0, 0.625997, 0.636905, 0.00998997, 0, 0.650154, 0.625154, 0.00934313, 0, 0.674976, 0.613481, 0.00874839, 0, 0.700518, 0.60154, 0.00818265, 0, 0.726845, 0.58943, 0.00766889, 0, 0.754032, 0.576828, 0.00717153, 0, 0.782167, 0.564194, 0.00672696, 0, 0.811344, 0.551501, 0.00630863, 0, 0.841644, 0.538635, 0.00592177, 0, 0.873016, 0.525724, 0.00554888, 0, 0.904762, 0.513209, 0.00520225, 0, 0.936508, 0.500457, 0.00488231, 0, 0.968254, 0.48799, 0.00457153, 0, 1, 1, 0.0810131, 0, 0, 1, 0.0810133, 0, 0, 0.999997, 0.0810145, 0, 0, 0.999985, 0.08102, 0, 0, 0.999956, 0.0810347, 0, 1.95026e-05, 0.999893, 0.0810656, 0, 0.000719316, 0.999777, 0.0811205, 0, 0.00259774, 0.999583, 0.081208, 0, 0.00561807, 0.999281, 0.0813343, 0, 0.00967472, 0.998813, 0.0814969, 0, 0.0146627, 0.997597, 0.0815217, 0, 0.0204902, 0.994379, 0.0808502, 0, 0.0270802, 0.992744, 0.0806792, 0, 0.0343674, 0.990745, 0.0804589, 0, 0.0422974, 0.986646, 0.0796107, 0, 0.0508242, 0.983611, 0.0790913, 0, 0.0599087, 0.978869, 0.0780746, 0, 0.0695175, 0.973475, 0.0768218, 0, 0.0796223, 0.967845, 0.0754926, 0, 0.0901983, 0.960778, 0.0737063, 0, 0.101224, 0.953333, 0.0718052, 0, 0.112682, 0.945274, 0.0695946, 0, 0.124555, 0.936955, 0.0672492, 0, 0.136831, 0.928319, 0.0647732, 0, 0.149496, 0.919075, 0.0620947, 0, 0.162542, 0.909114, 0.0591816, 0, 0.175958, 0.900137, 0.0563917, 0, 0.189739, 0.891069, 0.0535392, 0, 0.203877, 0.882262, 0.0507642, 0, 0.218368, 0.873232, 0.0479793, 0, 0.233208, 0.864042, 0.045226, 0, 0.248393, 0.855002, 0.0425413, 0, 0.263923, 0.846569, 0.0400126, 0, 0.279796, 0.837714, 0.0375269, 0, 0.296012, 0.828918, 0.0352027, 0, 0.312573, 0.819783, 0.0330011, 0, 0.329479, 0.810129, 0.0308908, 0, 0.346734, 0.800866, 0.0289112, 0, 0.364342, 0.79093, 0.0270255, 0, 0.382307, 0.780593, 0.0252758, 0, 0.400637, 0.769511, 0.0236178, 0, 0.419337, 0.758558, 0.0220652, 0, 0.438418, 0.747632, 0.0206289, 0, 0.457889, 0.736146, 0.0192873, 0, 0.477761, 0.724093, 0.0180333, 0, 0.49805, 0.71234, 0.0168264, 0, 0.51877, 0.700201, 0.015746, 0, 0.53994, 0.687949, 0.0147027, 0, 0.561581, 0.676163, 0.0137512, 0, 0.583718, 0.665001, 0.0128655, 0, 0.60638, 0.65472, 0.0120366, 0, 0.629599, 0.644213, 0.0112604, 0, 0.653415, 0.633382, 0.0105413, 0, 0.677874, 0.62212, 0.00986498, 0, 0.70303, 0.610631, 0.00923308, 0, 0.728948, 0.599078, 0.00864206, 0, 0.755706, 0.587519, 0.00811784, 0, 0.783396, 0.575505, 0.00761237, 0, 0.812121, 0.563148, 0.00713949, 0, 0.841989, 0.550828, 0.00668379, 0, 0.873035, 0.538458, 0.00627715, 0, 0.904762, 0.525905, 0.00588336, 0, 0.936508, 0.513517, 0.00552687, 0, 0.968254, 0.501395, 0.00519681, 0, 1, 1, 0.0991506, 0, 0, 1, 0.0991504, 0, 0, 0.999996, 0.0991515, 0, 0, 0.999984, 0.0991558, 0, 0, 0.999947, 0.0991672, 0, 0.000114389, 0.999874, 0.0991912, 0, 0.00121503, 0.999739, 0.0992331, 0, 0.00356108, 0.999514, 0.0992983, 0, 0.00705578, 0.999159, 0.0993877, 0, 0.011574, 0.998586, 0.0994837, 0, 0.017003, 0.995731, 0.0988425, 0, 0.0232484, 0.993384, 0.098276, 0, 0.0302318, 0.991615, 0.0979269, 0, 0.0378884, 0.989029, 0.0973432, 0, 0.0461641, 0.985373, 0.0963539, 0, 0.0550136, 0.981278, 0.0952306, 0, 0.0643988, 0.975777, 0.0936233, 0, 0.0742868, 0.970526, 0.0920219, 0, 0.0846501, 0.963755, 0.0898912, 0, 0.0954644, 0.956676, 0.0876064, 0, 0.106709, 0.948099, 0.0847751, 0, 0.118367, 0.939718, 0.0818638, 0, 0.130423, 0.931305, 0.078857, 0, 0.142862, 0.922342, 0.0756127, 0, 0.155674, 0.912842, 0.0721473, 0, 0.168849, 0.903304, 0.0686195, 0, 0.182378, 0.89411, 0.0650589, 0, 0.196255, 0.885512, 0.0616022, 0, 0.210473, 0.877193, 0.0582434, 0, 0.225027, 0.86877, 0.0548979, 0, 0.239915, 0.860267, 0.0516095, 0, 0.255132, 0.851915, 0.048468, 0, 0.270678, 0.843912, 0.0454447, 0, 0.286551, 0.83604, 0.0425612, 0, 0.302751, 0.828245, 0.0398752, 0, 0.31928, 0.820159, 0.0373198, 0, 0.336138, 0.81167, 0.034916, 0, 0.35333, 0.802659, 0.0326402, 0, 0.370858, 0.793921, 0.0304901, 0, 0.388728, 0.784713, 0.0284857, 0, 0.406944, 0.774946, 0.0266186, 0, 0.425515, 0.76448, 0.0248593, 0, 0.444449, 0.753793, 0.0232114, 0, 0.463756, 0.743506, 0.0217039, 0, 0.483447, 0.732555, 0.0202841, 0, 0.503535, 0.720965, 0.0189648, 0, 0.524036, 0.709422, 0.0177189, 0, 0.544968, 0.697756, 0.0165626, 0, 0.56635, 0.685565, 0.015483, 0, 0.588208, 0.673987, 0.0144892, 0, 0.610569, 0.66244, 0.0135607, 0, 0.633466, 0.651675, 0.0126956, 0, 0.656936, 0.641598, 0.0118788, 0, 0.681025, 0.63121, 0.0111261, 0, 0.705788, 0.620514, 0.010437, 0, 0.731289, 0.609366, 0.00978747, 0, 0.757606, 0.598137, 0.00917257, 0, 0.784834, 0.586966, 0.00859778, 0, 0.813085, 0.575549, 0.00806803, 0, 0.842485, 0.563797, 0.00757294, 0, 0.87313, 0.551758, 0.00710592, 0, 0.904762, 0.539894, 0.0066841, 0, 0.936508, 0.527901, 0.00627901, 0, 0.968254, 0.515819, 0.00590506, 0, 1, 1, 0.120864, 0, 0, 1, 0.120864, 0, 0, 0.999996, 0.120864, 0, 0, 0.99998, 0.120867, 0, 0, 0.99994, 0.120872, 0, 0.000323781, 0.999852, 0.120884, 0, 0.00188693, 0.999693, 0.120903, 0, 0.00473489, 0.999426, 0.120929, 0, 0.00872704, 0.999002, 0.120955, 0, 0.0137237, 0.998235, 0.120918, 0, 0.0196068, 0.994608, 0.119764, 0, 0.0262803, 0.992997, 0.119265, 0, 0.0336657, 0.990968, 0.11863, 0, 0.0416987, 0.987002, 0.117261, 0, 0.0503261, 0.983524, 0.116009, 0, 0.0595035, 0.97875, 0.114252, 0, 0.0691935, 0.972652, 0.11193, 0, 0.0793645, 0.966613, 0.109555, 0, 0.0899894, 0.959275, 0.106612, 0, 0.101045, 0.951272, 0.103375, 0, 0.112512, 0.942323, 0.0996594, 0, 0.124372, 0.933679, 0.0958841, 0, 0.136611, 0.924822, 0.0919265, 0, 0.149216, 0.915742, 0.0878061, 0, 0.162176, 0.906348, 0.0834894, 0, 0.175482, 0.896883, 0.079085, 0, 0.189125, 0.88774, 0.0746745, 0, 0.203098, 0.87986, 0.0705773, 0, 0.217396, 0.871998, 0.0665005, 0, 0.232015, 0.864325, 0.0625413, 0, 0.24695, 0.856685, 0.0586781, 0, 0.2622, 0.84925, 0.0550063, 0, 0.277761, 0.841719, 0.0514727, 0, 0.293634, 0.834755, 0.0481398, 0, 0.309819, 0.827853, 0.0450172, 0, 0.326315, 0.820888, 0.0420969, 0, 0.343126, 0.813616, 0.0393702, 0, 0.360254, 0.805767, 0.0367771, 0, 0.377701, 0.797338, 0.0343274, 0, 0.395474, 0.789122, 0.0320529, 0, 0.413577, 0.780601, 0.0299485, 0, 0.432018, 0.771424, 0.0279812, 0, 0.450804, 0.761502, 0.0261054, 0, 0.469944, 0.751166, 0.0243942, 0, 0.489451, 0.741276, 0.0228087, 0, 0.509337, 0.730898, 0.0213265, 0, 0.529617, 0.719878, 0.0199307, 0, 0.550307, 0.708379, 0.0186574, 0, 0.571428, 0.697165, 0.0174446, 0, 0.593003, 0.685554, 0.0163144, 0, 0.615059, 0.673631, 0.015276, 0, 0.637628, 0.662385, 0.0143003, 0, 0.660746, 0.651059, 0.0134112, 0, 0.68446, 0.640451, 0.0125794, 0, 0.70882, 0.630536, 0.011793, 0, 0.733893, 0.620316, 0.0110547, 0, 0.759756, 0.609722, 0.0103668, 0, 0.786505, 0.598804, 0.00973009, 0, 0.814259, 0.587871, 0.00912812, 0, 0.843157, 0.577121, 0.00858916, 0, 0.87334, 0.566019, 0.00807333, 0, 0.904762, 0.554664, 0.00759687, 0, 0.936508, 0.543101, 0.00714759, 0, 0.968254, 0.531558, 0.00673418, 0, 1, 1, 0.146767, 0, 0, 1, 0.146767, 0, 0, 0.999997, 0.146767, 0, 0, 0.999977, 0.146765, 0, 3.20658e-06, 0.999929, 0.146762, 0, 0.000682576, 0.999823, 0.146753, 0, 0.00276402, 0.999633, 0.146735, 0, 0.00614771, 0.999314, 0.146699, 0, 0.0106613, 0.998796, 0.14662, 0, 0.0161546, 0.997124, 0.146107, 0, 0.0225063, 0.994062, 0.144857, 0, 0.0296198, 0.992154, 0.144011, 0, 0.037417, 0.989186, 0.142712, 0, 0.0458348, 0.985279, 0.140926, 0, 0.0548211, 0.980826, 0.13885, 0, 0.0643326, 0.975056, 0.136168, 0, 0.074333, 0.969005, 0.133217, 0, 0.0847917, 0.961554, 0.12959, 0, 0.0956828, 0.954206, 0.125886, 0, 0.106984, 0.945046, 0.121335, 0, 0.118675, 0.935678, 0.116492, 0, 0.130741, 0.926748, 0.111635, 0, 0.143166, 0.917764, 0.106625, 0, 0.155939, 0.908358, 0.101325, 0, 0.169049, 0.899219, 0.0960249, 0, 0.182487, 0.890089, 0.0906527, 0, 0.196245, 0.881488, 0.0853905, 0, 0.210317, 0.874031, 0.0804177, 0, 0.224697, 0.866932, 0.0756005, 0, 0.23938, 0.859976, 0.0709019, 0, 0.254364, 0.853375, 0.0664391, 0, 0.269646, 0.846971, 0.0622012, 0, 0.285223, 0.840483, 0.058129, 0, 0.301096, 0.833969, 0.0542762, 0, 0.317265, 0.82806, 0.0507042, 0, 0.333729, 0.822128, 0.047368, 0, 0.350491, 0.815989, 0.044272, 0, 0.367554, 0.809336, 0.0413444, 0, 0.38492, 0.802177, 0.038601, 0, 0.402594, 0.79441, 0.0360227, 0, 0.420582, 0.786573, 0.0336383, 0, 0.438891, 0.778619, 0.0314321, 0, 0.457527, 0.77, 0.029362, 0, 0.476499, 0.760698, 0.0274102, 0, 0.49582, 0.750932, 0.0256146, 0, 0.5155, 0.740993, 0.023974, 0, 0.535555, 0.731159, 0.0224182, 0, 0.556, 0.720836, 0.0209889, 0, 0.576855, 0.709913, 0.0196411, 0, 0.598143, 0.698415, 0.0183824, 0, 0.619888, 0.68745, 0.0172222, 0, 0.642123, 0.676154, 0.0161509, 0, 0.664883, 0.664383, 0.0151397, 0, 0.688211, 0.6533, 0.0141873, 0, 0.71216, 0.642072, 0.0133105, 0, 0.736792, 0.631412, 0.0124932, 0, 0.762186, 0.621622, 0.0117408, 0, 0.788439, 0.611681, 0.0110358, 0, 0.815672, 0.60142, 0.0103775, 0, 0.844034, 0.59083, 0.00975623, 0, 0.873699, 0.580254, 0.00918084, 0, 0.904765, 0.569841, 0.00864721, 0, 0.936508, 0.559224, 0.00815731, 0, 0.968254, 0.548315, 0.00767924, 0, 1, 1, 0.177563, 0, 0, 1, 0.177563, 0, 0, 0.999994, 0.177562, 0, 0, 0.999972, 0.177555, 0, 6.64171e-05, 0.999914, 0.177536, 0, 0.0012276, 0.999787, 0.177496, 0, 0.00388025, 0.999556, 0.17742, 0, 0.00783463, 0.999165, 0.177285, 0, 0.0128953, 0.9985, 0.177037, 0, 0.0189053, 0.995388, 0.175634, 0, 0.025742, 0.993102, 0.174375, 0, 0.033309, 0.990992, 0.173121, 0, 0.0415298, 0.986932, 0.170896, 0, 0.0503425, 0.982786, 0.16847, 0, 0.0596964, 0.977592, 0.165455, 0, 0.0695498, 0.971075, 0.161676, 0, 0.0798676, 0.963967, 0.157458, 0, 0.0906201, 0.956397, 0.152836, 0, 0.101783, 0.947489, 0.147467, 0, 0.113333, 0.937564, 0.14145, 0, 0.125254, 0.928182, 0.135383, 0, 0.137529, 0.919027, 0.129212, 0, 0.150144, 0.909618, 0.12276, 0, 0.163088, 0.900492, 0.116273, 0, 0.176351, 0.891671, 0.1098, 0, 0.189924, 0.883146, 0.103362, 0, 0.203799, 0.875151, 0.0970799, 0, 0.21797, 0.868338, 0.0911732, 0, 0.232433, 0.862033, 0.0854966, 0, 0.247182, 0.856107, 0.0800691, 0, 0.262216, 0.850644, 0.0749618, 0, 0.27753, 0.845261, 0.070079, 0, 0.293124, 0.839885, 0.0654321, 0, 0.308997, 0.834609, 0.0610975, 0, 0.325149, 0.829083, 0.0569741, 0, 0.341581, 0.82404, 0.0531736, 0, 0.358294, 0.818968, 0.049665, 0, 0.37529, 0.813496, 0.0463856, 0, 0.392573, 0.807533, 0.0433217, 0, 0.410148, 0.80099, 0.0404402, 0, 0.428019, 0.793891, 0.0377578, 0, 0.446192, 0.786281, 0.0352616, 0, 0.464676, 0.778773, 0.0329577, 0, 0.483478, 0.770737, 0.030808, 0, 0.502608, 0.762094, 0.0287964, 0, 0.522079, 0.752898, 0.0269254, 0, 0.541905, 0.743306, 0.0251926, 0, 0.5621, 0.733416, 0.023595, 0, 0.582684, 0.723742, 0.0221155, 0, 0.603677, 0.713542, 0.0207435, 0, 0.625106, 0.702755, 0.019434, 0, 0.646998, 0.691484, 0.0182046, 0, 0.66939, 0.680531, 0.0170771, 0, 0.692324, 0.66953, 0.0160339, 0, 0.715849, 0.658126, 0.0150677, 0, 0.740028, 0.646933, 0.0141551, 0, 0.764937, 0.636107, 0.0133179, 0, 0.790673, 0.625271, 0.0125284, 0, 0.817358, 0.615225, 0.0117937, 0, 0.84515, 0.605678, 0.0111181, 0, 0.874244, 0.59583, 0.0104759, 0, 0.904828, 0.585704, 0.00986672, 0, 0.936508, 0.575413, 0.00929712, 0, 0.968254, 0.565373, 0.00876713, 0, 1, 1, 0.214058, 0, 0, 0.999999, 0.214058, 0, 0, 0.999994, 0.214055, 0, 0, 0.999966, 0.214039, 0, 0.000259642, 0.999893, 0.213998, 0, 0.00200075, 0.999737, 0.21391, 0, 0.00527775, 0.999449, 0.213745, 0, 0.00983959, 0.99896, 0.213458, 0, 0.0154755, 0.9979, 0.212855, 0, 0.0220249, 0.994278, 0.210779, 0, 0.0293654, 0.992254, 0.20926, 0, 0.0374021, 0.98881, 0.206908, 0, 0.0460604, 0.984715, 0.204009, 0, 0.0552802, 0.979738, 0.200471, 0, 0.0650127, 0.972884, 0.195813, 0, 0.0752175, 0.965996, 0.190856, 0, 0.0858612, 0.957974, 0.185077, 0, 0.0969155, 0.949155, 0.17868, 0, 0.108356, 0.939288, 0.171513, 0, 0.120163, 0.928996, 0.163838, 0, 0.132319, 0.919563, 0.156246, 0, 0.144808, 0.910004, 0.148359, 0, 0.157618, 0.900791, 0.140417, 0, 0.170737, 0.892135, 0.132569, 0, 0.184155, 0.883803, 0.124741, 0, 0.197866, 0.876034, 0.117091, 0, 0.211861, 0.869219, 0.109835, 0, 0.226134, 0.863062, 0.102859, 0, 0.240682, 0.857795, 0.0962928, 0, 0.255499, 0.853009, 0.0900725, 0, 0.270583, 0.848603, 0.0842101, 0, 0.285931, 0.844335, 0.0786527, 0, 0.301542, 0.840208, 0.0734397, 0, 0.317415, 0.836035, 0.0685334, 0, 0.33355, 0.83172, 0.0639275, 0, 0.349948, 0.827135, 0.0595909, 0, 0.36661, 0.822797, 0.0556204, 0, 0.383539, 0.818387, 0.0519394, 0, 0.400738, 0.813565, 0.0485317, 0, 0.41821, 0.808142, 0.0453138, 0, 0.435961, 0.802212, 0.0423354, 0, 0.453997, 0.79573, 0.0395553, 0, 0.472324, 0.788741, 0.036988, 0, 0.490951, 0.781093, 0.0345688, 0, 0.509887, 0.773597, 0.0323297, 0, 0.529144, 0.765622, 0.0302719, 0, 0.548735, 0.757083, 0.0283477, 0, 0.568674, 0.747992, 0.0265562, 0, 0.588979, 0.738591, 0.0248844, 0, 0.609671, 0.728719, 0.0233342, 0, 0.630773, 0.719146, 0.0219081, 0, 0.652314, 0.709165, 0.0205711, 0, 0.674328, 0.69875, 0.0193248, 0, 0.696854, 0.687884, 0.0181582, 0, 0.719942, 0.676818, 0.0170746, 0, 0.743651, 0.666247, 0.0160718, 0, 0.768057, 0.655284, 0.0151262, 0, 0.793253, 0.64401, 0.0142561, 0, 0.819363, 0.633353, 0.0134327, 0, 0.846547, 0.622674, 0.012653, 0, 0.875017, 0.612265, 0.0119354, 0, 0.905021, 0.602455, 0.0112533, 0, 0.936508, 0.593147, 0.0106234, 0, 0.968254, 0.583592, 0.0100213, 0, 1, 1, 0.25717, 0, 0, 1, 0.25717, 0, 0, 0.999992, 0.257164, 0, 0, 0.999958, 0.257135, 0, 0.000641715, 0.999864, 0.25706, 0, 0.00305314, 0.999666, 0.256897, 0, 0.00700975, 0.999302, 0.256596, 0, 0.0122194, 0.998663, 0.25607, 0, 0.0184622, 0.995607, 0.254123, 0, 0.0255773, 0.993094, 0.252081, 0, 0.0334439, 0.9907, 0.249867, 0, 0.0419696, 0.98594, 0.246118, 0, 0.0510823, 0.981214, 0.242049, 0, 0.0607242, 0.974966, 0.236869, 0, 0.0708486, 0.967589, 0.230724, 0, 0.081417, 0.95915, 0.223635, 0, 0.0923974, 0.950257, 0.21596, 0, 0.103763, 0.940165, 0.207296, 0, 0.115491, 0.929396, 0.197901, 0, 0.127562, 0.919288, 0.188437, 0, 0.13996, 0.909428, 0.178762, 0, 0.15267, 0.900105, 0.169072, 0, 0.165679, 0.891418, 0.159478, 0, 0.178979, 0.883347, 0.15002, 0, 0.192558, 0.875992, 0.140813, 0, 0.20641, 0.869466, 0.13196, 0, 0.220529, 0.863699, 0.123501, 0, 0.234907, 0.858553, 0.115436, 0, 0.249542, 0.854379, 0.107901, 0, 0.264428, 0.850894, 0.10088, 0, 0.279564, 0.847632, 0.0942296, 0, 0.294947, 0.844571, 0.0879861, 0, 0.310575, 0.84163, 0.0821534, 0, 0.326448, 0.838542, 0.0766409, 0, 0.342566, 0.835412, 0.0715322, 0, 0.358929, 0.831899, 0.0666883, 0, 0.37554, 0.828177, 0.0622175, 0, 0.392399, 0.82416, 0.0580452, 0, 0.409511, 0.820393, 0.054267, 0, 0.426878, 0.816068, 0.0507172, 0, 0.444506, 0.811201, 0.0474041, 0, 0.4624, 0.805785, 0.0443174, 0, 0.480566, 0.799878, 0.0414562, 0, 0.499013, 0.793469, 0.0388147, 0, 0.517749, 0.786473, 0.0363453, 0, 0.536785, 0.778874, 0.0340225, 0, 0.556134, 0.771277, 0.0318599, 0, 0.575809, 0.763426, 0.0298859, 0, 0.595827, 0.755044, 0.0280357, 0, 0.616207, 0.746161, 0.0262979, 0, 0.636973, 0.737124, 0.0247295, 0, 0.65815, 0.72761, 0.0232514, 0, 0.679772, 0.717822, 0.0218755, 0, 0.701876, 0.708279, 0.0205942, 0, 0.724509, 0.698333, 0.0193947, 0, 0.74773, 0.68802, 0.0182717, 0, 0.771609, 0.677321, 0.0172044, 0, 0.79624, 0.666504, 0.0162122, 0, 0.821743, 0.656184, 0.0152924, 0, 0.84828, 0.64556, 0.0144326, 0, 0.876069, 0.634636, 0.0136157, 0, 0.905404, 0.624124, 0.0128612, 0, 0.936508, 0.613914, 0.0121435, 0, 0.968254, 0.603589, 0.0114887, 0, 1, 1, 0.307946, 0, 0, 0.999999, 0.307945, 0, 0, 0.999988, 0.307934, 0, 2.04479e-05, 0.999944, 0.307886, 0, 0.00127833, 0.999824, 0.307756, 0, 0.00445047, 0.999565, 0.30748, 0, 0.00914673, 0.999085, 0.306966, 0, 0.0150498, 0.998103, 0.306004, 0, 0.0219367, 0.994249, 0.303028, 0, 0.0296485, 0.991807, 0.300435, 0, 0.038068, 0.987773, 0.296554, 0, 0.0471062, 0.982673, 0.2916, 0, 0.0566942, 0.976623, 0.285641, 0, 0.0667768, 0.968757, 0.27815, 0, 0.0773099, 0.959849, 0.269529, 0, 0.088257, 0.950663, 0.260248, 0, 0.0995879, 0.940129, 0.249704, 0, 0.111277, 0.92895, 0.238291, 0, 0.123304, 0.917996, 0.226501, 0, 0.13565, 0.907813, 0.214669, 0, 0.148299, 0.898305, 0.202835, 0, 0.161237, 0.889626, 0.191158, 0, 0.174455, 0.88175, 0.179695, 0, 0.187941, 0.874715, 0.168548, 0, 0.201687, 0.868746, 0.15792, 0, 0.215687, 0.863703, 0.147807, 0, 0.229933, 0.859315, 0.138149, 0, 0.24442, 0.855538, 0.128993, 0, 0.259145, 0.852428, 0.120414, 0, 0.274103, 0.850168, 0.112498, 0, 0.289293, 0.848132, 0.105054, 0, 0.304711, 0.846291, 0.0981087, 0, 0.320357, 0.844431, 0.0915942, 0, 0.33623, 0.842493, 0.0855056, 0, 0.35233, 0.840368, 0.0798204, 0, 0.368658, 0.83798, 0.0745097, 0, 0.385214, 0.83523, 0.0695424, 0, 0.402002, 0.832091, 0.0649092, 0, 0.419023, 0.828667, 0.0606291, 0, 0.436282, 0.824805, 0.0566523, 0, 0.453782, 0.820988, 0.0530229, 0, 0.471529, 0.816635, 0.0496364, 0, 0.489528, 0.811725, 0.0464658, 0, 0.507788, 0.806316, 0.0435082, 0, 0.526317, 0.800469, 0.0407873, 0, 0.545124, 0.794107, 0.038255, 0, 0.564221, 0.787218, 0.0358825, 0, 0.583621, 0.779872, 0.0336785, 0, 0.603341, 0.772097, 0.0316379, 0, 0.623397, 0.764484, 0.0297379, 0, 0.643812, 0.756428, 0.0279581, 0, 0.664611, 0.748022, 0.0263153, 0, 0.685824, 0.739268, 0.0247799, 0, 0.707488, 0.73024, 0.0233385, 0, 0.729646, 0.720893, 0.0220035, 0, 0.752354, 0.71119, 0.0207555, 0, 0.77568, 0.701791, 0.0195843, 0, 0.799715, 0.692184, 0.0184891, 0, 0.824574, 0.682258, 0.0174541, 0, 0.850417, 0.67206, 0.0164873, 0, 0.877466, 0.661717, 0.0155959, 0, 0.90604, 0.651462, 0.0147519, 0, 0.936528, 0.641467, 0.0139727, 0, 0.968254, 0.631229, 0.0132363, 0, 1, 1, 0.367573, 0, 0, 0.999999, 0.367571, 0, 0, 0.999984, 0.367553, 0, 0.000183382, 0.999925, 0.367473, 0, 0.00225254, 0.999759, 0.367259, 0, 0.00628165, 0.99941, 0.366801, 0, 0.0117858, 0.998739, 0.365946, 0, 0.0184359, 0.995529, 0.363191, 0, 0.0260114, 0.992875, 0.360171, 0, 0.0343581, 0.989135, 0.355981, 0, 0.0433637, 0.984166, 0.350401, 0, 0.0529438, 0.977871, 0.343348, 0, 0.0630334, 0.96951, 0.334341, 0, 0.0735805, 0.959964, 0.323862, 0, 0.0845437, 0.950162, 0.312521, 0, 0.095889, 0.938882, 0.299577, 0, 0.107588, 0.926992, 0.285573, 0, 0.119617, 0.915589, 0.271212, 0, 0.131957, 0.904791, 0.256611, 0, 0.144591, 0.895177, 0.242224, 0, 0.157503, 0.886403, 0.227952, 0, 0.170682, 0.878957, 0.214192, 0, 0.184117, 0.872418, 0.200795, 0, 0.197799, 0.867029, 0.188015, 0, 0.21172, 0.862835, 0.175975, 0, 0.225873, 0.859411, 0.164526, 0, 0.240253, 0.856655, 0.153693, 0, 0.254854, 0.854519, 0.14352, 0, 0.269673, 0.852828, 0.13397, 0, 0.284707, 0.851412, 0.124984, 0, 0.299953, 0.850609, 0.116748, 0, 0.315408, 0.849855, 0.10905, 0, 0.331073, 0.849017, 0.101839, 0, 0.346946, 0.848079, 0.0951359, 0, 0.363028, 0.846911, 0.0888774, 0, 0.379318, 0.845445, 0.0830375, 0, 0.395818, 0.84362, 0.0775844, 0, 0.41253, 0.841411, 0.0725054, 0, 0.429457, 0.838768, 0.0677691, 0, 0.446602, 0.835801, 0.0634016, 0, 0.463968, 0.832341, 0.0593095, 0, 0.481561, 0.828424, 0.0555121, 0, 0.499386, 0.824312, 0.052024, 0, 0.51745, 0.819918, 0.0487865, 0, 0.535761, 0.815072, 0.0457801, 0, 0.554328, 0.809863, 0.0430184, 0, 0.573162, 0.804164, 0.0404245, 0, 0.592275, 0.798034, 0.0380146, 0, 0.611681, 0.791436, 0.0357436, 0, 0.631398, 0.784498, 0.0336475, 0, 0.651445, 0.777125, 0.0316666, 0, 0.671845, 0.769365, 0.0298122, 0, 0.692628, 0.761579, 0.0281001, 0, 0.713827, 0.753746, 0.0265049, 0, 0.735484, 0.745573, 0.0250067, 0, 0.75765, 0.737083, 0.0236026, 0, 0.78039, 0.728545, 0.0223302, 0, 0.803789, 0.719691, 0.0211243, 0, 0.82796, 0.710569, 0.0199983, 0, 0.853056, 0.701216, 0.0189569, 0, 0.879298, 0.692094, 0.0179702, 0, 0.907014, 0.682909, 0.0170418, 0, 0.936691, 0.673509, 0.0161732, 0, 0.968254, 0.663863, 0.0153406, 0, 1, 1, 0.437395, 0, 0, 0.999998, 0.437394, 0, 0, 0.99998, 0.437363, 0, 0.000616704, 0.999891, 0.437232, 0, 0.00367925, 0.999656, 0.436877, 0, 0.00867446, 0.999148, 0.436121, 0, 0.0150679, 0.997959, 0.434564, 0, 0.022531, 0.993464, 0.430134, 0, 0.0308507, 0.990606, 0.426077, 0, 0.0398805, 0.985027, 0.419397, 0, 0.0495148, 0.978491, 0.41118, 0, 0.0596749, 0.969643, 0.40048, 0, 0.0703001, 0.959189, 0.38769, 0, 0.0813427, 0.948223, 0.373575, 0, 0.0927641, 0.935955, 0.357622, 0, 0.104533, 0.923237, 0.34043, 0, 0.116624, 0.911074, 0.322735, 0, 0.129015, 0.899724, 0.30479, 0, 0.141687, 0.890189, 0.287392, 0, 0.154626, 0.881796, 0.270248, 0, 0.167818, 0.874781, 0.253659, 0, 0.181252, 0.869166, 0.237786, 0, 0.194918, 0.864725, 0.222618, 0, 0.208807, 0.861565, 0.208356, 0, 0.222913, 0.859284, 0.194867, 0, 0.237229, 0.857677, 0.18212, 0, 0.25175, 0.856714, 0.17018, 0, 0.266473, 0.856155, 0.158969, 0, 0.281392, 0.8558, 0.148413, 0, 0.296505, 0.855672, 0.138578, 0, 0.311811, 0.855538, 0.129345, 0, 0.327306, 0.855689, 0.120861, 0, 0.342991, 0.855767, 0.112969, 0, 0.358864, 0.855618, 0.105593, 0, 0.374925, 0.85525, 0.0987451, 0, 0.391176, 0.854583, 0.0923727, 0, 0.407616, 0.853534, 0.0864143, 0, 0.424249, 0.852061, 0.0808338, 0, 0.441076, 0.850253, 0.0756771, 0, 0.4581, 0.848004, 0.0708612, 0, 0.475324, 0.845333, 0.0663784, 0, 0.492754, 0.842376, 0.0622631, 0, 0.510394, 0.838956, 0.0584112, 0, 0.528251, 0.835121, 0.0548328, 0, 0.546331, 0.830842, 0.0514838, 0, 0.564644, 0.826212, 0.048355, 0, 0.583198, 0.821522, 0.0454714, 0, 0.602005, 0.816551, 0.0428263, 0, 0.621078, 0.811211, 0.0403612, 0, 0.640434, 0.805479, 0.038039, 0, 0.660089, 0.799409, 0.0358739, 0, 0.680066, 0.79306, 0.0338727, 0, 0.70039, 0.786395, 0.0319985, 0, 0.721094, 0.779416, 0.030241, 0, 0.742215, 0.77214, 0.0285951, 0, 0.7638, 0.764636, 0.0270747, 0, 0.785912, 0.756836, 0.0256354, 0, 0.808628, 0.749315, 0.0243027, 0, 0.832055, 0.741561, 0.0230497, 0, 0.856338, 0.733589, 0.0218801, 0, 0.88169, 0.725479, 0.020784, 0, 0.908441, 0.717255, 0.0197702, 0, 0.937125, 0.708829, 0.0188168, 0, 0.968254, 0.700191, 0.0179113, 0, 1, 1, 0.518937, 0, 0, 0.999998, 0.518933, 0, 0, 0.999967, 0.518883, 0, 0.00147741, 0.999832, 0.51866, 0, 0.00573221, 0.999466, 0.518057, 0, 0.011826, 0.998644, 0.516752, 0, 0.0192116, 0.994458, 0.512347, 0, 0.027573, 0.991223, 0.507675, 0, 0.0367099, 0.985515, 0.500188, 0, 0.046487, 0.978308, 0.490408, 0, 0.0568071, 0.968359, 0.477357, 0, 0.0675984, 0.95682, 0.461752, 0, 0.0788059, 0.943929, 0.443796, 0, 0.090386, 0.930224, 0.423893, 0, 0.102304, 0.916514, 0.402682, 0, 0.114532, 0.903653, 0.380914, 0, 0.127047, 0.892315, 0.359212, 0, 0.139828, 0.882942, 0.338102, 0, 0.152861, 0.875438, 0.31773, 0, 0.16613, 0.869642, 0.298186, 0, 0.179624, 0.865304, 0.279491, 0, 0.193332, 0.862382, 0.261804, 0, 0.207247, 0.860666, 0.245146, 0, 0.22136, 0.859788, 0.229406, 0, 0.235666, 0.859608, 0.214605, 0, 0.250158, 0.859912, 0.200691, 0, 0.264832, 0.86053, 0.187623, 0, 0.279684, 0.861368, 0.17539, 0, 0.294711, 0.862237, 0.163901, 0, 0.309911, 0.863127, 0.153175, 0, 0.32528, 0.863923, 0.143147, 0, 0.340819, 0.864567, 0.133781, 0, 0.356524, 0.865013, 0.125042, 0, 0.372397, 0.86539, 0.116952, 0, 0.388438, 0.865591, 0.109476, 0, 0.404645, 0.865517, 0.102542, 0, 0.421022, 0.865084, 0.0960688, 0, 0.437569, 0.864309, 0.0900499, 0, 0.454287, 0.863151, 0.0844328, 0, 0.471181, 0.861649, 0.0792218, 0, 0.488253, 0.859742, 0.0743482, 0, 0.505507, 0.857446, 0.0697963, 0, 0.522947, 0.854757, 0.0655364, 0, 0.54058, 0.851783, 0.061608, 0, 0.558412, 0.848516, 0.0579701, 0, 0.576449, 0.844897, 0.0545742, 0, 0.594701, 0.840956, 0.0514167, 0, 0.613178, 0.836676, 0.0484598, 0, 0.631892, 0.832075, 0.0456934, 0, 0.650856, 0.827191, 0.0431178, 0, 0.670088, 0.822295, 0.0407718, 0, 0.689606, 0.817294, 0.0386032, 0, 0.709434, 0.812013, 0.0365675, 0, 0.7296, 0.806465, 0.0346547, 0, 0.750138, 0.800691, 0.0328717, 0, 0.771093, 0.794709, 0.031211, 0, 0.792519, 0.788493, 0.0296504, 0, 0.814488, 0.782049, 0.0281782, 0, 0.837097, 0.775403, 0.0267965, 0, 0.860481, 0.76857, 0.0255002, 0, 0.884842, 0.761536, 0.0242759, 0, 0.910494, 0.754303, 0.0231142, 0, 0.937985, 0.74692, 0.0220305, 0, 0.968254, 0.739745, 0.0210192, 0, 1, 1, 0.613914, 0, 0, 0.999996, 0.613907, 0, 9.63597e-05, 0.999942, 0.613814, 0, 0.00301247, 0.999704, 0.613407, 0, 0.00870385, 0.999046, 0.612302, 0, 0.0160714, 0.995516, 0.608266, 0, 0.0245899, 0.991726, 0.602863, 0, 0.0339681, 0.985157, 0.593956, 0, 0.0440254, 0.97642, 0.581748, 0, 0.0546409, 0.964404, 0.565183, 0, 0.0657284, 0.950601, 0.545273, 0, 0.0772246, 0.935158, 0.522129, 0, 0.0890812, 0.919364, 0.496782, 0, 0.10126, 0.904754, 0.470571, 0, 0.113731, 0.89176, 0.444037, 0, 0.126469, 0.881492, 0.418322, 0, 0.139454, 0.873656, 0.393522, 0, 0.15267, 0.868053, 0.369795, 0, 0.166101, 0.864336, 0.347171, 0, 0.179736, 0.862259, 0.325737, 0, 0.193565, 0.861556, 0.305532, 0, 0.207578, 0.861776, 0.286416, 0, 0.221769, 0.862661, 0.268355, 0, 0.23613, 0.864015, 0.251334, 0, 0.250656, 0.865711, 0.235352, 0, 0.265343, 0.867519, 0.220302, 0, 0.280187, 0.869351, 0.206161, 0, 0.295183, 0.871144, 0.192908, 0, 0.31033, 0.872839, 0.180505, 0, 0.325624, 0.874307, 0.168848, 0, 0.341065, 0.875667, 0.158021, 0, 0.35665, 0.876758, 0.147877, 0, 0.37238, 0.87764, 0.138441, 0, 0.388253, 0.878237, 0.129627, 0, 0.404269, 0.878563, 0.121415, 0, 0.42043, 0.878572, 0.113741, 0, 0.436735, 0.87842, 0.106652, 0, 0.453187, 0.878057, 0.100097, 0, 0.469786, 0.877413, 0.0940128, 0, 0.486536, 0.87646, 0.0883462, 0, 0.503439, 0.875233, 0.0830924, 0, 0.520498, 0.8737, 0.0781975, 0, 0.537717, 0.871873, 0.07364, 0, 0.555102, 0.86978, 0.0694103, 0, 0.572657, 0.867405, 0.0654696, 0, 0.59039, 0.864751, 0.0617914, 0, 0.608307, 0.861818, 0.0583491, 0, 0.626419, 0.858645, 0.0551443, 0, 0.644733, 0.855307, 0.0521894, 0, 0.663264, 0.851736, 0.0494334, 0, 0.682025, 0.847927, 0.0468504, 0, 0.701032, 0.843888, 0.0444261, 0, 0.720308, 0.839629, 0.0421497, 0, 0.739875, 0.835158, 0.0400082, 0, 0.759764, 0.830509, 0.0380076, 0, 0.780014, 0.825714, 0.0361488, 0, 0.800673, 0.820729, 0.0343956, 0, 0.821803, 0.815751, 0.0327781, 0, 0.843492, 0.810752, 0.031275, 0, 0.86586, 0.805587, 0.0298542, 0, 0.889087, 0.800317, 0.0285397, 0, 0.913466, 0.79489, 0.0272948, 0, 0.93952, 0.789314, 0.0261139, 0, 0.96835, 0.783593, 0.0249938, 0, 1, 1, 0.724258, 0, 0, 0.999992, 0.724243, 0, 0.000726889, 0.99987, 0.724044, 0, 0.00569574, 0.999336, 0.72317, 0, 0.0131702, 0.996271, 0.719432, 0, 0.0220738, 0.991159, 0.712576, 0, 0.0319405, 0.982465, 0.700927, 0, 0.0425202, 0.97049, 0.684297, 0, 0.0536599, 0.953973, 0.661244, 0, 0.065258, 0.935546, 0.633804, 0, 0.0772427, 0.916596, 0.603071, 0, 0.0895616, 0.899353, 0.57105, 0, 0.102175, 0.885216, 0.539206, 0, 0.11505, 0.875076, 0.508714, 0, 0.128164, 0.868334, 0.479571, 0, 0.141495, 0.864414, 0.451796, 0, 0.155026, 0.862678, 0.425328, 0, 0.168745, 0.862835, 0.400352, 0, 0.182639, 0.864067, 0.376532, 0, 0.196699, 0.866086, 0.35391, 0, 0.210915, 0.868557, 0.332424, 0, 0.225282, 0.871271, 0.312053, 0, 0.239792, 0.874058, 0.292764, 0, 0.25444, 0.8768, 0.27453, 0, 0.269223, 0.87939, 0.257297, 0, 0.284135, 0.8819, 0.24114, 0, 0.299174, 0.884187, 0.225934, 0, 0.314337, 0.886262, 0.211669, 0, 0.329622, 0.888119, 0.198311, 0, 0.345026, 0.889709, 0.185783, 0, 0.360549, 0.891054, 0.174063, 0, 0.376189, 0.892196, 0.163143, 0, 0.391946, 0.893101, 0.152952, 0, 0.407819, 0.893803, 0.143475, 0, 0.423808, 0.894277, 0.134647, 0, 0.439914, 0.894532, 0.126434, 0, 0.456137, 0.894576, 0.1188, 0, 0.472479, 0.894393, 0.111694, 0, 0.48894, 0.893976, 0.105069, 0, 0.505523, 0.893346, 0.0989077, 0, 0.52223, 0.892502, 0.0931724, 0, 0.539064, 0.891441, 0.0878276, 0, 0.556028, 0.890276, 0.082903, 0, 0.573125, 0.888972, 0.0783505, 0, 0.590361, 0.887469, 0.0741083, 0, 0.607741, 0.885785, 0.0701633, 0, 0.62527, 0.883914, 0.0664835, 0, 0.642957, 0.881872, 0.0630567, 0, 0.660809, 0.879651, 0.0598527, 0, 0.678836, 0.877267, 0.0568615, 0, 0.69705, 0.874717, 0.05406, 0, 0.715465, 0.872012, 0.0514378, 0, 0.734098, 0.869157, 0.0489805, 0, 0.752968, 0.866155, 0.0466727, 0, 0.772101, 0.863014, 0.0445056, 0, 0.791529, 0.859748, 0.0424733, 0, 0.81129, 0.856416, 0.0405957, 0, 0.831438, 0.852958, 0.0388273, 0, 0.852044, 0.849382, 0.0371619, 0, 0.87321, 0.845694, 0.0355959, 0, 0.89509, 0.841893, 0.0341155, 0, 0.917932, 0.837981, 0.0327141, 0, 0.942204, 0.833963, 0.0313856, 0, 0.968981, 0.829847, 0.0301275, 0, 1, 1, 0.85214, 0, 0, 0.999969, 0.852095, 0, 0.00279627, 0.999483, 0.851408, 0, 0.0107635, 0.994545, 0.84579, 0, 0.0206454, 0.986188, 0.835231, 0, 0.0315756, 0.969847, 0.814687, 0, 0.0432021, 0.945951, 0.783735, 0, 0.0553396, 0.91917, 0.746074, 0, 0.0678766, 0.895488, 0.706938, 0, 0.0807395, 0.878232, 0.669534, 0, 0.0938767, 0.868252, 0.635168, 0, 0.10725, 0.863873, 0.603069, 0, 0.120832, 0.863369, 0.572514, 0, 0.134598, 0.86545, 0.543169, 0, 0.148533, 0.868803, 0.514578, 0, 0.16262, 0.872794, 0.486762, 0, 0.176849, 0.87702, 0.459811, 0, 0.19121, 0.881054, 0.433654, 0, 0.205694, 0.884974, 0.408574, 0, 0.220294, 0.888587, 0.384525, 0, 0.235005, 0.891877, 0.36156, 0, 0.24982, 0.894793, 0.339661, 0, 0.264737, 0.89743, 0.318913, 0, 0.279751, 0.899796, 0.299302, 0, 0.294859, 0.901943, 0.280843, 0, 0.310058, 0.903858, 0.263481, 0, 0.325346, 0.905574, 0.247197, 0, 0.340721, 0.907069, 0.231915, 0, 0.356181, 0.908379, 0.217614, 0, 0.371725, 0.90952, 0.20425, 0, 0.387353, 0.910483, 0.191758, 0, 0.403063, 0.91128, 0.180092, 0, 0.418854, 0.911936, 0.169222, 0, 0.434727, 0.912454, 0.159098, 0, 0.450682, 0.912835, 0.149668, 0, 0.466718, 0.913078, 0.140884, 0, 0.482837, 0.913192, 0.132709, 0, 0.499038, 0.913175, 0.125095, 0, 0.515324, 0.91304, 0.118012, 0, 0.531695, 0.912781, 0.111417, 0, 0.548153, 0.91241, 0.105281, 0, 0.5647, 0.911924, 0.0995691, 0, 0.581338, 0.911331, 0.0942531, 0, 0.59807, 0.910637, 0.0893076, 0, 0.6149, 0.90984, 0.0846998, 0, 0.63183, 0.908941, 0.0804044, 0, 0.648865, 0.907944, 0.0763984, 0, 0.666011, 0.906857, 0.0726638, 0, 0.683273, 0.90568, 0.0691783, 0, 0.700659, 0.904416, 0.0659222, 0, 0.718176, 0.903067, 0.0628782, 0, 0.735834, 0.901637, 0.0600307, 0, 0.753646, 0.900128, 0.0573647, 0, 0.771625, 0.898544, 0.0548668, 0, 0.78979, 0.89689, 0.052527, 0, 0.808162, 0.895165, 0.0503306, 0, 0.826771, 0.893371, 0.0482668, 0, 0.845654, 0.891572, 0.0463605, 0, 0.864863, 0.889763, 0.0445998, 0, 0.884472, 0.887894, 0.0429451, 0, 0.904592, 0.885967, 0.0413884, 0, 0.925407, 0.883984, 0.0399225, 0, 0.947271, 0.881945, 0.0385405, 0, 0.97105, 0.879854, 0.0372362, 0, 1, 0.999804, 0.995833, 0, 0, 0.938155, 0.933611, 0, 0.0158731, 0.864755, 0.854311, 0, 0.0317461, 0.888594, 0.865264, 0, 0.0476191, 0.905575, 0.863922, 0, 0.0634921, 0.915125, 0.850558, 0, 0.0793651, 0.920665, 0.829254, 0, 0.0952381, 0.924073, 0.802578, 0, 0.111111, 0.926304, 0.772211, 0, 0.126984, 0.927829, 0.739366, 0, 0.142857, 0.928924, 0.705033, 0, 0.15873, 0.92973, 0.670019, 0, 0.174603, 0.930339, 0.634993, 0, 0.190476, 0.930811, 0.600485, 0, 0.206349, 0.931191, 0.566897, 0, 0.222222, 0.93149, 0.534485, 0, 0.238095, 0.931737, 0.503429, 0, 0.253968, 0.931939, 0.473811, 0, 0.269841, 0.932108, 0.445668, 0, 0.285714, 0.93225, 0.418993, 0, 0.301587, 0.932371, 0.393762, 0, 0.31746, 0.932474, 0.369939, 0, 0.333333, 0.932562, 0.347479, 0, 0.349206, 0.932638, 0.326336, 0, 0.365079, 0.932703, 0.306462, 0, 0.380952, 0.93276, 0.287805, 0, 0.396825, 0.932809, 0.270313, 0, 0.412698, 0.932851, 0.253933, 0, 0.428571, 0.932887, 0.23861, 0, 0.444444, 0.932917, 0.224289, 0, 0.460317, 0.932943, 0.210917, 0, 0.47619, 0.932965, 0.19844, 0, 0.492063, 0.932982, 0.186807, 0, 0.507937, 0.932995, 0.175966, 0, 0.52381, 0.933005, 0.165869, 0, 0.539683, 0.933011, 0.156468, 0, 0.555556, 0.933013, 0.147719, 0, 0.571429, 0.933013, 0.139579, 0, 0.587302, 0.93301, 0.132007, 0, 0.603175, 0.933004, 0.124965, 0, 0.619048, 0.932994, 0.118416, 0, 0.634921, 0.932982, 0.112326, 0, 0.650794, 0.932968, 0.106663, 0, 0.666667, 0.93295, 0.101397, 0, 0.68254, 0.932931, 0.0964993, 0, 0.698413, 0.932908, 0.0919438, 0, 0.714286, 0.932883, 0.0877057, 0, 0.730159, 0.932856, 0.0837623, 0, 0.746032, 0.932827, 0.0800921, 0, 0.761905, 0.932796, 0.0766754, 0, 0.777778, 0.932762, 0.0734936, 0, 0.793651, 0.932727, 0.0705296, 0, 0.809524, 0.932689, 0.0677676, 0, 0.825397, 0.93265, 0.0651929, 0, 0.84127, 0.932609, 0.0627917, 0, 0.857143, 0.932565, 0.0605515, 0, 0.873016, 0.932521, 0.0584606, 0, 0.888889, 0.932474, 0.0565082, 0, 0.904762, 0.932427, 0.0546841, 0, 0.920635, 0.932377, 0.0529793, 0, 0.936508, 0.932326, 0.0513851, 0, 0.952381, 0.932274, 0.0498936, 0, 0.968254, 0.93222, 0.0484975, 0, 0.984127, 0.932164, 0.0471899, 0, 1 ];    // data textures    const ltc_float_1 = new Float32Array( LTC_MAT_1 );   const ltc_float_2 = new Float32Array( LTC_MAT_2 );    const LTC_FLOAT_1 = new DataTexture( ltc_float_1, 64, 64, RGBAFormat, FloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1 );   const LTC_FLOAT_2 = new DataTexture( ltc_float_2, 64, 64, RGBAFormat, FloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1 );    LTC_FLOAT_1.needsUpdate = true;   LTC_FLOAT_2.needsUpdate = true;    const ltc_half_1 = new Uint16Array( LTC_MAT_1.length );    LTC_MAT_1.forEach( function ( x, index ) {     ltc_half_1[ index ] = DataUtils.toHalfFloat( x );    } );    const ltc_half_2 = new Uint16Array( LTC_MAT_2.length );    LTC_MAT_2.forEach( function ( x, index ) {     ltc_half_2[ index ] = DataUtils.toHalfFloat( x );    } );    const LTC_HALF_1 = new DataTexture( ltc_half_1, 64, 64, RGBAFormat, HalfFloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1 );   const LTC_HALF_2 = new DataTexture( ltc_half_2, 64, 64, RGBAFormat, HalfFloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1 );    LTC_HALF_1.needsUpdate = true;   LTC_HALF_2.needsUpdate = true;    this.LTC_HALF_1 = LTC_HALF_1;   this.LTC_HALF_1 = LTC_HALF_2;    this.LTC_FLOAT_1 = LTC_FLOAT_1;   this.LTC_FLOAT_2 = LTC_FLOAT_2;    return this;   }  }  RectAreaLightTexturesLib.LTC_HALF_1 = null; RectAreaLightTexturesLib.LTC_HALF_1 = null;  RectAreaLightTexturesLib.LTC_FLOAT_1 = null; RectAreaLightTexturesLib.LTC_FLOAT_2 = null;  export { RectAreaLightTexturesLib }; 
^..^ FILENAME ^..^
addons|lights|RectAreaLightUniformsLib.js
^..^ CONTENTS ^..^
import { UniformsLib } from 'three'; import { RectAreaLightTexturesLib } from './RectAreaLightTexturesLib.js';  class RectAreaLightUniformsLib {   static init() {    RectAreaLightTexturesLib.init();    const { LTC_FLOAT_1, LTC_FLOAT_2, LTC_HALF_1, LTC_HALF_2 } = RectAreaLightTexturesLib;    // data textures    UniformsLib.LTC_FLOAT_1 = LTC_FLOAT_1;   UniformsLib.LTC_FLOAT_2 = LTC_FLOAT_2;    UniformsLib.LTC_HALF_1 = LTC_HALF_1;   UniformsLib.LTC_HALF_2 = LTC_HALF_2;   }  }  export { RectAreaLightUniformsLib }; 
^..^ FILENAME ^..^
addons|lines|Line2.js
^..^ CONTENTS ^..^
import { LineSegments2 } from '../lines/LineSegments2.js'; import { LineGeometry } from '../lines/LineGeometry.js'; import { LineMaterial } from '../lines/LineMaterial.js';  class Line2 extends LineSegments2 {   constructor( geometry = new LineGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {    super( geometry, material );    this.isLine2 = true;    this.type = 'Line2';   }  }  export { Line2 }; 
^..^ FILENAME ^..^
addons|lines|LineGeometry.js
^..^ CONTENTS ^..^
import { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';  class LineGeometry extends LineSegmentsGeometry {   constructor() {    super();    this.isLineGeometry = true;    this.type = 'LineGeometry';   }   setPositions( array ) {    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format    const length = array.length - 3;   const points = new Float32Array( 2 * length );    for ( let i = 0; i < length; i += 3 ) {     points[ 2 * i ] = array[ i ];    points[ 2 * i + 1 ] = array[ i + 1 ];    points[ 2 * i + 2 ] = array[ i + 2 ];     points[ 2 * i + 3 ] = array[ i + 3 ];    points[ 2 * i + 4 ] = array[ i + 4 ];    points[ 2 * i + 5 ] = array[ i + 5 ];    }    super.setPositions( points );    return this;   }   setColors( array ) {    // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format    const length = array.length - 3;   const colors = new Float32Array( 2 * length );    for ( let i = 0; i < length; i += 3 ) {     colors[ 2 * i ] = array[ i ];    colors[ 2 * i + 1 ] = array[ i + 1 ];    colors[ 2 * i + 2 ] = array[ i + 2 ];     colors[ 2 * i + 3 ] = array[ i + 3 ];    colors[ 2 * i + 4 ] = array[ i + 4 ];    colors[ 2 * i + 5 ] = array[ i + 5 ];    }    super.setColors( colors );    return this;   }   fromLine( line ) {    const geometry = line.geometry;    this.setPositions( geometry.attributes.position.array ); // assumes non-indexed    // set colors, maybe    return this;   }  }  export { LineGeometry }; 
^..^ FILENAME ^..^
addons|lines|LineMaterial.js
^..^ CONTENTS ^..^
import {  ShaderLib,  ShaderMaterial,  UniformsLib,  UniformsUtils,  Vector2, } from 'three';  UniformsLib.line = {   worldUnits: { value: 1 },  linewidth: { value: 1 },  resolution: { value: new Vector2( 1, 1 ) },  dashOffset: { value: 0 },  dashScale: { value: 1 },  dashSize: { value: 1 },  gapSize: { value: 1 } // todo FIX - maybe change to totalSize  };  ShaderLib[ 'line' ] = {   uniforms: UniformsUtils.merge( [   UniformsLib.common,   UniformsLib.fog,   UniformsLib.line  ] ),   vertexShader:  /* glsl */|   #include <common>   #include <color_pars_vertex>   #include <fog_pars_vertex>   #include <logdepthbuf_pars_vertex>   #include <clipping_planes_pars_vertex>    uniform float linewidth;   uniform vec2 resolution;    attribute vec3 instanceStart;   attribute vec3 instanceEnd;    attribute vec3 instanceColorStart;   attribute vec3 instanceColorEnd;    #ifdef WORLD_UNITS     varying vec4 worldPos;    varying vec3 worldStart;    varying vec3 worldEnd;     #ifdef USE_DASH      varying vec2 vUv;     #endif    #else     varying vec2 vUv;    #endif    #ifdef USE_DASH     uniform float dashScale;    attribute float instanceDistanceStart;    attribute float instanceDistanceEnd;    varying float vLineDistance;    #endif    void trimSegment( const in vec4 start, inout vec4 end ) {     // trim end segment so it terminates between the camera plane and the near plane     // conservative estimate of the near plane    float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column    float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column    float nearEstimate = - 0.5 * b / a;     float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );     end.xyz = mix( start.xyz, end.xyz, alpha );    }    void main() {     #ifdef USE_COLOR      vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;     #endif     #ifdef USE_DASH      vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;     vUv = uv;     #endif     float aspect = resolution.x / resolution.y;     // camera space    vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );    vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );     #ifdef WORLD_UNITS      worldStart = start.xyz;     worldEnd = end.xyz;     #else      vUv = uv;     #endif     // special case for perspective projection, and segments that terminate either in, or behind, the camera plane    // clearly the gpu firmware has a way of addressing this issue when projecting into ndc space    // but we need to perform ndc-space calculations in the shader, so we must address this issue directly    // perhaps there is a more elegant solution -- WestLangley     bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column     if ( perspective ) {      if ( start.z < 0.0 && end.z >= 0.0 ) {       trimSegment( start, end );      } else if ( end.z < 0.0 && start.z >= 0.0 ) {       trimSegment( end, start );      }     }     // clip space    vec4 clipStart = projectionMatrix * start;    vec4 clipEnd = projectionMatrix * end;     // ndc space    vec3 ndcStart = clipStart.xyz / clipStart.w;    vec3 ndcEnd = clipEnd.xyz / clipEnd.w;     // direction    vec2 dir = ndcEnd.xy - ndcStart.xy;     // account for clip-space aspect ratio    dir.x *= aspect;    dir = normalize( dir );     #ifdef WORLD_UNITS      vec3 worldDir = normalize( end.xyz - start.xyz );     vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );     vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );     vec3 worldFwd = cross( worldDir, worldUp );     worldPos = position.y < 0.5 ? start: end;      // height offset     float hw = linewidth * 0.5;     worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;      // don't extend the line if we're rendering dashes because we     // won't be rendering the endcaps     #ifndef USE_DASH       // cap extension      worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;       // add width to the box      worldPos.xyz += worldFwd * hw;       // endcaps      if ( position.y > 1.0 || position.y < 0.0 ) {        worldPos.xyz -= worldFwd * 2.0 * hw;       }      #endif      // project the worldpos     vec4 clip = projectionMatrix * worldPos;      // shift the depth of the projected points so the line     // segments overlap neatly     vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;     clip.z = clipPose.z * clip.w;     #else      vec2 offset = vec2( dir.y, - dir.x );     // undo aspect ratio adjustment     dir.x /= aspect;     offset.x /= aspect;      // sign flip     if ( position.x < 0.0 ) offset *= - 1.0;      // endcaps     if ( position.y < 0.0 ) {       offset += - dir;      } else if ( position.y > 1.0 ) {       offset += dir;      }      // adjust for linewidth     offset *= linewidth;      // adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...     offset /= resolution.y;      // select end     vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;      // back to clip space     offset *= clip.w;      clip.xy += offset;     #endif     gl_Position = clip;     vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation     #include <logdepthbuf_vertex>    #include <clipping_planes_vertex>    #include <fog_vertex>    }   |,   fragmentShader:  /* glsl */|   uniform vec3 diffuse;   uniform float opacity;   uniform float linewidth;    #ifdef USE_DASH     uniform float dashOffset;    uniform float dashSize;    uniform float gapSize;    #endif    varying float vLineDistance;    #ifdef WORLD_UNITS     varying vec4 worldPos;    varying vec3 worldStart;    varying vec3 worldEnd;     #ifdef USE_DASH      varying vec2 vUv;     #endif    #else     varying vec2 vUv;    #endif    #include <common>   #include <color_pars_fragment>   #include <fog_pars_fragment>   #include <logdepthbuf_pars_fragment>   #include <clipping_planes_pars_fragment>    vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {     float mua;    float mub;     vec3 p13 = p1 - p3;    vec3 p43 = p4 - p3;     vec3 p21 = p2 - p1;     float d1343 = dot( p13, p43 );    float d4321 = dot( p43, p21 );    float d1321 = dot( p13, p21 );    float d4343 = dot( p43, p43 );    float d2121 = dot( p21, p21 );     float denom = d2121 * d4343 - d4321 * d4321;     float numer = d1343 * d4321 - d1321 * d4343;     mua = numer / denom;    mua = clamp( mua, 0.0, 1.0 );    mub = ( d1343 + d4321 * ( mua ) ) / d4343;    mub = clamp( mub, 0.0, 1.0 );     return vec2( mua, mub );    }    void main() {     #include <clipping_planes_fragment>     #ifdef USE_DASH      if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps      if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX     #endif     float alpha = opacity;     #ifdef WORLD_UNITS      // Find the closest points on the view ray and the line segment     vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;     vec3 lineDir = worldEnd - worldStart;     vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );      vec3 p1 = worldStart + lineDir * params.x;     vec3 p2 = rayEnd * params.y;     vec3 delta = p1 - p2;     float len = length( delta );     float norm = len / linewidth;      #ifndef USE_DASH       #ifdef USE_ALPHA_TO_COVERAGE        float dnorm = fwidth( norm );       alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );       #else        if ( norm > 0.5 ) {         discard;        }       #endif      #endif     #else      #ifdef USE_ALPHA_TO_COVERAGE       // artifacts appear on some hardware if a derivative is taken within a conditional      float a = vUv.x;      float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;      float len2 = a * a + b * b;      float dlen = fwidth( len2 );       if ( abs( vUv.y ) > 1.0 ) {        alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );       }      #else       if ( abs( vUv.y ) > 1.0 ) {        float a = vUv.x;       float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;       float len2 = a * a + b * b;        if ( len2 > 1.0 ) discard;       }      #endif     #endif     vec4 diffuseColor = vec4( diffuse, alpha );     #include <logdepthbuf_fragment>    #include <color_fragment>     gl_FragColor = vec4( diffuseColor.rgb, alpha );     #include <tonemapping_fragment>    #include <colorspace_fragment>    #include <fog_fragment>    #include <premultiplied_alpha_fragment>    }   | };  class LineMaterial extends ShaderMaterial {   constructor( parameters ) {    super( {     type: 'LineMaterial',     uniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),     vertexShader: ShaderLib[ 'line' ].vertexShader,    fragmentShader: ShaderLib[ 'line' ].fragmentShader,     clipping: true // required for clipping support    } );    this.isLineMaterial = true;    this.setValues( parameters );   }   get color() {    return this.uniforms.diffuse.value;   }   set color( value ) {    this.uniforms.diffuse.value = value;   }   get worldUnits() {    return 'WORLD_UNITS' in this.defines;   }   set worldUnits( value ) {    if ( value === true ) {     this.defines.WORLD_UNITS = '';    } else {     delete this.defines.WORLD_UNITS;    }   }   get linewidth() {    return this.uniforms.linewidth.value;   }   set linewidth( value ) {    if ( ! this.uniforms.linewidth ) return;   this.uniforms.linewidth.value = value;   }   get dashed() {    return 'USE_DASH' in this.defines;   }   set dashed( value ) {    if ( ( value === true ) !== this.dashed ) {     this.needsUpdate = true;    }    if ( value === true ) {     this.defines.USE_DASH = '';    } else {     delete this.defines.USE_DASH;    }   }   get dashScale() {    return this.uniforms.dashScale.value;   }   set dashScale( value ) {    this.uniforms.dashScale.value = value;   }   get dashSize() {    return this.uniforms.dashSize.value;   }   set dashSize( value ) {    this.uniforms.dashSize.value = value;   }   get dashOffset() {    return this.uniforms.dashOffset.value;   }   set dashOffset( value ) {    this.uniforms.dashOffset.value = value;   }   get gapSize() {    return this.uniforms.gapSize.value;   }   set gapSize( value ) {    this.uniforms.gapSize.value = value;   }   get opacity() {    return this.uniforms.opacity.value;   }   set opacity( value ) {    if ( ! this.uniforms ) return;   this.uniforms.opacity.value = value;   }   get resolution() {    return this.uniforms.resolution.value;   }   set resolution( value ) {    this.uniforms.resolution.value.copy( value );   }   get alphaToCoverage() {    return 'USE_ALPHA_TO_COVERAGE' in this.defines;   }   set alphaToCoverage( value ) {    if ( ! this.defines ) return;    if ( ( value === true ) !== this.alphaToCoverage ) {     this.needsUpdate = true;    }    if ( value === true ) {     this.defines.USE_ALPHA_TO_COVERAGE = '';    } else {     delete this.defines.USE_ALPHA_TO_COVERAGE;    }   }  }  export { LineMaterial }; 
^..^ FILENAME ^..^
addons|lines|LineSegments2.js
^..^ CONTENTS ^..^
import {  Box3,  InstancedInterleavedBuffer,  InterleavedBufferAttribute,  Line3,  MathUtils,  Matrix4,  Mesh,  Sphere,  Vector3,  Vector4 } from 'three'; import { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js'; import { LineMaterial } from '../lines/LineMaterial.js';  const _viewport = new Vector4();  const _start = new Vector3(); const _end = new Vector3();  const _start4 = new Vector4(); const _end4 = new Vector4();  const _ssOrigin = new Vector4(); const _ssOrigin3 = new Vector3(); const _mvMatrix = new Matrix4(); const _line = new Line3(); const _closestPoint = new Vector3();  const _box = new Box3(); const _sphere = new Sphere(); const _clipToWorldVector = new Vector4();  let _ray, _lineWidth;  // Returns the margin required to expand by in world space given the distance from the camera, // line width, resolution, and camera projection function getWorldSpaceHalfWidth( camera, distance, resolution ) {   // transform into clip space, adjust the x and y values by the pixel width offset, then  // transform back into world space to get world offset. Note clip space is [-1, 1] so full  // width does not need to be halved.  _clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );  _clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );  _clipToWorldVector.x = _lineWidth / resolution.width;  _clipToWorldVector.y = _lineWidth / resolution.height;  _clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );  _clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );   return Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );  }  function raycastWorldUnits( lineSegments, intersects ) {   const matrixWorld = lineSegments.matrixWorld;  const geometry = lineSegments.geometry;  const instanceStart = geometry.attributes.instanceStart;  const instanceEnd = geometry.attributes.instanceEnd;  const segmentCount = Math.min( geometry.instanceCount, instanceStart.count );   for ( let i = 0, l = segmentCount; i < l; i ++ ) {    _line.start.fromBufferAttribute( instanceStart, i );   _line.end.fromBufferAttribute( instanceEnd, i );    _line.applyMatrix4( matrixWorld );    const pointOnLine = new Vector3();   const point = new Vector3();    _ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );   const isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;    if ( isInside ) {     intersects.push( {     point,     pointOnLine,     distance: _ray.origin.distanceTo( point ),     object: lineSegments,     face: null,     faceIndex: i,     uv: null,     uv1: null,    } );    }   }  }  function raycastScreenSpace( lineSegments, camera, intersects ) {   const projectionMatrix = camera.projectionMatrix;  const material = lineSegments.material;  const resolution = material.resolution;  const matrixWorld = lineSegments.matrixWorld;   const geometry = lineSegments.geometry;  const instanceStart = geometry.attributes.instanceStart;  const instanceEnd = geometry.attributes.instanceEnd;  const segmentCount = Math.min( geometry.instanceCount, instanceStart.count );   const near = - camera.near;   //   // pick a point 1 unit out along the ray to avoid the ray origin  // sitting at the camera origin which will cause "w" to be 0 when  // applying the projection matrix.  _ray.at( 1, _ssOrigin );   // ndc space [ - 1.0, 1.0 ]  _ssOrigin.w = 1;  _ssOrigin.applyMatrix4( camera.matrixWorldInverse );  _ssOrigin.applyMatrix4( projectionMatrix );  _ssOrigin.multiplyScalar( 1 / _ssOrigin.w );   // screen space  _ssOrigin.x *= resolution.x / 2;  _ssOrigin.y *= resolution.y / 2;  _ssOrigin.z = 0;   _ssOrigin3.copy( _ssOrigin );   _mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );   for ( let i = 0, l = segmentCount; i < l; i ++ ) {    _start4.fromBufferAttribute( instanceStart, i );   _end4.fromBufferAttribute( instanceEnd, i );    _start4.w = 1;   _end4.w = 1;    // camera space   _start4.applyMatrix4( _mvMatrix );   _end4.applyMatrix4( _mvMatrix );    // skip the segment if it's entirely behind the camera   const isBehindCameraNear = _start4.z > near && _end4.z > near;   if ( isBehindCameraNear ) {     continue;    }    // trim the segment if it extends behind camera near   if ( _start4.z > near ) {     const deltaDist = _start4.z - _end4.z;    const t = ( _start4.z - near ) / deltaDist;    _start4.lerp( _end4, t );    } else if ( _end4.z > near ) {     const deltaDist = _end4.z - _start4.z;    const t = ( _end4.z - near ) / deltaDist;    _end4.lerp( _start4, t );    }    // clip space   _start4.applyMatrix4( projectionMatrix );   _end4.applyMatrix4( projectionMatrix );    // ndc space [ - 1.0, 1.0 ]   _start4.multiplyScalar( 1 / _start4.w );   _end4.multiplyScalar( 1 / _end4.w );    // screen space   _start4.x *= resolution.x / 2;   _start4.y *= resolution.y / 2;    _end4.x *= resolution.x / 2;   _end4.y *= resolution.y / 2;    // create 2d segment   _line.start.copy( _start4 );   _line.start.z = 0;    _line.end.copy( _end4 );   _line.end.z = 0;    // get closest point on ray to segment   const param = _line.closestPointToPointParameter( _ssOrigin3, true );   _line.at( param, _closestPoint );    // check if the intersection point is within clip space   const zPos = MathUtils.lerp( _start4.z, _end4.z, param );   const isInClipSpace = zPos >= - 1 && zPos <= 1;    const isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;    if ( isInClipSpace && isInside ) {     _line.start.fromBufferAttribute( instanceStart, i );    _line.end.fromBufferAttribute( instanceEnd, i );     _line.start.applyMatrix4( matrixWorld );    _line.end.applyMatrix4( matrixWorld );     const pointOnLine = new Vector3();    const point = new Vector3();     _ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );     intersects.push( {     point: point,     pointOnLine: pointOnLine,     distance: _ray.origin.distanceTo( point ),     object: lineSegments,     face: null,     faceIndex: i,     uv: null,     uv1: null,    } );    }   }  }  class LineSegments2 extends Mesh {   constructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {    super( geometry, material );    this.isLineSegments2 = true;    this.type = 'LineSegments2';   }   // for backwards-compatibility, but could be a method of LineSegmentsGeometry...   computeLineDistances() {    const geometry = this.geometry;    const instanceStart = geometry.attributes.instanceStart;   const instanceEnd = geometry.attributes.instanceEnd;   const lineDistances = new Float32Array( 2 * instanceStart.count );    for ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {     _start.fromBufferAttribute( instanceStart, i );    _end.fromBufferAttribute( instanceEnd, i );     lineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];    lineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );    }    const instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1    geometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0   geometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1    return this;   }   raycast( raycaster, intersects ) {    const worldUnits = this.material.worldUnits;   const camera = raycaster.camera;    if ( camera === null && ! worldUnits ) {     console.error( 'LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );    }    const threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;    _ray = raycaster.ray;    const matrixWorld = this.matrixWorld;   const geometry = this.geometry;   const material = this.material;    _lineWidth = material.linewidth + threshold;    // check if we intersect the sphere bounds   if ( geometry.boundingSphere === null ) {     geometry.computeBoundingSphere();    }    _sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );    // increase the sphere bounds by the worst case line screen space width   let sphereMargin;   if ( worldUnits ) {     sphereMargin = _lineWidth * 0.5;    } else {     const distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );    sphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, material.resolution );    }    _sphere.radius += sphereMargin;    if ( _ray.intersectsSphere( _sphere ) === false ) {     return;    }    // check if we intersect the box bounds   if ( geometry.boundingBox === null ) {     geometry.computeBoundingBox();    }    _box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );    // increase the box bounds by the worst case line width   let boxMargin;   if ( worldUnits ) {     boxMargin = _lineWidth * 0.5;    } else {     const distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );    boxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, material.resolution );    }    _box.expandByScalar( boxMargin );    if ( _ray.intersectsBox( _box ) === false ) {     return;    }    if ( worldUnits ) {     raycastWorldUnits( this, intersects );    } else {     raycastScreenSpace( this, camera, intersects );    }   }   onBeforeRender( renderer ) {    const uniforms = this.material.uniforms;    if ( uniforms && uniforms.resolution ) {     renderer.getViewport( _viewport );    this.material.uniforms.resolution.value.set( _viewport.z, _viewport.w );    }   }  }  export { LineSegments2 }; 
^..^ FILENAME ^..^
addons|lines|LineSegmentsGeometry.js
^..^ CONTENTS ^..^
import {  Box3,  Float32BufferAttribute,  InstancedBufferGeometry,  InstancedInterleavedBuffer,  InterleavedBufferAttribute,  Sphere,  Vector3,  WireframeGeometry } from 'three';  const _box = new Box3(); const _vector = new Vector3();  class LineSegmentsGeometry extends InstancedBufferGeometry {   constructor() {    super();    this.isLineSegmentsGeometry = true;    this.type = 'LineSegmentsGeometry';    const positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];   const uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];   const index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];    this.setIndex( index );   this.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );   this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );   }   applyMatrix4( matrix ) {    const start = this.attributes.instanceStart;   const end = this.attributes.instanceEnd;    if ( start !== undefined ) {     start.applyMatrix4( matrix );     end.applyMatrix4( matrix );     start.needsUpdate = true;    }    if ( this.boundingBox !== null ) {     this.computeBoundingBox();    }    if ( this.boundingSphere !== null ) {     this.computeBoundingSphere();    }    return this;   }   setPositions( array ) {    let lineSegments;    if ( array instanceof Float32Array ) {     lineSegments = array;    } else if ( Array.isArray( array ) ) {     lineSegments = new Float32Array( array );    }    const instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz    this.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz   this.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz    //    this.computeBoundingBox();   this.computeBoundingSphere();    return this;   }   setColors( array ) {    let colors;    if ( array instanceof Float32Array ) {     colors = array;    } else if ( Array.isArray( array ) ) {     colors = new Float32Array( array );    }    const instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb    this.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb   this.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb    return this;   }   fromWireframeGeometry( geometry ) {    this.setPositions( geometry.attributes.position.array );    return this;   }   fromEdgesGeometry( geometry ) {    this.setPositions( geometry.attributes.position.array );    return this;   }   fromMesh( mesh ) {    this.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );    // set colors, maybe    return this;   }   fromLineSegments( lineSegments ) {    const geometry = lineSegments.geometry;    this.setPositions( geometry.attributes.position.array ); // assumes non-indexed    // set colors, maybe    return this;   }   computeBoundingBox() {    if ( this.boundingBox === null ) {     this.boundingBox = new Box3();    }    const start = this.attributes.instanceStart;   const end = this.attributes.instanceEnd;    if ( start !== undefined && end !== undefined ) {     this.boundingBox.setFromBufferAttribute( start );     _box.setFromBufferAttribute( end );     this.boundingBox.union( _box );    }   }   computeBoundingSphere() {    if ( this.boundingSphere === null ) {     this.boundingSphere = new Sphere();    }    if ( this.boundingBox === null ) {     this.computeBoundingBox();    }    const start = this.attributes.instanceStart;   const end = this.attributes.instanceEnd;    if ( start !== undefined && end !== undefined ) {     const center = this.boundingSphere.center;     this.boundingBox.getCenter( center );     let maxRadiusSq = 0;     for ( let i = 0, il = start.count; i < il; i ++ ) {      _vector.fromBufferAttribute( start, i );     maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );      _vector.fromBufferAttribute( end, i );     maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );     }     this.boundingSphere.radius = Math.sqrt( maxRadiusSq );     if ( isNaN( this.boundingSphere.radius ) ) {      console.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );     }    }   }   toJSON() {    // todo   }   applyMatrix( matrix ) {    console.warn( 'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().' );    return this.applyMatrix4( matrix );   }  }  export { LineSegmentsGeometry }; 
^..^ FILENAME ^..^
addons|lines|Wireframe.js
^..^ CONTENTS ^..^
import {  InstancedInterleavedBuffer,  InterleavedBufferAttribute,  Mesh,  Vector3,  Vector4 } from 'three'; import { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js'; import { LineMaterial } from '../lines/LineMaterial.js';  const _start = new Vector3(); const _end = new Vector3(); const _viewport = new Vector4();  class Wireframe extends Mesh {   constructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {    super( geometry, material );    this.isWireframe = true;    this.type = 'Wireframe';   }   // for backwards-compatibility, but could be a method of LineSegmentsGeometry...   computeLineDistances() {    const geometry = this.geometry;    const instanceStart = geometry.attributes.instanceStart;   const instanceEnd = geometry.attributes.instanceEnd;   const lineDistances = new Float32Array( 2 * instanceStart.count );    for ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {     _start.fromBufferAttribute( instanceStart, i );    _end.fromBufferAttribute( instanceEnd, i );     lineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];    lineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );    }    const instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1    geometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0   geometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1    return this;   }   onBeforeRender( renderer ) {    const uniforms = this.material.uniforms;    if ( uniforms && uniforms.resolution ) {     renderer.getViewport( _viewport );    this.material.uniforms.resolution.value.set( _viewport.z, _viewport.w );    }   }  }  export { Wireframe }; 
^..^ FILENAME ^..^
addons|lines|WireframeGeometry2.js
^..^ CONTENTS ^..^
import {  WireframeGeometry } from 'three'; import { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';  class WireframeGeometry2 extends LineSegmentsGeometry {   constructor( geometry ) {    super();    this.isWireframeGeometry2 = true;    this.type = 'WireframeGeometry2';    this.fromWireframeGeometry( new WireframeGeometry( geometry ) );    // set colors, maybe   }  }  export { WireframeGeometry2 }; 
^..^ FILENAME ^..^
addons|lines|webgpu|Line2.js
^..^ CONTENTS ^..^
import { LineSegments2 } from './LineSegments2.js'; import { LineGeometry } from '../LineGeometry.js';  import { Line2NodeMaterial } from 'three';  class Line2 extends LineSegments2 {   constructor( geometry = new LineGeometry(), material = new Line2NodeMaterial( { color: Math.random() * 0xffffff } ) ) {    super( geometry, material );    this.isLine2 = true;    this.type = 'Line2';   }  }  export { Line2 }; 
^..^ FILENAME ^..^
addons|lines|webgpu|LineSegments2.js
^..^ CONTENTS ^..^
import {  Box3,  InstancedInterleavedBuffer,  InterleavedBufferAttribute,  Line3,  MathUtils,  Matrix4,  Mesh,  Sphere,  Vector3,  Vector4,  Line2NodeMaterial } from 'three'; import { LineSegmentsGeometry } from '../../lines/LineSegmentsGeometry.js';  const _viewport = new Vector4();  const _start = new Vector3(); const _end = new Vector3();  const _start4 = new Vector4(); const _end4 = new Vector4();  const _ssOrigin = new Vector4(); const _ssOrigin3 = new Vector3(); const _mvMatrix = new Matrix4(); const _line = new Line3(); const _closestPoint = new Vector3();  const _box = new Box3(); const _sphere = new Sphere(); const _clipToWorldVector = new Vector4();  let _ray, _lineWidth;  // Returns the margin required to expand by in world space given the distance from the camera, // line width, resolution, and camera projection function getWorldSpaceHalfWidth( camera, distance, resolution ) {   // transform into clip space, adjust the x and y values by the pixel width offset, then  // transform back into world space to get world offset. Note clip space is [-1, 1] so full  // width does not need to be halved.  _clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );  _clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );  _clipToWorldVector.x = _lineWidth / resolution.width;  _clipToWorldVector.y = _lineWidth / resolution.height;  _clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );  _clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );   return Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );  }  function raycastWorldUnits( lineSegments, intersects ) {   const matrixWorld = lineSegments.matrixWorld;  const geometry = lineSegments.geometry;  const instanceStart = geometry.attributes.instanceStart;  const instanceEnd = geometry.attributes.instanceEnd;  const segmentCount = Math.min( geometry.instanceCount, instanceStart.count );   for ( let i = 0, l = segmentCount; i < l; i ++ ) {    _line.start.fromBufferAttribute( instanceStart, i );   _line.end.fromBufferAttribute( instanceEnd, i );    _line.applyMatrix4( matrixWorld );    const pointOnLine = new Vector3();   const point = new Vector3();    _ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );   const isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;    if ( isInside ) {     intersects.push( {     point,     pointOnLine,     distance: _ray.origin.distanceTo( point ),     object: lineSegments,     face: null,     faceIndex: i,     uv: null,     uv1: null,    } );    }   }  }  function raycastScreenSpace( lineSegments, camera, intersects ) {   const projectionMatrix = camera.projectionMatrix;  const material = lineSegments.material;  const resolution = material.resolution;  const matrixWorld = lineSegments.matrixWorld;   const geometry = lineSegments.geometry;  const instanceStart = geometry.attributes.instanceStart;  const instanceEnd = geometry.attributes.instanceEnd;  const segmentCount = Math.min( geometry.instanceCount, instanceStart.count );   const near = - camera.near;   //   // pick a point 1 unit out along the ray to avoid the ray origin  // sitting at the camera origin which will cause "w" to be 0 when  // applying the projection matrix.  _ray.at( 1, _ssOrigin );   // ndc space [ - 1.0, 1.0 ]  _ssOrigin.w = 1;  _ssOrigin.applyMatrix4( camera.matrixWorldInverse );  _ssOrigin.applyMatrix4( projectionMatrix );  _ssOrigin.multiplyScalar( 1 / _ssOrigin.w );   // screen space  _ssOrigin.x *= resolution.x / 2;  _ssOrigin.y *= resolution.y / 2;  _ssOrigin.z = 0;   _ssOrigin3.copy( _ssOrigin );   _mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );   for ( let i = 0, l = segmentCount; i < l; i ++ ) {    _start4.fromBufferAttribute( instanceStart, i );   _end4.fromBufferAttribute( instanceEnd, i );    _start4.w = 1;   _end4.w = 1;    // camera space   _start4.applyMatrix4( _mvMatrix );   _end4.applyMatrix4( _mvMatrix );    // skip the segment if it's entirely behind the camera   const isBehindCameraNear = _start4.z > near && _end4.z > near;   if ( isBehindCameraNear ) {     continue;    }    // trim the segment if it extends behind camera near   if ( _start4.z > near ) {     const deltaDist = _start4.z - _end4.z;    const t = ( _start4.z - near ) / deltaDist;    _start4.lerp( _end4, t );    } else if ( _end4.z > near ) {     const deltaDist = _end4.z - _start4.z;    const t = ( _end4.z - near ) / deltaDist;    _end4.lerp( _start4, t );    }    // clip space   _start4.applyMatrix4( projectionMatrix );   _end4.applyMatrix4( projectionMatrix );    // ndc space [ - 1.0, 1.0 ]   _start4.multiplyScalar( 1 / _start4.w );   _end4.multiplyScalar( 1 / _end4.w );    // screen space   _start4.x *= resolution.x / 2;   _start4.y *= resolution.y / 2;    _end4.x *= resolution.x / 2;   _end4.y *= resolution.y / 2;    // create 2d segment   _line.start.copy( _start4 );   _line.start.z = 0;    _line.end.copy( _end4 );   _line.end.z = 0;    // get closest point on ray to segment   const param = _line.closestPointToPointParameter( _ssOrigin3, true );   _line.at( param, _closestPoint );    // check if the intersection point is within clip space   const zPos = MathUtils.lerp( _start4.z, _end4.z, param );   const isInClipSpace = zPos >= - 1 && zPos <= 1;    const isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;    if ( isInClipSpace && isInside ) {     _line.start.fromBufferAttribute( instanceStart, i );    _line.end.fromBufferAttribute( instanceEnd, i );     _line.start.applyMatrix4( matrixWorld );    _line.end.applyMatrix4( matrixWorld );     const pointOnLine = new Vector3();    const point = new Vector3();     _ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );     intersects.push( {     point: point,     pointOnLine: pointOnLine,     distance: _ray.origin.distanceTo( point ),     object: lineSegments,     face: null,     faceIndex: i,     uv: null,     uv1: null,    } );    }   }  }  class LineSegments2 extends Mesh {   constructor( geometry = new LineSegmentsGeometry(), material = new Line2NodeMaterial( { color: Math.random() * 0xffffff } ) ) {    super( geometry, material );    this.isLineSegments2 = true;    this.type = 'LineSegments2';   }   // for backwards-compatibility, but could be a method of LineSegmentsGeometry...   computeLineDistances() {    const geometry = this.geometry;    const instanceStart = geometry.attributes.instanceStart;   const instanceEnd = geometry.attributes.instanceEnd;   const lineDistances = new Float32Array( 2 * instanceStart.count );    for ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {     _start.fromBufferAttribute( instanceStart, i );    _end.fromBufferAttribute( instanceEnd, i );     lineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];    lineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );    }    const instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1    geometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0   geometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1    return this;   }   raycast( raycaster, intersects ) {    const worldUnits = this.material.worldUnits;   const camera = raycaster.camera;    if ( camera === null && ! worldUnits ) {     console.error( 'LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );    }    const threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;    _ray = raycaster.ray;    const matrixWorld = this.matrixWorld;   const geometry = this.geometry;   const material = this.material;    _lineWidth = material.linewidth + threshold;    // check if we intersect the sphere bounds   if ( geometry.boundingSphere === null ) {     geometry.computeBoundingSphere();    }    _sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );    // increase the sphere bounds by the worst case line screen space width   let sphereMargin;   if ( worldUnits ) {     sphereMargin = _lineWidth * 0.5;    } else {     const distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );    sphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, material.resolution );    }    _sphere.radius += sphereMargin;    if ( _ray.intersectsSphere( _sphere ) === false ) {     return;    }    // check if we intersect the box bounds   if ( geometry.boundingBox === null ) {     geometry.computeBoundingBox();    }    _box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );    // increase the box bounds by the worst case line width   let boxMargin;   if ( worldUnits ) {     boxMargin = _lineWidth * 0.5;    } else {     const distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );    boxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, material.resolution );    }    _box.expandByScalar( boxMargin );    if ( _ray.intersectsBox( _box ) === false ) {     return;    }    if ( worldUnits ) {     raycastWorldUnits( this, intersects );    } else {     raycastScreenSpace( this, camera, intersects );    }   }   onBeforeRender( renderer ) {    const uniforms = this.material.uniforms;    if ( uniforms && uniforms.resolution ) {     renderer.getViewport( _viewport );    this.material.uniforms.resolution.value.set( _viewport.z, _viewport.w );    }   }  }  export { LineSegments2 }; 
^..^ FILENAME ^..^
addons|loaders|3DMLoader.js
^..^ CONTENTS ^..^
import {  BufferGeometryLoader,  CanvasTexture,  ClampToEdgeWrapping,  Color,  DirectionalLight,  DoubleSide,  FileLoader,  LinearFilter,  Line,  LineBasicMaterial,  Loader,  Matrix4,  Mesh,  MeshPhysicalMaterial,  MeshStandardMaterial,  Object3D,  PointLight,  Points,  PointsMaterial,  RectAreaLight,  RepeatWrapping,  SpotLight,  Sprite,  SpriteMaterial,  TextureLoader } from 'three';  import { EXRLoader } from '../loaders/EXRLoader.js';  const _taskCache = new WeakMap();  class Rhino3dmLoader extends Loader {   constructor( manager ) {    super( manager );    this.libraryPath = '';   this.libraryPending = null;   this.libraryBinary = null;   this.libraryConfig = {};    this.url = '';    this.workerLimit = 4;   this.workerPool = [];   this.workerNextTaskID = 1;   this.workerSourceURL = '';   this.workerConfig = {};    this.materials = [];   this.warnings = [];   }   setLibraryPath( path ) {    this.libraryPath = path;    return this;   }   setWorkerLimit( workerLimit ) {    this.workerLimit = workerLimit;    return this;   }   load( url, onLoad, onProgress, onError ) {    const loader = new FileLoader( this.manager );    loader.setPath( this.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( this.requestHeader );    this.url = url;    loader.load( url, ( buffer ) => {     // Check for an existing task using this buffer. A transferred buffer cannot be transferred    // again from this thread.    if ( _taskCache.has( buffer ) ) {      const cachedTask = _taskCache.get( buffer );      return cachedTask.promise.then( onLoad ).catch( onError );     }     this.decodeObjects( buffer, url )     .then( result => {       result.userData.warnings = this.warnings;      onLoad( result );       } )     .catch( e => onError( e ) );    }, onProgress, onError );   }   debug() {    console.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );   }   decodeObjects( buffer, url ) {    let worker;   let taskID;    const taskCost = buffer.byteLength;    const objectPending = this._getWorker( taskCost )    .then( ( _worker ) => {      worker = _worker;     taskID = this.workerNextTaskID ++;      return new Promise( ( resolve, reject ) => {       worker._callbacks[ taskID ] = { resolve, reject };       worker.postMessage( { type: 'decode', id: taskID, buffer }, [ buffer ] );       // this.debug();      } );     } )    .then( ( message ) => this._createGeometry( message.data ) )    .catch( e => {      throw e;     } );    // Remove task from the task list.   // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)   objectPending    .catch( () => true )    .then( () => {      if ( worker && taskID ) {       this._releaseTask( worker, taskID );       //this.debug();      }     } );    // Cache the task result.   _taskCache.set( buffer, {     url: url,    promise: objectPending    } );    return objectPending;   }   parse( data, onLoad, onError ) {    this.decodeObjects( data, '' )    .then( result => {      result.userData.warnings = this.warnings;     onLoad( result );     } )    .catch( e => onError( e ) );   }   _compareMaterials( material ) {    const mat = {};   mat.name = material.name;   mat.color = {};   mat.color.r = material.color.r;   mat.color.g = material.color.g;   mat.color.b = material.color.b;   mat.type = material.type;   mat.vertexColors = material.vertexColors;    const json = JSON.stringify( mat );    for ( let i = 0; i < this.materials.length; i ++ ) {     const m = this.materials[ i ];    const _mat = {};    _mat.name = m.name;    _mat.color = {};    _mat.color.r = m.color.r;    _mat.color.g = m.color.g;    _mat.color.b = m.color.b;    _mat.type = m.type;    _mat.vertexColors = m.vertexColors;     if ( JSON.stringify( _mat ) === json ) {      return m;     }    }    this.materials.push( material );    return material;   }   _createMaterial( material, renderEnvironment ) {    if ( material === undefined ) {     return new MeshStandardMaterial( {     color: new Color( 1, 1, 1 ),     metalness: 0.8,     name: Loader.DEFAULT_MATERIAL_NAME,     side: DoubleSide    } );    }    //console.log(material)    const mat = new MeshPhysicalMaterial( {     color: new Color( material.diffuseColor.r / 255.0, material.diffuseColor.g / 255.0, material.diffuseColor.b / 255.0 ),    emissive: new Color( material.emissionColor.r, material.emissionColor.g, material.emissionColor.b ),    flatShading: material.disableLighting,    ior: material.indexOfRefraction,    name: material.name,    reflectivity: material.reflectivity,    opacity: 1.0 - material.transparency,    side: DoubleSide,    specularColor: material.specularColor,    transparent: material.transparency > 0 ? true : false    } );    mat.userData.id = material.id;    if ( material.pbrSupported ) {     const pbr = material.pbr;     mat.anisotropy = pbr.anisotropic;    mat.anisotropyRotation = pbr.anisotropicRotation;    mat.color = new Color( pbr.baseColor.r, pbr.baseColor.g, pbr.baseColor.b );    mat.clearcoat = pbr.clearcoat;    mat.clearcoatRoughness = pbr.clearcoatRoughness;    mat.metalness = pbr.metallic;    mat.transmission = 1 - pbr.opacity;    mat.roughness = pbr.roughness;    mat.sheen = pbr.sheen;    mat.specularIntensity = pbr.specular;    mat.thickness = pbr.subsurface;    }    if ( material.pbrSupported && material.pbr.opacity === 0 && material.transparency === 1 ) {     //some compromises     mat.opacity = 0.2;    mat.transmission = 1.00;    }    const textureLoader = new TextureLoader();    for ( let i = 0; i < material.textures.length; i ++ ) {     const texture = material.textures[ i ];     if ( texture.image !== null ) {      const map = textureLoader.load( texture.image );      //console.log(texture.type )      switch ( texture.type ) {       case 'Bump':        mat.bumpMap = map;        break;       case 'Diffuse':        mat.map = map;        break;       case 'Emap':        mat.envMap = map;        break;       case 'Opacity':        mat.transmissionMap = map;        break;       case 'Transparency':        mat.alphaMap = map;       mat.transparent = true;        break;       case 'PBR_Alpha':        mat.alphaMap = map;       mat.transparent = true;        break;       case 'PBR_AmbientOcclusion':        mat.aoMap = map;        break;       case 'PBR_Anisotropic':        mat.anisotropyMap = map;        break;       case 'PBR_BaseColor':        mat.map = map;        break;       case 'PBR_Clearcoat':        mat.clearcoatMap = map;        break;       case 'PBR_ClearcoatBump':        mat.clearcoatNormalMap = map;        break;       case 'PBR_ClearcoatRoughness':        mat.clearcoatRoughnessMap = map;        break;       case 'PBR_Displacement':        mat.displacementMap = map;        break;       case 'PBR_Emission':        mat.emissiveMap = map;        break;       case 'PBR_Metallic':        mat.metalnessMap = map;        break;       case 'PBR_Roughness':        mat.roughnessMap = map;        break;       case 'PBR_Sheen':        mat.sheenColorMap = map;        break;       case 'PBR_Specular':        mat.specularColorMap = map;        break;       case 'PBR_Subsurface':        mat.thicknessMap = map;        break;       default:        this.warnings.push( {        message: |THREE.3DMLoader: No conversion exists for 3dm |texture.type}.|,        type: 'no conversion'       } );        break;      }      map.wrapS = texture.wrapU === 0 ? RepeatWrapping : ClampToEdgeWrapping;     map.wrapT = texture.wrapV === 0 ? RepeatWrapping : ClampToEdgeWrapping;      if ( texture.repeat ) {       map.repeat.set( texture.repeat[ 0 ], texture.repeat[ 1 ] );      }     }    }    if ( renderEnvironment ) {     new EXRLoader().load( renderEnvironment.image, function ( texture ) {      texture.mapping = THREE.EquirectangularReflectionMapping;     mat.envMap = texture;     } );    }    return mat;   }   _createGeometry( data ) {    const object = new Object3D();   const instanceDefinitionObjects = [];   const instanceDefinitions = [];   const instanceReferences = [];    object.userData[ 'layers' ] = data.layers;   object.userData[ 'groups' ] = data.groups;   object.userData[ 'settings' ] = data.settings;   object.userData.settings[ 'renderSettings' ] = data.renderSettings;   object.userData[ 'objectType' ] = 'File3dm';   object.userData[ 'materials' ] = null;    object.name = this.url;    let objects = data.objects;   const materials = data.materials;    for ( let i = 0; i < objects.length; i ++ ) {     const obj = objects[ i ];    const attributes = obj.attributes;     switch ( obj.objectType ) {      case 'InstanceDefinition':       instanceDefinitions.push( obj );       break;      case 'InstanceReference':       instanceReferences.push( obj );       break;      default:       let matId = null;       switch ( attributes.materialSource.name ) {        case 'ObjectMaterialSource_MaterialFromLayer':        //check layer index        if ( attributes.layerIndex >= 0 ) {          matId = data.layers[ attributes.layerIndex ].renderMaterialIndex;         }         break;        case 'ObjectMaterialSource_MaterialFromObject':         if ( attributes.materialIndex >= 0 ) {          matId = attributes.materialIndex;         }         break;       }       let material = null;       if ( matId >= 0 ) {        const rMaterial = materials[ matId ];       material = this._createMaterial( rMaterial, data.renderEnvironment );        }       const _object = this._createObject( obj, material );       if ( _object === undefined ) {        continue;       }       const layer = data.layers[ attributes.layerIndex ];       _object.visible = layer ? data.layers[ attributes.layerIndex ].visible : true;       if ( attributes.isInstanceDefinitionObject ) {        instanceDefinitionObjects.push( _object );       } else {        object.add( _object );       }       break;     }    }    for ( let i = 0; i < instanceDefinitions.length; i ++ ) {     const iDef = instanceDefinitions[ i ];     objects = [];     for ( let j = 0; j < iDef.attributes.objectIds.length; j ++ ) {      const objId = iDef.attributes.objectIds[ j ];      for ( let p = 0; p < instanceDefinitionObjects.length; p ++ ) {       const idoId = instanceDefinitionObjects[ p ].userData.attributes.id;       if ( objId === idoId ) {        objects.push( instanceDefinitionObjects[ p ] );       }      }     }     // Currently clones geometry and does not take advantage of instancing     for ( let j = 0; j < instanceReferences.length; j ++ ) {      const iRef = instanceReferences[ j ];      if ( iRef.geometry.parentIdefId === iDef.attributes.id ) {       const iRefObject = new Object3D();      const xf = iRef.geometry.xform.array;       const matrix = new Matrix4();      matrix.set( ...xf );       iRefObject.applyMatrix4( matrix );       for ( let p = 0; p < objects.length; p ++ ) {        iRefObject.add( objects[ p ].clone( true ) );       }       object.add( iRefObject );      }     }    }    object.userData[ 'materials' ] = this.materials;   object.name = '';   return object;   }   _createObject( obj, mat ) {    const loader = new BufferGeometryLoader();    const attributes = obj.attributes;    let geometry, material, _color, color;    switch ( obj.objectType ) {     case 'Point':    case 'PointSet':      geometry = loader.parse( obj.geometry );      if ( geometry.attributes.hasOwnProperty( 'color' ) ) {       material = new PointsMaterial( { vertexColors: true, sizeAttenuation: false, size: 2 } );      } else {       _color = attributes.drawColor;      color = new Color( _color.r / 255.0, _color.g / 255.0, _color.b / 255.0 );      material = new PointsMaterial( { color: color, sizeAttenuation: false, size: 2 } );      }      material = this._compareMaterials( material );      const points = new Points( geometry, material );     points.userData[ 'attributes' ] = attributes;     points.userData[ 'objectType' ] = obj.objectType;      if ( attributes.name ) {       points.name = attributes.name;      }      return points;     case 'Mesh':    case 'Extrusion':    case 'SubD':    case 'Brep':      if ( obj.geometry === null ) return;      geometry = loader.parse( obj.geometry );       if ( mat === null ) {       mat = this._createMaterial();      }       if ( geometry.attributes.hasOwnProperty( 'color' ) ) {       mat.vertexColors = true;      }      mat = this._compareMaterials( mat );      const mesh = new Mesh( geometry, mat );     mesh.castShadow = attributes.castsShadows;     mesh.receiveShadow = attributes.receivesShadows;     mesh.userData[ 'attributes' ] = attributes;     mesh.userData[ 'objectType' ] = obj.objectType;      if ( attributes.name ) {       mesh.name = attributes.name;      }      return mesh;     case 'Curve':      geometry = loader.parse( obj.geometry );      _color = attributes.drawColor;     color = new Color( _color.r / 255.0, _color.g / 255.0, _color.b / 255.0 );      material = new LineBasicMaterial( { color: color } );     material = this._compareMaterials( material );      const lines = new Line( geometry, material );     lines.userData[ 'attributes' ] = attributes;     lines.userData[ 'objectType' ] = obj.objectType;      if ( attributes.name ) {       lines.name = attributes.name;      }      return lines;     case 'TextDot':      geometry = obj.geometry;      const ctx = document.createElement( 'canvas' ).getContext( '2d' );     const font = ||geometry.fontHeight}px |geometry.fontFace}|;     ctx.font = font;     const width = ctx.measureText( geometry.text ).width + 10;     const height = geometry.fontHeight + 10;      const r = window.devicePixelRatio;      ctx.canvas.width = width * r;     ctx.canvas.height = height * r;     ctx.canvas.style.width = width + 'px';     ctx.canvas.style.height = height + 'px';     ctx.setTransform( r, 0, 0, r, 0, 0 );      ctx.font = font;     ctx.textBaseline = 'middle';     ctx.textAlign = 'center';     color = attributes.drawColor;     ctx.fillStyle = |rgba(|color.r},|color.g},|color.b},|color.a})|;     ctx.fillRect( 0, 0, width, height );     ctx.fillStyle = 'white';     ctx.fillText( geometry.text, width / 2, height / 2 );      const texture = new CanvasTexture( ctx.canvas );     texture.minFilter = LinearFilter;     texture.wrapS = ClampToEdgeWrapping;     texture.wrapT = ClampToEdgeWrapping;      material = new SpriteMaterial( { map: texture, depthTest: false } );     const sprite = new Sprite( material );     sprite.position.set( geometry.point[ 0 ], geometry.point[ 1 ], geometry.point[ 2 ] );     sprite.scale.set( width / 10, height / 10, 1.0 );      sprite.userData[ 'attributes' ] = attributes;     sprite.userData[ 'objectType' ] = obj.objectType;      if ( attributes.name ) {       sprite.name = attributes.name;      }      return sprite;     case 'Light':      geometry = obj.geometry;      let light;      switch ( geometry.lightStyle.name ) {       case 'LightStyle_WorldPoint':        light = new PointLight();       light.castShadow = attributes.castsShadows;       light.position.set( geometry.location[ 0 ], geometry.location[ 1 ], geometry.location[ 2 ] );       light.shadow.normalBias = 0.1;        break;       case 'LightStyle_WorldSpot':        light = new SpotLight();       light.castShadow = attributes.castsShadows;       light.position.set( geometry.location[ 0 ], geometry.location[ 1 ], geometry.location[ 2 ] );       light.target.position.set( geometry.direction[ 0 ], geometry.direction[ 1 ], geometry.direction[ 2 ] );       light.angle = geometry.spotAngleRadians;       light.shadow.normalBias = 0.1;        break;       case 'LightStyle_WorldRectangular':        light = new RectAreaLight();       const width = Math.abs( geometry.width[ 2 ] );       const height = Math.abs( geometry.length[ 0 ] );       light.position.set( geometry.location[ 0 ] - ( height / 2 ), geometry.location[ 1 ], geometry.location[ 2 ] - ( width / 2 ) );       light.height = height;       light.width = width;       light.lookAt( geometry.direction[ 0 ], geometry.direction[ 1 ], geometry.direction[ 2 ] );        break;       case 'LightStyle_WorldDirectional':        light = new DirectionalLight();       light.castShadow = attributes.castsShadows;       light.position.set( geometry.location[ 0 ], geometry.location[ 1 ], geometry.location[ 2 ] );       light.target.position.set( geometry.direction[ 0 ], geometry.direction[ 1 ], geometry.direction[ 2 ] );       light.shadow.normalBias = 0.1;        break;       case 'LightStyle_WorldLinear':       // no conversion exists, warning has already been printed to the console       break;       default:       break;      }      if ( light ) {       light.intensity = geometry.intensity;      _color = geometry.diffuse;      color = new Color( _color.r / 255.0, _color.g / 255.0, _color.b / 255.0 );      light.color = color;      light.userData[ 'attributes' ] = attributes;      light.userData[ 'objectType' ] = obj.objectType;      }      return light;    }   }   _initLibrary() {    if ( ! this.libraryPending ) {     // Load rhino3dm wrapper.    const jsLoader = new FileLoader( this.manager );    jsLoader.setPath( this.libraryPath );    const jsContent = new Promise( ( resolve, reject ) => {      jsLoader.load( 'rhino3dm.js', resolve, undefined, reject );     } );     // Load rhino3dm WASM binary.    const binaryLoader = new FileLoader( this.manager );    binaryLoader.setPath( this.libraryPath );    binaryLoader.setResponseType( 'arraybuffer' );    const binaryContent = new Promise( ( resolve, reject ) => {      binaryLoader.load( 'rhino3dm.wasm', resolve, undefined, reject );     } );     this.libraryPending = Promise.all( [ jsContent, binaryContent ] )     .then( ( [ jsContent, binaryContent ] ) => {       //this.libraryBinary = binaryContent;      this.libraryConfig.wasmBinary = binaryContent;       const fn = Rhino3dmWorker.toString();       const body = [       '/* rhino3dm.js */',       jsContent,       '/* worker */',       fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )      ].join( '|n' );       this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );      } );    }    return this.libraryPending;   }   _getWorker( taskCost ) {    return this._initLibrary().then( () => {     if ( this.workerPool.length < this.workerLimit ) {      const worker = new Worker( this.workerSourceURL );      worker._callbacks = {};     worker._taskCosts = {};     worker._taskLoad = 0;      worker.postMessage( {      type: 'init',      libraryConfig: this.libraryConfig     } );      worker.onmessage = e => {       const message = e.data;       switch ( message.type ) {        case 'warning':        this.warnings.push( message.data );        console.warn( message.data );        break;        case 'decode':        worker._callbacks[ message.id ].resolve( message );        break;        case 'error':        worker._callbacks[ message.id ].reject( message );        break;        default:        console.error( 'THREE.Rhino3dmLoader: Unexpected message, "' + message.type + '"' );       }      };      this.workerPool.push( worker );     } else {      this.workerPool.sort( function ( a, b ) {       return a._taskLoad > b._taskLoad ? - 1 : 1;      } );     }     const worker = this.workerPool[ this.workerPool.length - 1 ];     worker._taskLoad += taskCost;     return worker;    } );   }   _releaseTask( worker, taskID ) {    worker._taskLoad -= worker._taskCosts[ taskID ];   delete worker._callbacks[ taskID ];   delete worker._taskCosts[ taskID ];   }   dispose() {    for ( let i = 0; i < this.workerPool.length; ++ i ) {     this.workerPool[ i ].terminate();    }    this.workerPool.length = 0;    return this;   }  }  /* WEB WORKER */  function Rhino3dmWorker() {   let libraryPending;  let libraryConfig;  let rhino;  let taskID;   onmessage = function ( e ) {    const message = e.data;    switch ( message.type ) {     case 'init':      libraryConfig = message.libraryConfig;     const wasmBinary = libraryConfig.wasmBinary;     let RhinoModule;     libraryPending = new Promise( function ( resolve ) {       /* Like Basis Loader */      RhinoModule = { wasmBinary, onRuntimeInitialized: resolve };       rhino3dm( RhinoModule ); // eslint-disable-line no-undef       } ).then( () => {       rhino = RhinoModule;       } );      break;     case 'decode':      taskID = message.id;     const buffer = message.buffer;     libraryPending.then( () => {       try {        const data = decodeObjects( rhino, buffer );       self.postMessage( { type: 'decode', id: message.id, data } );       } catch ( error ) {        self.postMessage( { type: 'error', id: message.id, error } );       }      } );      break;    }   };   function decodeObjects( rhino, buffer ) {    const arr = new Uint8Array( buffer );   const doc = rhino.File3dm.fromByteArray( arr );    const objects = [];   const materials = [];   const layers = [];   const views = [];   const namedViews = [];   const groups = [];   const strings = [];    //Handle objects    const objs = doc.objects();   const cnt = objs.count;    for ( let i = 0; i < cnt; i ++ ) {     const _object = objs.get( i );     const object = extractObjectData( _object, doc );     _object.delete();     if ( object ) {      objects.push( object );     }    }    // Handle instance definitions   // console.log( |Instance Definitions Count: |doc.instanceDefinitions().count()}| );    for ( let i = 0; i < doc.instanceDefinitions().count; i ++ ) {     const idef = doc.instanceDefinitions().get( i );    const idefAttributes = extractProperties( idef );    idefAttributes.objectIds = idef.getObjectIds();     objects.push( { geometry: null, attributes: idefAttributes, objectType: 'InstanceDefinition' } );    }    // Handle materials    const textureTypes = [    // rhino.TextureType.Bitmap,    rhino.TextureType.Diffuse,    rhino.TextureType.Bump,    rhino.TextureType.Transparency,    rhino.TextureType.Opacity,    rhino.TextureType.Emap   ];    const pbrTextureTypes = [    rhino.TextureType.PBR_BaseColor,    rhino.TextureType.PBR_Subsurface,    rhino.TextureType.PBR_SubsurfaceScattering,    rhino.TextureType.PBR_SubsurfaceScatteringRadius,    rhino.TextureType.PBR_Metallic,    rhino.TextureType.PBR_Specular,    rhino.TextureType.PBR_SpecularTint,    rhino.TextureType.PBR_Roughness,    rhino.TextureType.PBR_Anisotropic,    rhino.TextureType.PBR_Anisotropic_Rotation,    rhino.TextureType.PBR_Sheen,    rhino.TextureType.PBR_SheenTint,    rhino.TextureType.PBR_Clearcoat,    rhino.TextureType.PBR_ClearcoatBump,    rhino.TextureType.PBR_ClearcoatRoughness,    rhino.TextureType.PBR_OpacityIor,    rhino.TextureType.PBR_OpacityRoughness,    rhino.TextureType.PBR_Emission,    rhino.TextureType.PBR_AmbientOcclusion,    rhino.TextureType.PBR_Displacement   ];    for ( let i = 0; i < doc.materials().count; i ++ ) {     const _material = doc.materials().get( i );     const material = extractProperties( _material );     const textures = [];     textures.push( ...extractTextures( _material, textureTypes, doc ) );     material.pbrSupported = _material.physicallyBased().supported;     if ( material.pbrSupported ) {      textures.push( ...extractTextures( _material, pbrTextureTypes, doc ) );     material.pbr = extractProperties( _material.physicallyBased() );     }     material.textures = textures;     materials.push( material );     _material.delete();    }    // Handle layers    for ( let i = 0; i < doc.layers().count; i ++ ) {     const _layer = doc.layers().get( i );    const layer = extractProperties( _layer );     layers.push( layer );     _layer.delete();    }    // Handle views    for ( let i = 0; i < doc.views().count; i ++ ) {     const _view = doc.views().get( i );    const view = extractProperties( _view );     views.push( view );     _view.delete();    }    // Handle named views    for ( let i = 0; i < doc.namedViews().count; i ++ ) {     const _namedView = doc.namedViews().get( i );    const namedView = extractProperties( _namedView );     namedViews.push( namedView );     _namedView.delete();    }    // Handle groups    for ( let i = 0; i < doc.groups().count; i ++ ) {     const _group = doc.groups().get( i );    const group = extractProperties( _group );     groups.push( group );     _group.delete();    }    // Handle settings    const settings = extractProperties( doc.settings() );    //TODO: Handle other document stuff like dimstyles, instance definitions, bitmaps etc.    // Handle dimstyles   // console.log( |Dimstyle Count: |doc.dimstyles().count()}| );    // Handle bitmaps   // console.log( |Bitmap Count: |doc.bitmaps().count()}| );    // Handle strings   // console.log( |Document Strings Count: |doc.strings().count()}| );   // Note: doc.strings().documentUserTextCount() counts any doc.strings defined in a section   // console.log( |Document User Text Count: |doc.strings().documentUserTextCount()}| );    const strings_count = doc.strings().count;    for ( let i = 0; i < strings_count; i ++ ) {     strings.push( doc.strings().get( i ) );    }    // Handle Render Environments for Material Environment    // get the id of the active render environment skylight, which we'll use for environment texture   const reflectionId = doc.settings().renderSettings().renderEnvironments.reflectionId;    const rc = doc.renderContent();    let renderEnvironment = null;    for ( let i = 0; i < rc.count; i ++ ) {     const content = rc.get( i );     switch ( content.kind ) {      case 'environment':       const id = content.id;       // there could be multiple render environments in a 3dm file      if ( id !== reflectionId ) break;       const renderTexture = content.findChild( 'texture' );      const fileName = renderTexture.fileName;       for ( let j = 0; j < doc.embeddedFiles().count; j ++ ) {        const _fileName = doc.embeddedFiles().get( j ).fileName;        if ( fileName === _fileName ) {         const background = doc.getEmbeddedFileAsBase64( fileName );        const backgroundImage = 'data:image/png;base64,' + background;        renderEnvironment = { type: 'renderEnvironment', image: backgroundImage, name: fileName };        }       }       break;     }    }    // Handle Render Settings    const renderSettings = {    ambientLight: doc.settings().renderSettings().ambientLight,    backgroundColorTop: doc.settings().renderSettings().backgroundColorTop,    backgroundColorBottom: doc.settings().renderSettings().backgroundColorBottom,    useHiddenLights: doc.settings().renderSettings().useHiddenLights,    depthCue: doc.settings().renderSettings().depthCue,    flatShade: doc.settings().renderSettings().flatShade,    renderBackFaces: doc.settings().renderSettings().renderBackFaces,    renderPoints: doc.settings().renderSettings().renderPoints,    renderCurves: doc.settings().renderSettings().renderCurves,    renderIsoParams: doc.settings().renderSettings().renderIsoParams,    renderMeshEdges: doc.settings().renderSettings().renderMeshEdges,    renderAnnotations: doc.settings().renderSettings().renderAnnotations,    useViewportSize: doc.settings().renderSettings().useViewportSize,    scaleBackgroundToFit: doc.settings().renderSettings().scaleBackgroundToFit,    transparentBackground: doc.settings().renderSettings().transparentBackground,    imageDpi: doc.settings().renderSettings().imageDpi,    shadowMapLevel: doc.settings().renderSettings().shadowMapLevel,    namedView: doc.settings().renderSettings().namedView,    snapShot: doc.settings().renderSettings().snapShot,    specificViewport: doc.settings().renderSettings().specificViewport,    groundPlane: extractProperties( doc.settings().renderSettings().groundPlane ),    safeFrame: extractProperties( doc.settings().renderSettings().safeFrame ),    dithering: extractProperties( doc.settings().renderSettings().dithering ),    skylight: extractProperties( doc.settings().renderSettings().skylight ),    linearWorkflow: extractProperties( doc.settings().renderSettings().linearWorkflow ),    renderChannels: extractProperties( doc.settings().renderSettings().renderChannels ),    sun: extractProperties( doc.settings().renderSettings().sun ),    renderEnvironments: extractProperties( doc.settings().renderSettings().renderEnvironments ),    postEffects: extractProperties( doc.settings().renderSettings().postEffects ),    };    doc.delete();    return { objects, materials, layers, views, namedViews, groups, strings, settings, renderSettings, renderEnvironment };   }   function extractTextures( m, tTypes, d ) {    const textures = [];    for ( let i = 0; i < tTypes.length; i ++ ) {     const _texture = m.getTexture( tTypes[ i ] );    if ( _texture ) {      let textureType = tTypes[ i ].constructor.name;     textureType = textureType.substring( 12, textureType.length );     const texture = extractTextureData( _texture, textureType, d );     textures.push( texture );     _texture.delete();     }    }    return textures;   }   function extractTextureData( t, tType, d ) {    const texture = { type: tType };    const image = d.getEmbeddedFileAsBase64( t.fileName );    texture.wrapU = t.wrapU;   texture.wrapV = t.wrapV;   texture.wrapW = t.wrapW;   const uvw = t.uvwTransform.toFloatArray( true );    texture.repeat = [ uvw[ 0 ], uvw[ 5 ] ];    if ( image ) {     texture.image = 'data:image/png;base64,' + image;    } else {     self.postMessage( { type: 'warning', id: taskID, data: {     message: |THREE.3DMLoader: Image for |tType} texture not embedded in file.|,     type: 'missing resource'    }     } );     texture.image = null;    }    return texture;   }   function extractObjectData( object, doc ) {    const _geometry = object.geometry();   const _attributes = object.attributes();   let objectType = _geometry.objectType;   let geometry, attributes, position, data, mesh;    // skip instance definition objects   //if( _attributes.isInstanceDefinitionObject ) { continue; }    // TODO: handle other geometry types   switch ( objectType ) {     case rhino.ObjectType.Curve:      const pts = curveToPoints( _geometry, 100 );      position = {};     attributes = {};     data = {};      position.itemSize = 3;     position.type = 'Float32Array';     position.array = [];      for ( let j = 0; j < pts.length; j ++ ) {       position.array.push( pts[ j ][ 0 ] );      position.array.push( pts[ j ][ 1 ] );      position.array.push( pts[ j ][ 2 ] );      }      attributes.position = position;     data.attributes = attributes;      geometry = { data };      break;     case rhino.ObjectType.Point:      const pt = _geometry.location;      position = {};     const color = {};     attributes = {};     data = {};      position.itemSize = 3;     position.type = 'Float32Array';     position.array = [ pt[ 0 ], pt[ 1 ], pt[ 2 ] ];      const _color = _attributes.drawColor( doc );      color.itemSize = 3;     color.type = 'Float32Array';     color.array = [ _color.r / 255.0, _color.g / 255.0, _color.b / 255.0 ];      attributes.position = position;     attributes.color = color;     data.attributes = attributes;      geometry = { data };      break;     case rhino.ObjectType.PointSet:    case rhino.ObjectType.Mesh:      geometry = _geometry.toThreejsJSON();      break;     case rhino.ObjectType.Brep:      const faces = _geometry.faces();     mesh = new rhino.Mesh();      for ( let faceIndex = 0; faceIndex < faces.count; faceIndex ++ ) {       const face = faces.get( faceIndex );      const _mesh = face.getMesh( rhino.MeshType.Any );       if ( _mesh ) {        mesh.append( _mesh );       _mesh.delete();       }       face.delete();      }      if ( mesh.faces().count > 0 ) {       mesh.compact();      geometry = mesh.toThreejsJSON();      faces.delete();      }      mesh.delete();      break;     case rhino.ObjectType.Extrusion:      mesh = _geometry.getMesh( rhino.MeshType.Any );      if ( mesh ) {       geometry = mesh.toThreejsJSON();      mesh.delete();      }      break;     case rhino.ObjectType.TextDot:      geometry = extractProperties( _geometry );      break;     case rhino.ObjectType.Light:      geometry = extractProperties( _geometry );      if ( geometry.lightStyle.name === 'LightStyle_WorldLinear' ) {       self.postMessage( { type: 'warning', id: taskID, data: {       message: |THREE.3DMLoader: No conversion exists for |objectType.constructor.name} |geometry.lightStyle.name}|,       type: 'no conversion',       guid: _attributes.id      }       } );      }      break;     case rhino.ObjectType.InstanceReference:      geometry = extractProperties( _geometry );     geometry.xform = extractProperties( _geometry.xform );     geometry.xform.array = _geometry.xform.toFloatArray( true );      break;     case rhino.ObjectType.SubD:      // TODO: precalculate resulting vertices and faces and warn on excessive results     _geometry.subdivide( 3 );     mesh = rhino.Mesh.createFromSubDControlNet( _geometry, false );     if ( mesh ) {       geometry = mesh.toThreejsJSON();      mesh.delete();      }      break;      /*     case rhino.ObjectType.Annotation:     case rhino.ObjectType.Hatch:     case rhino.ObjectType.ClipPlane:     */     default:      self.postMessage( { type: 'warning', id: taskID, data: {      message: |THREE.3DMLoader: Conversion not implemented for |objectType.constructor.name}|,      type: 'not implemented',      guid: _attributes.id     }      } );      break;    }    if ( geometry ) {     attributes = extractProperties( _attributes );    attributes.geometry = extractProperties( _geometry );     if ( _attributes.groupCount > 0 ) {      attributes.groupIds = _attributes.getGroupList();     }     if ( _attributes.userStringCount > 0 ) {      attributes.userStrings = _attributes.getUserStrings();     }     if ( _geometry.userStringCount > 0 ) {      attributes.geometry.userStrings = _geometry.getUserStrings();     }     if ( _attributes.decals().count > 0 ) {      self.postMessage( { type: 'warning', id: taskID, data: {      message: 'THREE.3DMLoader: No conversion exists for the decals associated with this object.',      type: 'no conversion',      guid: _attributes.id     }      } );     }     attributes.drawColor = _attributes.drawColor( doc );     objectType = objectType.constructor.name;    objectType = objectType.substring( 11, objectType.length );     return { geometry, attributes, objectType };    } else {     self.postMessage( { type: 'warning', id: taskID, data: {     message: |THREE.3DMLoader: |objectType.constructor.name} has no associated mesh geometry.|,     type: 'missing mesh',     guid: _attributes.id    }     } );    }   }   function extractProperties( object ) {    const result = {};    for ( const property in object ) {     const value = object[ property ];     if ( typeof value !== 'function' ) {      if ( typeof value === 'object' && value !== null && value.hasOwnProperty( 'constructor' ) ) {       result[ property ] = { name: value.constructor.name, value: value.value };      } else if ( typeof value === 'object' && value !== null ) {       result[ property ] = extractProperties( value );      } else {       result[ property ] = value;      }     } else {      // these are functions that could be called to extract more data.     //console.log( ||property}: |object[ property ].constructor.name}| );     }    }    return result;   }   function curveToPoints( curve, pointLimit ) {    let pointCount = pointLimit;   let rc = [];   const ts = [];    if ( curve instanceof rhino.LineCurve ) {     return [ curve.pointAtStart, curve.pointAtEnd ];    }    if ( curve instanceof rhino.PolylineCurve ) {     pointCount = curve.pointCount;    for ( let i = 0; i < pointCount; i ++ ) {      rc.push( curve.point( i ) );     }     return rc;    }    if ( curve instanceof rhino.PolyCurve ) {     const segmentCount = curve.segmentCount;     for ( let i = 0; i < segmentCount; i ++ ) {      const segment = curve.segmentCurve( i );     const segmentArray = curveToPoints( segment, pointCount );     rc = rc.concat( segmentArray );     segment.delete();     }     return rc;    }    if ( curve instanceof rhino.ArcCurve ) {     pointCount = Math.floor( curve.angleDegrees / 5 );    pointCount = pointCount < 2 ? 2 : pointCount;    // alternative to this hardcoded version: https://stackoverflow.com/a/18499923/2179399    }    if ( curve instanceof rhino.NurbsCurve && curve.degree === 1 ) {     const pLine = curve.tryGetPolyline();     for ( let i = 0; i < pLine.count; i ++ ) {      rc.push( pLine.get( i ) );     }     pLine.delete();     return rc;    }    const domain = curve.domain;   const divisions = pointCount - 1.0;    for ( let j = 0; j < pointCount; j ++ ) {     const t = domain[ 0 ] + ( j / divisions ) * ( domain[ 1 ] - domain[ 0 ] );     if ( t === domain[ 0 ] || t === domain[ 1 ] ) {      ts.push( t );     continue;     }     const tan = curve.tangentAt( t );    const prevTan = curve.tangentAt( ts.slice( - 1 )[ 0 ] );     // Duplicated from THREE.Vector3    // How to pass imports to worker?     const tS = tan[ 0 ] * tan[ 0 ] + tan[ 1 ] * tan[ 1 ] + tan[ 2 ] * tan[ 2 ];    const ptS = prevTan[ 0 ] * prevTan[ 0 ] + prevTan[ 1 ] * prevTan[ 1 ] + prevTan[ 2 ] * prevTan[ 2 ];     const denominator = Math.sqrt( tS * ptS );     let angle;     if ( denominator === 0 ) {      angle = Math.PI / 2;     } else {      const theta = ( tan.x * prevTan.x + tan.y * prevTan.y + tan.z * prevTan.z ) / denominator;     angle = Math.acos( Math.max( - 1, Math.min( 1, theta ) ) );     }     if ( angle < 0.1 ) continue;     ts.push( t );    }    rc = ts.map( t => curve.pointAt( t ) );   return rc;   }  }  export { Rhino3dmLoader }; 
^..^ FILENAME ^..^
addons|loaders|3MFLoader.js
^..^ CONTENTS ^..^
import {  BufferAttribute,  BufferGeometry,  ClampToEdgeWrapping,  Color,  FileLoader,  Float32BufferAttribute,  Group,  LinearFilter,  LinearMipmapLinearFilter,  Loader,  Matrix4,  Mesh,  MeshPhongMaterial,  MeshStandardMaterial,  MirroredRepeatWrapping,  NearestFilter,  RepeatWrapping,  TextureLoader,  SRGBColorSpace } from 'three'; import * as fflate from '../libs/fflate.module.js';  const COLOR_SPACE_3MF = SRGBColorSpace;  /**  *  * 3D Manufacturing Format (3MF) specification: https://3mf.io/specification/  *  * The following features from the core specification are supported:  *  * - 3D Models  * - Object Resources (Meshes and Components)  * - Material Resources (Base Materials)  *  * 3MF Materials and Properties Extension are only partially supported.  *  * - Texture 2D  * - Texture 2D Groups  * - Color Groups (Vertex Colors)  * - Metallic Display Properties (PBR)  */  class ThreeMFLoader extends Loader {   constructor( manager ) {    super( manager );    this.availableExtensions = [];   }   load( url, onLoad, onProgress, onError ) {    const scope = this;   const loader = new FileLoader( scope.manager );   loader.setPath( scope.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( scope.requestHeader );   loader.setWithCredentials( scope.withCredentials );   loader.load( url, function ( buffer ) {     try {      onLoad( scope.parse( buffer ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( data ) {    const scope = this;   const textureLoader = new TextureLoader( this.manager );    function loadDocument( data ) {     let zip = null;    let file = null;     let relsName;    let modelRelsName;    const modelPartNames = [];    const texturesPartNames = [];     let modelRels;    const modelParts = {};    const printTicketParts = {};    const texturesParts = {};     const textDecoder = new TextDecoder();     try {      zip = fflate.unzipSync( new Uint8Array( data ) );     } catch ( e ) {      if ( e instanceof ReferenceError ) {       console.error( 'THREE.3MFLoader: fflate missing and file is compressed.' );      return null;      }     }     for ( file in zip ) {      if ( file.match( /|_rels|/.rels$/ ) ) {       relsName = file;      } else if ( file.match( /3D|/_rels|/.*|.model|.rels$/ ) ) {       modelRelsName = file;      } else if ( file.match( /^3D|/.*|.model$/ ) ) {       modelPartNames.push( file );      } else if ( file.match( /^3D|/Textures?|/.*/ ) ) {       texturesPartNames.push( file );      }     }     if ( relsName === undefined ) throw new Error( 'THREE.ThreeMFLoader: Cannot find relationship file |rels| in 3MF archive.' );     //     const relsView = zip[ relsName ];    const relsFileText = textDecoder.decode( relsView );    const rels = parseRelsXml( relsFileText );     //     if ( modelRelsName ) {      const relsView = zip[ modelRelsName ];     const relsFileText = textDecoder.decode( relsView );     modelRels = parseRelsXml( relsFileText );     }     //     for ( let i = 0; i < modelPartNames.length; i ++ ) {      const modelPart = modelPartNames[ i ];     const view = zip[ modelPart ];      const fileText = textDecoder.decode( view );     const xmlData = new DOMParser().parseFromString( fileText, 'application/xml' );      if ( xmlData.documentElement.nodeName.toLowerCase() !== 'model' ) {       console.error( 'THREE.3MFLoader: Error loading 3MF - no 3MF document found: ', modelPart );      }      const modelNode = xmlData.querySelector( 'model' );     const extensions = {};      for ( let i = 0; i < modelNode.attributes.length; i ++ ) {       const attr = modelNode.attributes[ i ];      if ( attr.name.match( /^xmlns:(.+)$/ ) ) {        extensions[ attr.value ] = RegExp.$1;       }      }      const modelData = parseModelNode( modelNode );     modelData[ 'xml' ] = modelNode;      if ( 0 < Object.keys( extensions ).length ) {       modelData[ 'extensions' ] = extensions;      }      modelParts[ modelPart ] = modelData;     }     //     for ( let i = 0; i < texturesPartNames.length; i ++ ) {      const texturesPartName = texturesPartNames[ i ];     texturesParts[ texturesPartName ] = zip[ texturesPartName ].buffer;     }     return {     rels: rels,     modelRels: modelRels,     model: modelParts,     printTicket: printTicketParts,     texture: texturesParts    };    }    function parseRelsXml( relsFileText ) {     const relationships = [];     const relsXmlData = new DOMParser().parseFromString( relsFileText, 'application/xml' );     const relsNodes = relsXmlData.querySelectorAll( 'Relationship' );     for ( let i = 0; i < relsNodes.length; i ++ ) {      const relsNode = relsNodes[ i ];      const relationship = {      target: relsNode.getAttribute( 'Target' ), //required      id: relsNode.getAttribute( 'Id' ), //required      type: relsNode.getAttribute( 'Type' ) //required     };      relationships.push( relationship );     }     return relationships;    }    function parseMetadataNodes( metadataNodes ) {     const metadataData = {};     for ( let i = 0; i < metadataNodes.length; i ++ ) {      const metadataNode = metadataNodes[ i ];     const name = metadataNode.getAttribute( 'name' );     const validNames = [      'Title',      'Designer',      'Description',      'Copyright',      'LicenseTerms',      'Rating',      'CreationDate',      'ModificationDate'     ];      if ( 0 <= validNames.indexOf( name ) ) {       metadataData[ name ] = metadataNode.textContent;      }     }     return metadataData;    }    function parseBasematerialsNode( basematerialsNode ) {     const basematerialsData = {     id: basematerialsNode.getAttribute( 'id' ), // required     basematerials: []    };     const basematerialNodes = basematerialsNode.querySelectorAll( 'base' );     for ( let i = 0; i < basematerialNodes.length; i ++ ) {      const basematerialNode = basematerialNodes[ i ];     const basematerialData = parseBasematerialNode( basematerialNode );     basematerialData.index = i; // the order and count of the material nodes form an implicit 0-based index     basematerialsData.basematerials.push( basematerialData );     }     return basematerialsData;    }    function parseTexture2DNode( texture2DNode ) {     const texture2dData = {     id: texture2DNode.getAttribute( 'id' ), // required     path: texture2DNode.getAttribute( 'path' ), // required     contenttype: texture2DNode.getAttribute( 'contenttype' ), // required     tilestyleu: texture2DNode.getAttribute( 'tilestyleu' ),     tilestylev: texture2DNode.getAttribute( 'tilestylev' ),     filter: texture2DNode.getAttribute( 'filter' ),    };     return texture2dData;    }    function parseTextures2DGroupNode( texture2DGroupNode ) {     const texture2DGroupData = {     id: texture2DGroupNode.getAttribute( 'id' ), // required     texid: texture2DGroupNode.getAttribute( 'texid' ), // required     displaypropertiesid: texture2DGroupNode.getAttribute( 'displaypropertiesid' )    };     const tex2coordNodes = texture2DGroupNode.querySelectorAll( 'tex2coord' );     const uvs = [];     for ( let i = 0; i < tex2coordNodes.length; i ++ ) {      const tex2coordNode = tex2coordNodes[ i ];     const u = tex2coordNode.getAttribute( 'u' );     const v = tex2coordNode.getAttribute( 'v' );      uvs.push( parseFloat( u ), parseFloat( v ) );     }     texture2DGroupData[ 'uvs' ] = new Float32Array( uvs );     return texture2DGroupData;    }    function parseColorGroupNode( colorGroupNode ) {     const colorGroupData = {     id: colorGroupNode.getAttribute( 'id' ), // required     displaypropertiesid: colorGroupNode.getAttribute( 'displaypropertiesid' )    };     const colorNodes = colorGroupNode.querySelectorAll( 'color' );     const colors = [];    const colorObject = new Color();     for ( let i = 0; i < colorNodes.length; i ++ ) {      const colorNode = colorNodes[ i ];     const color = colorNode.getAttribute( 'color' );      colorObject.setStyle( color.substring( 0, 7 ), COLOR_SPACE_3MF );      colors.push( colorObject.r, colorObject.g, colorObject.b );     }     colorGroupData[ 'colors' ] = new Float32Array( colors );     return colorGroupData;    }    function parseMetallicDisplaypropertiesNode( metallicDisplaypropetiesNode ) {     const metallicDisplaypropertiesData = {     id: metallicDisplaypropetiesNode.getAttribute( 'id' ) // required    };     const metallicNodes = metallicDisplaypropetiesNode.querySelectorAll( 'pbmetallic' );     const metallicData = [];     for ( let i = 0; i < metallicNodes.length; i ++ ) {      const metallicNode = metallicNodes[ i ];      metallicData.push( {      name: metallicNode.getAttribute( 'name' ), // required      metallicness: parseFloat( metallicNode.getAttribute( 'metallicness' ) ), // required      roughness: parseFloat( metallicNode.getAttribute( 'roughness' ) ) // required     } );     }     metallicDisplaypropertiesData.data = metallicData;     return metallicDisplaypropertiesData;    }    function parseBasematerialNode( basematerialNode ) {     const basematerialData = {};     basematerialData[ 'name' ] = basematerialNode.getAttribute( 'name' ); // required    basematerialData[ 'displaycolor' ] = basematerialNode.getAttribute( 'displaycolor' ); // required    basematerialData[ 'displaypropertiesid' ] = basematerialNode.getAttribute( 'displaypropertiesid' );     return basematerialData;    }    function parseMeshNode( meshNode ) {     const meshData = {};     const vertices = [];    const vertexNodes = meshNode.querySelectorAll( 'vertices vertex' );     for ( let i = 0; i < vertexNodes.length; i ++ ) {      const vertexNode = vertexNodes[ i ];     const x = vertexNode.getAttribute( 'x' );     const y = vertexNode.getAttribute( 'y' );     const z = vertexNode.getAttribute( 'z' );      vertices.push( parseFloat( x ), parseFloat( y ), parseFloat( z ) );     }     meshData[ 'vertices' ] = new Float32Array( vertices );     const triangleProperties = [];    const triangles = [];    const triangleNodes = meshNode.querySelectorAll( 'triangles triangle' );     for ( let i = 0; i < triangleNodes.length; i ++ ) {      const triangleNode = triangleNodes[ i ];     const v1 = triangleNode.getAttribute( 'v1' );     const v2 = triangleNode.getAttribute( 'v2' );     const v3 = triangleNode.getAttribute( 'v3' );     const p1 = triangleNode.getAttribute( 'p1' );     const p2 = triangleNode.getAttribute( 'p2' );     const p3 = triangleNode.getAttribute( 'p3' );     const pid = triangleNode.getAttribute( 'pid' );      const triangleProperty = {};      triangleProperty[ 'v1' ] = parseInt( v1, 10 );     triangleProperty[ 'v2' ] = parseInt( v2, 10 );     triangleProperty[ 'v3' ] = parseInt( v3, 10 );      triangles.push( triangleProperty[ 'v1' ], triangleProperty[ 'v2' ], triangleProperty[ 'v3' ] );      // optional      if ( p1 ) {       triangleProperty[ 'p1' ] = parseInt( p1, 10 );      }      if ( p2 ) {       triangleProperty[ 'p2' ] = parseInt( p2, 10 );      }      if ( p3 ) {       triangleProperty[ 'p3' ] = parseInt( p3, 10 );      }      if ( pid ) {       triangleProperty[ 'pid' ] = pid;      }      if ( 0 < Object.keys( triangleProperty ).length ) {       triangleProperties.push( triangleProperty );      }     }     meshData[ 'triangleProperties' ] = triangleProperties;    meshData[ 'triangles' ] = new Uint32Array( triangles );     return meshData;    }    function parseComponentsNode( componentsNode ) {     const components = [];     const componentNodes = componentsNode.querySelectorAll( 'component' );     for ( let i = 0; i < componentNodes.length; i ++ ) {      const componentNode = componentNodes[ i ];     const componentData = parseComponentNode( componentNode );     components.push( componentData );     }     return components;    }    function parseComponentNode( componentNode ) {     const componentData = {};     componentData[ 'objectId' ] = componentNode.getAttribute( 'objectid' ); // required     const transform = componentNode.getAttribute( 'transform' );     if ( transform ) {      componentData[ 'transform' ] = parseTransform( transform );     }     return componentData;    }    function parseTransform( transform ) {     const t = [];    transform.split( ' ' ).forEach( function ( s ) {      t.push( parseFloat( s ) );     } );     const matrix = new Matrix4();    matrix.set(     t[ 0 ], t[ 3 ], t[ 6 ], t[ 9 ],     t[ 1 ], t[ 4 ], t[ 7 ], t[ 10 ],     t[ 2 ], t[ 5 ], t[ 8 ], t[ 11 ],      0.0, 0.0, 0.0, 1.0    );     return matrix;    }    function parseObjectNode( objectNode ) {     const objectData = {     type: objectNode.getAttribute( 'type' )    };     const id = objectNode.getAttribute( 'id' );     if ( id ) {      objectData[ 'id' ] = id;     }     const pid = objectNode.getAttribute( 'pid' );     if ( pid ) {      objectData[ 'pid' ] = pid;     }     const pindex = objectNode.getAttribute( 'pindex' );     if ( pindex ) {      objectData[ 'pindex' ] = pindex;     }     const thumbnail = objectNode.getAttribute( 'thumbnail' );     if ( thumbnail ) {      objectData[ 'thumbnail' ] = thumbnail;     }     const partnumber = objectNode.getAttribute( 'partnumber' );     if ( partnumber ) {      objectData[ 'partnumber' ] = partnumber;     }     const name = objectNode.getAttribute( 'name' );     if ( name ) {      objectData[ 'name' ] = name;     }     const meshNode = objectNode.querySelector( 'mesh' );     if ( meshNode ) {      objectData[ 'mesh' ] = parseMeshNode( meshNode );     }     const componentsNode = objectNode.querySelector( 'components' );     if ( componentsNode ) {      objectData[ 'components' ] = parseComponentsNode( componentsNode );     }     return objectData;    }    function parseResourcesNode( resourcesNode ) {     const resourcesData = {};     resourcesData[ 'basematerials' ] = {};    const basematerialsNodes = resourcesNode.querySelectorAll( 'basematerials' );     for ( let i = 0; i < basematerialsNodes.length; i ++ ) {      const basematerialsNode = basematerialsNodes[ i ];     const basematerialsData = parseBasematerialsNode( basematerialsNode );     resourcesData[ 'basematerials' ][ basematerialsData[ 'id' ] ] = basematerialsData;     }     //     resourcesData[ 'texture2d' ] = {};    const textures2DNodes = resourcesNode.querySelectorAll( 'texture2d' );     for ( let i = 0; i < textures2DNodes.length; i ++ ) {      const textures2DNode = textures2DNodes[ i ];     const texture2DData = parseTexture2DNode( textures2DNode );     resourcesData[ 'texture2d' ][ texture2DData[ 'id' ] ] = texture2DData;     }     //     resourcesData[ 'colorgroup' ] = {};    const colorGroupNodes = resourcesNode.querySelectorAll( 'colorgroup' );     for ( let i = 0; i < colorGroupNodes.length; i ++ ) {      const colorGroupNode = colorGroupNodes[ i ];     const colorGroupData = parseColorGroupNode( colorGroupNode );     resourcesData[ 'colorgroup' ][ colorGroupData[ 'id' ] ] = colorGroupData;     }     //     resourcesData[ 'pbmetallicdisplayproperties' ] = {};    const pbmetallicdisplaypropertiesNodes = resourcesNode.querySelectorAll( 'pbmetallicdisplayproperties' );     for ( let i = 0; i < pbmetallicdisplaypropertiesNodes.length; i ++ ) {      const pbmetallicdisplaypropertiesNode = pbmetallicdisplaypropertiesNodes[ i ];     const pbmetallicdisplaypropertiesData = parseMetallicDisplaypropertiesNode( pbmetallicdisplaypropertiesNode );     resourcesData[ 'pbmetallicdisplayproperties' ][ pbmetallicdisplaypropertiesData[ 'id' ] ] = pbmetallicdisplaypropertiesData;     }     //     resourcesData[ 'texture2dgroup' ] = {};    const textures2DGroupNodes = resourcesNode.querySelectorAll( 'texture2dgroup' );     for ( let i = 0; i < textures2DGroupNodes.length; i ++ ) {      const textures2DGroupNode = textures2DGroupNodes[ i ];     const textures2DGroupData = parseTextures2DGroupNode( textures2DGroupNode );     resourcesData[ 'texture2dgroup' ][ textures2DGroupData[ 'id' ] ] = textures2DGroupData;     }     //     resourcesData[ 'object' ] = {};    const objectNodes = resourcesNode.querySelectorAll( 'object' );     for ( let i = 0; i < objectNodes.length; i ++ ) {      const objectNode = objectNodes[ i ];     const objectData = parseObjectNode( objectNode );     resourcesData[ 'object' ][ objectData[ 'id' ] ] = objectData;     }     return resourcesData;    }    function parseBuildNode( buildNode ) {     const buildData = [];    const itemNodes = buildNode.querySelectorAll( 'item' );     for ( let i = 0; i < itemNodes.length; i ++ ) {      const itemNode = itemNodes[ i ];     const buildItem = {      objectId: itemNode.getAttribute( 'objectid' )     };     const transform = itemNode.getAttribute( 'transform' );      if ( transform ) {       buildItem[ 'transform' ] = parseTransform( transform );      }      buildData.push( buildItem );     }     return buildData;    }    function parseModelNode( modelNode ) {     const modelData = { unit: modelNode.getAttribute( 'unit' ) || 'millimeter' };    const metadataNodes = modelNode.querySelectorAll( 'metadata' );     if ( metadataNodes ) {      modelData[ 'metadata' ] = parseMetadataNodes( metadataNodes );     }     const resourcesNode = modelNode.querySelector( 'resources' );     if ( resourcesNode ) {      modelData[ 'resources' ] = parseResourcesNode( resourcesNode );     }     const buildNode = modelNode.querySelector( 'build' );     if ( buildNode ) {      modelData[ 'build' ] = parseBuildNode( buildNode );     }     return modelData;    }    function buildTexture( texture2dgroup, objects, modelData, textureData ) {     const texid = texture2dgroup.texid;    const texture2ds = modelData.resources.texture2d;    const texture2d = texture2ds[ texid ];     if ( texture2d ) {      const data = textureData[ texture2d.path ];     const type = texture2d.contenttype;      const blob = new Blob( [ data ], { type: type } );     const sourceURI = URL.createObjectURL( blob );      const texture = textureLoader.load( sourceURI, function () {       URL.revokeObjectURL( sourceURI );      } );      texture.colorSpace = COLOR_SPACE_3MF;      // texture parameters      switch ( texture2d.tilestyleu ) {       case 'wrap':       texture.wrapS = RepeatWrapping;       break;       case 'mirror':       texture.wrapS = MirroredRepeatWrapping;       break;       case 'none':      case 'clamp':       texture.wrapS = ClampToEdgeWrapping;       break;       default:       texture.wrapS = RepeatWrapping;      }      switch ( texture2d.tilestylev ) {       case 'wrap':       texture.wrapT = RepeatWrapping;       break;       case 'mirror':       texture.wrapT = MirroredRepeatWrapping;       break;       case 'none':      case 'clamp':       texture.wrapT = ClampToEdgeWrapping;       break;       default:       texture.wrapT = RepeatWrapping;      }      switch ( texture2d.filter ) {       case 'auto':       texture.magFilter = LinearFilter;       texture.minFilter = LinearMipmapLinearFilter;       break;       case 'linear':       texture.magFilter = LinearFilter;       texture.minFilter = LinearFilter;       break;       case 'nearest':       texture.magFilter = NearestFilter;       texture.minFilter = NearestFilter;       break;       default:       texture.magFilter = LinearFilter;       texture.minFilter = LinearMipmapLinearFilter;      }      return texture;     } else {      return null;     }    }    function buildBasematerialsMeshes( basematerials, triangleProperties, meshData, objects, modelData, textureData, objectData ) {     const objectPindex = objectData.pindex;     const materialMap = {};     for ( let i = 0, l = triangleProperties.length; i < l; i ++ ) {      const triangleProperty = triangleProperties[ i ];     const pindex = ( triangleProperty.p1 !== undefined ) ? triangleProperty.p1 : objectPindex;      if ( materialMap[ pindex ] === undefined ) materialMap[ pindex ] = [];      materialMap[ pindex ].push( triangleProperty );     }     //     const keys = Object.keys( materialMap );    const meshes = [];     for ( let i = 0, l = keys.length; i < l; i ++ ) {      const materialIndex = keys[ i ];     const trianglePropertiesProps = materialMap[ materialIndex ];     const basematerialData = basematerials.basematerials[ materialIndex ];     const material = getBuild( basematerialData, objects, modelData, textureData, objectData, buildBasematerial );      //      const geometry = new BufferGeometry();      const positionData = [];      const vertices = meshData.vertices;      for ( let j = 0, jl = trianglePropertiesProps.length; j < jl; j ++ ) {       const triangleProperty = trianglePropertiesProps[ j ];       positionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 0 ] );      positionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 1 ] );      positionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 2 ] );       positionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 0 ] );      positionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 1 ] );      positionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 2 ] );       positionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 0 ] );      positionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 1 ] );      positionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 2 ] );       }      geometry.setAttribute( 'position', new Float32BufferAttribute( positionData, 3 ) );      //      const mesh = new Mesh( geometry, material );     meshes.push( mesh );     }     return meshes;    }    function buildTexturedMesh( texture2dgroup, triangleProperties, meshData, objects, modelData, textureData, objectData ) {     // geometry     const geometry = new BufferGeometry();     const positionData = [];    const uvData = [];     const vertices = meshData.vertices;    const uvs = texture2dgroup.uvs;     for ( let i = 0, l = triangleProperties.length; i < l; i ++ ) {      const triangleProperty = triangleProperties[ i ];      positionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 0 ] );     positionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 1 ] );     positionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 2 ] );      positionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 0 ] );     positionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 1 ] );     positionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 2 ] );      positionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 0 ] );     positionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 1 ] );     positionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 2 ] );      //      uvData.push( uvs[ ( triangleProperty.p1 * 2 ) + 0 ] );     uvData.push( uvs[ ( triangleProperty.p1 * 2 ) + 1 ] );      uvData.push( uvs[ ( triangleProperty.p2 * 2 ) + 0 ] );     uvData.push( uvs[ ( triangleProperty.p2 * 2 ) + 1 ] );      uvData.push( uvs[ ( triangleProperty.p3 * 2 ) + 0 ] );     uvData.push( uvs[ ( triangleProperty.p3 * 2 ) + 1 ] );     }     geometry.setAttribute( 'position', new Float32BufferAttribute( positionData, 3 ) );    geometry.setAttribute( 'uv', new Float32BufferAttribute( uvData, 2 ) );     // material     const texture = getBuild( texture2dgroup, objects, modelData, textureData, objectData, buildTexture );     const material = new MeshPhongMaterial( { map: texture, flatShading: true } );     // mesh     const mesh = new Mesh( geometry, material );     return mesh;    }    function buildVertexColorMesh( colorgroup, triangleProperties, meshData, objectData ) {     // geometry     const geometry = new BufferGeometry();     const positionData = [];    const colorData = [];     const vertices = meshData.vertices;    const colors = colorgroup.colors;     for ( let i = 0, l = triangleProperties.length; i < l; i ++ ) {      const triangleProperty = triangleProperties[ i ];      const v1 = triangleProperty.v1;     const v2 = triangleProperty.v2;     const v3 = triangleProperty.v3;      positionData.push( vertices[ ( v1 * 3 ) + 0 ] );     positionData.push( vertices[ ( v1 * 3 ) + 1 ] );     positionData.push( vertices[ ( v1 * 3 ) + 2 ] );      positionData.push( vertices[ ( v2 * 3 ) + 0 ] );     positionData.push( vertices[ ( v2 * 3 ) + 1 ] );     positionData.push( vertices[ ( v2 * 3 ) + 2 ] );      positionData.push( vertices[ ( v3 * 3 ) + 0 ] );     positionData.push( vertices[ ( v3 * 3 ) + 1 ] );     positionData.push( vertices[ ( v3 * 3 ) + 2 ] );      //      const p1 = ( triangleProperty.p1 !== undefined ) ? triangleProperty.p1 : objectData.pindex;     const p2 = ( triangleProperty.p2 !== undefined ) ? triangleProperty.p2 : p1;     const p3 = ( triangleProperty.p3 !== undefined ) ? triangleProperty.p3 : p1;      colorData.push( colors[ ( p1 * 3 ) + 0 ] );     colorData.push( colors[ ( p1 * 3 ) + 1 ] );     colorData.push( colors[ ( p1 * 3 ) + 2 ] );      colorData.push( colors[ ( p2 * 3 ) + 0 ] );     colorData.push( colors[ ( p2 * 3 ) + 1 ] );     colorData.push( colors[ ( p2 * 3 ) + 2 ] );      colorData.push( colors[ ( p3 * 3 ) + 0 ] );     colorData.push( colors[ ( p3 * 3 ) + 1 ] );     colorData.push( colors[ ( p3 * 3 ) + 2 ] );     }     geometry.setAttribute( 'position', new Float32BufferAttribute( positionData, 3 ) );    geometry.setAttribute( 'color', new Float32BufferAttribute( colorData, 3 ) );     // material     const material = new MeshPhongMaterial( { vertexColors: true, flatShading: true } );     // mesh     const mesh = new Mesh( geometry, material );     return mesh;    }    function buildDefaultMesh( meshData ) {     const geometry = new BufferGeometry();    geometry.setIndex( new BufferAttribute( meshData[ 'triangles' ], 1 ) );    geometry.setAttribute( 'position', new BufferAttribute( meshData[ 'vertices' ], 3 ) );     const material = new MeshPhongMaterial( {     name: Loader.DEFAULT_MATERIAL_NAME,     color: 0xffffff,     flatShading: true    } );     const mesh = new Mesh( geometry, material );     return mesh;    }    function buildMeshes( resourceMap, meshData, objects, modelData, textureData, objectData ) {     const keys = Object.keys( resourceMap );    const meshes = [];     for ( let i = 0, il = keys.length; i < il; i ++ ) {      const resourceId = keys[ i ];     const triangleProperties = resourceMap[ resourceId ];     const resourceType = getResourceType( resourceId, modelData );      switch ( resourceType ) {       case 'material':       const basematerials = modelData.resources.basematerials[ resourceId ];       const newMeshes = buildBasematerialsMeshes( basematerials, triangleProperties, meshData, objects, modelData, textureData, objectData );        for ( let j = 0, jl = newMeshes.length; j < jl; j ++ ) {         meshes.push( newMeshes[ j ] );        }        break;       case 'texture':       const texture2dgroup = modelData.resources.texture2dgroup[ resourceId ];       meshes.push( buildTexturedMesh( texture2dgroup, triangleProperties, meshData, objects, modelData, textureData, objectData ) );       break;       case 'vertexColors':       const colorgroup = modelData.resources.colorgroup[ resourceId ];       meshes.push( buildVertexColorMesh( colorgroup, triangleProperties, meshData, objectData ) );       break;       case 'default':       meshes.push( buildDefaultMesh( meshData ) );       break;       default:       console.error( 'THREE.3MFLoader: Unsupported resource type.' );      }     }     if ( objectData.name ) {      for ( let i = 0; i < meshes.length; i ++ ) {       meshes[ i ].name = objectData.name;      }     }     return meshes;    }    function getResourceType( pid, modelData ) {     if ( modelData.resources.texture2dgroup[ pid ] !== undefined ) {      return 'texture';     } else if ( modelData.resources.basematerials[ pid ] !== undefined ) {      return 'material';     } else if ( modelData.resources.colorgroup[ pid ] !== undefined ) {      return 'vertexColors';     } else if ( pid === 'default' ) {      return 'default';     } else {      return undefined;     }    }    function analyzeObject( meshData, objectData ) {     const resourceMap = {};     const triangleProperties = meshData[ 'triangleProperties' ];     const objectPid = objectData.pid;     for ( let i = 0, l = triangleProperties.length; i < l; i ++ ) {      const triangleProperty = triangleProperties[ i ];     let pid = ( triangleProperty.pid !== undefined ) ? triangleProperty.pid : objectPid;      if ( pid === undefined ) pid = 'default';      if ( resourceMap[ pid ] === undefined ) resourceMap[ pid ] = [];      resourceMap[ pid ].push( triangleProperty );     }     return resourceMap;    }    function buildGroup( meshData, objects, modelData, textureData, objectData ) {     const group = new Group();     const resourceMap = analyzeObject( meshData, objectData );    const meshes = buildMeshes( resourceMap, meshData, objects, modelData, textureData, objectData );     for ( let i = 0, l = meshes.length; i < l; i ++ ) {      group.add( meshes[ i ] );     }     return group;    }    function applyExtensions( extensions, meshData, modelXml ) {     if ( ! extensions ) {      return;     }     const availableExtensions = [];    const keys = Object.keys( extensions );     for ( let i = 0; i < keys.length; i ++ ) {      const ns = keys[ i ];      for ( let j = 0; j < scope.availableExtensions.length; j ++ ) {       const extension = scope.availableExtensions[ j ];       if ( extension.ns === ns ) {        availableExtensions.push( extension );       }      }     }     for ( let i = 0; i < availableExtensions.length; i ++ ) {      const extension = availableExtensions[ i ];     extension.apply( modelXml, extensions[ extension[ 'ns' ] ], meshData );     }    }    function getBuild( data, objects, modelData, textureData, objectData, builder ) {     if ( data.build !== undefined ) return data.build;     data.build = builder( data, objects, modelData, textureData, objectData );     return data.build;    }    function buildBasematerial( materialData, objects, modelData ) {     let material;     const displaypropertiesid = materialData.displaypropertiesid;    const pbmetallicdisplayproperties = modelData.resources.pbmetallicdisplayproperties;     if ( displaypropertiesid !== null && pbmetallicdisplayproperties[ displaypropertiesid ] !== undefined ) {      // metallic display property, use StandardMaterial      const pbmetallicdisplayproperty = pbmetallicdisplayproperties[ displaypropertiesid ];     const metallicData = pbmetallicdisplayproperty.data[ materialData.index ];      material = new MeshStandardMaterial( { flatShading: true, roughness: metallicData.roughness, metalness: metallicData.metallicness } );     } else {      // otherwise use PhongMaterial      material = new MeshPhongMaterial( { flatShading: true } );     }     material.name = materialData.name;     // displaycolor MUST be specified with a value of a 6 or 8 digit hexadecimal number, e.g. "#RRGGBB" or "#RRGGBBAA"     const displaycolor = materialData.displaycolor;     const color = displaycolor.substring( 0, 7 );    material.color.setStyle( color, COLOR_SPACE_3MF );     // process alpha if set     if ( displaycolor.length === 9 ) {      material.opacity = parseInt( displaycolor.charAt( 7 ) + displaycolor.charAt( 8 ), 16 ) / 255;     }     return material;    }    function buildComposite( compositeData, objects, modelData, textureData ) {     const composite = new Group();     for ( let j = 0; j < compositeData.length; j ++ ) {      const component = compositeData[ j ];     let build = objects[ component.objectId ];      if ( build === undefined ) {       buildObject( component.objectId, objects, modelData, textureData );      build = objects[ component.objectId ];      }      const object3D = build.clone();      // apply component transform      const transform = component.transform;      if ( transform ) {       object3D.applyMatrix4( transform );      }      composite.add( object3D );     }     return composite;    }    function buildObject( objectId, objects, modelData, textureData ) {     const objectData = modelData[ 'resources' ][ 'object' ][ objectId ];     if ( objectData[ 'mesh' ] ) {      const meshData = objectData[ 'mesh' ];      const extensions = modelData[ 'extensions' ];     const modelXml = modelData[ 'xml' ];      applyExtensions( extensions, meshData, modelXml );      objects[ objectData.id ] = getBuild( meshData, objects, modelData, textureData, objectData, buildGroup );     } else {      const compositeData = objectData[ 'components' ];      objects[ objectData.id ] = getBuild( compositeData, objects, modelData, textureData, objectData, buildComposite );     }     if ( objectData.name ) {      objects[ objectData.id ].name = objectData.name;     }    }    function buildObjects( data3mf ) {     const modelsData = data3mf.model;    const modelRels = data3mf.modelRels;    const objects = {};    const modelsKeys = Object.keys( modelsData );    const textureData = {};     // evaluate model relationships to textures     if ( modelRels ) {      for ( let i = 0, l = modelRels.length; i < l; i ++ ) {       const modelRel = modelRels[ i ];      const textureKey = modelRel.target.substring( 1 );       if ( data3mf.texture[ textureKey ] ) {        textureData[ modelRel.target ] = data3mf.texture[ textureKey ];       }      }     }     // start build     for ( let i = 0; i < modelsKeys.length; i ++ ) {      const modelsKey = modelsKeys[ i ];     const modelData = modelsData[ modelsKey ];      const objectIds = Object.keys( modelData[ 'resources' ][ 'object' ] );      for ( let j = 0; j < objectIds.length; j ++ ) {       const objectId = objectIds[ j ];       buildObject( objectId, objects, modelData, textureData );      }     }     return objects;    }    function fetch3DModelPart( rels ) {     for ( let i = 0; i < rels.length; i ++ ) {      const rel = rels[ i ];     const extension = rel.target.split( '.' ).pop();      if ( extension.toLowerCase() === 'model' ) return rel;     }    }    function build( objects, data3mf ) {     const group = new Group();     const relationship = fetch3DModelPart( data3mf[ 'rels' ] );    const buildData = data3mf.model[ relationship[ 'target' ].substring( 1 ) ][ 'build' ];     for ( let i = 0; i < buildData.length; i ++ ) {      const buildItem = buildData[ i ];     const object3D = objects[ buildItem[ 'objectId' ] ].clone();      // apply transform      const transform = buildItem[ 'transform' ];      if ( transform ) {       object3D.applyMatrix4( transform );      }      group.add( object3D );     }     return group;    }    const data3mf = loadDocument( data );   const objects = buildObjects( data3mf );    return build( objects, data3mf );   }   addExtension( extension ) {    this.availableExtensions.push( extension );   }  }  export { ThreeMFLoader }; 
^..^ FILENAME ^..^
addons|loaders|AMFLoader.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  Color,  FileLoader,  Float32BufferAttribute,  Group,  Loader,  Mesh,  MeshPhongMaterial } from 'three'; import * as fflate from '../libs/fflate.module.js';  /**  * Description: Early release of an AMF Loader following the pattern of the  * example loaders in the three.js project.  *  * Usage:  * const loader = new AMFLoader();  * loader.load('/path/to/project.amf', function(objecttree) {  *  scene.add(objecttree);  * });  *  * Materials now supported, material colors supported  * Zip support, requires fflate  * No constellation support (yet)!  *  */  class AMFLoader extends Loader {   constructor( manager ) {    super( manager );   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( scope.manager );   loader.setPath( scope.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( scope.requestHeader );   loader.setWithCredentials( scope.withCredentials );   loader.load( url, function ( text ) {     try {      onLoad( scope.parse( text ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( data ) {    function loadDocument( data ) {     let view = new DataView( data );    const magic = String.fromCharCode( view.getUint8( 0 ), view.getUint8( 1 ) );     if ( magic === 'PK' ) {      let zip = null;     let file = null;      console.log( 'THREE.AMFLoader: Loading Zip' );      try {       zip = fflate.unzipSync( new Uint8Array( data ) );      } catch ( e ) {       if ( e instanceof ReferenceError ) {        console.log( 'THREE.AMFLoader: fflate missing and file is compressed.' );       return null;       }      }      for ( file in zip ) {       if ( file.toLowerCase().slice( - 4 ) === '.amf' ) {        break;       }      }      console.log( 'THREE.AMFLoader: Trying to load file asset: ' + file );     view = new DataView( zip[ file ].buffer );     }     const fileText = new TextDecoder().decode( view );    const xmlData = new DOMParser().parseFromString( fileText, 'application/xml' );     if ( xmlData.documentElement.nodeName.toLowerCase() !== 'amf' ) {      console.log( 'THREE.AMFLoader: Error loading AMF - no AMF document found.' );     return null;     }     return xmlData;    }    function loadDocumentScale( node ) {     let scale = 1.0;    let unit = 'millimeter';     if ( node.documentElement.attributes.unit !== undefined ) {      unit = node.documentElement.attributes.unit.value.toLowerCase();     }     const scaleUnits = {     millimeter: 1.0,     inch: 25.4,     feet: 304.8,     meter: 1000.0,     micron: 0.001    };     if ( scaleUnits[ unit ] !== undefined ) {      scale = scaleUnits[ unit ];     }     console.log( 'THREE.AMFLoader: Unit scale: ' + scale );    return scale;    }    function loadMaterials( node ) {     let matName = 'AMF Material';    const matId = node.attributes.id.textContent;    let color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };     let loadedMaterial = null;     for ( let i = 0; i < node.childNodes.length; i ++ ) {      const matChildEl = node.childNodes[ i ];      if ( matChildEl.nodeName === 'metadata' && matChildEl.attributes.type !== undefined ) {       if ( matChildEl.attributes.type.value === 'name' ) {        matName = matChildEl.textContent;       }      } else if ( matChildEl.nodeName === 'color' ) {       color = loadColor( matChildEl );      }     }     loadedMaterial = new MeshPhongMaterial( {     flatShading: true,     color: new Color( color.r, color.g, color.b ),     name: matName    } );     if ( color.a !== 1.0 ) {      loadedMaterial.transparent = true;     loadedMaterial.opacity = color.a;     }     return { id: matId, material: loadedMaterial };    }    function loadColor( node ) {     const color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };     for ( let i = 0; i < node.childNodes.length; i ++ ) {      const matColor = node.childNodes[ i ];      if ( matColor.nodeName === 'r' ) {       color.r = matColor.textContent;      } else if ( matColor.nodeName === 'g' ) {       color.g = matColor.textContent;      } else if ( matColor.nodeName === 'b' ) {       color.b = matColor.textContent;      } else if ( matColor.nodeName === 'a' ) {       color.a = matColor.textContent;      }     }     return color;    }    function loadMeshVolume( node ) {     const volume = { name: '', triangles: [], materialid: null };     let currVolumeNode = node.firstElementChild;     if ( node.attributes.materialid !== undefined ) {      volume.materialId = node.attributes.materialid.nodeValue;     }     while ( currVolumeNode ) {      if ( currVolumeNode.nodeName === 'metadata' ) {       if ( currVolumeNode.attributes.type !== undefined ) {        if ( currVolumeNode.attributes.type.value === 'name' ) {         volume.name = currVolumeNode.textContent;        }       }      } else if ( currVolumeNode.nodeName === 'triangle' ) {       const v1 = currVolumeNode.getElementsByTagName( 'v1' )[ 0 ].textContent;      const v2 = currVolumeNode.getElementsByTagName( 'v2' )[ 0 ].textContent;      const v3 = currVolumeNode.getElementsByTagName( 'v3' )[ 0 ].textContent;       volume.triangles.push( v1, v2, v3 );      }      currVolumeNode = currVolumeNode.nextElementSibling;     }     return volume;    }    function loadMeshVertices( node ) {     const vertArray = [];    const normalArray = [];    let currVerticesNode = node.firstElementChild;     while ( currVerticesNode ) {      if ( currVerticesNode.nodeName === 'vertex' ) {       let vNode = currVerticesNode.firstElementChild;       while ( vNode ) {        if ( vNode.nodeName === 'coordinates' ) {         const x = vNode.getElementsByTagName( 'x' )[ 0 ].textContent;        const y = vNode.getElementsByTagName( 'y' )[ 0 ].textContent;        const z = vNode.getElementsByTagName( 'z' )[ 0 ].textContent;         vertArray.push( x, y, z );        } else if ( vNode.nodeName === 'normal' ) {         const nx = vNode.getElementsByTagName( 'nx' )[ 0 ].textContent;        const ny = vNode.getElementsByTagName( 'ny' )[ 0 ].textContent;        const nz = vNode.getElementsByTagName( 'nz' )[ 0 ].textContent;         normalArray.push( nx, ny, nz );        }        vNode = vNode.nextElementSibling;       }      }      currVerticesNode = currVerticesNode.nextElementSibling;     }     return { 'vertices': vertArray, 'normals': normalArray };    }    function loadObject( node ) {     const objId = node.attributes.id.textContent;    const loadedObject = { name: 'amfobject', meshes: [] };    let currColor = null;    let currObjNode = node.firstElementChild;     while ( currObjNode ) {      if ( currObjNode.nodeName === 'metadata' ) {       if ( currObjNode.attributes.type !== undefined ) {        if ( currObjNode.attributes.type.value === 'name' ) {         loadedObject.name = currObjNode.textContent;        }       }      } else if ( currObjNode.nodeName === 'color' ) {       currColor = loadColor( currObjNode );      } else if ( currObjNode.nodeName === 'mesh' ) {       let currMeshNode = currObjNode.firstElementChild;      const mesh = { vertices: [], normals: [], volumes: [], color: currColor };       while ( currMeshNode ) {        if ( currMeshNode.nodeName === 'vertices' ) {         const loadedVertices = loadMeshVertices( currMeshNode );         mesh.normals = mesh.normals.concat( loadedVertices.normals );        mesh.vertices = mesh.vertices.concat( loadedVertices.vertices );        } else if ( currMeshNode.nodeName === 'volume' ) {         mesh.volumes.push( loadMeshVolume( currMeshNode ) );        }        currMeshNode = currMeshNode.nextElementSibling;       }       loadedObject.meshes.push( mesh );      }      currObjNode = currObjNode.nextElementSibling;     }     return { 'id': objId, 'obj': loadedObject };    }    const xmlData = loadDocument( data );   let amfName = '';   let amfAuthor = '';   const amfScale = loadDocumentScale( xmlData );   const amfMaterials = {};   const amfObjects = {};   const childNodes = xmlData.documentElement.childNodes;    let i, j;    for ( i = 0; i < childNodes.length; i ++ ) {     const child = childNodes[ i ];     if ( child.nodeName === 'metadata' ) {      if ( child.attributes.type !== undefined ) {       if ( child.attributes.type.value === 'name' ) {        amfName = child.textContent;       } else if ( child.attributes.type.value === 'author' ) {        amfAuthor = child.textContent;       }      }     } else if ( child.nodeName === 'material' ) {      const loadedMaterial = loadMaterials( child );      amfMaterials[ loadedMaterial.id ] = loadedMaterial.material;     } else if ( child.nodeName === 'object' ) {      const loadedObject = loadObject( child );      amfObjects[ loadedObject.id ] = loadedObject.obj;     }    }    const sceneObject = new Group();   const defaultMaterial = new MeshPhongMaterial( {    name: Loader.DEFAULT_MATERIAL_NAME,    color: 0xaaaaff,    flatShading: true   } );    sceneObject.name = amfName;   sceneObject.userData.author = amfAuthor;   sceneObject.userData.loader = 'AMF';    for ( const id in amfObjects ) {     const part = amfObjects[ id ];    const meshes = part.meshes;    const newObject = new Group();    newObject.name = part.name || '';     for ( i = 0; i < meshes.length; i ++ ) {      let objDefaultMaterial = defaultMaterial;     const mesh = meshes[ i ];     const vertices = new Float32BufferAttribute( mesh.vertices, 3 );     let normals = null;      if ( mesh.normals.length ) {       normals = new Float32BufferAttribute( mesh.normals, 3 );      }      if ( mesh.color ) {       const color = mesh.color;       objDefaultMaterial = defaultMaterial.clone();      objDefaultMaterial.color = new Color( color.r, color.g, color.b );       if ( color.a !== 1.0 ) {        objDefaultMaterial.transparent = true;       objDefaultMaterial.opacity = color.a;       }      }      const volumes = mesh.volumes;      for ( j = 0; j < volumes.length; j ++ ) {       const volume = volumes[ j ];      const newGeometry = new BufferGeometry();      let material = objDefaultMaterial;       newGeometry.setIndex( volume.triangles );      newGeometry.setAttribute( 'position', vertices.clone() );       if ( normals ) {        newGeometry.setAttribute( 'normal', normals.clone() );       }       if ( amfMaterials[ volume.materialId ] !== undefined ) {        material = amfMaterials[ volume.materialId ];       }       newGeometry.scale( amfScale, amfScale, amfScale );      newObject.add( new Mesh( newGeometry, material.clone() ) );      }     }     sceneObject.add( newObject );    }    return sceneObject;   }  }  export { AMFLoader }; 
^..^ FILENAME ^..^
addons|loaders|BVHLoader.js
^..^ CONTENTS ^..^
import {  AnimationClip,  Bone,  FileLoader,  Loader,  Quaternion,  QuaternionKeyframeTrack,  Skeleton,  Vector3,  VectorKeyframeTrack } from 'three';  /**  * Description: reads BVH files and outputs a single Skeleton and an AnimationClip  *  * Currently only supports bvh files containing a single root.  *  */  class BVHLoader extends Loader {   constructor( manager ) {    super( manager );    this.animateBonePositions = true;   this.animateBoneRotations = true;   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( scope.manager );   loader.setPath( scope.path );   loader.setRequestHeader( scope.requestHeader );   loader.setWithCredentials( scope.withCredentials );   loader.load( url, function ( text ) {     try {      onLoad( scope.parse( text ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( text ) {    /*    reads a string array (lines) from a BVH file    and outputs a skeleton structure including motion data     returns thee root node:    { name: '', channels: [], children: [] }   */   function readBvh( lines ) {     // read model structure     if ( nextLine( lines ) !== 'HIERARCHY' ) {      console.error( 'THREE.BVHLoader: HIERARCHY expected.' );     }     const list = []; // collects flat array of all bones    const root = readNode( lines, nextLine( lines ), list );     // read motion data     if ( nextLine( lines ) !== 'MOTION' ) {      console.error( 'THREE.BVHLoader: MOTION expected.' );     }     // number of frames     let tokens = nextLine( lines ).split( /[|s]+/ );    const numFrames = parseInt( tokens[ 1 ] );     if ( isNaN( numFrames ) ) {      console.error( 'THREE.BVHLoader: Failed to read number of frames.' );     }     // frame time     tokens = nextLine( lines ).split( /[|s]+/ );    const frameTime = parseFloat( tokens[ 2 ] );     if ( isNaN( frameTime ) ) {      console.error( 'THREE.BVHLoader: Failed to read frame time.' );     }     // read frame data line by line     for ( let i = 0; i < numFrames; i ++ ) {      tokens = nextLine( lines ).split( /[|s]+/ );     readFrameData( tokens, i * frameTime, root );     }     return list;    }    /*    Recursively reads data from a single frame into the bone hierarchy.    The passed bone hierarchy has to be structured in the same order as the BVH file.    keyframe data is stored in bone.frames.     - data: splitted string array (frame values), values are shift()ed so    this should be empty after parsing the whole hierarchy.    - frameTime: playback time for this keyframe.    - bone: the bone to read frame data from.   */   function readFrameData( data, frameTime, bone ) {     // end sites have no motion data     if ( bone.type === 'ENDSITE' ) return;     // add keyframe     const keyframe = {     time: frameTime,     position: new Vector3(),     rotation: new Quaternion()    };     bone.frames.push( keyframe );     const quat = new Quaternion();     const vx = new Vector3( 1, 0, 0 );    const vy = new Vector3( 0, 1, 0 );    const vz = new Vector3( 0, 0, 1 );     // parse values for each channel in node     for ( let i = 0; i < bone.channels.length; i ++ ) {      switch ( bone.channels[ i ] ) {       case 'Xposition':       keyframe.position.x = parseFloat( data.shift().trim() );       break;      case 'Yposition':       keyframe.position.y = parseFloat( data.shift().trim() );       break;      case 'Zposition':       keyframe.position.z = parseFloat( data.shift().trim() );       break;      case 'Xrotation':       quat.setFromAxisAngle( vx, parseFloat( data.shift().trim() ) * Math.PI / 180 );       keyframe.rotation.multiply( quat );       break;      case 'Yrotation':       quat.setFromAxisAngle( vy, parseFloat( data.shift().trim() ) * Math.PI / 180 );       keyframe.rotation.multiply( quat );       break;      case 'Zrotation':       quat.setFromAxisAngle( vz, parseFloat( data.shift().trim() ) * Math.PI / 180 );       keyframe.rotation.multiply( quat );       break;      default:       console.warn( 'THREE.BVHLoader: Invalid channel type.' );      }     }     // parse child nodes     for ( let i = 0; i < bone.children.length; i ++ ) {      readFrameData( data, frameTime, bone.children[ i ] );     }    }    /*    Recursively parses the HIERACHY section of the BVH file     - lines: all lines of the file. lines are consumed as we go along.    - firstline: line containing the node type and name e.g. 'JOINT hip'    - list: collects a flat list of nodes     returns: a BVH node including children   */   function readNode( lines, firstline, list ) {     const node = { name: '', type: '', frames: [] };    list.push( node );     // parse node type and name     let tokens = firstline.split( /[|s]+/ );     if ( tokens[ 0 ].toUpperCase() === 'END' && tokens[ 1 ].toUpperCase() === 'SITE' ) {      node.type = 'ENDSITE';     node.name = 'ENDSITE'; // bvh end sites have no name     } else {      node.name = tokens[ 1 ];     node.type = tokens[ 0 ].toUpperCase();     }     if ( nextLine( lines ) !== '{' ) {      console.error( 'THREE.BVHLoader: Expected opening { after type & name' );     }     // parse OFFSET     tokens = nextLine( lines ).split( /[|s]+/ );     if ( tokens[ 0 ] !== 'OFFSET' ) {      console.error( 'THREE.BVHLoader: Expected OFFSET but got: ' + tokens[ 0 ] );     }     if ( tokens.length !== 4 ) {      console.error( 'THREE.BVHLoader: Invalid number of values for OFFSET.' );     }     const offset = new Vector3(     parseFloat( tokens[ 1 ] ),     parseFloat( tokens[ 2 ] ),     parseFloat( tokens[ 3 ] )    );     if ( isNaN( offset.x ) || isNaN( offset.y ) || isNaN( offset.z ) ) {      console.error( 'THREE.BVHLoader: Invalid values of OFFSET.' );     }     node.offset = offset;     // parse CHANNELS definitions     if ( node.type !== 'ENDSITE' ) {      tokens = nextLine( lines ).split( /[|s]+/ );      if ( tokens[ 0 ] !== 'CHANNELS' ) {       console.error( 'THREE.BVHLoader: Expected CHANNELS definition.' );      }      const numChannels = parseInt( tokens[ 1 ] );     node.channels = tokens.splice( 2, numChannels );     node.children = [];     }     // read children     while ( true ) {      const line = nextLine( lines );      if ( line === '}' ) {       return node;      } else {       node.children.push( readNode( lines, line, list ) );      }     }    }    /*    recursively converts the internal bvh node structure to a Bone hierarchy     source: the bvh root node    list: pass an empty array, collects a flat list of all converted THREE.Bones     returns the root Bone   */   function toTHREEBone( source, list ) {     const bone = new Bone();    list.push( bone );     bone.position.add( source.offset );    bone.name = source.name;     if ( source.type !== 'ENDSITE' ) {      for ( let i = 0; i < source.children.length; i ++ ) {       bone.add( toTHREEBone( source.children[ i ], list ) );      }     }     return bone;    }    /*    builds a AnimationClip from the keyframe data saved in each bone.     bone: bvh root node     returns: a AnimationClip containing position and quaternion tracks   */   function toTHREEAnimation( bones ) {     const tracks = [];     // create a position and quaternion animation track for each node     for ( let i = 0; i < bones.length; i ++ ) {      const bone = bones[ i ];      if ( bone.type === 'ENDSITE' )      continue;      // track data      const times = [];     const positions = [];     const rotations = [];      for ( let j = 0; j < bone.frames.length; j ++ ) {       const frame = bone.frames[ j ];       times.push( frame.time );       // the animation system animates the position property,      // so we have to add the joint offset to all values       positions.push( frame.position.x + bone.offset.x );      positions.push( frame.position.y + bone.offset.y );      positions.push( frame.position.z + bone.offset.z );       rotations.push( frame.rotation.x );      rotations.push( frame.rotation.y );      rotations.push( frame.rotation.z );      rotations.push( frame.rotation.w );      }      if ( scope.animateBonePositions ) {       tracks.push( new VectorKeyframeTrack( bone.name + '.position', times, positions ) );      }      if ( scope.animateBoneRotations ) {       tracks.push( new QuaternionKeyframeTrack( bone.name + '.quaternion', times, rotations ) );      }     }     return new AnimationClip( 'animation', - 1, tracks );    }    /*    returns the next non-empty line in lines   */   function nextLine( lines ) {     let line;    // skip empty lines    while ( ( line = lines.shift().trim() ).length === 0 ) { }     return line;    }    const scope = this;    const lines = text.split( /[|r|n]+/g );    const bones = readBvh( lines );    const threeBones = [];   toTHREEBone( bones[ 0 ], threeBones );    const threeClip = toTHREEAnimation( bones );    return {    skeleton: new Skeleton( threeBones ),    clip: threeClip   };   }  }  export { BVHLoader }; 
^..^ FILENAME ^..^
addons|loaders|ColladaLoader.js
^..^ CONTENTS ^..^
import {  AmbientLight,  AnimationClip,  Bone,  BufferGeometry,  ClampToEdgeWrapping,  Color,  ColorManagement,  DirectionalLight,  DoubleSide,  FileLoader,  Float32BufferAttribute,  FrontSide,  Group,  Line,  LineBasicMaterial,  LineSegments,  Loader,  LoaderUtils,  MathUtils,  Matrix4,  Mesh,  MeshBasicMaterial,  MeshLambertMaterial,  MeshPhongMaterial,  OrthographicCamera,  PerspectiveCamera,  PointLight,  Quaternion,  QuaternionKeyframeTrack,  RepeatWrapping,  Scene,  Skeleton,  SkinnedMesh,  SpotLight,  TextureLoader,  Vector2,  Vector3,  VectorKeyframeTrack,  SRGBColorSpace } from 'three'; import { TGALoader } from '../loaders/TGALoader.js';  class ColladaLoader extends Loader {   load( url, onLoad, onProgress, onError ) {    const scope = this;    const path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;    const loader = new FileLoader( scope.manager );   loader.setPath( scope.path );   loader.setRequestHeader( scope.requestHeader );   loader.setWithCredentials( scope.withCredentials );   loader.load( url, function ( text ) {     try {      onLoad( scope.parse( text, path ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( text, path ) {    function getElementsByTagName( xml, name ) {     // Non recursive xml.getElementsByTagName() ...     const array = [];    const childNodes = xml.childNodes;     for ( let i = 0, l = childNodes.length; i < l; i ++ ) {      const child = childNodes[ i ];      if ( child.nodeName === name ) {       array.push( child );      }     }     return array;    }    function parseStrings( text ) {     if ( text.length === 0 ) return [];     const parts = text.trim().split( /|s+/ );    const array = new Array( parts.length );     for ( let i = 0, l = parts.length; i < l; i ++ ) {      array[ i ] = parts[ i ];     }     return array;    }    function parseFloats( text ) {     if ( text.length === 0 ) return [];     const parts = text.trim().split( /|s+/ );    const array = new Array( parts.length );     for ( let i = 0, l = parts.length; i < l; i ++ ) {      array[ i ] = parseFloat( parts[ i ] );     }     return array;    }    function parseInts( text ) {     if ( text.length === 0 ) return [];     const parts = text.trim().split( /|s+/ );    const array = new Array( parts.length );     for ( let i = 0, l = parts.length; i < l; i ++ ) {      array[ i ] = parseInt( parts[ i ] );     }     return array;    }    function parseId( text ) {     return text.substring( 1 );    }    function generateId() {     return 'three_default_' + ( count ++ );    }    function isEmpty( object ) {     return Object.keys( object ).length === 0;    }    // asset    function parseAsset( xml ) {     return {     unit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),     upAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )    };    }    function parseAssetUnit( xml ) {     if ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {      return parseFloat( xml.getAttribute( 'meter' ) );     } else {      return 1; // default 1 meter     }    }    function parseAssetUpAxis( xml ) {     return xml !== undefined ? xml.textContent : 'Y_UP';    }    // library    function parseLibrary( xml, libraryName, nodeName, parser ) {     const library = getElementsByTagName( xml, libraryName )[ 0 ];     if ( library !== undefined ) {      const elements = getElementsByTagName( library, nodeName );      for ( let i = 0; i < elements.length; i ++ ) {       parser( elements[ i ] );      }     }    }    function buildLibrary( data, builder ) {     for ( const name in data ) {      const object = data[ name ];     object.build = builder( data[ name ] );     }    }    // get    function getBuild( data, builder ) {     if ( data.build !== undefined ) return data.build;     data.build = builder( data );     return data.build;    }    // animation    function parseAnimation( xml ) {     const data = {     sources: {},     samplers: {},     channels: {}    };     let hasChildren = false;     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      let id;      switch ( child.nodeName ) {       case 'source':       id = child.getAttribute( 'id' );       data.sources[ id ] = parseSource( child );       break;       case 'sampler':       id = child.getAttribute( 'id' );       data.samplers[ id ] = parseAnimationSampler( child );       break;       case 'channel':       id = child.getAttribute( 'target' );       data.channels[ id ] = parseAnimationChannel( child );       break;       case 'animation':       // hierarchy of related animations       parseAnimation( child );       hasChildren = true;       break;       default:       console.log( child );      }     }     if ( hasChildren === false ) {      // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment      library.animations[ xml.getAttribute( 'id' ) || MathUtils.generateUUID() ] = data;     }    }    function parseAnimationSampler( xml ) {     const data = {     inputs: {},    };     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'input':       const id = parseId( child.getAttribute( 'source' ) );       const semantic = child.getAttribute( 'semantic' );       data.inputs[ semantic ] = id;       break;      }     }     return data;    }    function parseAnimationChannel( xml ) {     const data = {};     const target = xml.getAttribute( 'target' );     // parsing SID Addressing Syntax     let parts = target.split( '/' );     const id = parts.shift();    let sid = parts.shift();     // check selection syntax     const arraySyntax = ( sid.indexOf( '(' ) !== - 1 );    const memberSyntax = ( sid.indexOf( '.' ) !== - 1 );     if ( memberSyntax ) {      //  member selection access      parts = sid.split( '.' );     sid = parts.shift();     data.member = parts.shift();     } else if ( arraySyntax ) {      // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.      const indices = sid.split( '(' );     sid = indices.shift();      for ( let i = 0; i < indices.length; i ++ ) {       indices[ i ] = parseInt( indices[ i ].replace( /|)/, '' ) );      }      data.indices = indices;     }     data.id = id;    data.sid = sid;     data.arraySyntax = arraySyntax;    data.memberSyntax = memberSyntax;     data.sampler = parseId( xml.getAttribute( 'source' ) );     return data;    }    function buildAnimation( data ) {     const tracks = [];     const channels = data.channels;    const samplers = data.samplers;    const sources = data.sources;     for ( const target in channels ) {      if ( channels.hasOwnProperty( target ) ) {       const channel = channels[ target ];      const sampler = samplers[ channel.sampler ];       const inputId = sampler.inputs.INPUT;      const outputId = sampler.inputs.OUTPUT;       const inputSource = sources[ inputId ];      const outputSource = sources[ outputId ];       const animation = buildAnimationChannel( channel, inputSource, outputSource );       createKeyframeTracks( animation, tracks );      }     }     return tracks;    }    function getAnimation( id ) {     return getBuild( library.animations[ id ], buildAnimation );    }    function buildAnimationChannel( channel, inputSource, outputSource ) {     const node = library.nodes[ channel.id ];    const object3D = getNode( node.id );     const transform = node.transforms[ channel.sid ];    const defaultMatrix = node.matrix.clone().transpose();     let time, stride;    let i, il, j, jl;     const data = {};     // the collada spec allows the animation of data in various ways.    // depending on the transform type (matrix, translate, rotate, scale), we execute different logic     switch ( transform ) {      case 'matrix':       for ( i = 0, il = inputSource.array.length; i < il; i ++ ) {        time = inputSource.array[ i ];       stride = i * outputSource.stride;        if ( data[ time ] === undefined ) data[ time ] = {};        if ( channel.arraySyntax === true ) {         const value = outputSource.array[ stride ];        const index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];         data[ time ][ index ] = value;        } else {         for ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {          data[ time ][ j ] = outputSource.array[ stride + j ];         }        }       }       break;      case 'translate':      console.warn( 'THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform );      break;      case 'rotate':      console.warn( 'THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform );      break;      case 'scale':      console.warn( 'THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform );      break;     }     const keyframes = prepareAnimationData( data, defaultMatrix );     const animation = {     name: object3D.uuid,     keyframes: keyframes    };     return animation;    }    function prepareAnimationData( data, defaultMatrix ) {     const keyframes = [];     // transfer data into a sortable array     for ( const time in data ) {      keyframes.push( { time: parseFloat( time ), value: data[ time ] } );     }     // ensure keyframes are sorted by time     keyframes.sort( ascending );     // now we clean up all animation data, so we can use them for keyframe tracks     for ( let i = 0; i < 16; i ++ ) {      transformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );     }     return keyframes;     // array sort function     function ascending( a, b ) {      return a.time - b.time;     }    }    const position = new Vector3();   const scale = new Vector3();   const quaternion = new Quaternion();    function createKeyframeTracks( animation, tracks ) {     const keyframes = animation.keyframes;    const name = animation.name;     const times = [];    const positionData = [];    const quaternionData = [];    const scaleData = [];     for ( let i = 0, l = keyframes.length; i < l; i ++ ) {      const keyframe = keyframes[ i ];      const time = keyframe.time;     const value = keyframe.value;      matrix.fromArray( value ).transpose();     matrix.decompose( position, quaternion, scale );      times.push( time );     positionData.push( position.x, position.y, position.z );     quaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );     scaleData.push( scale.x, scale.y, scale.z );     }     if ( positionData.length > 0 ) tracks.push( new VectorKeyframeTrack( name + '.position', times, positionData ) );    if ( quaternionData.length > 0 ) tracks.push( new QuaternionKeyframeTrack( name + '.quaternion', times, quaternionData ) );    if ( scaleData.length > 0 ) tracks.push( new VectorKeyframeTrack( name + '.scale', times, scaleData ) );     return tracks;    }    function transformAnimationData( keyframes, property, defaultValue ) {     let keyframe;     let empty = true;    let i, l;     // check, if values of a property are missing in our keyframes     for ( i = 0, l = keyframes.length; i < l; i ++ ) {      keyframe = keyframes[ i ];      if ( keyframe.value[ property ] === undefined ) {       keyframe.value[ property ] = null; // mark as missing      } else {       empty = false;      }     }     if ( empty === true ) {      // no values at all, so we set a default value      for ( i = 0, l = keyframes.length; i < l; i ++ ) {       keyframe = keyframes[ i ];       keyframe.value[ property ] = defaultValue;      }     } else {      // filling gaps      createMissingKeyframes( keyframes, property );     }    }    function createMissingKeyframes( keyframes, property ) {     let prev, next;     for ( let i = 0, l = keyframes.length; i < l; i ++ ) {      const keyframe = keyframes[ i ];      if ( keyframe.value[ property ] === null ) {       prev = getPrev( keyframes, i, property );      next = getNext( keyframes, i, property );       if ( prev === null ) {        keyframe.value[ property ] = next.value[ property ];       continue;       }       if ( next === null ) {        keyframe.value[ property ] = prev.value[ property ];       continue;       }       interpolate( keyframe, prev, next, property );      }     }    }    function getPrev( keyframes, i, property ) {     while ( i >= 0 ) {      const keyframe = keyframes[ i ];      if ( keyframe.value[ property ] !== null ) return keyframe;      i --;     }     return null;    }    function getNext( keyframes, i, property ) {     while ( i < keyframes.length ) {      const keyframe = keyframes[ i ];      if ( keyframe.value[ property ] !== null ) return keyframe;      i ++;     }     return null;    }    function interpolate( key, prev, next, property ) {     if ( ( next.time - prev.time ) === 0 ) {      key.value[ property ] = prev.value[ property ];     return;     }     key.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];    }    // animation clips    function parseAnimationClip( xml ) {     const data = {     name: xml.getAttribute( 'id' ) || 'default',     start: parseFloat( xml.getAttribute( 'start' ) || 0 ),     end: parseFloat( xml.getAttribute( 'end' ) || 0 ),     animations: []    };     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'instance_animation':       data.animations.push( parseId( child.getAttribute( 'url' ) ) );       break;      }     }     library.clips[ xml.getAttribute( 'id' ) ] = data;    }    function buildAnimationClip( data ) {     const tracks = [];     const name = data.name;    const duration = ( data.end - data.start ) || - 1;    const animations = data.animations;     for ( let i = 0, il = animations.length; i < il; i ++ ) {      const animationTracks = getAnimation( animations[ i ] );      for ( let j = 0, jl = animationTracks.length; j < jl; j ++ ) {       tracks.push( animationTracks[ j ] );      }     }     return new AnimationClip( name, duration, tracks );    }    function getAnimationClip( id ) {     return getBuild( library.clips[ id ], buildAnimationClip );    }    // controller    function parseController( xml ) {     const data = {};     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'skin':       // there is exactly one skin per controller       data.id = parseId( child.getAttribute( 'source' ) );       data.skin = parseSkin( child );       break;       case 'morph':       data.id = parseId( child.getAttribute( 'source' ) );       console.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );       break;      }     }     library.controllers[ xml.getAttribute( 'id' ) ] = data;    }    function parseSkin( xml ) {     const data = {     sources: {}    };     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'bind_shape_matrix':       data.bindShapeMatrix = parseFloats( child.textContent );       break;       case 'source':       const id = child.getAttribute( 'id' );       data.sources[ id ] = parseSource( child );       break;       case 'joints':       data.joints = parseJoints( child );       break;       case 'vertex_weights':       data.vertexWeights = parseVertexWeights( child );       break;      }     }     return data;    }    function parseJoints( xml ) {     const data = {     inputs: {}    };     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'input':       const semantic = child.getAttribute( 'semantic' );       const id = parseId( child.getAttribute( 'source' ) );       data.inputs[ semantic ] = id;       break;      }     }     return data;    }    function parseVertexWeights( xml ) {     const data = {     inputs: {}    };     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'input':       const semantic = child.getAttribute( 'semantic' );       const id = parseId( child.getAttribute( 'source' ) );       const offset = parseInt( child.getAttribute( 'offset' ) );       data.inputs[ semantic ] = { id: id, offset: offset };       break;       case 'vcount':       data.vcount = parseInts( child.textContent );       break;       case 'v':       data.v = parseInts( child.textContent );       break;      }     }     return data;    }    function buildController( data ) {     const build = {     id: data.id    };     const geometry = library.geometries[ build.id ];     if ( data.skin !== undefined ) {      build.skin = buildSkin( data.skin );      // we enhance the 'sources' property of the corresponding geometry with our skin data      geometry.sources.skinIndices = build.skin.indices;     geometry.sources.skinWeights = build.skin.weights;     }     return build;    }    function buildSkin( data ) {     const BONE_LIMIT = 4;     const build = {     joints: [], // this must be an array to preserve the joint order     indices: {      array: [],      stride: BONE_LIMIT     },     weights: {      array: [],      stride: BONE_LIMIT     }    };     const sources = data.sources;    const vertexWeights = data.vertexWeights;     const vcount = vertexWeights.vcount;    const v = vertexWeights.v;    const jointOffset = vertexWeights.inputs.JOINT.offset;    const weightOffset = vertexWeights.inputs.WEIGHT.offset;     const jointSource = data.sources[ data.joints.inputs.JOINT ];    const inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];     const weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;    let stride = 0;     let i, j, l;     // process skin data for each vertex     for ( i = 0, l = vcount.length; i < l; i ++ ) {      const jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex     const vertexSkinData = [];      for ( j = 0; j < jointCount; j ++ ) {       const skinIndex = v[ stride + jointOffset ];      const weightId = v[ stride + weightOffset ];      const skinWeight = weights[ weightId ];       vertexSkinData.push( { index: skinIndex, weight: skinWeight } );       stride += 2;      }      // we sort the joints in descending order based on the weights.     // this ensures, we only procced the most important joints of the vertex      vertexSkinData.sort( descending );      // now we provide for each vertex a set of four index and weight values.     // the order of the skin data matches the order of vertices      for ( j = 0; j < BONE_LIMIT; j ++ ) {       const d = vertexSkinData[ j ];       if ( d !== undefined ) {        build.indices.array.push( d.index );       build.weights.array.push( d.weight );       } else {        build.indices.array.push( 0 );       build.weights.array.push( 0 );       }      }     }     // setup bind matrix     if ( data.bindShapeMatrix ) {      build.bindMatrix = new Matrix4().fromArray( data.bindShapeMatrix ).transpose();     } else {      build.bindMatrix = new Matrix4().identity();     }     // process bones and inverse bind matrix data     for ( i = 0, l = jointSource.array.length; i < l; i ++ ) {      const name = jointSource.array[ i ];     const boneInverse = new Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();      build.joints.push( { name: name, boneInverse: boneInverse } );     }     return build;     // array sort function     function descending( a, b ) {      return b.weight - a.weight;     }    }    function getController( id ) {     return getBuild( library.controllers[ id ], buildController );    }    // image    function parseImage( xml ) {     const data = {     init_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent    };     library.images[ xml.getAttribute( 'id' ) ] = data;    }    function buildImage( data ) {     if ( data.build !== undefined ) return data.build;     return data.init_from;    }    function getImage( id ) {     const data = library.images[ id ];     if ( data !== undefined ) {      return getBuild( data, buildImage );     }     console.warn( 'THREE.ColladaLoader: Couldn|'t find image with ID:', id );     return null;    }    // effect    function parseEffect( xml ) {     const data = {};     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'profile_COMMON':       data.profile = parseEffectProfileCOMMON( child );       break;      }     }     library.effects[ xml.getAttribute( 'id' ) ] = data;    }    function parseEffectProfileCOMMON( xml ) {     const data = {     surfaces: {},     samplers: {}    };     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'newparam':       parseEffectNewparam( child, data );       break;       case 'technique':       data.technique = parseEffectTechnique( child );       break;       case 'extra':       data.extra = parseEffectExtra( child );       break;      }     }     return data;    }    function parseEffectNewparam( xml, data ) {     const sid = xml.getAttribute( 'sid' );     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'surface':       data.surfaces[ sid ] = parseEffectSurface( child );       break;       case 'sampler2D':       data.samplers[ sid ] = parseEffectSampler( child );       break;      }     }    }    function parseEffectSurface( xml ) {     const data = {};     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'init_from':       data.init_from = child.textContent;       break;      }     }     return data;    }    function parseEffectSampler( xml ) {     const data = {};     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'source':       data.source = child.textContent;       break;      }     }     return data;    }    function parseEffectTechnique( xml ) {     const data = {};     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'constant':      case 'lambert':      case 'blinn':      case 'phong':       data.type = child.nodeName;       data.parameters = parseEffectParameters( child );       break;       case 'extra':       data.extra = parseEffectExtra( child );       break;      }     }     return data;    }    function parseEffectParameters( xml ) {     const data = {};     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'emission':      case 'diffuse':      case 'specular':      case 'bump':      case 'ambient':      case 'shininess':      case 'transparency':       data[ child.nodeName ] = parseEffectParameter( child );       break;      case 'transparent':       data[ child.nodeName ] = {        opaque: child.hasAttribute( 'opaque' ) ? child.getAttribute( 'opaque' ) : 'A_ONE',        data: parseEffectParameter( child )       };       break;      }     }     return data;    }    function parseEffectParameter( xml ) {     const data = {};     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'color':       data[ child.nodeName ] = parseFloats( child.textContent );       break;       case 'float':       data[ child.nodeName ] = parseFloat( child.textContent );       break;       case 'texture':       data[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };       break;      }     }     return data;    }    function parseEffectParameterTexture( xml ) {     const data = {     technique: {}    };     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'extra':       parseEffectParameterTextureExtra( child, data );       break;      }     }     return data;    }    function parseEffectParameterTextureExtra( xml, data ) {     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'technique':       parseEffectParameterTextureExtraTechnique( child, data );       break;      }     }    }    function parseEffectParameterTextureExtraTechnique( xml, data ) {     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'repeatU':      case 'repeatV':      case 'offsetU':      case 'offsetV':       data.technique[ child.nodeName ] = parseFloat( child.textContent );       break;       case 'wrapU':      case 'wrapV':        // some files have values for wrapU/wrapV which become NaN via parseInt        if ( child.textContent.toUpperCase() === 'TRUE' ) {         data.technique[ child.nodeName ] = 1;        } else if ( child.textContent.toUpperCase() === 'FALSE' ) {         data.technique[ child.nodeName ] = 0;        } else {         data.technique[ child.nodeName ] = parseInt( child.textContent );        }        break;       case 'bump':       data[ child.nodeName ] = parseEffectExtraTechniqueBump( child );       break;      }     }    }    function parseEffectExtra( xml ) {     const data = {};     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'technique':       data.technique = parseEffectExtraTechnique( child );       break;      }     }     return data;    }    function parseEffectExtraTechnique( xml ) {     const data = {};     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'double_sided':       data[ child.nodeName ] = parseInt( child.textContent );       break;       case 'bump':       data[ child.nodeName ] = parseEffectExtraTechniqueBump( child );       break;      }     }     return data;    }    function parseEffectExtraTechniqueBump( xml ) {     const data = {};     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'texture':       data[ child.nodeName ] = { id: child.getAttribute( 'texture' ), texcoord: child.getAttribute( 'texcoord' ), extra: parseEffectParameterTexture( child ) };       break;      }     }     return data;    }    function buildEffect( data ) {     return data;    }    function getEffect( id ) {     return getBuild( library.effects[ id ], buildEffect );    }    // material    function parseMaterial( xml ) {     const data = {     name: xml.getAttribute( 'name' )    };     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'instance_effect':       data.url = parseId( child.getAttribute( 'url' ) );       break;      }     }     library.materials[ xml.getAttribute( 'id' ) ] = data;    }    function getTextureLoader( image ) {     let loader;     let extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/    extension = extension.toLowerCase();     switch ( extension ) {      case 'tga':      loader = tgaLoader;      break;      default:      loader = textureLoader;     }     return loader;    }    function buildMaterial( data ) {     const effect = getEffect( data.url );    const technique = effect.profile.technique;     let material;     switch ( technique.type ) {      case 'phong':     case 'blinn':      material = new MeshPhongMaterial();      break;      case 'lambert':      material = new MeshLambertMaterial();      break;      default:      material = new MeshBasicMaterial();      break;     }     material.name = data.name || '';     function getTexture( textureObject, colorSpace = null ) {      const sampler = effect.profile.samplers[ textureObject.id ];     let image = null;      // get image      if ( sampler !== undefined ) {       const surface = effect.profile.surfaces[ sampler.source ];      image = getImage( surface.init_from );      } else {       console.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' );      image = getImage( textureObject.id );      }      // create texture if image is avaiable      if ( image !== null ) {       const loader = getTextureLoader( image );       if ( loader !== undefined ) {        const texture = loader.load( image );        const extra = textureObject.extra;        if ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {         const technique = extra.technique;         texture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;        texture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;         texture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );        texture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );        } else {         texture.wrapS = RepeatWrapping;        texture.wrapT = RepeatWrapping;        }        if ( colorSpace !== null ) {         texture.colorSpace = colorSpace;        }        return texture;       } else {        console.warn( 'THREE.ColladaLoader: Loader for texture %s not found.', image );        return null;       }      } else {       console.warn( 'THREE.ColladaLoader: Couldn|'t create texture with ID:', textureObject.id );       return null;      }     }     const parameters = technique.parameters;     for ( const key in parameters ) {      const parameter = parameters[ key ];      switch ( key ) {       case 'diffuse':       if ( parameter.color ) material.color.fromArray( parameter.color );       if ( parameter.texture ) material.map = getTexture( parameter.texture, SRGBColorSpace );       break;      case 'specular':       if ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );       if ( parameter.texture ) material.specularMap = getTexture( parameter.texture );       break;      case 'bump':       if ( parameter.texture ) material.normalMap = getTexture( parameter.texture );       break;      case 'ambient':       if ( parameter.texture ) material.lightMap = getTexture( parameter.texture, SRGBColorSpace );       break;      case 'shininess':       if ( parameter.float && material.shininess ) material.shininess = parameter.float;       break;      case 'emission':       if ( parameter.color && material.emissive ) material.emissive.fromArray( parameter.color );       if ( parameter.texture ) material.emissiveMap = getTexture( parameter.texture, SRGBColorSpace );       break;      }     }     ColorManagement.toWorkingColorSpace( material.color, SRGBColorSpace );    if ( material.specular ) ColorManagement.toWorkingColorSpace( material.specular, SRGBColorSpace );    if ( material.emissive ) ColorManagement.toWorkingColorSpace( material.emissive, SRGBColorSpace );     //     let transparent = parameters[ 'transparent' ];    let transparency = parameters[ 'transparency' ];     // <transparency> does not exist but <transparent>     if ( transparency === undefined && transparent ) {      transparency = {      float: 1     };     }     // <transparent> does not exist but <transparency>     if ( transparent === undefined && transparency ) {      transparent = {      opaque: 'A_ONE',      data: {       color: [ 1, 1, 1, 1 ]      } };     }     if ( transparent && transparency ) {      // handle case if a texture exists but no color      if ( transparent.data.texture ) {       // we do not set an alpha map (see #13792)       material.transparent = true;      } else {       const color = transparent.data.color;       switch ( transparent.opaque ) {        case 'A_ONE':        material.opacity = color[ 3 ] * transparency.float;        break;       case 'RGB_ZERO':        material.opacity = 1 - ( color[ 0 ] * transparency.float );        break;       case 'A_ZERO':        material.opacity = 1 - ( color[ 3 ] * transparency.float );        break;       case 'RGB_ONE':        material.opacity = color[ 0 ] * transparency.float;        break;       default:        console.warn( 'THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', transparent.opaque );       }       if ( material.opacity < 1 ) material.transparent = true;      }     }     //      if ( technique.extra !== undefined && technique.extra.technique !== undefined ) {      const techniques = technique.extra.technique;      for ( const k in techniques ) {       const v = techniques[ k ];       switch ( k ) {        case 'double_sided':        material.side = ( v === 1 ? DoubleSide : FrontSide );        break;        case 'bump':        material.normalMap = getTexture( v.texture );        material.normalScale = new Vector2( 1, 1 );        break;       }      }     }     return material;    }    function getMaterial( id ) {     return getBuild( library.materials[ id ], buildMaterial );    }    // camera    function parseCamera( xml ) {     const data = {     name: xml.getAttribute( 'name' )    };     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'optics':       data.optics = parseCameraOptics( child );       break;      }     }     library.cameras[ xml.getAttribute( 'id' ) ] = data;    }    function parseCameraOptics( xml ) {     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      switch ( child.nodeName ) {       case 'technique_common':       return parseCameraTechnique( child );      }     }     return {};    }    function parseCameraTechnique( xml ) {     const data = {};     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      switch ( child.nodeName ) {       case 'perspective':      case 'orthographic':        data.technique = child.nodeName;       data.parameters = parseCameraParameters( child );        break;      }     }     return data;    }    function parseCameraParameters( xml ) {     const data = {};     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      switch ( child.nodeName ) {       case 'xfov':      case 'yfov':      case 'xmag':      case 'ymag':      case 'znear':      case 'zfar':      case 'aspect_ratio':       data[ child.nodeName ] = parseFloat( child.textContent );       break;      }     }     return data;    }    function buildCamera( data ) {     let camera;     switch ( data.optics.technique ) {      case 'perspective':      camera = new PerspectiveCamera(       data.optics.parameters.yfov,       data.optics.parameters.aspect_ratio,       data.optics.parameters.znear,       data.optics.parameters.zfar      );      break;      case 'orthographic':      let ymag = data.optics.parameters.ymag;      let xmag = data.optics.parameters.xmag;      const aspectRatio = data.optics.parameters.aspect_ratio;       xmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;      ymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;       xmag *= 0.5;      ymag *= 0.5;       camera = new OrthographicCamera(       - xmag, xmag, ymag, - ymag, // left, right, top, bottom       data.optics.parameters.znear,       data.optics.parameters.zfar      );      break;      default:      camera = new PerspectiveCamera();      break;     }     camera.name = data.name || '';     return camera;    }    function getCamera( id ) {     const data = library.cameras[ id ];     if ( data !== undefined ) {      return getBuild( data, buildCamera );     }     console.warn( 'THREE.ColladaLoader: Couldn|'t find camera with ID:', id );     return null;    }    // light    function parseLight( xml ) {     let data = {};     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'technique_common':       data = parseLightTechnique( child );       break;      }     }     library.lights[ xml.getAttribute( 'id' ) ] = data;    }    function parseLightTechnique( xml ) {     const data = {};     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'directional':      case 'point':      case 'spot':      case 'ambient':        data.technique = child.nodeName;       data.parameters = parseLightParameters( child );      }     }     return data;    }    function parseLightParameters( xml ) {     const data = {};     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'color':       const array = parseFloats( child.textContent );       data.color = new Color().fromArray( array );       ColorManagement.toWorkingColorSpace( data.color, SRGBColorSpace );       break;       case 'falloff_angle':       data.falloffAngle = parseFloat( child.textContent );       break;       case 'quadratic_attenuation':       const f = parseFloat( child.textContent );       data.distance = f ? Math.sqrt( 1 / f ) : 0;       break;      }     }     return data;    }    function buildLight( data ) {     let light;     switch ( data.technique ) {      case 'directional':      light = new DirectionalLight();      break;      case 'point':      light = new PointLight();      break;      case 'spot':      light = new SpotLight();      break;      case 'ambient':      light = new AmbientLight();      break;     }     if ( data.parameters.color ) light.color.copy( data.parameters.color );    if ( data.parameters.distance ) light.distance = data.parameters.distance;     return light;    }    function getLight( id ) {     const data = library.lights[ id ];     if ( data !== undefined ) {      return getBuild( data, buildLight );     }     console.warn( 'THREE.ColladaLoader: Couldn|'t find light with ID:', id );     return null;    }    // geometry    function parseGeometry( xml ) {     const data = {     name: xml.getAttribute( 'name' ),     sources: {},     vertices: {},     primitives: []    };     const mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];     // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep    if ( mesh === undefined ) return;     for ( let i = 0; i < mesh.childNodes.length; i ++ ) {      const child = mesh.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      const id = child.getAttribute( 'id' );      switch ( child.nodeName ) {       case 'source':       data.sources[ id ] = parseSource( child );       break;       case 'vertices':       // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];       data.vertices = parseGeometryVertices( child );       break;       case 'polygons':       console.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );       break;       case 'lines':      case 'linestrips':      case 'polylist':      case 'triangles':       data.primitives.push( parseGeometryPrimitive( child ) );       break;       default:       console.log( child );      }     }     library.geometries[ xml.getAttribute( 'id' ) ] = data;    }    function parseSource( xml ) {     const data = {     array: [],     stride: 3    };     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'float_array':       data.array = parseFloats( child.textContent );       break;       case 'Name_array':       data.array = parseStrings( child.textContent );       break;       case 'technique_common':       const accessor = getElementsByTagName( child, 'accessor' )[ 0 ];        if ( accessor !== undefined ) {         data.stride = parseInt( accessor.getAttribute( 'stride' ) );        }        break;      }     }     return data;    }    function parseGeometryVertices( xml ) {     const data = {};     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      data[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );     }     return data;    }    function parseGeometryPrimitive( xml ) {     const primitive = {     type: xml.nodeName,     material: xml.getAttribute( 'material' ),     count: parseInt( xml.getAttribute( 'count' ) ),     inputs: {},     stride: 0,     hasUV: false    };     for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'input':       const id = parseId( child.getAttribute( 'source' ) );       const semantic = child.getAttribute( 'semantic' );       const offset = parseInt( child.getAttribute( 'offset' ) );       const set = parseInt( child.getAttribute( 'set' ) );       const inputname = ( set > 0 ? semantic + set : semantic );       primitive.inputs[ inputname ] = { id: id, offset: offset };       primitive.stride = Math.max( primitive.stride, offset + 1 );       if ( semantic === 'TEXCOORD' ) primitive.hasUV = true;       break;       case 'vcount':       primitive.vcount = parseInts( child.textContent );       break;       case 'p':       primitive.p = parseInts( child.textContent );       break;      }     }     return primitive;    }    function groupPrimitives( primitives ) {     const build = {};     for ( let i = 0; i < primitives.length; i ++ ) {      const primitive = primitives[ i ];      if ( build[ primitive.type ] === undefined ) build[ primitive.type ] = [];      build[ primitive.type ].push( primitive );     }     return build;    }    function checkUVCoordinates( primitives ) {     let count = 0;     for ( let i = 0, l = primitives.length; i < l; i ++ ) {      const primitive = primitives[ i ];      if ( primitive.hasUV === true ) {       count ++;      }     }     if ( count > 0 && count < primitives.length ) {      primitives.uvsNeedsFix = true;     }    }    function buildGeometry( data ) {     const build = {};     const sources = data.sources;    const vertices = data.vertices;    const primitives = data.primitives;     if ( primitives.length === 0 ) return {};     // our goal is to create one buffer geometry for a single type of primitives    // first, we group all primitives by their type     const groupedPrimitives = groupPrimitives( primitives );     for ( const type in groupedPrimitives ) {      const primitiveType = groupedPrimitives[ type ];      // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)      checkUVCoordinates( primitiveType );      // third, create a buffer geometry for each type of primitives      build[ type ] = buildGeometryType( primitiveType, sources, vertices );     }     return build;    }    function buildGeometryType( primitives, sources, vertices ) {     const build = {};     const position = { array: [], stride: 0 };    const normal = { array: [], stride: 0 };    const uv = { array: [], stride: 0 };    const uv1 = { array: [], stride: 0 };    const color = { array: [], stride: 0 };     const skinIndex = { array: [], stride: 4 };    const skinWeight = { array: [], stride: 4 };     const geometry = new BufferGeometry();     const materialKeys = [];     let start = 0;     for ( let p = 0; p < primitives.length; p ++ ) {      const primitive = primitives[ p ];     const inputs = primitive.inputs;      // groups      let count = 0;      switch ( primitive.type ) {       case 'lines':      case 'linestrips':       count = primitive.count * 2;       break;       case 'triangles':       count = primitive.count * 3;       break;       case 'polylist':        for ( let g = 0; g < primitive.count; g ++ ) {         const vc = primitive.vcount[ g ];         switch ( vc ) {          case 3:          count += 3; // single triangle          break;          case 4:          count += 6; // quad, subdivided into two triangles          break;          default:          count += ( vc - 2 ) * 3; // polylist with more than four vertices          break;         }        }        break;       default:       console.warn( 'THREE.ColladaLoader: Unknow primitive type:', primitive.type );      }      geometry.addGroup( start, count, p );     start += count;      // material      if ( primitive.material ) {       materialKeys.push( primitive.material );      }      // geometry data      for ( const name in inputs ) {       const input = inputs[ name ];       switch ( name ) {        case 'VERTEX':        for ( const key in vertices ) {          const id = vertices[ key ];          switch ( key ) {           case 'POSITION':           const prevLength = position.array.length;           buildGeometryData( primitive, sources[ id ], input.offset, position.array );           position.stride = sources[ id ].stride;            if ( sources.skinWeights && sources.skinIndices ) {             buildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );            buildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );            }            // see #3803            if ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {             const count = ( position.array.length - prevLength ) / position.stride;             for ( let i = 0; i < count; i ++ ) {              // fill missing uv coordinates              uv.array.push( 0, 0 );             }            }            break;           case 'NORMAL':           buildGeometryData( primitive, sources[ id ], input.offset, normal.array );           normal.stride = sources[ id ].stride;           break;           case 'COLOR':           buildGeometryData( primitive, sources[ id ], input.offset, color.array );           color.stride = sources[ id ].stride;           break;           case 'TEXCOORD':           buildGeometryData( primitive, sources[ id ], input.offset, uv.array );           uv.stride = sources[ id ].stride;           break;           case 'TEXCOORD1':           buildGeometryData( primitive, sources[ id ], input.offset, uv1.array );           uv.stride = sources[ id ].stride;           break;           default:           console.warn( 'THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', key );          }         }         break;        case 'NORMAL':        buildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );        normal.stride = sources[ input.id ].stride;        break;        case 'COLOR':        buildGeometryData( primitive, sources[ input.id ], input.offset, color.array, true );        color.stride = sources[ input.id ].stride;        break;        case 'TEXCOORD':        buildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );        uv.stride = sources[ input.id ].stride;        break;        case 'TEXCOORD1':        buildGeometryData( primitive, sources[ input.id ], input.offset, uv1.array );        uv1.stride = sources[ input.id ].stride;        break;       }      }     }     // build geometry     if ( position.array.length > 0 ) geometry.setAttribute( 'position', new Float32BufferAttribute( position.array, position.stride ) );    if ( normal.array.length > 0 ) geometry.setAttribute( 'normal', new Float32BufferAttribute( normal.array, normal.stride ) );    if ( color.array.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( color.array, color.stride ) );    if ( uv.array.length > 0 ) geometry.setAttribute( 'uv', new Float32BufferAttribute( uv.array, uv.stride ) );    if ( uv1.array.length > 0 ) geometry.setAttribute( 'uv1', new Float32BufferAttribute( uv1.array, uv1.stride ) );     if ( skinIndex.array.length > 0 ) geometry.setAttribute( 'skinIndex', new Float32BufferAttribute( skinIndex.array, skinIndex.stride ) );    if ( skinWeight.array.length > 0 ) geometry.setAttribute( 'skinWeight', new Float32BufferAttribute( skinWeight.array, skinWeight.stride ) );     build.data = geometry;    build.type = primitives[ 0 ].type;    build.materialKeys = materialKeys;     return build;    }    function buildGeometryData( primitive, source, offset, array, isColor = false ) {     const indices = primitive.p;    const stride = primitive.stride;    const vcount = primitive.vcount;     function pushVector( i ) {      let index = indices[ i + offset ] * sourceStride;     const length = index + sourceStride;      for ( ; index < length; index ++ ) {       array.push( sourceArray[ index ] );      }      if ( isColor ) {       // convert the vertex colors from srgb to linear if present      const startIndex = array.length - sourceStride - 1;      tempColor.setRGB(       array[ startIndex + 0 ],       array[ startIndex + 1 ],       array[ startIndex + 2 ],       SRGBColorSpace      );       array[ startIndex + 0 ] = tempColor.r;      array[ startIndex + 1 ] = tempColor.g;      array[ startIndex + 2 ] = tempColor.b;      }     }     const sourceArray = source.array;    const sourceStride = source.stride;     if ( primitive.vcount !== undefined ) {      let index = 0;      for ( let i = 0, l = vcount.length; i < l; i ++ ) {       const count = vcount[ i ];       if ( count === 4 ) {        const a = index + stride * 0;       const b = index + stride * 1;       const c = index + stride * 2;       const d = index + stride * 3;        pushVector( a ); pushVector( b ); pushVector( d );       pushVector( b ); pushVector( c ); pushVector( d );       } else if ( count === 3 ) {        const a = index + stride * 0;       const b = index + stride * 1;       const c = index + stride * 2;        pushVector( a ); pushVector( b ); pushVector( c );       } else if ( count > 4 ) {        for ( let k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {         const a = index + stride * 0;        const b = index + stride * k;        const c = index + stride * ( k + 1 );         pushVector( a ); pushVector( b ); pushVector( c );        }       }       index += stride * count;      }     } else {      for ( let i = 0, l = indices.length; i < l; i += stride ) {       pushVector( i );      }     }    }    function getGeometry( id ) {     return getBuild( library.geometries[ id ], buildGeometry );    }    // kinematics    function parseKinematicsModel( xml ) {     const data = {     name: xml.getAttribute( 'name' ) || '',     joints: {},     links: []    };     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'technique_common':       parseKinematicsTechniqueCommon( child, data );       break;      }     }     library.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;    }    function buildKinematicsModel( data ) {     if ( data.build !== undefined ) return data.build;     return data;    }    function getKinematicsModel( id ) {     return getBuild( library.kinematicsModels[ id ], buildKinematicsModel );    }    function parseKinematicsTechniqueCommon( xml, data ) {     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'joint':       data.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );       break;       case 'link':       data.links.push( parseKinematicsLink( child ) );       break;      }     }    }    function parseKinematicsJoint( xml ) {     let data;     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'prismatic':      case 'revolute':       data = parseKinematicsJointParameter( child );       break;      }     }     return data;    }    function parseKinematicsJointParameter( xml ) {     const data = {     sid: xml.getAttribute( 'sid' ),     name: xml.getAttribute( 'name' ) || '',     axis: new Vector3(),     limits: {      min: 0,      max: 0     },     type: xml.nodeName,     static: false,     zeroPosition: 0,     middlePosition: 0    };     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'axis':       const array = parseFloats( child.textContent );       data.axis.fromArray( array );       break;      case 'limits':       const max = child.getElementsByTagName( 'max' )[ 0 ];       const min = child.getElementsByTagName( 'min' )[ 0 ];        data.limits.max = parseFloat( max.textContent );       data.limits.min = parseFloat( min.textContent );       break;      }     }     // if min is equal to or greater than max, consider the joint static     if ( data.limits.min >= data.limits.max ) {      data.static = true;     }     // calculate middle position     data.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;     return data;    }    function parseKinematicsLink( xml ) {     const data = {     sid: xml.getAttribute( 'sid' ),     name: xml.getAttribute( 'name' ) || '',     attachments: [],     transforms: []    };     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'attachment_full':       data.attachments.push( parseKinematicsAttachment( child ) );       break;       case 'matrix':      case 'translate':      case 'rotate':       data.transforms.push( parseKinematicsTransform( child ) );       break;      }     }     return data;    }    function parseKinematicsAttachment( xml ) {     const data = {     joint: xml.getAttribute( 'joint' ).split( '/' ).pop(),     transforms: [],     links: []    };     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'link':       data.links.push( parseKinematicsLink( child ) );       break;       case 'matrix':      case 'translate':      case 'rotate':       data.transforms.push( parseKinematicsTransform( child ) );       break;      }     }     return data;    }    function parseKinematicsTransform( xml ) {     const data = {     type: xml.nodeName    };     const array = parseFloats( xml.textContent );     switch ( data.type ) {      case 'matrix':      data.obj = new Matrix4();      data.obj.fromArray( array ).transpose();      break;      case 'translate':      data.obj = new Vector3();      data.obj.fromArray( array );      break;      case 'rotate':      data.obj = new Vector3();      data.obj.fromArray( array );      data.angle = MathUtils.degToRad( array[ 3 ] );      break;     }     return data;    }    // physics    function parsePhysicsModel( xml ) {     const data = {     name: xml.getAttribute( 'name' ) || '',     rigidBodies: {}    };     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'rigid_body':       data.rigidBodies[ child.getAttribute( 'name' ) ] = {};       parsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );       break;      }     }     library.physicsModels[ xml.getAttribute( 'id' ) ] = data;    }    function parsePhysicsRigidBody( xml, data ) {     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'technique_common':       parsePhysicsTechniqueCommon( child, data );       break;      }     }    }    function parsePhysicsTechniqueCommon( xml, data ) {     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'inertia':       data.inertia = parseFloats( child.textContent );       break;       case 'mass':       data.mass = parseFloats( child.textContent )[ 0 ];       break;      }     }    }    // scene    function parseKinematicsScene( xml ) {     const data = {     bindJointAxis: []    };     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'bind_joint_axis':       data.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );       break;      }     }     library.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;    }    function parseKinematicsBindJointAxis( xml ) {     const data = {     target: xml.getAttribute( 'target' ).split( '/' ).pop()    };     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      switch ( child.nodeName ) {       case 'axis':       const param = child.getElementsByTagName( 'param' )[ 0 ];       data.axis = param.textContent;       const tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];       data.jointIndex = tmpJointIndex.substring( 0, tmpJointIndex.length - 1 );       break;      }     }     return data;    }    function buildKinematicsScene( data ) {     if ( data.build !== undefined ) return data.build;     return data;    }    function getKinematicsScene( id ) {     return getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );    }    function setupKinematics() {     const kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];    const kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];    const visualSceneId = Object.keys( library.visualScenes )[ 0 ];     if ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;     const kinematicsModel = getKinematicsModel( kinematicsModelId );    const kinematicsScene = getKinematicsScene( kinematicsSceneId );    const visualScene = getVisualScene( visualSceneId );     const bindJointAxis = kinematicsScene.bindJointAxis;    const jointMap = {};     for ( let i = 0, l = bindJointAxis.length; i < l; i ++ ) {      const axis = bindJointAxis[ i ];      // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'      const targetElement = collada.querySelector( '[sid="' + axis.target + '"]' );      if ( targetElement ) {       // get the parent of the transform element       const parentVisualElement = targetElement.parentElement;       // connect the joint of the kinematics model with the element in the visual scene       connect( axis.jointIndex, parentVisualElement );      }     }     function connect( jointIndex, visualElement ) {      const visualElementName = visualElement.getAttribute( 'name' );     const joint = kinematicsModel.joints[ jointIndex ];      visualScene.traverse( function ( object ) {       if ( object.name === visualElementName ) {        jointMap[ jointIndex ] = {        object: object,        transforms: buildTransformList( visualElement ),        joint: joint,        position: joint.zeroPosition       };       }      } );     }     const m0 = new Matrix4();     kinematics = {      joints: kinematicsModel && kinematicsModel.joints,      getJointValue: function ( jointIndex ) {       const jointData = jointMap[ jointIndex ];       if ( jointData ) {        return jointData.position;       } else {        console.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn|'t exist.' );       }      },      setJointValue: function ( jointIndex, value ) {       const jointData = jointMap[ jointIndex ];       if ( jointData ) {        const joint = jointData.joint;        if ( value > joint.limits.max || value < joint.limits.min ) {         console.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );        } else if ( joint.static ) {         console.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );        } else {         const object = jointData.object;        const axis = joint.axis;        const transforms = jointData.transforms;         matrix.identity();         // each update, we have to apply all transforms in the correct order         for ( let i = 0; i < transforms.length; i ++ ) {          const transform = transforms[ i ];          // if there is a connection of the transform node with a joint, apply the joint value          if ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {           switch ( joint.type ) {            case 'revolute':            matrix.multiply( m0.makeRotationAxis( axis, MathUtils.degToRad( value ) ) );            break;            case 'prismatic':            matrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );            break;            default:            console.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );            break;           }          } else {           switch ( transform.type ) {            case 'matrix':            matrix.multiply( transform.obj );            break;            case 'translate':            matrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );            break;            case 'scale':            matrix.scale( transform.obj );            break;            case 'rotate':            matrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );            break;           }          }         }         object.matrix.copy( matrix );        object.matrix.decompose( object.position, object.quaternion, object.scale );         jointMap[ jointIndex ].position = value;        }       } else {        console.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );       }      }     };    }    function buildTransformList( node ) {     const transforms = [];     const xml = collada.querySelector( '[id="' + node.id + '"]' );     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      let array, vector;      switch ( child.nodeName ) {       case 'matrix':       array = parseFloats( child.textContent );       const matrix = new Matrix4().fromArray( array ).transpose();       transforms.push( {        sid: child.getAttribute( 'sid' ),        type: child.nodeName,        obj: matrix       } );       break;       case 'translate':      case 'scale':       array = parseFloats( child.textContent );       vector = new Vector3().fromArray( array );       transforms.push( {        sid: child.getAttribute( 'sid' ),        type: child.nodeName,        obj: vector       } );       break;       case 'rotate':       array = parseFloats( child.textContent );       vector = new Vector3().fromArray( array );       const angle = MathUtils.degToRad( array[ 3 ] );       transforms.push( {        sid: child.getAttribute( 'sid' ),        type: child.nodeName,        obj: vector,        angle: angle       } );       break;      }     }     return transforms;    }    // nodes    function prepareNodes( xml ) {     const elements = xml.getElementsByTagName( 'node' );     // ensure all node elements have id attributes     for ( let i = 0; i < elements.length; i ++ ) {      const element = elements[ i ];      if ( element.hasAttribute( 'id' ) === false ) {       element.setAttribute( 'id', generateId() );      }     }    }    const matrix = new Matrix4();   const vector = new Vector3();    function parseNode( xml ) {     const data = {     name: xml.getAttribute( 'name' ) || '',     type: xml.getAttribute( 'type' ),     id: xml.getAttribute( 'id' ),     sid: xml.getAttribute( 'sid' ),     matrix: new Matrix4(),     nodes: [],     instanceCameras: [],     instanceControllers: [],     instanceLights: [],     instanceGeometries: [],     instanceNodes: [],     transforms: {}    };     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      if ( child.nodeType !== 1 ) continue;      let array;      switch ( child.nodeName ) {       case 'node':       data.nodes.push( child.getAttribute( 'id' ) );       parseNode( child );       break;       case 'instance_camera':       data.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );       break;       case 'instance_controller':       data.instanceControllers.push( parseNodeInstance( child ) );       break;       case 'instance_light':       data.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );       break;       case 'instance_geometry':       data.instanceGeometries.push( parseNodeInstance( child ) );       break;       case 'instance_node':       data.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );       break;       case 'matrix':       array = parseFloats( child.textContent );       data.matrix.multiply( matrix.fromArray( array ).transpose() );       data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;       break;       case 'translate':       array = parseFloats( child.textContent );       vector.fromArray( array );       data.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );       data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;       break;       case 'rotate':       array = parseFloats( child.textContent );       const angle = MathUtils.degToRad( array[ 3 ] );       data.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );       data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;       break;       case 'scale':       array = parseFloats( child.textContent );       data.matrix.scale( vector.fromArray( array ) );       data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;       break;       case 'extra':       break;       default:       console.log( child );      }     }     if ( hasNode( data.id ) ) {      console.warn( 'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );     } else {      library.nodes[ data.id ] = data;     }     return data;    }    function parseNodeInstance( xml ) {     const data = {     id: parseId( xml.getAttribute( 'url' ) ),     materials: {},     skeletons: []    };     for ( let i = 0; i < xml.childNodes.length; i ++ ) {      const child = xml.childNodes[ i ];      switch ( child.nodeName ) {       case 'bind_material':       const instances = child.getElementsByTagName( 'instance_material' );        for ( let j = 0; j < instances.length; j ++ ) {         const instance = instances[ j ];        const symbol = instance.getAttribute( 'symbol' );        const target = instance.getAttribute( 'target' );         data.materials[ symbol ] = parseId( target );        }        break;       case 'skeleton':       data.skeletons.push( parseId( child.textContent ) );       break;       default:       break;      }     }     return data;    }    function buildSkeleton( skeletons, joints ) {     const boneData = [];    const sortedBoneData = [];     let i, j, data;     // a skeleton can have multiple root bones. collada expresses this    // situtation with multiple "skeleton" tags per controller instance     for ( i = 0; i < skeletons.length; i ++ ) {      const skeleton = skeletons[ i ];      let root;      if ( hasNode( skeleton ) ) {       root = getNode( skeleton );      buildBoneHierarchy( root, joints, boneData );      } else if ( hasVisualScene( skeleton ) ) {       // handle case where the skeleton refers to the visual scene (#13335)       const visualScene = library.visualScenes[ skeleton ];      const children = visualScene.children;       for ( let j = 0; j < children.length; j ++ ) {        const child = children[ j ];        if ( child.type === 'JOINT' ) {         const root = getNode( child.id );        buildBoneHierarchy( root, joints, boneData );        }       }      } else {       console.error( 'THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );      }     }     // sort bone data (the order is defined in the corresponding controller)     for ( i = 0; i < joints.length; i ++ ) {      for ( j = 0; j < boneData.length; j ++ ) {       data = boneData[ j ];       if ( data.bone.name === joints[ i ].name ) {        sortedBoneData[ i ] = data;       data.processed = true;       break;       }      }     }     // add unprocessed bone data at the end of the list     for ( i = 0; i < boneData.length; i ++ ) {      data = boneData[ i ];      if ( data.processed === false ) {       sortedBoneData.push( data );      data.processed = true;      }     }     // setup arrays for skeleton creation     const bones = [];    const boneInverses = [];     for ( i = 0; i < sortedBoneData.length; i ++ ) {      data = sortedBoneData[ i ];      bones.push( data.bone );     boneInverses.push( data.boneInverse );     }     return new Skeleton( bones, boneInverses );    }    function buildBoneHierarchy( root, joints, boneData ) {     // setup bone data from visual scene     root.traverse( function ( object ) {      if ( object.isBone === true ) {       let boneInverse;       // retrieve the boneInverse from the controller data       for ( let i = 0; i < joints.length; i ++ ) {        const joint = joints[ i ];        if ( joint.name === object.name ) {         boneInverse = joint.boneInverse;        break;        }       }       if ( boneInverse === undefined ) {        // Unfortunately, there can be joints in the visual scene that are not part of the       // corresponding controller. In this case, we have to create a dummy boneInverse matrix       // for the respective bone. This bone won't affect any vertices, because there are no skin indices       // and weights defined for it. But we still have to add the bone to the sorted bone list in order to       // ensure a correct animation of the model.        boneInverse = new Matrix4();       }       boneData.push( { bone: object, boneInverse: boneInverse, processed: false } );      }     } );    }    function buildNode( data ) {     const objects = [];     const matrix = data.matrix;    const nodes = data.nodes;    const type = data.type;    const instanceCameras = data.instanceCameras;    const instanceControllers = data.instanceControllers;    const instanceLights = data.instanceLights;    const instanceGeometries = data.instanceGeometries;    const instanceNodes = data.instanceNodes;     // nodes     for ( let i = 0, l = nodes.length; i < l; i ++ ) {      objects.push( getNode( nodes[ i ] ) );     }     // instance cameras     for ( let i = 0, l = instanceCameras.length; i < l; i ++ ) {      const instanceCamera = getCamera( instanceCameras[ i ] );      if ( instanceCamera !== null ) {       objects.push( instanceCamera.clone() );      }     }     // instance controllers     for ( let i = 0, l = instanceControllers.length; i < l; i ++ ) {      const instance = instanceControllers[ i ];     const controller = getController( instance.id );     const geometries = getGeometry( controller.id );     const newObjects = buildObjects( geometries, instance.materials );      const skeletons = instance.skeletons;     const joints = controller.skin.joints;      const skeleton = buildSkeleton( skeletons, joints );      for ( let j = 0, jl = newObjects.length; j < jl; j ++ ) {       const object = newObjects[ j ];       if ( object.isSkinnedMesh ) {        object.bind( skeleton, controller.skin.bindMatrix );       object.normalizeSkinWeights();       }       objects.push( object );      }     }     // instance lights     for ( let i = 0, l = instanceLights.length; i < l; i ++ ) {      const instanceLight = getLight( instanceLights[ i ] );      if ( instanceLight !== null ) {       objects.push( instanceLight.clone() );      }     }     // instance geometries     for ( let i = 0, l = instanceGeometries.length; i < l; i ++ ) {      const instance = instanceGeometries[ i ];      // a single geometry instance in collada can lead to multiple object3Ds.     // this is the case when primitives are combined like triangles and lines      const geometries = getGeometry( instance.id );     const newObjects = buildObjects( geometries, instance.materials );      for ( let j = 0, jl = newObjects.length; j < jl; j ++ ) {       objects.push( newObjects[ j ] );      }     }     // instance nodes     for ( let i = 0, l = instanceNodes.length; i < l; i ++ ) {      objects.push( getNode( instanceNodes[ i ] ).clone() );     }     let object;     if ( nodes.length === 0 && objects.length === 1 ) {      object = objects[ 0 ];     } else {      object = ( type === 'JOINT' ) ? new Bone() : new Group();      for ( let i = 0; i < objects.length; i ++ ) {       object.add( objects[ i ] );      }     }     object.name = ( type === 'JOINT' ) ? data.sid : data.name;    object.matrix.copy( matrix );    object.matrix.decompose( object.position, object.quaternion, object.scale );     return object;    }    const fallbackMaterial = new MeshBasicMaterial( {    name: Loader.DEFAULT_MATERIAL_NAME,    color: 0xff00ff   } );    function resolveMaterialBinding( keys, instanceMaterials ) {     const materials = [];     for ( let i = 0, l = keys.length; i < l; i ++ ) {      const id = instanceMaterials[ keys[ i ] ];      if ( id === undefined ) {       console.warn( 'THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );      materials.push( fallbackMaterial );      } else {       materials.push( getMaterial( id ) );      }     }     return materials;    }    function buildObjects( geometries, instanceMaterials ) {     const objects = [];     for ( const type in geometries ) {      const geometry = geometries[ type ];      const materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );      // handle case if no materials are defined      if ( materials.length === 0 ) {       if ( type === 'lines' || type === 'linestrips' ) {        materials.push( new LineBasicMaterial() );       } else {        materials.push( new MeshPhongMaterial() );       }      }      // Collada allows to use phong and lambert materials with lines. Replacing these cases with LineBasicMaterial.      if ( type === 'lines' || type === 'linestrips' ) {       for ( let i = 0, l = materials.length; i < l; i ++ ) {        const material = materials[ i ];        if ( material.isMeshPhongMaterial === true || material.isMeshLambertMaterial === true ) {         const lineMaterial = new LineBasicMaterial();         // copy compatible properties         lineMaterial.color.copy( material.color );        lineMaterial.opacity = material.opacity;        lineMaterial.transparent = material.transparent;         // replace material         materials[ i ] = lineMaterial;        }       }      }      // regard skinning      const skinning = ( geometry.data.attributes.skinIndex !== undefined );      // choose between a single or multi materials (material array)      const material = ( materials.length === 1 ) ? materials[ 0 ] : materials;      // now create a specific 3D object      let object;      switch ( type ) {       case 'lines':       object = new LineSegments( geometry.data, material );       break;       case 'linestrips':       object = new Line( geometry.data, material );       break;       case 'triangles':      case 'polylist':       if ( skinning ) {         object = new SkinnedMesh( geometry.data, material );        } else {         object = new Mesh( geometry.data, material );        }        break;      }      objects.push( object );     }     return objects;    }    function hasNode( id ) {     return library.nodes[ id ] !== undefined;    }    function getNode( id ) {     return getBuild( library.nodes[ id ], buildNode );    }    // visual scenes    function parseVisualScene( xml ) {     const data = {     name: xml.getAttribute( 'name' ),     children: []    };     prepareNodes( xml );     const elements = getElementsByTagName( xml, 'node' );     for ( let i = 0; i < elements.length; i ++ ) {      data.children.push( parseNode( elements[ i ] ) );     }     library.visualScenes[ xml.getAttribute( 'id' ) ] = data;    }    function buildVisualScene( data ) {     const group = new Group();    group.name = data.name;     const children = data.children;     for ( let i = 0; i < children.length; i ++ ) {      const child = children[ i ];      group.add( getNode( child.id ) );     }     return group;    }    function hasVisualScene( id ) {     return library.visualScenes[ id ] !== undefined;    }    function getVisualScene( id ) {     return getBuild( library.visualScenes[ id ], buildVisualScene );    }    // scenes    function parseScene( xml ) {     const instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];    return getVisualScene( parseId( instance.getAttribute( 'url' ) ) );    }    function setupAnimations() {     const clips = library.clips;     if ( isEmpty( clips ) === true ) {      if ( isEmpty( library.animations ) === false ) {       // if there are animations but no clips, we create a default clip for playback       const tracks = [];       for ( const id in library.animations ) {        const animationTracks = getAnimation( id );        for ( let i = 0, l = animationTracks.length; i < l; i ++ ) {         tracks.push( animationTracks[ i ] );        }       }       animations.push( new AnimationClip( 'default', - 1, tracks ) );      }     } else {      for ( const id in clips ) {       animations.push( getAnimationClip( id ) );      }     }    }    // convert the parser error element into text with each child elements text   // separated by new lines.    function parserErrorToText( parserError ) {     let result = '';    const stack = [ parserError ];     while ( stack.length ) {      const node = stack.shift();      if ( node.nodeType === Node.TEXT_NODE ) {       result += node.textContent;      } else {       result += '|n';      stack.push.apply( stack, node.childNodes );      }     }     return result.trim();    }    if ( text.length === 0 ) {     return { scene: new Scene() };    }    const xml = new DOMParser().parseFromString( text, 'application/xml' );    const collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];    const parserError = xml.getElementsByTagName( 'parsererror' )[ 0 ];   if ( parserError !== undefined ) {     // Chrome will return parser error with a div in it     const errorElement = getElementsByTagName( parserError, 'div' )[ 0 ];    let errorText;     if ( errorElement ) {      errorText = errorElement.textContent;     } else {      errorText = parserErrorToText( parserError );     }     console.error( 'THREE.ColladaLoader: Failed to parse collada file.|n', errorText );     return null;    }    // metadata    const version = collada.getAttribute( 'version' );   console.debug( 'THREE.ColladaLoader: File version', version );    const asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );   const textureLoader = new TextureLoader( this.manager );   textureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );    let tgaLoader;    if ( TGALoader ) {     tgaLoader = new TGALoader( this.manager );    tgaLoader.setPath( this.resourcePath || path );    }    //    const tempColor = new Color();   const animations = [];   let kinematics = {};   let count = 0;    //    const library = {    animations: {},    clips: {},    controllers: {},    images: {},    effects: {},    materials: {},    cameras: {},    lights: {},    geometries: {},    nodes: {},    visualScenes: {},    kinematicsModels: {},    physicsModels: {},    kinematicsScenes: {}   };    parseLibrary( collada, 'library_animations', 'animation', parseAnimation );   parseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );   parseLibrary( collada, 'library_controllers', 'controller', parseController );   parseLibrary( collada, 'library_images', 'image', parseImage );   parseLibrary( collada, 'library_effects', 'effect', parseEffect );   parseLibrary( collada, 'library_materials', 'material', parseMaterial );   parseLibrary( collada, 'library_cameras', 'camera', parseCamera );   parseLibrary( collada, 'library_lights', 'light', parseLight );   parseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );   parseLibrary( collada, 'library_nodes', 'node', parseNode );   parseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );   parseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );   parseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );   parseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );    buildLibrary( library.animations, buildAnimation );   buildLibrary( library.clips, buildAnimationClip );   buildLibrary( library.controllers, buildController );   buildLibrary( library.images, buildImage );   buildLibrary( library.effects, buildEffect );   buildLibrary( library.materials, buildMaterial );   buildLibrary( library.cameras, buildCamera );   buildLibrary( library.lights, buildLight );   buildLibrary( library.geometries, buildGeometry );   buildLibrary( library.visualScenes, buildVisualScene );    setupAnimations();   setupKinematics();    const scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );   scene.animations = animations;    if ( asset.upAxis === 'Z_UP' ) {     console.warn( 'THREE.ColladaLoader: You are loading an asset with a Z-UP coordinate system. The loader just rotates the asset to transform it into Y-UP. The vertex data are not converted, see #24289.' );    scene.rotation.set( - Math.PI / 2, 0, 0 );    }    scene.scale.multiplyScalar( asset.unit );    return {    get animations() {      console.warn( 'THREE.ColladaLoader: Please access animations over scene.animations now.' );     return animations;     },    kinematics: kinematics,    library: library,    scene: scene   };   }  }  export { ColladaLoader }; 
^..^ FILENAME ^..^
addons|loaders|DDSLoader.js
^..^ CONTENTS ^..^
import {  CompressedTextureLoader,  RGBAFormat,  RGBA_S3TC_DXT3_Format,  RGBA_S3TC_DXT5_Format,  RGB_ETC1_Format,  RGB_S3TC_DXT1_Format,  RGB_BPTC_SIGNED_Format,  RGB_BPTC_UNSIGNED_Format } from 'three';  class DDSLoader extends CompressedTextureLoader {   constructor( manager ) {    super( manager );   }   parse( buffer, loadMipmaps ) {    const dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };    // Adapted from @toji's DDS utils   // https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js    // All values and structures referenced from:   // http://msdn.microsoft.com/en-us/library/bb943991.aspx/    const DDS_MAGIC = 0x20534444;    // const DDSD_CAPS = 0x1;   // const DDSD_HEIGHT = 0x2;   // const DDSD_WIDTH = 0x4;   // const DDSD_PITCH = 0x8;   // const DDSD_PIXELFORMAT = 0x1000;   const DDSD_MIPMAPCOUNT = 0x20000;   // const DDSD_LINEARSIZE = 0x80000;   // const DDSD_DEPTH = 0x800000;    // const DDSCAPS_COMPLEX = 0x8;   // const DDSCAPS_MIPMAP = 0x400000;   // const DDSCAPS_TEXTURE = 0x1000;    const DDSCAPS2_CUBEMAP = 0x200;   const DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;   const DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;   const DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;   const DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;   const DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;   const DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;   // const DDSCAPS2_VOLUME = 0x200000;    // const DDPF_ALPHAPIXELS = 0x1;   // const DDPF_ALPHA = 0x2;   // const DDPF_FOURCC = 0x4;   // const DDPF_RGB = 0x40;   // const DDPF_YUV = 0x200;   // const DDPF_LUMINANCE = 0x20000;    const DXGI_FORMAT_BC6H_UF16 = 95;   const DXGI_FORMAT_BC6H_SF16 = 96;    function fourCCToInt32( value ) {     return value.charCodeAt( 0 ) +     ( value.charCodeAt( 1 ) << 8 ) +     ( value.charCodeAt( 2 ) << 16 ) +     ( value.charCodeAt( 3 ) << 24 );    }    function int32ToFourCC( value ) {     return String.fromCharCode(     value & 0xff,     ( value >> 8 ) & 0xff,     ( value >> 16 ) & 0xff,     ( value >> 24 ) & 0xff    );    }    function loadARGBMip( buffer, dataOffset, width, height ) {     const dataLength = width * height * 4;    const srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );    const byteArray = new Uint8Array( dataLength );    let dst = 0;    let src = 0;    for ( let y = 0; y < height; y ++ ) {      for ( let x = 0; x < width; x ++ ) {       const b = srcBuffer[ src ]; src ++;      const g = srcBuffer[ src ]; src ++;      const r = srcBuffer[ src ]; src ++;      const a = srcBuffer[ src ]; src ++;      byteArray[ dst ] = r; dst ++; //r      byteArray[ dst ] = g; dst ++; //g      byteArray[ dst ] = b; dst ++; //b      byteArray[ dst ] = a; dst ++; //a      }     }     return byteArray;    }    const FOURCC_DXT1 = fourCCToInt32( 'DXT1' );   const FOURCC_DXT3 = fourCCToInt32( 'DXT3' );   const FOURCC_DXT5 = fourCCToInt32( 'DXT5' );   const FOURCC_ETC1 = fourCCToInt32( 'ETC1' );   const FOURCC_DX10 = fourCCToInt32( 'DX10' );    const headerLengthInt = 31; // The header length in 32 bit ints   const extendedHeaderLengthInt = 5; // The extended header length in 32 bit ints    // Offsets into the header array    const off_magic = 0;    const off_size = 1;   const off_flags = 2;   const off_height = 3;   const off_width = 4;    const off_mipmapCount = 7;    // const off_pfFlags = 20;   const off_pfFourCC = 21;   const off_RGBBitCount = 22;   const off_RBitMask = 23;   const off_GBitMask = 24;   const off_BBitMask = 25;   const off_ABitMask = 26;    // const off_caps = 27;   const off_caps2 = 28;   // const off_caps3 = 29;   // const off_caps4 = 30;    // If fourCC = DX10, the extended header starts after 32   const off_dxgiFormat = 0;    // Parse header    const header = new Int32Array( buffer, 0, headerLengthInt );    if ( header[ off_magic ] !== DDS_MAGIC ) {     console.error( 'THREE.DDSLoader.parse: Invalid magic number in DDS header.' );    return dds;    }    let blockBytes;    const fourCC = header[ off_pfFourCC ];    let isRGBAUncompressed = false;    let dataOffset = header[ off_size ] + 4;    switch ( fourCC ) {     case FOURCC_DXT1:      blockBytes = 8;     dds.format = RGB_S3TC_DXT1_Format;     break;     case FOURCC_DXT3:      blockBytes = 16;     dds.format = RGBA_S3TC_DXT3_Format;     break;     case FOURCC_DXT5:      blockBytes = 16;     dds.format = RGBA_S3TC_DXT5_Format;     break;     case FOURCC_ETC1:      blockBytes = 8;     dds.format = RGB_ETC1_Format;     break;     case FOURCC_DX10:      dataOffset += extendedHeaderLengthInt * 4;     const extendedHeader = new Int32Array( buffer, ( headerLengthInt + 1 ) * 4, extendedHeaderLengthInt );     const dxgiFormat = extendedHeader[ off_dxgiFormat ];     switch ( dxgiFormat ) {       case DXGI_FORMAT_BC6H_SF16: {        blockBytes = 16;       dds.format = RGB_BPTC_SIGNED_Format;       break;       }       case DXGI_FORMAT_BC6H_UF16: {        blockBytes = 16;       dds.format = RGB_BPTC_UNSIGNED_Format;       break;       }       default: {        console.error( 'THREE.DDSLoader.parse: Unsupported DXGI_FORMAT code ', dxgiFormat );       return dds;       }      }      break;     default:      if ( header[ off_RGBBitCount ] === 32      && header[ off_RBitMask ] & 0xff0000      && header[ off_GBitMask ] & 0xff00      && header[ off_BBitMask ] & 0xff      && header[ off_ABitMask ] & 0xff000000 ) {       isRGBAUncompressed = true;      blockBytes = 64;      dds.format = RGBAFormat;      } else {       console.error( 'THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );      return dds;      }    }    dds.mipmapCount = 1;    if ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {     dds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );    }    const caps2 = header[ off_caps2 ];   dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;   if ( dds.isCubemap && (    ! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ||    ! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ||    ! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ||    ! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ||    ! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ||    ! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ )   ) ) {     console.error( 'THREE.DDSLoader.parse: Incomplete cubemap faces' );    return dds;    }    dds.width = header[ off_width ];   dds.height = header[ off_height ];    // Extract mipmaps buffers    const faces = dds.isCubemap ? 6 : 1;    for ( let face = 0; face < faces; face ++ ) {     let width = dds.width;    let height = dds.height;     for ( let i = 0; i < dds.mipmapCount; i ++ ) {      let byteArray, dataLength;      if ( isRGBAUncompressed ) {       byteArray = loadARGBMip( buffer, dataOffset, width, height );      dataLength = byteArray.length;      } else {       dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;      byteArray = new Uint8Array( buffer, dataOffset, dataLength );      }      const mipmap = { 'data': byteArray, 'width': width, 'height': height };     dds.mipmaps.push( mipmap );      dataOffset += dataLength;      width = Math.max( width >> 1, 1 );     height = Math.max( height >> 1, 1 );     }    }    return dds;   }  }  export { DDSLoader }; 
^..^ FILENAME ^..^
addons|loaders|DRACOLoader.js
^..^ CONTENTS ^..^
import {  BufferAttribute,  BufferGeometry,  Color,  ColorManagement,  FileLoader,  Loader,  LinearSRGBColorSpace,  SRGBColorSpace } from 'three';  const _taskCache = new WeakMap();  class DRACOLoader extends Loader {   constructor( manager ) {    super( manager );    this.decoderPath = '';   this.decoderConfig = {};   this.decoderBinary = null;   this.decoderPending = null;    this.workerLimit = 4;   this.workerPool = [];   this.workerNextTaskID = 1;   this.workerSourceURL = '';    this.defaultAttributeIDs = {    position: 'POSITION',    normal: 'NORMAL',    color: 'COLOR',    uv: 'TEX_COORD'   };   this.defaultAttributeTypes = {    position: 'Float32Array',    normal: 'Float32Array',    color: 'Float32Array',    uv: 'Float32Array'   };   }   setDecoderPath( path ) {    this.decoderPath = path;    return this;   }   setDecoderConfig( config ) {    this.decoderConfig = config;    return this;   }   setWorkerLimit( workerLimit ) {    this.workerLimit = workerLimit;    return this;   }   load( url, onLoad, onProgress, onError ) {    const loader = new FileLoader( this.manager );    loader.setPath( this.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( this.requestHeader );   loader.setWithCredentials( this.withCredentials );    loader.load( url, ( buffer ) => {     this.parse( buffer, onLoad, onError );    }, onProgress, onError );   }    parse( buffer, onLoad, onError = ()=>{} ) {    this.decodeDracoFile( buffer, onLoad, null, null, SRGBColorSpace, onError ).catch( onError );   }   decodeDracoFile( buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace, onError = () => {} ) {    const taskConfig = {    attributeIDs: attributeIDs || this.defaultAttributeIDs,    attributeTypes: attributeTypes || this.defaultAttributeTypes,    useUniqueIDs: !! attributeIDs,    vertexColorSpace: vertexColorSpace,   };    return this.decodeGeometry( buffer, taskConfig ).then( callback ).catch( onError );   }   decodeGeometry( buffer, taskConfig ) {    const taskKey = JSON.stringify( taskConfig );    // Check for an existing task using this buffer. A transferred buffer cannot be transferred   // again from this thread.   if ( _taskCache.has( buffer ) ) {     const cachedTask = _taskCache.get( buffer );     if ( cachedTask.key === taskKey ) {      return cachedTask.promise;     } else if ( buffer.byteLength === 0 ) {      // Technically, it would be possible to wait for the previous task to complete,     // transfer the buffer back, and decode again with the second configuration. That     // is complex, and I don't know of any reason to decode a Draco buffer twice in     // different ways, so this is left unimplemented.     throw new Error(       'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +      'settings. Buffer has already been transferred.'      );     }    }    //    let worker;   const taskID = this.workerNextTaskID ++;   const taskCost = buffer.byteLength;    // Obtain a worker and assign a task, and construct a geometry instance   // when the task completes.   const geometryPending = this._getWorker( taskID, taskCost )    .then( ( _worker ) => {      worker = _worker;      return new Promise( ( resolve, reject ) => {       worker._callbacks[ taskID ] = { resolve, reject };       worker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );       // this.debug();      } );     } )    .then( ( message ) => this._createGeometry( message.geometry ) );    // Remove task from the task list.   // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)   geometryPending    .catch( () => true )    .then( () => {      if ( worker && taskID ) {       this._releaseTask( worker, taskID );       // this.debug();      }     } );    // Cache the task result.   _taskCache.set( buffer, {     key: taskKey,    promise: geometryPending    } );    return geometryPending;   }   _createGeometry( geometryData ) {    const geometry = new BufferGeometry();    if ( geometryData.index ) {     geometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) );    }    for ( let i = 0; i < geometryData.attributes.length; i ++ ) {     const result = geometryData.attributes[ i ];    const name = result.name;    const array = result.array;    const itemSize = result.itemSize;     const attribute = new BufferAttribute( array, itemSize );     if ( name === 'color' ) {      this._assignVertexColorSpace( attribute, result.vertexColorSpace );      attribute.normalized = ( array instanceof Float32Array ) === false;     }     geometry.setAttribute( name, attribute );    }    return geometry;   }   _assignVertexColorSpace( attribute, inputColorSpace ) {    // While .drc files do not specify colorspace, the only 'official' tooling   // is PLY and OBJ converters, which use sRGB. We'll assume sRGB when a .drc   // file is passed into .load() or .parse(). GLTFLoader uses internal APIs   // to decode geometry, and vertex colors are already Linear-sRGB in there.    if ( inputColorSpace !== SRGBColorSpace ) return;    const _color = new Color();    for ( let i = 0, il = attribute.count; i < il; i ++ ) {     _color.fromBufferAttribute( attribute, i );    ColorManagement.toWorkingColorSpace( _color, SRGBColorSpace );    attribute.setXYZ( i, _color.r, _color.g, _color.b );    }   }   _loadLibrary( url, responseType ) {    const loader = new FileLoader( this.manager );   loader.setPath( this.decoderPath );   loader.setResponseType( responseType );   loader.setWithCredentials( this.withCredentials );    return new Promise( ( resolve, reject ) => {     loader.load( url, resolve, undefined, reject );    } );   }   preload() {    this._initDecoder();    return this;   }   _initDecoder() {    if ( this.decoderPending ) return this.decoderPending;    const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';   const librariesPending = [];    if ( useJS ) {     librariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );    } else {     librariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );    librariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );    }    this.decoderPending = Promise.all( librariesPending )    .then( ( libraries ) => {      const jsContent = libraries[ 0 ];      if ( ! useJS ) {       this.decoderConfig.wasmBinary = libraries[ 1 ];      }      const fn = DRACOWorker.toString();      const body = [      '/* draco decoder */',      jsContent,      '',      '/* worker */',      fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )     ].join( '|n' );      this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );     } );    return this.decoderPending;   }   _getWorker( taskID, taskCost ) {    return this._initDecoder().then( () => {     if ( this.workerPool.length < this.workerLimit ) {      const worker = new Worker( this.workerSourceURL );      worker._callbacks = {};     worker._taskCosts = {};     worker._taskLoad = 0;      worker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );      worker.onmessage = function ( e ) {       const message = e.data;       switch ( message.type ) {        case 'decode':        worker._callbacks[ message.id ].resolve( message );        break;        case 'error':        worker._callbacks[ message.id ].reject( message );        break;        default:        console.error( 'THREE.DRACOLoader: Unexpected message, "' + message.type + '"' );       }      };      this.workerPool.push( worker );     } else {      this.workerPool.sort( function ( a, b ) {       return a._taskLoad > b._taskLoad ? - 1 : 1;      } );     }     const worker = this.workerPool[ this.workerPool.length - 1 ];    worker._taskCosts[ taskID ] = taskCost;    worker._taskLoad += taskCost;    return worker;    } );   }   _releaseTask( worker, taskID ) {    worker._taskLoad -= worker._taskCosts[ taskID ];   delete worker._callbacks[ taskID ];   delete worker._taskCosts[ taskID ];   }   debug() {    console.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );   }   dispose() {    for ( let i = 0; i < this.workerPool.length; ++ i ) {     this.workerPool[ i ].terminate();    }    this.workerPool.length = 0;    if ( this.workerSourceURL !== '' ) {     URL.revokeObjectURL( this.workerSourceURL );    }    return this;   }  }  /* WEB WORKER */  function DRACOWorker() {   let decoderConfig;  let decoderPending;   onmessage = function ( e ) {    const message = e.data;    switch ( message.type ) {     case 'init':     decoderConfig = message.decoderConfig;     decoderPending = new Promise( function ( resolve/*, reject*/ ) {       decoderConfig.onModuleLoaded = function ( draco ) {        // Module is Promise-like. Wrap before resolving to avoid loop.       resolve( { draco: draco } );       };       DracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef      } );     break;     case 'decode':     const buffer = message.buffer;     const taskConfig = message.taskConfig;     decoderPending.then( ( module ) => {       const draco = module.draco;      const decoder = new draco.Decoder();       try {        const geometry = decodeGeometry( draco, decoder, new Int8Array( buffer ), taskConfig );        const buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );        if ( geometry.index ) buffers.push( geometry.index.array.buffer );        self.postMessage( { type: 'decode', id: message.id, geometry }, buffers );       } catch ( error ) {        console.error( error );        self.postMessage( { type: 'error', id: message.id, error: error.message } );       } finally {        draco.destroy( decoder );       }      } );     break;    }   };   function decodeGeometry( draco, decoder, array, taskConfig ) {    const attributeIDs = taskConfig.attributeIDs;   const attributeTypes = taskConfig.attributeTypes;    let dracoGeometry;   let decodingStatus;    const geometryType = decoder.GetEncodedGeometryType( array );    if ( geometryType === draco.TRIANGULAR_MESH ) {     dracoGeometry = new draco.Mesh();    decodingStatus = decoder.DecodeArrayToMesh( array, array.byteLength, dracoGeometry );    } else if ( geometryType === draco.POINT_CLOUD ) {     dracoGeometry = new draco.PointCloud();    decodingStatus = decoder.DecodeArrayToPointCloud( array, array.byteLength, dracoGeometry );    } else {     throw new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );    }    if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {     throw new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );    }    const geometry = { index: null, attributes: [] };    // Gather all vertex attributes.   for ( const attributeName in attributeIDs ) {     const attributeType = self[ attributeTypes[ attributeName ] ];     let attribute;    let attributeID;     // A Draco file may be created with default vertex attributes, whose attribute IDs    // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,    // a Draco file may contain a custom set of attributes, identified by known unique    // IDs. glTF files always do the latter, and |.drc| files typically do the former.    if ( taskConfig.useUniqueIDs ) {      attributeID = attributeIDs[ attributeName ];     attribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );     } else {      attributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );      if ( attributeID === - 1 ) continue;      attribute = decoder.GetAttribute( dracoGeometry, attributeID );     }     const attributeResult = decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute );     if ( attributeName === 'color' ) {      attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;     }     geometry.attributes.push( attributeResult );    }    // Add index.   if ( geometryType === draco.TRIANGULAR_MESH ) {     geometry.index = decodeIndex( draco, decoder, dracoGeometry );    }    draco.destroy( dracoGeometry );    return geometry;   }   function decodeIndex( draco, decoder, dracoGeometry ) {    const numFaces = dracoGeometry.num_faces();   const numIndices = numFaces * 3;   const byteLength = numIndices * 4;    const ptr = draco._malloc( byteLength );   decoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );   const index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();   draco._free( ptr );    return { array: index, itemSize: 1 };   }   function decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {    const numComponents = attribute.num_components();   const numPoints = dracoGeometry.num_points();   const numValues = numPoints * numComponents;   const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;   const dataType = getDracoDataType( draco, attributeType );    const ptr = draco._malloc( byteLength );   decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );   const array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();   draco._free( ptr );    return {    name: attributeName,    array: array,    itemSize: numComponents   };   }   function getDracoDataType( draco, attributeType ) {    switch ( attributeType ) {     case Float32Array: return draco.DT_FLOAT32;    case Int8Array: return draco.DT_INT8;    case Int16Array: return draco.DT_INT16;    case Int32Array: return draco.DT_INT32;    case Uint8Array: return draco.DT_UINT8;    case Uint16Array: return draco.DT_UINT16;    case Uint32Array: return draco.DT_UINT32;    }   }  }  export { DRACOLoader }; 
^..^ FILENAME ^..^
addons|loaders|EXRLoader.js
^..^ CONTENTS ^..^
import {  DataTextureLoader,  DataUtils,  FloatType,  HalfFloatType,  NoColorSpace,  LinearFilter,  LinearSRGBColorSpace,  RedFormat,  RGBAFormat } from 'three'; import * as fflate from '../libs/fflate.module.js';  /**  * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.  * Supports reading as UnsignedByte, HalfFloat and Float type data texture.  *  * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita  * implementation, so I have preserved their copyright notices.  */  // /* // Copyright (c) 2014 - 2017, Syoyo Fujita // All rights reserved.  // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: //     * Redistributions of source code must retain the above copyright //       notice, this list of conditions and the following disclaimer. //     * Redistributions in binary form must reproduce the above copyright //       notice, this list of conditions and the following disclaimer in the //       documentation and/or other materials provided with the distribution. //     * Neither the name of the Syoyo Fujita nor the //       names of its contributors may be used to endorse or promote products //       derived from this software without specific prior written permission.  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND // ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED // WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE // DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY // DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES // (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; // LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND // ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // */  // // TinyEXR contains some OpenEXR code, which is licensed under ------------  // /////////////////////////////////////////////////////////////////////////// // // // // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas // // Digital Ltd. LLC // // // // All rights reserved. // // // // Redistribution and use in source and binary forms, with or without // // modification, are permitted provided that the following conditions are // // met: // // *       Redistributions of source code must retain the above copyright // // notice, this list of conditions and the following disclaimer. // // *       Redistributions in binary form must reproduce the above // // copyright notice, this list of conditions and the following disclaimer // // in the documentation and/or other materials provided with the // // distribution. // // *       Neither the name of Industrial Light & Magic nor the names of // // its contributors may be used to endorse or promote products derived // // from this software without specific prior written permission. // // // // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS // // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT // // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR // // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT // // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT // // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, // // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY // // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT // // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE // // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // // // ///////////////////////////////////////////////////////////////////////////  // // End of OpenEXR license -------------------------------------------------  class EXRLoader extends DataTextureLoader {   constructor( manager ) {    super( manager );    this.type = HalfFloatType;   }   parse( buffer ) {    const USHORT_RANGE = ( 1 << 16 );   const BITMAP_SIZE = ( USHORT_RANGE >> 3 );    const HUF_ENCBITS = 16; // literal (value) bit length   const HUF_DECBITS = 14; // decoding bit size (>= 8)    const HUF_ENCSIZE = ( 1 << HUF_ENCBITS ) + 1; // encoding table size   const HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size   const HUF_DECMASK = HUF_DECSIZE - 1;    const NBITS = 16;   const A_OFFSET = 1 << ( NBITS - 1 );   const MOD_MASK = ( 1 << NBITS ) - 1;    const SHORT_ZEROCODE_RUN = 59;   const LONG_ZEROCODE_RUN = 63;   const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;    const ULONG_SIZE = 8;   const FLOAT32_SIZE = 4;   const INT32_SIZE = 4;   const INT16_SIZE = 2;   const INT8_SIZE = 1;    const STATIC_HUFFMAN = 0;   const DEFLATE = 1;    const UNKNOWN = 0;   const LOSSY_DCT = 1;   const RLE = 2;    const logBase = Math.pow( 2.7182818, 2.2 );    function reverseLutFromBitmap( bitmap, lut ) {     let k = 0;     for ( let i = 0; i < USHORT_RANGE; ++ i ) {      if ( ( i == 0 ) || ( bitmap[ i >> 3 ] & ( 1 << ( i & 7 ) ) ) ) {       lut[ k ++ ] = i;      }     }     const n = k - 1;     while ( k < USHORT_RANGE ) lut[ k ++ ] = 0;     return n;    }    function hufClearDecTable( hdec ) {     for ( let i = 0; i < HUF_DECSIZE; i ++ ) {      hdec[ i ] = {};     hdec[ i ].len = 0;     hdec[ i ].lit = 0;     hdec[ i ].p = null;     }    }    const getBitsReturn = { l: 0, c: 0, lc: 0 };    function getBits( nBits, c, lc, uInt8Array, inOffset ) {     while ( lc < nBits ) {      c = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );     lc += 8;     }     lc -= nBits;     getBitsReturn.l = ( c >> lc ) & ( ( 1 << nBits ) - 1 );    getBitsReturn.c = c;    getBitsReturn.lc = lc;    }    const hufTableBuffer = new Array( 59 );    function hufCanonicalCodeTable( hcode ) {     for ( let i = 0; i <= 58; ++ i ) hufTableBuffer[ i ] = 0;    for ( let i = 0; i < HUF_ENCSIZE; ++ i ) hufTableBuffer[ hcode[ i ] ] += 1;     let c = 0;     for ( let i = 58; i > 0; -- i ) {      const nc = ( ( c + hufTableBuffer[ i ] ) >> 1 );     hufTableBuffer[ i ] = c;     c = nc;     }     for ( let i = 0; i < HUF_ENCSIZE; ++ i ) {      const l = hcode[ i ];     if ( l > 0 ) hcode[ i ] = l | ( hufTableBuffer[ l ] ++ << 6 );     }    }    function hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, hcode ) {     const p = inOffset;    let c = 0;    let lc = 0;     for ( ; im <= iM; im ++ ) {      if ( p.value - inOffset.value > ni ) return false;      getBits( 6, c, lc, uInt8Array, p );      const l = getBitsReturn.l;     c = getBitsReturn.c;     lc = getBitsReturn.lc;      hcode[ im ] = l;      if ( l == LONG_ZEROCODE_RUN ) {       if ( p.value - inOffset.value > ni ) {        throw new Error( 'Something wrong with hufUnpackEncTable' );       }       getBits( 8, c, lc, uInt8Array, p );       let zerun = getBitsReturn.l + SHORTEST_LONG_RUN;      c = getBitsReturn.c;      lc = getBitsReturn.lc;       if ( im + zerun > iM + 1 ) {        throw new Error( 'Something wrong with hufUnpackEncTable' );       }       while ( zerun -- ) hcode[ im ++ ] = 0;       im --;      } else if ( l >= SHORT_ZEROCODE_RUN ) {       let zerun = l - SHORT_ZEROCODE_RUN + 2;       if ( im + zerun > iM + 1 ) {        throw new Error( 'Something wrong with hufUnpackEncTable' );       }       while ( zerun -- ) hcode[ im ++ ] = 0;       im --;      }     }     hufCanonicalCodeTable( hcode );    }    function hufLength( code ) {     return code & 63;    }    function hufCode( code ) {     return code >> 6;    }    function hufBuildDecTable( hcode, im, iM, hdecod ) {     for ( ; im <= iM; im ++ ) {      const c = hufCode( hcode[ im ] );     const l = hufLength( hcode[ im ] );      if ( c >> l ) {       throw new Error( 'Invalid table entry' );      }      if ( l > HUF_DECBITS ) {       const pl = hdecod[ ( c >> ( l - HUF_DECBITS ) ) ];       if ( pl.len ) {        throw new Error( 'Invalid table entry' );       }       pl.lit ++;       if ( pl.p ) {        const p = pl.p;       pl.p = new Array( pl.lit );        for ( let i = 0; i < pl.lit - 1; ++ i ) {         pl.p[ i ] = p[ i ];        }       } else {        pl.p = new Array( 1 );       }       pl.p[ pl.lit - 1 ] = im;      } else if ( l ) {       let plOffset = 0;       for ( let i = 1 << ( HUF_DECBITS - l ); i > 0; i -- ) {        const pl = hdecod[ ( c << ( HUF_DECBITS - l ) ) + plOffset ];        if ( pl.len || pl.p ) {         throw new Error( 'Invalid table entry' );        }        pl.len = l;       pl.lit = im;        plOffset ++;       }      }     }     return true;    }    const getCharReturn = { c: 0, lc: 0 };    function getChar( c, lc, uInt8Array, inOffset ) {     c = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );    lc += 8;     getCharReturn.c = c;    getCharReturn.lc = lc;    }    const getCodeReturn = { c: 0, lc: 0 };    function getCode( po, rlc, c, lc, uInt8Array, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) {     if ( po == rlc ) {      if ( lc < 8 ) {       getChar( c, lc, uInt8Array, inOffset );      c = getCharReturn.c;      lc = getCharReturn.lc;      }      lc -= 8;      let cs = ( c >> lc );     cs = new Uint8Array( [ cs ] )[ 0 ];      if ( outBufferOffset.value + cs > outBufferEndOffset ) {       return false;      }      const s = outBuffer[ outBufferOffset.value - 1 ];      while ( cs -- > 0 ) {       outBuffer[ outBufferOffset.value ++ ] = s;      }     } else if ( outBufferOffset.value < outBufferEndOffset ) {      outBuffer[ outBufferOffset.value ++ ] = po;     } else {      return false;     }     getCodeReturn.c = c;    getCodeReturn.lc = lc;    }    function UInt16( value ) {     return ( value & 0xFFFF );    }    function Int16( value ) {     const ref = UInt16( value );    return ( ref > 0x7FFF ) ? ref - 0x10000 : ref;    }    const wdec14Return = { a: 0, b: 0 };    function wdec14( l, h ) {     const ls = Int16( l );    const hs = Int16( h );     const hi = hs;    const ai = ls + ( hi & 1 ) + ( hi >> 1 );     const as = ai;    const bs = ai - hi;     wdec14Return.a = as;    wdec14Return.b = bs;    }    function wdec16( l, h ) {     const m = UInt16( l );    const d = UInt16( h );     const bb = ( m - ( d >> 1 ) ) & MOD_MASK;    const aa = ( d + bb - A_OFFSET ) & MOD_MASK;     wdec14Return.a = aa;    wdec14Return.b = bb;    }    function wav2Decode( buffer, j, nx, ox, ny, oy, mx ) {     const w14 = mx < ( 1 << 14 );    const n = ( nx > ny ) ? ny : nx;    let p = 1;    let p2;    let py;     while ( p <= n ) p <<= 1;     p >>= 1;    p2 = p;    p >>= 1;     while ( p >= 1 ) {      py = 0;     const ey = py + oy * ( ny - p2 );     const oy1 = oy * p;     const oy2 = oy * p2;     const ox1 = ox * p;     const ox2 = ox * p2;     let i00, i01, i10, i11;      for ( ; py <= ey; py += oy2 ) {       let px = py;      const ex = py + ox * ( nx - p2 );       for ( ; px <= ex; px += ox2 ) {        const p01 = px + ox1;       const p10 = px + oy1;       const p11 = p10 + ox1;        if ( w14 ) {         wdec14( buffer[ px + j ], buffer[ p10 + j ] );         i00 = wdec14Return.a;        i10 = wdec14Return.b;         wdec14( buffer[ p01 + j ], buffer[ p11 + j ] );         i01 = wdec14Return.a;        i11 = wdec14Return.b;         wdec14( i00, i01 );         buffer[ px + j ] = wdec14Return.a;        buffer[ p01 + j ] = wdec14Return.b;         wdec14( i10, i11 );         buffer[ p10 + j ] = wdec14Return.a;        buffer[ p11 + j ] = wdec14Return.b;        } else {         wdec16( buffer[ px + j ], buffer[ p10 + j ] );         i00 = wdec14Return.a;        i10 = wdec14Return.b;         wdec16( buffer[ p01 + j ], buffer[ p11 + j ] );         i01 = wdec14Return.a;        i11 = wdec14Return.b;         wdec16( i00, i01 );         buffer[ px + j ] = wdec14Return.a;        buffer[ p01 + j ] = wdec14Return.b;         wdec16( i10, i11 );         buffer[ p10 + j ] = wdec14Return.a;        buffer[ p11 + j ] = wdec14Return.b;         }       }       if ( nx & p ) {        const p10 = px + oy1;        if ( w14 )        wdec14( buffer[ px + j ], buffer[ p10 + j ] );       else        wdec16( buffer[ px + j ], buffer[ p10 + j ] );        i00 = wdec14Return.a;       buffer[ p10 + j ] = wdec14Return.b;        buffer[ px + j ] = i00;       }      }      if ( ny & p ) {       let px = py;      const ex = py + ox * ( nx - p2 );       for ( ; px <= ex; px += ox2 ) {        const p01 = px + ox1;        if ( w14 )        wdec14( buffer[ px + j ], buffer[ p01 + j ] );       else        wdec16( buffer[ px + j ], buffer[ p01 + j ] );        i00 = wdec14Return.a;       buffer[ p01 + j ] = wdec14Return.b;        buffer[ px + j ] = i00;       }      }      p2 = p;     p >>= 1;     }     return py;    }    function hufDecode( encodingTable, decodingTable, uInt8Array, inOffset, ni, rlc, no, outBuffer, outOffset ) {     let c = 0;    let lc = 0;    const outBufferEndOffset = no;    const inOffsetEnd = Math.trunc( inOffset.value + ( ni + 7 ) / 8 );     while ( inOffset.value < inOffsetEnd ) {      getChar( c, lc, uInt8Array, inOffset );      c = getCharReturn.c;     lc = getCharReturn.lc;      while ( lc >= HUF_DECBITS ) {       const index = ( c >> ( lc - HUF_DECBITS ) ) & HUF_DECMASK;      const pl = decodingTable[ index ];       if ( pl.len ) {        lc -= pl.len;        getCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );        c = getCodeReturn.c;       lc = getCodeReturn.lc;       } else {        if ( ! pl.p ) {         throw new Error( 'hufDecode issues' );        }        let j;        for ( j = 0; j < pl.lit; j ++ ) {         const l = hufLength( encodingTable[ pl.p[ j ] ] );         while ( lc < l && inOffset.value < inOffsetEnd ) {          getChar( c, lc, uInt8Array, inOffset );          c = getCharReturn.c;         lc = getCharReturn.lc;         }         if ( lc >= l ) {          if ( hufCode( encodingTable[ pl.p[ j ] ] ) == ( ( c >> ( lc - l ) ) & ( ( 1 << l ) - 1 ) ) ) {           lc -= l;           getCode( pl.p[ j ], rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );           c = getCodeReturn.c;          lc = getCodeReturn.lc;           break;          }         }        }        if ( j == pl.lit ) {         throw new Error( 'hufDecode issues' );        }       }      }     }     const i = ( 8 - ni ) & 7;     c >>= i;    lc -= i;     while ( lc > 0 ) {      const pl = decodingTable[ ( c << ( HUF_DECBITS - lc ) ) & HUF_DECMASK ];      if ( pl.len ) {       lc -= pl.len;       getCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );       c = getCodeReturn.c;      lc = getCodeReturn.lc;      } else {       throw new Error( 'hufDecode issues' );      }     }     return true;    }    function hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw ) {     const outOffset = { value: 0 };    const initialInOffset = inOffset.value;     const im = parseUint32( inDataView, inOffset );    const iM = parseUint32( inDataView, inOffset );     inOffset.value += 4;     const nBits = parseUint32( inDataView, inOffset );     inOffset.value += 4;     if ( im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE ) {      throw new Error( 'Something wrong with HUF_ENCSIZE' );     }     const freq = new Array( HUF_ENCSIZE );    const hdec = new Array( HUF_DECSIZE );     hufClearDecTable( hdec );     const ni = nCompressed - ( inOffset.value - initialInOffset );     hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, freq );     if ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) {      throw new Error( 'Something wrong with hufUncompress' );     }     hufBuildDecTable( freq, im, iM, hdec );     hufDecode( freq, hdec, uInt8Array, inOffset, nBits, iM, nRaw, outBuffer, outOffset );    }    function applyLut( lut, data, nData ) {     for ( let i = 0; i < nData; ++ i ) {      data[ i ] = lut[ data[ i ] ];     }    }    function predictor( source ) {     for ( let t = 1; t < source.length; t ++ ) {      const d = source[ t - 1 ] + source[ t ] - 128;     source[ t ] = d;     }    }    function interleaveScalar( source, out ) {     let t1 = 0;    let t2 = Math.floor( ( source.length + 1 ) / 2 );    let s = 0;    const stop = source.length - 1;     while ( true ) {      if ( s > stop ) break;     out[ s ++ ] = source[ t1 ++ ];      if ( s > stop ) break;     out[ s ++ ] = source[ t2 ++ ];     }    }    function decodeRunLength( source ) {     let size = source.byteLength;    const out = new Array();    let p = 0;     const reader = new DataView( source );     while ( size > 0 ) {      const l = reader.getInt8( p ++ );      if ( l < 0 ) {       const count = - l;      size -= count + 1;       for ( let i = 0; i < count; i ++ ) {        out.push( reader.getUint8( p ++ ) );       }       } else {       const count = l;      size -= 2;       const value = reader.getUint8( p ++ );       for ( let i = 0; i < count + 1; i ++ ) {        out.push( value );       }      }     }     return out;    }    function lossyDctDecode( cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer ) {     let dataView = new DataView( outBuffer.buffer );     const width = channelData[ cscSet.idx[ 0 ] ].width;    const height = channelData[ cscSet.idx[ 0 ] ].height;     const numComp = 3;     const numFullBlocksX = Math.floor( width / 8.0 );    const numBlocksX = Math.ceil( width / 8.0 );    const numBlocksY = Math.ceil( height / 8.0 );    const leftoverX = width - ( numBlocksX - 1 ) * 8;    const leftoverY = height - ( numBlocksY - 1 ) * 8;     const currAcComp = { value: 0 };    const currDcComp = new Array( numComp );    const dctData = new Array( numComp );    const halfZigBlock = new Array( numComp );    const rowBlock = new Array( numComp );    const rowOffsets = new Array( numComp );     for ( let comp = 0; comp < numComp; ++ comp ) {      rowOffsets[ comp ] = rowPtrs[ cscSet.idx[ comp ] ];     currDcComp[ comp ] = ( comp < 1 ) ? 0 : currDcComp[ comp - 1 ] + numBlocksX * numBlocksY;     dctData[ comp ] = new Float32Array( 64 );     halfZigBlock[ comp ] = new Uint16Array( 64 );     rowBlock[ comp ] = new Uint16Array( numBlocksX * 64 );     }     for ( let blocky = 0; blocky < numBlocksY; ++ blocky ) {      let maxY = 8;      if ( blocky == numBlocksY - 1 )      maxY = leftoverY;      let maxX = 8;      for ( let blockx = 0; blockx < numBlocksX; ++ blockx ) {       if ( blockx == numBlocksX - 1 )       maxX = leftoverX;       for ( let comp = 0; comp < numComp; ++ comp ) {        halfZigBlock[ comp ].fill( 0 );        // set block DC component       halfZigBlock[ comp ][ 0 ] = dcBuffer[ currDcComp[ comp ] ++ ];       // set block AC components       unRleAC( currAcComp, acBuffer, halfZigBlock[ comp ] );        // UnZigZag block to float       unZigZag( halfZigBlock[ comp ], dctData[ comp ] );       // decode float dct       dctInverse( dctData[ comp ] );       }       if ( numComp == 3 ) {        csc709Inverse( dctData );       }       for ( let comp = 0; comp < numComp; ++ comp ) {        convertToHalf( dctData[ comp ], rowBlock[ comp ], blockx * 64 );       }      } // blockx      let offset = 0;      for ( let comp = 0; comp < numComp; ++ comp ) {       const type = channelData[ cscSet.idx[ comp ] ].type;       for ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {        offset = rowOffsets[ comp ][ y ];        for ( let blockx = 0; blockx < numFullBlocksX; ++ blockx ) {         const src = blockx * 64 + ( ( y & 0x7 ) * 8 );         dataView.setUint16( offset + 0 * INT16_SIZE * type, rowBlock[ comp ][ src + 0 ], true );        dataView.setUint16( offset + 1 * INT16_SIZE * type, rowBlock[ comp ][ src + 1 ], true );        dataView.setUint16( offset + 2 * INT16_SIZE * type, rowBlock[ comp ][ src + 2 ], true );        dataView.setUint16( offset + 3 * INT16_SIZE * type, rowBlock[ comp ][ src + 3 ], true );         dataView.setUint16( offset + 4 * INT16_SIZE * type, rowBlock[ comp ][ src + 4 ], true );        dataView.setUint16( offset + 5 * INT16_SIZE * type, rowBlock[ comp ][ src + 5 ], true );        dataView.setUint16( offset + 6 * INT16_SIZE * type, rowBlock[ comp ][ src + 6 ], true );        dataView.setUint16( offset + 7 * INT16_SIZE * type, rowBlock[ comp ][ src + 7 ], true );         offset += 8 * INT16_SIZE * type;        }       }       // handle partial X blocks      if ( numFullBlocksX != numBlocksX ) {        for ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {         const offset = rowOffsets[ comp ][ y ] + 8 * numFullBlocksX * INT16_SIZE * type;        const src = numFullBlocksX * 64 + ( ( y & 0x7 ) * 8 );         for ( let x = 0; x < maxX; ++ x ) {          dataView.setUint16( offset + x * INT16_SIZE * type, rowBlock[ comp ][ src + x ], true );         }        }       }      } // comp     } // blocky     const halfRow = new Uint16Array( width );    dataView = new DataView( outBuffer.buffer );     // convert channels back to float, if needed    for ( let comp = 0; comp < numComp; ++ comp ) {      channelData[ cscSet.idx[ comp ] ].decoded = true;     const type = channelData[ cscSet.idx[ comp ] ].type;      if ( channelData[ comp ].type != 2 ) continue;      for ( let y = 0; y < height; ++ y ) {       const offset = rowOffsets[ comp ][ y ];       for ( let x = 0; x < width; ++ x ) {        halfRow[ x ] = dataView.getUint16( offset + x * INT16_SIZE * type, true );       }       for ( let x = 0; x < width; ++ x ) {        dataView.setFloat32( offset + x * INT16_SIZE * type, decodeFloat16( halfRow[ x ] ), true );       }      }     }    }    function unRleAC( currAcComp, acBuffer, halfZigBlock ) {     let acValue;    let dctComp = 1;     while ( dctComp < 64 ) {      acValue = acBuffer[ currAcComp.value ];      if ( acValue == 0xff00 ) {       dctComp = 64;      } else if ( acValue >> 8 == 0xff ) {       dctComp += acValue & 0xff;      } else {       halfZigBlock[ dctComp ] = acValue;      dctComp ++;      }      currAcComp.value ++;     }    }    function unZigZag( src, dst ) {     dst[ 0 ] = decodeFloat16( src[ 0 ] );    dst[ 1 ] = decodeFloat16( src[ 1 ] );    dst[ 2 ] = decodeFloat16( src[ 5 ] );    dst[ 3 ] = decodeFloat16( src[ 6 ] );    dst[ 4 ] = decodeFloat16( src[ 14 ] );    dst[ 5 ] = decodeFloat16( src[ 15 ] );    dst[ 6 ] = decodeFloat16( src[ 27 ] );    dst[ 7 ] = decodeFloat16( src[ 28 ] );    dst[ 8 ] = decodeFloat16( src[ 2 ] );    dst[ 9 ] = decodeFloat16( src[ 4 ] );     dst[ 10 ] = decodeFloat16( src[ 7 ] );    dst[ 11 ] = decodeFloat16( src[ 13 ] );    dst[ 12 ] = decodeFloat16( src[ 16 ] );    dst[ 13 ] = decodeFloat16( src[ 26 ] );    dst[ 14 ] = decodeFloat16( src[ 29 ] );    dst[ 15 ] = decodeFloat16( src[ 42 ] );    dst[ 16 ] = decodeFloat16( src[ 3 ] );    dst[ 17 ] = decodeFloat16( src[ 8 ] );    dst[ 18 ] = decodeFloat16( src[ 12 ] );    dst[ 19 ] = decodeFloat16( src[ 17 ] );     dst[ 20 ] = decodeFloat16( src[ 25 ] );    dst[ 21 ] = decodeFloat16( src[ 30 ] );    dst[ 22 ] = decodeFloat16( src[ 41 ] );    dst[ 23 ] = decodeFloat16( src[ 43 ] );    dst[ 24 ] = decodeFloat16( src[ 9 ] );    dst[ 25 ] = decodeFloat16( src[ 11 ] );    dst[ 26 ] = decodeFloat16( src[ 18 ] );    dst[ 27 ] = decodeFloat16( src[ 24 ] );    dst[ 28 ] = decodeFloat16( src[ 31 ] );    dst[ 29 ] = decodeFloat16( src[ 40 ] );     dst[ 30 ] = decodeFloat16( src[ 44 ] );    dst[ 31 ] = decodeFloat16( src[ 53 ] );    dst[ 32 ] = decodeFloat16( src[ 10 ] );    dst[ 33 ] = decodeFloat16( src[ 19 ] );    dst[ 34 ] = decodeFloat16( src[ 23 ] );    dst[ 35 ] = decodeFloat16( src[ 32 ] );    dst[ 36 ] = decodeFloat16( src[ 39 ] );    dst[ 37 ] = decodeFloat16( src[ 45 ] );    dst[ 38 ] = decodeFloat16( src[ 52 ] );    dst[ 39 ] = decodeFloat16( src[ 54 ] );     dst[ 40 ] = decodeFloat16( src[ 20 ] );    dst[ 41 ] = decodeFloat16( src[ 22 ] );    dst[ 42 ] = decodeFloat16( src[ 33 ] );    dst[ 43 ] = decodeFloat16( src[ 38 ] );    dst[ 44 ] = decodeFloat16( src[ 46 ] );    dst[ 45 ] = decodeFloat16( src[ 51 ] );    dst[ 46 ] = decodeFloat16( src[ 55 ] );    dst[ 47 ] = decodeFloat16( src[ 60 ] );    dst[ 48 ] = decodeFloat16( src[ 21 ] );    dst[ 49 ] = decodeFloat16( src[ 34 ] );     dst[ 50 ] = decodeFloat16( src[ 37 ] );    dst[ 51 ] = decodeFloat16( src[ 47 ] );    dst[ 52 ] = decodeFloat16( src[ 50 ] );    dst[ 53 ] = decodeFloat16( src[ 56 ] );    dst[ 54 ] = decodeFloat16( src[ 59 ] );    dst[ 55 ] = decodeFloat16( src[ 61 ] );    dst[ 56 ] = decodeFloat16( src[ 35 ] );    dst[ 57 ] = decodeFloat16( src[ 36 ] );    dst[ 58 ] = decodeFloat16( src[ 48 ] );    dst[ 59 ] = decodeFloat16( src[ 49 ] );     dst[ 60 ] = decodeFloat16( src[ 57 ] );    dst[ 61 ] = decodeFloat16( src[ 58 ] );    dst[ 62 ] = decodeFloat16( src[ 62 ] );    dst[ 63 ] = decodeFloat16( src[ 63 ] );    }    function dctInverse( data ) {     const a = 0.5 * Math.cos( 3.14159 / 4.0 );    const b = 0.5 * Math.cos( 3.14159 / 16.0 );    const c = 0.5 * Math.cos( 3.14159 / 8.0 );    const d = 0.5 * Math.cos( 3.0 * 3.14159 / 16.0 );    const e = 0.5 * Math.cos( 5.0 * 3.14159 / 16.0 );    const f = 0.5 * Math.cos( 3.0 * 3.14159 / 8.0 );    const g = 0.5 * Math.cos( 7.0 * 3.14159 / 16.0 );     const alpha = new Array( 4 );    const beta = new Array( 4 );    const theta = new Array( 4 );    const gamma = new Array( 4 );     for ( let row = 0; row < 8; ++ row ) {      const rowPtr = row * 8;      alpha[ 0 ] = c * data[ rowPtr + 2 ];     alpha[ 1 ] = f * data[ rowPtr + 2 ];     alpha[ 2 ] = c * data[ rowPtr + 6 ];     alpha[ 3 ] = f * data[ rowPtr + 6 ];      beta[ 0 ] = b * data[ rowPtr + 1 ] + d * data[ rowPtr + 3 ] + e * data[ rowPtr + 5 ] + g * data[ rowPtr + 7 ];     beta[ 1 ] = d * data[ rowPtr + 1 ] - g * data[ rowPtr + 3 ] - b * data[ rowPtr + 5 ] - e * data[ rowPtr + 7 ];     beta[ 2 ] = e * data[ rowPtr + 1 ] - b * data[ rowPtr + 3 ] + g * data[ rowPtr + 5 ] + d * data[ rowPtr + 7 ];     beta[ 3 ] = g * data[ rowPtr + 1 ] - e * data[ rowPtr + 3 ] + d * data[ rowPtr + 5 ] - b * data[ rowPtr + 7 ];      theta[ 0 ] = a * ( data[ rowPtr + 0 ] + data[ rowPtr + 4 ] );     theta[ 3 ] = a * ( data[ rowPtr + 0 ] - data[ rowPtr + 4 ] );     theta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];     theta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];      gamma[ 0 ] = theta[ 0 ] + theta[ 1 ];     gamma[ 1 ] = theta[ 3 ] + theta[ 2 ];     gamma[ 2 ] = theta[ 3 ] - theta[ 2 ];     gamma[ 3 ] = theta[ 0 ] - theta[ 1 ];      data[ rowPtr + 0 ] = gamma[ 0 ] + beta[ 0 ];     data[ rowPtr + 1 ] = gamma[ 1 ] + beta[ 1 ];     data[ rowPtr + 2 ] = gamma[ 2 ] + beta[ 2 ];     data[ rowPtr + 3 ] = gamma[ 3 ] + beta[ 3 ];      data[ rowPtr + 4 ] = gamma[ 3 ] - beta[ 3 ];     data[ rowPtr + 5 ] = gamma[ 2 ] - beta[ 2 ];     data[ rowPtr + 6 ] = gamma[ 1 ] - beta[ 1 ];     data[ rowPtr + 7 ] = gamma[ 0 ] - beta[ 0 ];     }     for ( let column = 0; column < 8; ++ column ) {      alpha[ 0 ] = c * data[ 16 + column ];     alpha[ 1 ] = f * data[ 16 + column ];     alpha[ 2 ] = c * data[ 48 + column ];     alpha[ 3 ] = f * data[ 48 + column ];      beta[ 0 ] = b * data[ 8 + column ] + d * data[ 24 + column ] + e * data[ 40 + column ] + g * data[ 56 + column ];     beta[ 1 ] = d * data[ 8 + column ] - g * data[ 24 + column ] - b * data[ 40 + column ] - e * data[ 56 + column ];     beta[ 2 ] = e * data[ 8 + column ] - b * data[ 24 + column ] + g * data[ 40 + column ] + d * data[ 56 + column ];     beta[ 3 ] = g * data[ 8 + column ] - e * data[ 24 + column ] + d * data[ 40 + column ] - b * data[ 56 + column ];      theta[ 0 ] = a * ( data[ column ] + data[ 32 + column ] );     theta[ 3 ] = a * ( data[ column ] - data[ 32 + column ] );      theta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];     theta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];      gamma[ 0 ] = theta[ 0 ] + theta[ 1 ];     gamma[ 1 ] = theta[ 3 ] + theta[ 2 ];     gamma[ 2 ] = theta[ 3 ] - theta[ 2 ];     gamma[ 3 ] = theta[ 0 ] - theta[ 1 ];      data[ 0 + column ] = gamma[ 0 ] + beta[ 0 ];     data[ 8 + column ] = gamma[ 1 ] + beta[ 1 ];     data[ 16 + column ] = gamma[ 2 ] + beta[ 2 ];     data[ 24 + column ] = gamma[ 3 ] + beta[ 3 ];      data[ 32 + column ] = gamma[ 3 ] - beta[ 3 ];     data[ 40 + column ] = gamma[ 2 ] - beta[ 2 ];     data[ 48 + column ] = gamma[ 1 ] - beta[ 1 ];     data[ 56 + column ] = gamma[ 0 ] - beta[ 0 ];     }    }    function csc709Inverse( data ) {     for ( let i = 0; i < 64; ++ i ) {      const y = data[ 0 ][ i ];     const cb = data[ 1 ][ i ];     const cr = data[ 2 ][ i ];      data[ 0 ][ i ] = y + 1.5747 * cr;     data[ 1 ][ i ] = y - 0.1873 * cb - 0.4682 * cr;     data[ 2 ][ i ] = y + 1.8556 * cb;     }    }    function convertToHalf( src, dst, idx ) {     for ( let i = 0; i < 64; ++ i ) {      dst[ idx + i ] = DataUtils.toHalfFloat( toLinear( src[ i ] ) );     }    }    function toLinear( float ) {     if ( float <= 1 ) {      return Math.sign( float ) * Math.pow( Math.abs( float ), 2.2 );     } else {      return Math.sign( float ) * Math.pow( logBase, Math.abs( float ) - 1.0 );     }    }    function uncompressRAW( info ) {     return new DataView( info.array.buffer, info.offset.value, info.size );    }    function uncompressRLE( info ) {     const compressed = info.viewer.buffer.slice( info.offset.value, info.offset.value + info.size );     const rawBuffer = new Uint8Array( decodeRunLength( compressed ) );    const tmpBuffer = new Uint8Array( rawBuffer.length );     predictor( rawBuffer ); // revert predictor     interleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels     return new DataView( tmpBuffer.buffer );    }    function uncompressZIP( info ) {     const compressed = info.array.slice( info.offset.value, info.offset.value + info.size );     const rawBuffer = fflate.unzlibSync( compressed );    const tmpBuffer = new Uint8Array( rawBuffer.length );     predictor( rawBuffer ); // revert predictor     interleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels     return new DataView( tmpBuffer.buffer );    }    function uncompressPIZ( info ) {     const inDataView = info.viewer;    const inOffset = { value: info.offset.value };     const outBuffer = new Uint16Array( info.columns * info.lines * ( info.inputChannels.length * info.type ) );    const bitmap = new Uint8Array( BITMAP_SIZE );     // Setup channel info    let outBufferEnd = 0;    const pizChannelData = new Array( info.inputChannels.length );    for ( let i = 0, il = info.inputChannels.length; i < il; i ++ ) {      pizChannelData[ i ] = {};     pizChannelData[ i ][ 'start' ] = outBufferEnd;     pizChannelData[ i ][ 'end' ] = pizChannelData[ i ][ 'start' ];     pizChannelData[ i ][ 'nx' ] = info.columns;     pizChannelData[ i ][ 'ny' ] = info.lines;     pizChannelData[ i ][ 'size' ] = info.type;      outBufferEnd += pizChannelData[ i ].nx * pizChannelData[ i ].ny * pizChannelData[ i ].size;     }     // Read range compression data     const minNonZero = parseUint16( inDataView, inOffset );    const maxNonZero = parseUint16( inDataView, inOffset );     if ( maxNonZero >= BITMAP_SIZE ) {      throw new Error( 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE' );     }     if ( minNonZero <= maxNonZero ) {      for ( let i = 0; i < maxNonZero - minNonZero + 1; i ++ ) {       bitmap[ i + minNonZero ] = parseUint8( inDataView, inOffset );      }     }     // Reverse LUT    const lut = new Uint16Array( USHORT_RANGE );    const maxValue = reverseLutFromBitmap( bitmap, lut );     const length = parseUint32( inDataView, inOffset );     // Huffman decoding    hufUncompress( info.array, inDataView, inOffset, length, outBuffer, outBufferEnd );     // Wavelet decoding    for ( let i = 0; i < info.inputChannels.length; ++ i ) {      const cd = pizChannelData[ i ];      for ( let j = 0; j < pizChannelData[ i ].size; ++ j ) {       wav2Decode(       outBuffer,       cd.start + j,       cd.nx,       cd.size,       cd.ny,       cd.nx * cd.size,       maxValue      );      }     }     // Expand the pixel data to their original range    applyLut( lut, outBuffer, outBufferEnd );     // Rearrange the pixel data into the format expected by the caller.    let tmpOffset = 0;    const tmpBuffer = new Uint8Array( outBuffer.buffer.byteLength );    for ( let y = 0; y < info.lines; y ++ ) {      for ( let c = 0; c < info.inputChannels.length; c ++ ) {       const cd = pizChannelData[ c ];       const n = cd.nx * cd.size;      const cp = new Uint8Array( outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE );       tmpBuffer.set( cp, tmpOffset );      tmpOffset += n * INT16_SIZE;      cd.end += n;      }     }     return new DataView( tmpBuffer.buffer );    }    function uncompressPXR( info ) {     const compressed = info.array.slice( info.offset.value, info.offset.value + info.size );     const rawBuffer = fflate.unzlibSync( compressed );     const byteSize = info.inputChannels.length * info.lines * info.columns * info.totalBytes;    const tmpBuffer = new ArrayBuffer( byteSize );    const viewer = new DataView( tmpBuffer );     let tmpBufferEnd = 0;    let writePtr = 0;    const ptr = new Array( 4 );     for ( let y = 0; y < info.lines; y ++ ) {      for ( let c = 0; c < info.inputChannels.length; c ++ ) {       let pixel = 0;       const type = info.inputChannels[ c ].pixelType;      switch ( type ) {        case 1:         ptr[ 0 ] = tmpBufferEnd;        ptr[ 1 ] = ptr[ 0 ] + info.columns;        tmpBufferEnd = ptr[ 1 ] + info.columns;         for ( let j = 0; j < info.columns; ++ j ) {          const diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 8 ) | rawBuffer[ ptr[ 1 ] ++ ];          pixel += diff;          viewer.setUint16( writePtr, pixel, true );         writePtr += 2;         }         break;        case 2:         ptr[ 0 ] = tmpBufferEnd;        ptr[ 1 ] = ptr[ 0 ] + info.columns;        ptr[ 2 ] = ptr[ 1 ] + info.columns;        tmpBufferEnd = ptr[ 2 ] + info.columns;         for ( let j = 0; j < info.columns; ++ j ) {          const diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 24 ) | ( rawBuffer[ ptr[ 1 ] ++ ] << 16 ) | ( rawBuffer[ ptr[ 2 ] ++ ] << 8 );          pixel += diff;          viewer.setUint32( writePtr, pixel, true );         writePtr += 4;         }         break;       }      }     }     return viewer;    }    function uncompressDWA( info ) {     const inDataView = info.viewer;    const inOffset = { value: info.offset.value };    const outBuffer = new Uint8Array( info.columns * info.lines * ( info.inputChannels.length * info.type * INT16_SIZE ) );     // Read compression header information    const dwaHeader = {      version: parseInt64( inDataView, inOffset ),     unknownUncompressedSize: parseInt64( inDataView, inOffset ),     unknownCompressedSize: parseInt64( inDataView, inOffset ),     acCompressedSize: parseInt64( inDataView, inOffset ),     dcCompressedSize: parseInt64( inDataView, inOffset ),     rleCompressedSize: parseInt64( inDataView, inOffset ),     rleUncompressedSize: parseInt64( inDataView, inOffset ),     rleRawSize: parseInt64( inDataView, inOffset ),     totalAcUncompressedCount: parseInt64( inDataView, inOffset ),     totalDcUncompressedCount: parseInt64( inDataView, inOffset ),     acCompression: parseInt64( inDataView, inOffset )     };     if ( dwaHeader.version < 2 )     throw new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported' );     // Read channel ruleset information    const channelRules = new Array();    let ruleSize = parseUint16( inDataView, inOffset ) - INT16_SIZE;     while ( ruleSize > 0 ) {      const name = parseNullTerminatedString( inDataView.buffer, inOffset );     const value = parseUint8( inDataView, inOffset );     const compression = ( value >> 2 ) & 3;     const csc = ( value >> 4 ) - 1;     const index = new Int8Array( [ csc ] )[ 0 ];     const type = parseUint8( inDataView, inOffset );      channelRules.push( {      name: name,      index: index,      type: type,      compression: compression,     } );      ruleSize -= name.length + 3;     }     // Classify channels    const channels = EXRHeader.channels;    const channelData = new Array( info.inputChannels.length );     for ( let i = 0; i < info.inputChannels.length; ++ i ) {      const cd = channelData[ i ] = {};     const channel = channels[ i ];      cd.name = channel.name;     cd.compression = UNKNOWN;     cd.decoded = false;     cd.type = channel.pixelType;     cd.pLinear = channel.pLinear;     cd.width = info.columns;     cd.height = info.lines;     }     const cscSet = {     idx: new Array( 3 )    };     for ( let offset = 0; offset < info.inputChannels.length; ++ offset ) {      const cd = channelData[ offset ];      for ( let i = 0; i < channelRules.length; ++ i ) {       const rule = channelRules[ i ];       if ( cd.name == rule.name ) {        cd.compression = rule.compression;        if ( rule.index >= 0 ) {         cscSet.idx[ rule.index ] = offset;        }        cd.offset = offset;       }      }     }     let acBuffer, dcBuffer, rleBuffer;     // Read DCT - AC component data    if ( dwaHeader.acCompressedSize > 0 ) {      switch ( dwaHeader.acCompression ) {       case STATIC_HUFFMAN:        acBuffer = new Uint16Array( dwaHeader.totalAcUncompressedCount );       hufUncompress( info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount );       break;       case DEFLATE:        const compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount );       const data = fflate.unzlibSync( compressed );       acBuffer = new Uint16Array( data.buffer );       inOffset.value += dwaHeader.totalAcUncompressedCount;       break;      }      }     // Read DCT - DC component data    if ( dwaHeader.dcCompressedSize > 0 ) {      const zlibInfo = {      array: info.array,      offset: inOffset,      size: dwaHeader.dcCompressedSize     };     dcBuffer = new Uint16Array( uncompressZIP( zlibInfo ).buffer );     inOffset.value += dwaHeader.dcCompressedSize;     }     // Read RLE compressed data    if ( dwaHeader.rleRawSize > 0 ) {      const compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.rleCompressedSize );     const data = fflate.unzlibSync( compressed );     rleBuffer = decodeRunLength( data.buffer );      inOffset.value += dwaHeader.rleCompressedSize;     }     // Prepare outbuffer data offset    let outBufferEnd = 0;    const rowOffsets = new Array( channelData.length );    for ( let i = 0; i < rowOffsets.length; ++ i ) {      rowOffsets[ i ] = new Array();     }     for ( let y = 0; y < info.lines; ++ y ) {      for ( let chan = 0; chan < channelData.length; ++ chan ) {       rowOffsets[ chan ].push( outBufferEnd );      outBufferEnd += channelData[ chan ].width * info.type * INT16_SIZE;      }     }     // Lossy DCT decode RGB channels    lossyDctDecode( cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer );     // Decode other channels    for ( let i = 0; i < channelData.length; ++ i ) {      const cd = channelData[ i ];      if ( cd.decoded ) continue;      switch ( cd.compression ) {       case RLE:        let row = 0;       let rleOffset = 0;        for ( let y = 0; y < info.lines; ++ y ) {         let rowOffsetBytes = rowOffsets[ i ][ row ];         for ( let x = 0; x < cd.width; ++ x ) {          for ( let byte = 0; byte < INT16_SIZE * cd.type; ++ byte ) {           outBuffer[ rowOffsetBytes ++ ] = rleBuffer[ rleOffset + byte * cd.width * cd.height ];          }          rleOffset ++;         }         row ++;        }        break;       case LOSSY_DCT: // skip       default:       throw new Error( 'EXRLoader.parse: unsupported channel compression' );      }     }     return new DataView( outBuffer.buffer );    }    function parseNullTerminatedString( buffer, offset ) {     const uintBuffer = new Uint8Array( buffer );    let endOffset = 0;     while ( uintBuffer[ offset.value + endOffset ] != 0 ) {      endOffset += 1;     }     const stringValue = new TextDecoder().decode(     uintBuffer.slice( offset.value, offset.value + endOffset )    );     offset.value = offset.value + endOffset + 1;     return stringValue;    }    function parseFixedLengthString( buffer, offset, size ) {     const stringValue = new TextDecoder().decode(     new Uint8Array( buffer ).slice( offset.value, offset.value + size )    );     offset.value = offset.value + size;     return stringValue;    }    function parseRational( dataView, offset ) {     const x = parseInt32( dataView, offset );    const y = parseUint32( dataView, offset );     return [ x, y ];    }    function parseTimecode( dataView, offset ) {     const x = parseUint32( dataView, offset );    const y = parseUint32( dataView, offset );     return [ x, y ];    }    function parseInt32( dataView, offset ) {     const Int32 = dataView.getInt32( offset.value, true );     offset.value = offset.value + INT32_SIZE;     return Int32;    }    function parseUint32( dataView, offset ) {     const Uint32 = dataView.getUint32( offset.value, true );     offset.value = offset.value + INT32_SIZE;     return Uint32;    }    function parseUint8Array( uInt8Array, offset ) {     const Uint8 = uInt8Array[ offset.value ];     offset.value = offset.value + INT8_SIZE;     return Uint8;    }    function parseUint8( dataView, offset ) {     const Uint8 = dataView.getUint8( offset.value );     offset.value = offset.value + INT8_SIZE;     return Uint8;    }    const parseInt64 = function ( dataView, offset ) {     let int;     if ( 'getBigInt64' in DataView.prototype ) {      int = Number( dataView.getBigInt64( offset.value, true ) );     } else {      int = dataView.getUint32( offset.value + 4, true ) + Number( dataView.getUint32( offset.value, true ) << 32 );     }     offset.value += ULONG_SIZE;     return int;    };    function parseFloat32( dataView, offset ) {     const float = dataView.getFloat32( offset.value, true );     offset.value += FLOAT32_SIZE;     return float;    }    function decodeFloat32( dataView, offset ) {     return DataUtils.toHalfFloat( parseFloat32( dataView, offset ) );    }    // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript   function decodeFloat16( binary ) {     const exponent = ( binary & 0x7C00 ) >> 10,     fraction = binary & 0x03FF;     return ( binary >> 15 ? - 1 : 1 ) * (     exponent ?      (       exponent === 0x1F ?        fraction ? NaN : Infinity :        Math.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )      ) :      6.103515625e-5 * ( fraction / 0x400 )    );    }    function parseUint16( dataView, offset ) {     const Uint16 = dataView.getUint16( offset.value, true );     offset.value += INT16_SIZE;     return Uint16;    }    function parseFloat16( buffer, offset ) {     return decodeFloat16( parseUint16( buffer, offset ) );    }    function parseChlist( dataView, buffer, offset, size ) {     const startOffset = offset.value;    const channels = [];     while ( offset.value < ( startOffset + size - 1 ) ) {      const name = parseNullTerminatedString( buffer, offset );     const pixelType = parseInt32( dataView, offset );     const pLinear = parseUint8( dataView, offset );     offset.value += 3; // reserved, three chars     const xSampling = parseInt32( dataView, offset );     const ySampling = parseInt32( dataView, offset );      channels.push( {      name: name,      pixelType: pixelType,      pLinear: pLinear,      xSampling: xSampling,      ySampling: ySampling     } );     }     offset.value += 1;     return channels;    }    function parseChromaticities( dataView, offset ) {     const redX = parseFloat32( dataView, offset );    const redY = parseFloat32( dataView, offset );    const greenX = parseFloat32( dataView, offset );    const greenY = parseFloat32( dataView, offset );    const blueX = parseFloat32( dataView, offset );    const blueY = parseFloat32( dataView, offset );    const whiteX = parseFloat32( dataView, offset );    const whiteY = parseFloat32( dataView, offset );     return { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };    }    function parseCompression( dataView, offset ) {     const compressionCodes = [     'NO_COMPRESSION',     'RLE_COMPRESSION',     'ZIPS_COMPRESSION',     'ZIP_COMPRESSION',     'PIZ_COMPRESSION',     'PXR24_COMPRESSION',     'B44_COMPRESSION',     'B44A_COMPRESSION',     'DWAA_COMPRESSION',     'DWAB_COMPRESSION'    ];     const compression = parseUint8( dataView, offset );     return compressionCodes[ compression ];    }    function parseBox2i( dataView, offset ) {     const xMin = parseInt32( dataView, offset );    const yMin = parseInt32( dataView, offset );    const xMax = parseInt32( dataView, offset );    const yMax = parseInt32( dataView, offset );     return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };    }    function parseLineOrder( dataView, offset ) {     const lineOrders = [     'INCREASING_Y',     'DECREASING_Y',     'RANDOM_Y',    ];     const lineOrder = parseUint8( dataView, offset );     return lineOrders[ lineOrder ];    }    function parseEnvmap( dataView, offset ) {     const envmaps = [     'ENVMAP_LATLONG',     'ENVMAP_CUBE'    ];     const envmap = parseUint8( dataView, offset );     return envmaps[ envmap ];    }    function parseTiledesc( dataView, offset ) {     const levelModes = [     'ONE_LEVEL',     'MIPMAP_LEVELS',     'RIPMAP_LEVELS',    ];     const roundingModes = [     'ROUND_DOWN',     'ROUND_UP',    ];     const xSize = parseUint32( dataView, offset );    const ySize = parseUint32( dataView, offset );    const modes = parseUint8( dataView, offset );     return {     xSize: xSize,     ySize: ySize,     levelMode: levelModes[ modes & 0xf ],     roundingMode: roundingModes[ modes >> 4 ]    };    }    function parseV2f( dataView, offset ) {     const x = parseFloat32( dataView, offset );    const y = parseFloat32( dataView, offset );     return [ x, y ];    }    function parseV3f( dataView, offset ) {     const x = parseFloat32( dataView, offset );    const y = parseFloat32( dataView, offset );    const z = parseFloat32( dataView, offset );     return [ x, y, z ];    }    function parseValue( dataView, buffer, offset, type, size ) {     if ( type === 'string' || type === 'stringvector' || type === 'iccProfile' ) {      return parseFixedLengthString( buffer, offset, size );     } else if ( type === 'chlist' ) {      return parseChlist( dataView, buffer, offset, size );     } else if ( type === 'chromaticities' ) {      return parseChromaticities( dataView, offset );     } else if ( type === 'compression' ) {      return parseCompression( dataView, offset );     } else if ( type === 'box2i' ) {      return parseBox2i( dataView, offset );     } else if ( type === 'envmap' ) {      return parseEnvmap( dataView, offset );     } else if ( type === 'tiledesc' ) {      return parseTiledesc( dataView, offset );     } else if ( type === 'lineOrder' ) {      return parseLineOrder( dataView, offset );     } else if ( type === 'float' ) {      return parseFloat32( dataView, offset );     } else if ( type === 'v2f' ) {      return parseV2f( dataView, offset );     } else if ( type === 'v3f' ) {      return parseV3f( dataView, offset );     } else if ( type === 'int' ) {      return parseInt32( dataView, offset );     } else if ( type === 'rational' ) {      return parseRational( dataView, offset );     } else if ( type === 'timecode' ) {      return parseTimecode( dataView, offset );     } else if ( type === 'preview' ) {      offset.value += size;     return 'skipped';     } else {      offset.value += size;     return undefined;     }    }    function roundLog2( x, mode ) {     const log2 = Math.log2( x );    return mode == 'ROUND_DOWN' ? Math.floor( log2 ) : Math.ceil( log2 );    }    function calculateTileLevels( tiledesc, w, h ) {     let num = 0;     switch ( tiledesc.levelMode ) {      case 'ONE_LEVEL':      num = 1;      break;      case 'MIPMAP_LEVELS':      num = roundLog2( Math.max( w, h ), tiledesc.roundingMode ) + 1;      break;      case 'RIPMAP_LEVELS':      throw new Error( 'THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.' );     }     return num;    }    function calculateTiles( count, dataSize, size, roundingMode ) {     const tiles = new Array( count );     for ( let i = 0; i < count; i ++ ) {      const b = ( 1 << i );     let s = ( dataSize / b ) | 0;      if ( roundingMode == 'ROUND_UP' && s * b < dataSize ) s += 1;      const l = Math.max( s, 1 );      tiles[ i ] = ( ( l + size - 1 ) / size ) | 0;     }     return tiles;    }    function parseTiles() {     const EXRDecoder = this;    const offset = EXRDecoder.offset;    const tmpOffset = { value: 0 };     for ( let tile = 0; tile < EXRDecoder.tileCount; tile ++ ) {      const tileX = parseInt32( EXRDecoder.viewer, offset );     const tileY = parseInt32( EXRDecoder.viewer, offset );     offset.value += 8; // skip levels - only parsing top-level     EXRDecoder.size = parseUint32( EXRDecoder.viewer, offset );      const startX = tileX * EXRDecoder.blockWidth;     const startY = tileY * EXRDecoder.blockHeight;     EXRDecoder.columns = ( startX + EXRDecoder.blockWidth > EXRDecoder.width ) ? EXRDecoder.width - startX : EXRDecoder.blockWidth;     EXRDecoder.lines = ( startY + EXRDecoder.blockHeight > EXRDecoder.height ) ? EXRDecoder.height - startY : EXRDecoder.blockHeight;      const bytesBlockLine = EXRDecoder.columns * EXRDecoder.totalBytes;     const isCompressed = EXRDecoder.size < EXRDecoder.lines * bytesBlockLine;     const viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );      offset.value += EXRDecoder.size;      for ( let line = 0; line < EXRDecoder.lines; line ++ ) {       const lineOffset = line * EXRDecoder.columns * EXRDecoder.totalBytes;       for ( let channelID = 0; channelID < EXRDecoder.inputChannels.length; channelID ++ ) {        const name = EXRHeader.channels[ channelID ].name;       const lOff = EXRDecoder.channelByteOffsets[ name ] * EXRDecoder.columns;       const cOff = EXRDecoder.decodeChannels[ name ];        if ( cOff === undefined ) continue;        tmpOffset.value = lineOffset + lOff;       const outLineOffset = ( EXRDecoder.height - ( 1 + startY + line ) ) * EXRDecoder.outLineWidth;        for ( let x = 0; x < EXRDecoder.columns; x ++ ) {         const outIndex = outLineOffset + ( x + startX ) * EXRDecoder.outputChannels + cOff;        EXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );        }       }      }     }    }    function parseScanline() {     const EXRDecoder = this;    const offset = EXRDecoder.offset;    const tmpOffset = { value: 0 };     for ( let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.blockHeight; scanlineBlockIdx ++ ) {      const line = parseInt32( EXRDecoder.viewer, offset ) - EXRHeader.dataWindow.yMin; // line_no     EXRDecoder.size = parseUint32( EXRDecoder.viewer, offset ); // data_len     EXRDecoder.lines = ( ( line + EXRDecoder.blockHeight > EXRDecoder.height ) ? ( EXRDecoder.height - line ) : EXRDecoder.blockHeight );      const bytesPerLine = EXRDecoder.columns * EXRDecoder.totalBytes;     const isCompressed = EXRDecoder.size < EXRDecoder.lines * bytesPerLine;     const viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );      offset.value += EXRDecoder.size;      for ( let line_y = 0; line_y < EXRDecoder.blockHeight; line_y ++ ) {       const scan_y = scanlineBlockIdx * EXRDecoder.blockHeight;      const true_y = line_y + EXRDecoder.scanOrder( scan_y );      if ( true_y >= EXRDecoder.height ) continue;       const lineOffset = line_y * bytesPerLine;      const outLineOffset = ( EXRDecoder.height - 1 - true_y ) * EXRDecoder.outLineWidth;       for ( let channelID = 0; channelID < EXRDecoder.inputChannels.length; channelID ++ ) {        const name = EXRHeader.channels[ channelID ].name;       const lOff = EXRDecoder.channelByteOffsets[ name ] * EXRDecoder.columns;       const cOff = EXRDecoder.decodeChannels[ name ];        if ( cOff === undefined ) continue;        tmpOffset.value = lineOffset + lOff;        for ( let x = 0; x < EXRDecoder.columns; x ++ ) {         const outIndex = outLineOffset + x * EXRDecoder.outputChannels + cOff;        EXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );        }       }      }     }    }    function parseHeader( dataView, buffer, offset ) {     const EXRHeader = {};     if ( dataView.getUint32( 0, true ) != 20000630 ) { // magic      throw new Error( 'THREE.EXRLoader: Provided file doesn|'t appear to be in OpenEXR format.' );     }     EXRHeader.version = dataView.getUint8( 4 );     const spec = dataView.getUint8( 5 ); // fullMask     EXRHeader.spec = {     singleTile: !! ( spec & 2 ),     longName: !! ( spec & 4 ),     deepFormat: !! ( spec & 8 ),     multiPart: !! ( spec & 16 ),    };     // start of header     offset.value = 8; // start at 8 - after pre-amble     let keepReading = true;     while ( keepReading ) {      const attributeName = parseNullTerminatedString( buffer, offset );      if ( attributeName == 0 ) {       keepReading = false;      } else {       const attributeType = parseNullTerminatedString( buffer, offset );      const attributeSize = parseUint32( dataView, offset );      const attributeValue = parseValue( dataView, buffer, offset, attributeType, attributeSize );       if ( attributeValue === undefined ) {        console.warn( |THREE.EXRLoader: Skipped unknown header attribute type |'|attributeType}|'.| );       } else {        EXRHeader[ attributeName ] = attributeValue;       }      }     }     if ( ( spec & ~ 0x06 ) != 0 ) { // unsupported deep-image, multi-part      console.error( 'THREE.EXRHeader:', EXRHeader );     throw new Error( 'THREE.EXRLoader: Provided file is currently unsupported.' );     }     return EXRHeader;    }    function setupDecoder( EXRHeader, dataView, uInt8Array, offset, outputType ) {     const EXRDecoder = {     size: 0,     viewer: dataView,     array: uInt8Array,     offset: offset,     width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,     height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,     inputChannels: EXRHeader.channels,     channelByteOffsets: {},     scanOrder: null,     totalBytes: null,     columns: null,     lines: null,     type: null,     uncompress: null,     getter: null,     format: null,     colorSpace: LinearSRGBColorSpace,    };     switch ( EXRHeader.compression ) {      case 'NO_COMPRESSION':      EXRDecoder.blockHeight = 1;      EXRDecoder.uncompress = uncompressRAW;      break;      case 'RLE_COMPRESSION':      EXRDecoder.blockHeight = 1;      EXRDecoder.uncompress = uncompressRLE;      break;      case 'ZIPS_COMPRESSION':      EXRDecoder.blockHeight = 1;      EXRDecoder.uncompress = uncompressZIP;      break;      case 'ZIP_COMPRESSION':      EXRDecoder.blockHeight = 16;      EXRDecoder.uncompress = uncompressZIP;      break;      case 'PIZ_COMPRESSION':      EXRDecoder.blockHeight = 32;      EXRDecoder.uncompress = uncompressPIZ;      break;      case 'PXR24_COMPRESSION':      EXRDecoder.blockHeight = 16;      EXRDecoder.uncompress = uncompressPXR;      break;      case 'DWAA_COMPRESSION':      EXRDecoder.blockHeight = 32;      EXRDecoder.uncompress = uncompressDWA;      break;      case 'DWAB_COMPRESSION':      EXRDecoder.blockHeight = 256;      EXRDecoder.uncompress = uncompressDWA;      break;      default:      throw new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported' );     }     const channels = {};    for ( const channel of EXRHeader.channels ) {      switch ( channel.name ) {       case 'Y':      case 'R':      case 'G':      case 'B':      case 'A':       channels[ channel.name ] = true;       EXRDecoder.type = channel.pixelType;      }     }     // RGB images will be converted to RGBA format, preventing software emulation in select devices.    let fillAlpha = false;     if ( channels.R && channels.G && channels.B ) {      fillAlpha = ! channels.A;     EXRDecoder.outputChannels = 4;     EXRDecoder.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };     } else if ( channels.Y ) {      EXRDecoder.outputChannels = 1;     EXRDecoder.decodeChannels = { Y: 0 };     } else {      throw new Error( 'EXRLoader.parse: file contains unsupported data channels.' );     }     if ( EXRDecoder.type == 1 ) {      // half     switch ( outputType ) {       case FloatType:       EXRDecoder.getter = parseFloat16;       break;       case HalfFloatType:       EXRDecoder.getter = parseUint16;       break;      }     } else if ( EXRDecoder.type == 2 ) {      // float     switch ( outputType ) {       case FloatType:       EXRDecoder.getter = parseFloat32;       break;       case HalfFloatType:       EXRDecoder.getter = decodeFloat32;      }     } else {      throw new Error( 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.' );     }     EXRDecoder.columns = EXRDecoder.width;    const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;     switch ( outputType ) {      case FloatType:      EXRDecoder.byteArray = new Float32Array( size );       // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten      if ( fillAlpha )       EXRDecoder.byteArray.fill( 1, 0, size );       break;      case HalfFloatType:      EXRDecoder.byteArray = new Uint16Array( size );       if ( fillAlpha )       EXRDecoder.byteArray.fill( 0x3C00, 0, size ); // Uint16Array holds half float data, 0x3C00 is 1       break;      default:      console.error( 'THREE.EXRLoader: unsupported type: ', outputType );      break;     }     let byteOffset = 0;    for ( const channel of EXRHeader.channels ) {      if ( EXRDecoder.decodeChannels[ channel.name ] !== undefined ) {       EXRDecoder.channelByteOffsets[ channel.name ] = byteOffset;      }      byteOffset += channel.pixelType * 2;     }     EXRDecoder.totalBytes = byteOffset;    EXRDecoder.outLineWidth = EXRDecoder.width * EXRDecoder.outputChannels;     if ( EXRHeader.lineOrder === 'INCREASING_Y' ) {      EXRDecoder.scanOrder = ( y ) => y;     } else {      EXRDecoder.scanOrder = ( y ) => EXRDecoder.height - 1 - y;     }     if ( EXRDecoder.outputChannels == 4 ) {      EXRDecoder.format = RGBAFormat;     EXRDecoder.colorSpace = LinearSRGBColorSpace;     } else {      EXRDecoder.format = RedFormat;     EXRDecoder.colorSpace = NoColorSpace;     }     if ( EXRHeader.spec.singleTile ) {      EXRDecoder.blockHeight = EXRHeader.tiles.ySize;     EXRDecoder.blockWidth = EXRHeader.tiles.xSize;      const numXLevels = calculateTileLevels( EXRHeader.tiles, EXRDecoder.width, EXRDecoder.height );     // const numYLevels = calculateTileLevels( EXRHeader.tiles, EXRDecoder.width, EXRDecoder.height );      const numXTiles = calculateTiles( numXLevels, EXRDecoder.width, EXRHeader.tiles.xSize, EXRHeader.tiles.roundingMode );     const numYTiles = calculateTiles( numXLevels, EXRDecoder.height, EXRHeader.tiles.ySize, EXRHeader.tiles.roundingMode );      EXRDecoder.tileCount = numXTiles[ 0 ] * numYTiles[ 0 ];      for ( let l = 0; l < numXLevels; l ++ )      for ( let y = 0; y < numYTiles[ l ]; y ++ )       for ( let x = 0; x < numXTiles[ l ]; x ++ )        parseInt64( dataView, offset ); // tileOffset      EXRDecoder.decode = parseTiles.bind( EXRDecoder );     } else {      EXRDecoder.blockWidth = EXRDecoder.width;     const blockCount = Math.ceil( EXRDecoder.height / EXRDecoder.blockHeight );      for ( let i = 0; i < blockCount; i ++ )      parseInt64( dataView, offset ); // scanlineOffset      EXRDecoder.decode = parseScanline.bind( EXRDecoder );     }     return EXRDecoder;    }    // start parsing file [START]   const offset = { value: 0 };   const bufferDataView = new DataView( buffer );   const uInt8Array = new Uint8Array( buffer );    // get header information and validate format.   const EXRHeader = parseHeader( bufferDataView, buffer, offset );    // get input compression information and prepare decoding.   const EXRDecoder = setupDecoder( EXRHeader, bufferDataView, uInt8Array, offset, this.type );    // parse input data   EXRDecoder.decode();    return {    header: EXRHeader,    width: EXRDecoder.width,    height: EXRDecoder.height,    data: EXRDecoder.byteArray,    format: EXRDecoder.format,    colorSpace: EXRDecoder.colorSpace,    type: this.type,   };   }   setDataType( value ) {    this.type = value;   return this;   }   load( url, onLoad, onProgress, onError ) {    function onLoadCallback( texture, texData ) {     texture.colorSpace = texData.colorSpace;    texture.minFilter = LinearFilter;    texture.magFilter = LinearFilter;    texture.generateMipmaps = false;    texture.flipY = false;     if ( onLoad ) onLoad( texture, texData );    }    return super.load( url, onLoadCallback, onProgress, onError );   }  }  export { EXRLoader }; 
^..^ FILENAME ^..^
addons|loaders|FBXLoader.js
^..^ CONTENTS ^..^
import {  AmbientLight,  AnimationClip,  Bone,  BufferGeometry,  ClampToEdgeWrapping,  Color,  ColorManagement,  DirectionalLight,  EquirectangularReflectionMapping,  Euler,  FileLoader,  Float32BufferAttribute,  Group,  Line,  LineBasicMaterial,  Loader,  LoaderUtils,  MathUtils,  Matrix3,  Matrix4,  Mesh,  MeshLambertMaterial,  MeshPhongMaterial,  NumberKeyframeTrack,  Object3D,  PerspectiveCamera,  PointLight,  PropertyBinding,  Quaternion,  QuaternionKeyframeTrack,  RepeatWrapping,  SRGBColorSpace,  ShapeUtils,  Skeleton,  SkinnedMesh,  SpotLight,  Texture,  TextureLoader,  Uint16BufferAttribute,  Vector2,  Vector3,  Vector4,  VectorKeyframeTrack } from 'three';  import * as fflate from '../libs/fflate.module.js'; import { NURBSCurve } from '../curves/NURBSCurve.js';  /**  * Loader loads FBX file and generates Group representing FBX scene.  * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format  * Versions lower than this may load but will probably have errors  *  * Needs Support:  *  Morph normals / blend shape normals  *  * FBX format references:  *  https://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)  *  * Binary format specification:  * https://code.blender.org/2013/08/fbx-binary-file-format-specification/  */   let fbxTree; let connections; let sceneGraph;  class FBXLoader extends Loader {   constructor( manager ) {    super( manager );   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;    const loader = new FileLoader( this.manager );   loader.setPath( scope.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( scope.requestHeader );   loader.setWithCredentials( scope.withCredentials );    loader.load( url, function ( buffer ) {     try {      onLoad( scope.parse( buffer, path ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( FBXBuffer, path ) {    if ( isFbxFormatBinary( FBXBuffer ) ) {     fbxTree = new BinaryParser().parse( FBXBuffer );    } else {     const FBXText = convertArrayBufferToString( FBXBuffer );     if ( ! isFbxFormatASCII( FBXText ) ) {      throw new Error( 'THREE.FBXLoader: Unknown format.' );     }     if ( getFbxVersion( FBXText ) < 7000 ) {      throw new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );     }     fbxTree = new TextParser().parse( FBXText );    }    // console.log( fbxTree );    const textureLoader = new TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );    return new FBXTreeParser( textureLoader, this.manager ).parse( fbxTree );   }  }  // Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group class FBXTreeParser {   constructor( textureLoader, manager ) {    this.textureLoader = textureLoader;   this.manager = manager;   }   parse() {    connections = this.parseConnections();    const images = this.parseImages();   const textures = this.parseTextures( images );   const materials = this.parseMaterials( textures );   const deformers = this.parseDeformers();   const geometryMap = new GeometryParser().parse( deformers );    this.parseScene( deformers, geometryMap, materials );    return sceneGraph;   }   // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )  // and details the connection type  parseConnections() {    const connectionMap = new Map();    if ( 'Connections' in fbxTree ) {     const rawConnections = fbxTree.Connections.connections;     rawConnections.forEach( function ( rawConnection ) {      const fromID = rawConnection[ 0 ];     const toID = rawConnection[ 1 ];     const relationship = rawConnection[ 2 ];      if ( ! connectionMap.has( fromID ) ) {       connectionMap.set( fromID, {       parents: [],       children: []      } );      }      const parentRelationship = { ID: toID, relationship: relationship };     connectionMap.get( fromID ).parents.push( parentRelationship );      if ( ! connectionMap.has( toID ) ) {       connectionMap.set( toID, {       parents: [],       children: []      } );      }      const childRelationship = { ID: fromID, relationship: relationship };     connectionMap.get( toID ).children.push( childRelationship );     } );    }    return connectionMap;   }   // Parse FBXTree.Objects.Video for embedded image data  // These images are connected to textures in FBXTree.Objects.Textures  // via FBXTree.Connections.  parseImages() {    const images = {};   const blobs = {};    if ( 'Video' in fbxTree.Objects ) {     const videoNodes = fbxTree.Objects.Video;     for ( const nodeID in videoNodes ) {      const videoNode = videoNodes[ nodeID ];      const id = parseInt( nodeID );      images[ id ] = videoNode.RelativeFilename || videoNode.Filename;      // raw image data is in videoNode.Content     if ( 'Content' in videoNode ) {       const arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );      const base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );       if ( arrayBufferContent || base64Content ) {        const image = this.parseImage( videoNodes[ nodeID ] );        blobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;       }      }     }    }    for ( const id in images ) {     const filename = images[ id ];     if ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];    else images[ id ] = images[ id ].split( '||' ).pop();    }    return images;   }   // Parse embedded image data in FBXTree.Video.Content  parseImage( videoNode ) {    const content = videoNode.Content;   const fileName = videoNode.RelativeFilename || videoNode.Filename;   const extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();    let type;    switch ( extension ) {     case 'bmp':      type = 'image/bmp';     break;     case 'jpg':    case 'jpeg':      type = 'image/jpeg';     break;     case 'png':      type = 'image/png';     break;     case 'tif':      type = 'image/tiff';     break;     case 'tga':      if ( this.manager.getHandler( '.tga' ) === null ) {       console.warn( 'FBXLoader: TGA loader not found, skipping ', fileName );      }      type = 'image/tga';     break;     default:      console.warn( 'FBXLoader: Image type "' + extension + '" is not supported.' );     return;    }    if ( typeof content === 'string' ) { // ASCII format     return 'data:' + type + ';base64,' + content;    } else { // Binary Format     const array = new Uint8Array( content );    return window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );    }   }   // Parse nodes in FBXTree.Objects.Texture  // These contain details such as UV scaling, cropping, rotation etc and are connected  // to images in FBXTree.Objects.Video  parseTextures( images ) {    const textureMap = new Map();    if ( 'Texture' in fbxTree.Objects ) {     const textureNodes = fbxTree.Objects.Texture;    for ( const nodeID in textureNodes ) {      const texture = this.parseTexture( textureNodes[ nodeID ], images );     textureMap.set( parseInt( nodeID ), texture );     }    }    return textureMap;   }   // Parse individual node in FBXTree.Objects.Texture  parseTexture( textureNode, images ) {    const texture = this.loadTexture( textureNode, images );    texture.ID = textureNode.id;    texture.name = textureNode.attrName;    const wrapModeU = textureNode.WrapModeU;   const wrapModeV = textureNode.WrapModeV;    const valueU = wrapModeU !== undefined ? wrapModeU.value : 0;   const valueV = wrapModeV !== undefined ? wrapModeV.value : 0;    // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a   // 0: repeat(default), 1: clamp    texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;   texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;    if ( 'Scaling' in textureNode ) {     const values = textureNode.Scaling.value;     texture.repeat.x = values[ 0 ];    texture.repeat.y = values[ 1 ];    }    if ( 'Translation' in textureNode ) {     const values = textureNode.Translation.value;     texture.offset.x = values[ 0 ];    texture.offset.y = values[ 1 ];    }    return texture;   }   // load a texture specified as a blob or data URI, or via an external URL using TextureLoader  loadTexture( textureNode, images ) {    const nonNativeExtensions = new Set( [ 'tga', 'tif', 'tiff', 'exr', 'dds', 'hdr', 'ktx2' ] );    const extension = textureNode.FileName.split( '.' ).pop().toLowerCase();    const loader = nonNativeExtensions.has( extension ) ? this.manager.getHandler( |.|extension}| ) : this.textureLoader;    if ( ! loader ) {     console.warn(     |FBXLoader: |extension.toUpperCase()} loader not found, creating placeholder texture for|,     textureNode.RelativeFilename    );    return new Texture();    }    const loaderPath = loader.path;    if ( ! loaderPath ) {     loader.setPath( this.textureLoader.path );    }    const children = connections.get( textureNode.id ).children;    let fileName;    if ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {     fileName = images[ children[ 0 ].ID ];     if ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {      loader.setPath( undefined );     }    }    const texture = loader.load( fileName );    // revert to initial path   loader.setPath( loaderPath );    return texture;   }   // Parse nodes in FBXTree.Objects.Material  parseMaterials( textureMap ) {    const materialMap = new Map();    if ( 'Material' in fbxTree.Objects ) {     const materialNodes = fbxTree.Objects.Material;     for ( const nodeID in materialNodes ) {      const material = this.parseMaterial( materialNodes[ nodeID ], textureMap );      if ( material !== null ) materialMap.set( parseInt( nodeID ), material );     }    }    return materialMap;   }   // Parse single node in FBXTree.Objects.Material  // Materials are connected to texture maps in FBXTree.Objects.Textures  // FBX format currently only supports Lambert and Phong shading models  parseMaterial( materialNode, textureMap ) {    const ID = materialNode.id;   const name = materialNode.attrName;   let type = materialNode.ShadingModel;    // Case where FBX wraps shading model in property object.   if ( typeof type === 'object' ) {     type = type.value;    }    // Ignore unused materials which don't have any connections.   if ( ! connections.has( ID ) ) return null;    const parameters = this.parseParameters( materialNode, textureMap, ID );    let material;    switch ( type.toLowerCase() ) {     case 'phong':     material = new MeshPhongMaterial();     break;    case 'lambert':     material = new MeshLambertMaterial();     break;    default:     console.warn( 'THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type );     material = new MeshPhongMaterial();     break;    }    material.setValues( parameters );   material.name = name;    return material;   }   // Parse FBX material and return parameters suitable for a three.js material  // Also parse the texture map and return any textures associated with the material  parseParameters( materialNode, textureMap, ID ) {    const parameters = {};    if ( materialNode.BumpFactor ) {     parameters.bumpScale = materialNode.BumpFactor.value;    }    if ( materialNode.Diffuse ) {     parameters.color = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.Diffuse.value ), SRGBColorSpace );    } else if ( materialNode.DiffuseColor && ( materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB' ) ) {     // The blender exporter exports diffuse here instead of in materialNode.Diffuse    parameters.color = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.DiffuseColor.value ), SRGBColorSpace );    }    if ( materialNode.DisplacementFactor ) {     parameters.displacementScale = materialNode.DisplacementFactor.value;    }    if ( materialNode.Emissive ) {     parameters.emissive = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.Emissive.value ), SRGBColorSpace );    } else if ( materialNode.EmissiveColor && ( materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB' ) ) {     // The blender exporter exports emissive color here instead of in materialNode.Emissive    parameters.emissive = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.EmissiveColor.value ), SRGBColorSpace );    }    if ( materialNode.EmissiveFactor ) {     parameters.emissiveIntensity = parseFloat( materialNode.EmissiveFactor.value );    }    if ( materialNode.Opacity ) {     parameters.opacity = parseFloat( materialNode.Opacity.value );    }    if ( parameters.opacity < 1.0 ) {     parameters.transparent = true;    }    if ( materialNode.ReflectionFactor ) {     parameters.reflectivity = materialNode.ReflectionFactor.value;    }    if ( materialNode.Shininess ) {     parameters.shininess = materialNode.Shininess.value;    }    if ( materialNode.Specular ) {     parameters.specular = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.Specular.value ), SRGBColorSpace );    } else if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) {     // The blender exporter exports specular color here instead of in materialNode.Specular    parameters.specular = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.SpecularColor.value ), SRGBColorSpace );    }    const scope = this;   connections.get( ID ).children.forEach( function ( child ) {     const type = child.relationship;     switch ( type ) {      case 'Bump':      parameters.bumpMap = scope.getTexture( textureMap, child.ID );      break;      case 'Maya|TEX_ao_map':      parameters.aoMap = scope.getTexture( textureMap, child.ID );      break;      case 'DiffuseColor':     case 'Maya|TEX_color_map':      parameters.map = scope.getTexture( textureMap, child.ID );      if ( parameters.map !== undefined ) {        parameters.map.colorSpace = SRGBColorSpace;       }       break;      case 'DisplacementColor':      parameters.displacementMap = scope.getTexture( textureMap, child.ID );      break;      case 'EmissiveColor':      parameters.emissiveMap = scope.getTexture( textureMap, child.ID );      if ( parameters.emissiveMap !== undefined ) {        parameters.emissiveMap.colorSpace = SRGBColorSpace;       }       break;      case 'NormalMap':     case 'Maya|TEX_normal_map':      parameters.normalMap = scope.getTexture( textureMap, child.ID );      break;      case 'ReflectionColor':      parameters.envMap = scope.getTexture( textureMap, child.ID );      if ( parameters.envMap !== undefined ) {        parameters.envMap.mapping = EquirectangularReflectionMapping;       parameters.envMap.colorSpace = SRGBColorSpace;       }       break;      case 'SpecularColor':      parameters.specularMap = scope.getTexture( textureMap, child.ID );      if ( parameters.specularMap !== undefined ) {        parameters.specularMap.colorSpace = SRGBColorSpace;       }       break;      case 'TransparentColor':     case 'TransparencyFactor':      parameters.alphaMap = scope.getTexture( textureMap, child.ID );      parameters.transparent = true;      break;      case 'AmbientColor':     case 'ShininessExponent': // AKA glossiness map     case 'SpecularFactor': // AKA specularLevel     case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor     default:      console.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type );      break;     }    } );    return parameters;   }   // get a texture from the textureMap for use by a material.  getTexture( textureMap, id ) {    // if the texture is a layered texture, just use the first layer and issue a warning   if ( 'LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture ) {     console.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );    id = connections.get( id ).children[ 0 ].ID;    }    return textureMap.get( id );   }   // Parse nodes in FBXTree.Objects.Deformer  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.  parseDeformers() {    const skeletons = {};   const morphTargets = {};    if ( 'Deformer' in fbxTree.Objects ) {     const DeformerNodes = fbxTree.Objects.Deformer;     for ( const nodeID in DeformerNodes ) {      const deformerNode = DeformerNodes[ nodeID ];      const relationships = connections.get( parseInt( nodeID ) );      if ( deformerNode.attrType === 'Skin' ) {       const skeleton = this.parseSkeleton( relationships, DeformerNodes );      skeleton.ID = nodeID;       if ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' );      skeleton.geometryID = relationships.parents[ 0 ].ID;       skeletons[ nodeID ] = skeleton;      } else if ( deformerNode.attrType === 'BlendShape' ) {       const morphTarget = {       id: nodeID,      };       morphTarget.rawTargets = this.parseMorphTargets( relationships, DeformerNodes );      morphTarget.id = nodeID;       if ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' );       morphTargets[ nodeID ] = morphTarget;      }     }    }    return {     skeletons: skeletons,    morphTargets: morphTargets,    };   }   // Parse single nodes in FBXTree.Objects.Deformer  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'  // Each skin node represents a skeleton and each cluster node represents a bone  parseSkeleton( relationships, deformerNodes ) {    const rawBones = [];    relationships.children.forEach( function ( child ) {     const boneNode = deformerNodes[ child.ID ];     if ( boneNode.attrType !== 'Cluster' ) return;     const rawBone = {      ID: child.ID,     indices: [],     weights: [],     transformLink: new Matrix4().fromArray( boneNode.TransformLink.a ),     // transform: new Matrix4().fromArray( boneNode.Transform.a ),     // linkMode: boneNode.Mode,     };     if ( 'Indexes' in boneNode ) {      rawBone.indices = boneNode.Indexes.a;     rawBone.weights = boneNode.Weights.a;     }     rawBones.push( rawBone );    } );    return {     rawBones: rawBones,    bones: []    };   }   // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"  parseMorphTargets( relationships, deformerNodes ) {    const rawMorphTargets = [];    for ( let i = 0; i < relationships.children.length; i ++ ) {     const child = relationships.children[ i ];     const morphTargetNode = deformerNodes[ child.ID ];     const rawMorphTarget = {      name: morphTargetNode.attrName,     initialWeight: morphTargetNode.DeformPercent,     id: morphTargetNode.id,     fullWeights: morphTargetNode.FullWeights.a     };     if ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return;     rawMorphTarget.geoID = connections.get( parseInt( child.ID ) ).children.filter( function ( child ) {      return child.relationship === undefined;     } )[ 0 ].ID;     rawMorphTargets.push( rawMorphTarget );    }    return rawMorphTargets;   }   // create the main Group() to be returned by the loader  parseScene( deformers, geometryMap, materialMap ) {    sceneGraph = new Group();    const modelMap = this.parseModels( deformers.skeletons, geometryMap, materialMap );    const modelNodes = fbxTree.Objects.Model;    const scope = this;   modelMap.forEach( function ( model ) {     const modelNode = modelNodes[ model.ID ];    scope.setLookAtProperties( model, modelNode );     const parentConnections = connections.get( model.ID ).parents;     parentConnections.forEach( function ( connection ) {      const parent = modelMap.get( connection.ID );     if ( parent !== undefined ) parent.add( model );     } );     if ( model.parent === null ) {      sceneGraph.add( model );     }     } );    this.bindSkeleton( deformers.skeletons, geometryMap, modelMap );    this.addGlobalSceneSettings();    sceneGraph.traverse( function ( node ) {     if ( node.userData.transformData ) {      if ( node.parent ) {       node.userData.transformData.parentMatrix = node.parent.matrix;      node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;      }      const transform = generateTransform( node.userData.transformData );      node.applyMatrix4( transform );     node.updateWorldMatrix();     }    } );    const animations = new AnimationParser().parse();    // if all the models where already combined in a single group, just return that   if ( sceneGraph.children.length === 1 && sceneGraph.children[ 0 ].isGroup ) {     sceneGraph.children[ 0 ].animations = animations;    sceneGraph = sceneGraph.children[ 0 ];    }    sceneGraph.animations = animations;   }   // parse nodes in FBXTree.Objects.Model  parseModels( skeletons, geometryMap, materialMap ) {    const modelMap = new Map();   const modelNodes = fbxTree.Objects.Model;    for ( const nodeID in modelNodes ) {     const id = parseInt( nodeID );    const node = modelNodes[ nodeID ];    const relationships = connections.get( id );     let model = this.buildSkeleton( relationships, skeletons, id, node.attrName );     if ( ! model ) {      switch ( node.attrType ) {       case 'Camera':       model = this.createCamera( relationships );       break;      case 'Light':       model = this.createLight( relationships );       break;      case 'Mesh':       model = this.createMesh( relationships, geometryMap, materialMap );       break;      case 'NurbsCurve':       model = this.createCurve( relationships, geometryMap );       break;      case 'LimbNode':      case 'Root':       model = new Bone();       break;      case 'Null':      default:       model = new Group();       break;      }      model.name = node.attrName ? PropertyBinding.sanitizeNodeName( node.attrName ) : '';     model.userData.originalName = node.attrName;      model.ID = id;     }     this.getTransformData( model, node );    modelMap.set( id, model );    }    return modelMap;   }   buildSkeleton( relationships, skeletons, id, name ) {    let bone = null;    relationships.parents.forEach( function ( parent ) {     for ( const ID in skeletons ) {      const skeleton = skeletons[ ID ];      skeleton.rawBones.forEach( function ( rawBone, i ) {       if ( rawBone.ID === parent.ID ) {        const subBone = bone;       bone = new Bone();        bone.matrixWorld.copy( rawBone.transformLink );        // set name and id here - otherwise in cases where "subBone" is created it will not have a name / id        bone.name = name ? PropertyBinding.sanitizeNodeName( name ) : '';       bone.userData.originalName = name;       bone.ID = id;        skeleton.bones[ i ] = bone;        // In cases where a bone is shared between multiple meshes       // duplicate the bone here and and it as a child of the first bone       if ( subBone !== null ) {         bone.add( subBone );        }       }      } );     }    } );    return bone;   }   // create a PerspectiveCamera or OrthographicCamera  createCamera( relationships ) {    let model;   let cameraAttribute;    relationships.children.forEach( function ( child ) {     const attr = fbxTree.Objects.NodeAttribute[ child.ID ];     if ( attr !== undefined ) {      cameraAttribute = attr;     }    } );    if ( cameraAttribute === undefined ) {     model = new Object3D();    } else {     let type = 0;    if ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {      type = 1;     }     let nearClippingPlane = 1;    if ( cameraAttribute.NearPlane !== undefined ) {      nearClippingPlane = cameraAttribute.NearPlane.value / 1000;     }     let farClippingPlane = 1000;    if ( cameraAttribute.FarPlane !== undefined ) {      farClippingPlane = cameraAttribute.FarPlane.value / 1000;     }      let width = window.innerWidth;    let height = window.innerHeight;     if ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {      width = cameraAttribute.AspectWidth.value;     height = cameraAttribute.AspectHeight.value;     }     const aspect = width / height;     let fov = 45;    if ( cameraAttribute.FieldOfView !== undefined ) {      fov = cameraAttribute.FieldOfView.value;     }     const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;     switch ( type ) {      case 0: // Perspective      model = new PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane );      if ( focalLength !== null ) model.setFocalLength( focalLength );      break;      case 1: // Orthographic      console.warn( 'THREE.FBXLoader: Orthographic cameras not supported yet.' );      model = new Object3D();      break;      default:      console.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );      model = new Object3D();      break;     }    }    return model;   }   // Create a DirectionalLight, PointLight or SpotLight  createLight( relationships ) {    let model;   let lightAttribute;    relationships.children.forEach( function ( child ) {     const attr = fbxTree.Objects.NodeAttribute[ child.ID ];     if ( attr !== undefined ) {      lightAttribute = attr;     }    } );    if ( lightAttribute === undefined ) {     model = new Object3D();    } else {     let type;     // LightType can be undefined for Point lights    if ( lightAttribute.LightType === undefined ) {      type = 0;     } else {      type = lightAttribute.LightType.value;     }     let color = 0xffffff;     if ( lightAttribute.Color !== undefined ) {      color = ColorManagement.toWorkingColorSpace( new Color().fromArray( lightAttribute.Color.value ), SRGBColorSpace );     }     let intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;     // light disabled    if ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {      intensity = 0;     }     let distance = 0;    if ( lightAttribute.FarAttenuationEnd !== undefined ) {      if ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {       distance = 0;      } else {       distance = lightAttribute.FarAttenuationEnd.value;      }     }     // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?    const decay = 1;     switch ( type ) {      case 0: // Point      model = new PointLight( color, intensity, distance, decay );      break;      case 1: // Directional      model = new DirectionalLight( color, intensity );      break;      case 2: // Spot      let angle = Math.PI / 3;       if ( lightAttribute.InnerAngle !== undefined ) {        angle = MathUtils.degToRad( lightAttribute.InnerAngle.value );       }       let penumbra = 0;      if ( lightAttribute.OuterAngle !== undefined ) {        // TODO: this is not correct - FBX calculates outer and inner angle in degrees       // with OuterAngle > InnerAngle && OuterAngle <= Math.PI       // while three.js uses a penumbra between (0, 1) to attenuate the inner angle       penumbra = MathUtils.degToRad( lightAttribute.OuterAngle.value );       penumbra = Math.max( penumbra, 1 );       }       model = new SpotLight( color, intensity, distance, angle, penumbra, decay );      break;      default:      console.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.' );      model = new PointLight( color, intensity );      break;     }     if ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {      model.castShadow = true;     }    }    return model;   }   createMesh( relationships, geometryMap, materialMap ) {    let model;   let geometry = null;   let material = null;   const materials = [];    // get geometry and materials(s) from connections   relationships.children.forEach( function ( child ) {     if ( geometryMap.has( child.ID ) ) {      geometry = geometryMap.get( child.ID );     }     if ( materialMap.has( child.ID ) ) {      materials.push( materialMap.get( child.ID ) );     }    } );    if ( materials.length > 1 ) {     material = materials;    } else if ( materials.length > 0 ) {     material = materials[ 0 ];    } else {     material = new MeshPhongMaterial( {     name: Loader.DEFAULT_MATERIAL_NAME,     color: 0xcccccc    } );    materials.push( material );    }    if ( 'color' in geometry.attributes ) {     materials.forEach( function ( material ) {      material.vertexColors = true;     } );    }    if ( geometry.FBX_Deformer ) {     model = new SkinnedMesh( geometry, material );    model.normalizeSkinWeights();    } else {     model = new Mesh( geometry, material );    }    return model;   }   createCurve( relationships, geometryMap ) {    const geometry = relationships.children.reduce( function ( geo, child ) {     if ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );     return geo;    }, null );    // FBX does not list materials for Nurbs lines, so we'll just put our own in here.   const material = new LineBasicMaterial( {    name: Loader.DEFAULT_MATERIAL_NAME,    color: 0x3300ff,    linewidth: 1   } );   return new Line( geometry, material );   }   // parse the model node for transform data  getTransformData( model, modelNode ) {    const transformData = {};    if ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );    if ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );   else transformData.eulerOrder = getEulerOrder( 0 );    if ( 'Lcl_Translation' in modelNode ) transformData.translation = modelNode.Lcl_Translation.value;    if ( 'PreRotation' in modelNode ) transformData.preRotation = modelNode.PreRotation.value;   if ( 'Lcl_Rotation' in modelNode ) transformData.rotation = modelNode.Lcl_Rotation.value;   if ( 'PostRotation' in modelNode ) transformData.postRotation = modelNode.PostRotation.value;    if ( 'Lcl_Scaling' in modelNode ) transformData.scale = modelNode.Lcl_Scaling.value;    if ( 'ScalingOffset' in modelNode ) transformData.scalingOffset = modelNode.ScalingOffset.value;   if ( 'ScalingPivot' in modelNode ) transformData.scalingPivot = modelNode.ScalingPivot.value;    if ( 'RotationOffset' in modelNode ) transformData.rotationOffset = modelNode.RotationOffset.value;   if ( 'RotationPivot' in modelNode ) transformData.rotationPivot = modelNode.RotationPivot.value;    model.userData.transformData = transformData;   }   setLookAtProperties( model, modelNode ) {    if ( 'LookAtProperty' in modelNode ) {     const children = connections.get( model.ID ).children;     children.forEach( function ( child ) {      if ( child.relationship === 'LookAtProperty' ) {       const lookAtTarget = fbxTree.Objects.Model[ child.ID ];       if ( 'Lcl_Translation' in lookAtTarget ) {        const pos = lookAtTarget.Lcl_Translation.value;        // DirectionalLight, SpotLight       if ( model.target !== undefined ) {         model.target.position.fromArray( pos );        sceneGraph.add( model.target );        } else { // Cameras and other Object3Ds         model.lookAt( new Vector3().fromArray( pos ) );        }       }      }     } );    }   }   bindSkeleton( skeletons, geometryMap, modelMap ) {    const bindMatrices = this.parsePoseNodes();    for ( const ID in skeletons ) {     const skeleton = skeletons[ ID ];     const parents = connections.get( parseInt( skeleton.ID ) ).parents;     parents.forEach( function ( parent ) {      if ( geometryMap.has( parent.ID ) ) {       const geoID = parent.ID;      const geoRelationships = connections.get( geoID );       geoRelationships.parents.forEach( function ( geoConnParent ) {        if ( modelMap.has( geoConnParent.ID ) ) {         const model = modelMap.get( geoConnParent.ID );         model.bind( new Skeleton( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );        }       } );      }     } );    }   }   parsePoseNodes() {    const bindMatrices = {};    if ( 'Pose' in fbxTree.Objects ) {     const BindPoseNode = fbxTree.Objects.Pose;     for ( const nodeID in BindPoseNode ) {      if ( BindPoseNode[ nodeID ].attrType === 'BindPose' && BindPoseNode[ nodeID ].NbPoseNodes > 0 ) {       const poseNodes = BindPoseNode[ nodeID ].PoseNode;       if ( Array.isArray( poseNodes ) ) {        poseNodes.forEach( function ( poseNode ) {         bindMatrices[ poseNode.Node ] = new Matrix4().fromArray( poseNode.Matrix.a );        } );       } else {        bindMatrices[ poseNodes.Node ] = new Matrix4().fromArray( poseNodes.Matrix.a );       }      }     }    }    return bindMatrices;   }   addGlobalSceneSettings() {    if ( 'GlobalSettings' in fbxTree ) {     if ( 'AmbientColor' in fbxTree.GlobalSettings ) {      // Parse ambient color - if it's not set to black (default), create an ambient light      const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;     const r = ambientColor[ 0 ];     const g = ambientColor[ 1 ];     const b = ambientColor[ 2 ];      if ( r !== 0 || g !== 0 || b !== 0 ) {       const color = new Color().setRGB( r, g, b, SRGBColorSpace );      sceneGraph.add( new AmbientLight( color, 1 ) );      }     }     if ( 'UnitScaleFactor' in fbxTree.GlobalSettings ) {      sceneGraph.userData.unitScaleFactor = fbxTree.GlobalSettings.UnitScaleFactor.value;     }    }   }  }  // parse Geometry data from FBXTree and return map of BufferGeometries class GeometryParser {   constructor() {    this.negativeMaterialIndices = false;   }   // Parse nodes in FBXTree.Objects.Geometry  parse( deformers ) {    const geometryMap = new Map();    if ( 'Geometry' in fbxTree.Objects ) {     const geoNodes = fbxTree.Objects.Geometry;     for ( const nodeID in geoNodes ) {      const relationships = connections.get( parseInt( nodeID ) );     const geo = this.parseGeometry( relationships, geoNodes[ nodeID ], deformers );      geometryMap.set( parseInt( nodeID ), geo );     }    }    // report warnings    if ( this.negativeMaterialIndices === true ) {     console.warn( 'THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.' );    }    return geometryMap;   }   // Parse single node in FBXTree.Objects.Geometry  parseGeometry( relationships, geoNode, deformers ) {    switch ( geoNode.attrType ) {     case 'Mesh':     return this.parseMeshGeometry( relationships, geoNode, deformers );     break;     case 'NurbsCurve':     return this.parseNurbsGeometry( geoNode );     break;    }   }   // Parse single node mesh geometry in FBXTree.Objects.Geometry  parseMeshGeometry( relationships, geoNode, deformers ) {    const skeletons = deformers.skeletons;   const morphTargets = [];    const modelNodes = relationships.parents.map( function ( parent ) {     return fbxTree.Objects.Model[ parent.ID ];    } );    // don't create geometry if it is not associated with any models   if ( modelNodes.length === 0 ) return;    const skeleton = relationships.children.reduce( function ( skeleton, child ) {     if ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ];     return skeleton;    }, null );    relationships.children.forEach( function ( child ) {     if ( deformers.morphTargets[ child.ID ] !== undefined ) {      morphTargets.push( deformers.morphTargets[ child.ID ] );     }    } );    // Assume one model and get the preRotation from that   // if there is more than one model associated with the geometry this may cause problems   const modelNode = modelNodes[ 0 ];    const transformData = {};    if ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );   if ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );    if ( 'GeometricTranslation' in modelNode ) transformData.translation = modelNode.GeometricTranslation.value;   if ( 'GeometricRotation' in modelNode ) transformData.rotation = modelNode.GeometricRotation.value;   if ( 'GeometricScaling' in modelNode ) transformData.scale = modelNode.GeometricScaling.value;    const transform = generateTransform( transformData );    return this.genGeometry( geoNode, skeleton, morphTargets, transform );   }   // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry  genGeometry( geoNode, skeleton, morphTargets, preTransform ) {    const geo = new BufferGeometry();   if ( geoNode.attrName ) geo.name = geoNode.attrName;    const geoInfo = this.parseGeoNode( geoNode, skeleton );   const buffers = this.genBuffers( geoInfo );    const positionAttribute = new Float32BufferAttribute( buffers.vertex, 3 );    positionAttribute.applyMatrix4( preTransform );    geo.setAttribute( 'position', positionAttribute );    if ( buffers.colors.length > 0 ) {     geo.setAttribute( 'color', new Float32BufferAttribute( buffers.colors, 3 ) );    }    if ( skeleton ) {     geo.setAttribute( 'skinIndex', new Uint16BufferAttribute( buffers.weightsIndices, 4 ) );     geo.setAttribute( 'skinWeight', new Float32BufferAttribute( buffers.vertexWeights, 4 ) );     // used later to bind the skeleton to the model    geo.FBX_Deformer = skeleton;    }    if ( buffers.normal.length > 0 ) {     const normalMatrix = new Matrix3().getNormalMatrix( preTransform );     const normalAttribute = new Float32BufferAttribute( buffers.normal, 3 );    normalAttribute.applyNormalMatrix( normalMatrix );     geo.setAttribute( 'normal', normalAttribute );    }    buffers.uvs.forEach( function ( uvBuffer, i ) {     const name = i === 0 ? 'uv' : |uv| i }|;     geo.setAttribute( name, new Float32BufferAttribute( buffers.uvs[ i ], 2 ) );    } );    if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {     // Convert the material indices of each vertex into rendering groups on the geometry.    let prevMaterialIndex = buffers.materialIndex[ 0 ];    let startIndex = 0;     buffers.materialIndex.forEach( function ( currentIndex, i ) {      if ( currentIndex !== prevMaterialIndex ) {       geo.addGroup( startIndex, i - startIndex, prevMaterialIndex );       prevMaterialIndex = currentIndex;      startIndex = i;      }     } );     // the loop above doesn't add the last group, do that here.    if ( geo.groups.length > 0 ) {      const lastGroup = geo.groups[ geo.groups.length - 1 ];     const lastIndex = lastGroup.start + lastGroup.count;      if ( lastIndex !== buffers.materialIndex.length ) {       geo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );      }     }     // case where there are multiple materials but the whole geometry is only    // using one of them    if ( geo.groups.length === 0 ) {      geo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );     }    }    this.addMorphTargets( geo, geoNode, morphTargets, preTransform );    return geo;   }   parseGeoNode( geoNode, skeleton ) {    const geoInfo = {};    geoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];   geoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];    if ( geoNode.LayerElementColor ) {     geoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );    }    if ( geoNode.LayerElementMaterial ) {     geoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );    }    if ( geoNode.LayerElementNormal ) {     geoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] );    }    if ( geoNode.LayerElementUV ) {     geoInfo.uv = [];     let i = 0;    while ( geoNode.LayerElementUV[ i ] ) {      if ( geoNode.LayerElementUV[ i ].UV ) {       geoInfo.uv.push( this.parseUVs( geoNode.LayerElementUV[ i ] ) );      }      i ++;     }    }    geoInfo.weightTable = {};    if ( skeleton !== null ) {     geoInfo.skeleton = skeleton;     skeleton.rawBones.forEach( function ( rawBone, i ) {      // loop over the bone's vertex indices and weights     rawBone.indices.forEach( function ( index, j ) {       if ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = [];       geoInfo.weightTable[ index ].push( {        id: i,       weight: rawBone.weights[ j ],       } );      } );     } );    }    return geoInfo;   }   genBuffers( geoInfo ) {    const buffers = {    vertex: [],    normal: [],    colors: [],    uvs: [],    materialIndex: [],    vertexWeights: [],    weightsIndices: [],   };    let polygonIndex = 0;   let faceLength = 0;   let displayedWeightsWarning = false;    // these will hold data for a single face   let facePositionIndexes = [];   let faceNormals = [];   let faceColors = [];   let faceUVs = [];   let faceWeights = [];   let faceWeightIndices = [];    const scope = this;   geoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {     let materialIndex;    let endOfFace = false;     // Face index and vertex index arrays are combined in a single array    // A cube with quad faces looks like this:    // PolygonVertexIndex: *24 {    //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5    //  }    // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3    // to find index of last vertex bit shift the index: ^ - 1    if ( vertexIndex < 0 ) {      vertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1     endOfFace = true;     }     let weightIndices = [];    let weights = [];     facePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );     if ( geoInfo.color ) {      const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );      faceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );     }     if ( geoInfo.skeleton ) {      if ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {       geoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {        weights.push( wt.weight );       weightIndices.push( wt.id );       } );       }      if ( weights.length > 4 ) {       if ( ! displayedWeightsWarning ) {        console.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );       displayedWeightsWarning = true;       }       const wIndex = [ 0, 0, 0, 0 ];      const Weight = [ 0, 0, 0, 0 ];       weights.forEach( function ( weight, weightIndex ) {        let currentWeight = weight;       let currentIndex = weightIndices[ weightIndex ];        Weight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {         if ( currentWeight > comparedWeight ) {          comparedWeightArray[ comparedWeightIndex ] = currentWeight;         currentWeight = comparedWeight;          const tmp = wIndex[ comparedWeightIndex ];         wIndex[ comparedWeightIndex ] = currentIndex;         currentIndex = tmp;         }        } );       } );       weightIndices = wIndex;      weights = Weight;      }      // if the weight array is shorter than 4 pad with 0s     while ( weights.length < 4 ) {       weights.push( 0 );      weightIndices.push( 0 );      }      for ( let i = 0; i < 4; ++ i ) {       faceWeights.push( weights[ i ] );      faceWeightIndices.push( weightIndices[ i ] );      }     }     if ( geoInfo.normal ) {      const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );      faceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );     }     if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {      materialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];      if ( materialIndex < 0 ) {       scope.negativeMaterialIndices = true;      materialIndex = 0; // fallback      }     }     if ( geoInfo.uv ) {      geoInfo.uv.forEach( function ( uv, i ) {       const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );       if ( faceUVs[ i ] === undefined ) {        faceUVs[ i ] = [];       }       faceUVs[ i ].push( data[ 0 ] );      faceUVs[ i ].push( data[ 1 ] );      } );     }     faceLength ++;     if ( endOfFace ) {      scope.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );      polygonIndex ++;     faceLength = 0;      // reset arrays for the next face     facePositionIndexes = [];     faceNormals = [];     faceColors = [];     faceUVs = [];     faceWeights = [];     faceWeightIndices = [];     }    } );    return buffers;   }   // See https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal  getNormalNewell( vertices ) {    const normal = new Vector3( 0.0, 0.0, 0.0 );    for ( let i = 0; i < vertices.length; i ++ ) {     const current = vertices[ i ];    const next = vertices[ ( i + 1 ) % vertices.length ];     normal.x += ( current.y - next.y ) * ( current.z + next.z );    normal.y += ( current.z - next.z ) * ( current.x + next.x );    normal.z += ( current.x - next.x ) * ( current.y + next.y );    }    normal.normalize();    return normal;   }   getNormalTangentAndBitangent( vertices ) {    const normalVector = this.getNormalNewell( vertices );   // Avoid up being equal or almost equal to normalVector   const up = Math.abs( normalVector.z ) > 0.5 ? new Vector3( 0.0, 1.0, 0.0 ) : new Vector3( 0.0, 0.0, 1.0 );   const tangent = up.cross( normalVector ).normalize();   const bitangent = normalVector.clone().cross( tangent ).normalize();    return {    normal: normalVector,    tangent: tangent,    bitangent: bitangent   };   }   flattenVertex( vertex, normalTangent, normalBitangent ) {    return new Vector2(    vertex.dot( normalTangent ),    vertex.dot( normalBitangent )   );   }   // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris  genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {    let triangles;    if ( faceLength > 3 ) {     // Triangulate n-gon using earcut     const vertices = [];    // in morphing scenario vertexPositions represent morphPositions    // while baseVertexPositions represent the original geometry's positions    const positions = geoInfo.baseVertexPositions || geoInfo.vertexPositions;    for ( let i = 0; i < facePositionIndexes.length; i += 3 ) {      vertices.push(      new Vector3(       positions[ facePositionIndexes[ i ] ],       positions[ facePositionIndexes[ i + 1 ] ],       positions[ facePositionIndexes[ i + 2 ] ]      )     );     }     const { tangent, bitangent } = this.getNormalTangentAndBitangent( vertices );    const triangulationInput = [];     for ( const vertex of vertices ) {      triangulationInput.push( this.flattenVertex( vertex, tangent, bitangent ) );     }     // When vertices is an array of [0,0,0] elements (which is the case for vertices not participating in morph)    // the triangulationInput will be an array of [0,0] elements    // resulting in an array of 0 triangles being returned from ShapeUtils.triangulateShape    // leading to not pushing into buffers.vertex the redundant vertices (the vertices that are not morphed).    // That's why, in order to support morphing scenario, "positions" is looking first for baseVertexPositions,    // so that we don't end up with an array of 0 triangles for the faces not participating in morph.    triangles = ShapeUtils.triangulateShape( triangulationInput, [] );    } else {     // Regular triangle, skip earcut triangulation step    triangles = [[ 0, 1, 2 ]];    }    for ( const [ i0, i1, i2 ] of triangles ) {     buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i0 * 3 ] ] );    buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i0 * 3 + 1 ] ] );    buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i0 * 3 + 2 ] ] );     buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i1 * 3 ] ] );    buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i1 * 3 + 1 ] ] );    buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i1 * 3 + 2 ] ] );     buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i2 * 3 ] ] );    buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i2 * 3 + 1 ] ] );    buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i2 * 3 + 2 ] ] );     if ( geoInfo.skeleton ) {      buffers.vertexWeights.push( faceWeights[ i0 * 4 ] );     buffers.vertexWeights.push( faceWeights[ i0 * 4 + 1 ] );     buffers.vertexWeights.push( faceWeights[ i0 * 4 + 2 ] );     buffers.vertexWeights.push( faceWeights[ i0 * 4 + 3 ] );      buffers.vertexWeights.push( faceWeights[ i1 * 4 ] );     buffers.vertexWeights.push( faceWeights[ i1 * 4 + 1 ] );     buffers.vertexWeights.push( faceWeights[ i1 * 4 + 2 ] );     buffers.vertexWeights.push( faceWeights[ i1 * 4 + 3 ] );      buffers.vertexWeights.push( faceWeights[ i2 * 4 ] );     buffers.vertexWeights.push( faceWeights[ i2 * 4 + 1 ] );     buffers.vertexWeights.push( faceWeights[ i2 * 4 + 2 ] );     buffers.vertexWeights.push( faceWeights[ i2 * 4 + 3 ] );      buffers.weightsIndices.push( faceWeightIndices[ i0 * 4 ] );     buffers.weightsIndices.push( faceWeightIndices[ i0 * 4 + 1 ] );     buffers.weightsIndices.push( faceWeightIndices[ i0 * 4 + 2 ] );     buffers.weightsIndices.push( faceWeightIndices[ i0 * 4 + 3 ] );      buffers.weightsIndices.push( faceWeightIndices[ i1 * 4 ] );     buffers.weightsIndices.push( faceWeightIndices[ i1 * 4 + 1 ] );     buffers.weightsIndices.push( faceWeightIndices[ i1 * 4 + 2 ] );     buffers.weightsIndices.push( faceWeightIndices[ i1 * 4 + 3 ] );      buffers.weightsIndices.push( faceWeightIndices[ i2 * 4 ] );     buffers.weightsIndices.push( faceWeightIndices[ i2 * 4 + 1 ] );     buffers.weightsIndices.push( faceWeightIndices[ i2 * 4 + 2 ] );     buffers.weightsIndices.push( faceWeightIndices[ i2 * 4 + 3 ] );     }     if ( geoInfo.color ) {      buffers.colors.push( faceColors[ i0 * 3 ] );     buffers.colors.push( faceColors[ i0 * 3 + 1 ] );     buffers.colors.push( faceColors[ i0 * 3 + 2 ] );      buffers.colors.push( faceColors[ i1 * 3 ] );     buffers.colors.push( faceColors[ i1 * 3 + 1 ] );     buffers.colors.push( faceColors[ i1 * 3 + 2 ] );      buffers.colors.push( faceColors[ i2 * 3 ] );     buffers.colors.push( faceColors[ i2 * 3 + 1 ] );     buffers.colors.push( faceColors[ i2 * 3 + 2 ] );     }     if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {      buffers.materialIndex.push( materialIndex );     buffers.materialIndex.push( materialIndex );     buffers.materialIndex.push( materialIndex );     }     if ( geoInfo.normal ) {      buffers.normal.push( faceNormals[ i0 * 3 ] );     buffers.normal.push( faceNormals[ i0 * 3 + 1 ] );     buffers.normal.push( faceNormals[ i0 * 3 + 2 ] );      buffers.normal.push( faceNormals[ i1 * 3 ] );     buffers.normal.push( faceNormals[ i1 * 3 + 1 ] );     buffers.normal.push( faceNormals[ i1 * 3 + 2 ] );      buffers.normal.push( faceNormals[ i2 * 3 ] );     buffers.normal.push( faceNormals[ i2 * 3 + 1 ] );     buffers.normal.push( faceNormals[ i2 * 3 + 2 ] );     }     if ( geoInfo.uv ) {      geoInfo.uv.forEach( function ( uv, j ) {       if ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];       buffers.uvs[ j ].push( faceUVs[ j ][ i0 * 2 ] );      buffers.uvs[ j ].push( faceUVs[ j ][ i0 * 2 + 1 ] );       buffers.uvs[ j ].push( faceUVs[ j ][ i1 * 2 ] );      buffers.uvs[ j ].push( faceUVs[ j ][ i1 * 2 + 1 ] );       buffers.uvs[ j ].push( faceUVs[ j ][ i2 * 2 ] );      buffers.uvs[ j ].push( faceUVs[ j ][ i2 * 2 + 1 ] );      } );     }    }   }   addMorphTargets( parentGeo, parentGeoNode, morphTargets, preTransform ) {    if ( morphTargets.length === 0 ) return;    parentGeo.morphTargetsRelative = true;    parentGeo.morphAttributes.position = [];   // parentGeo.morphAttributes.normal = []; // not implemented    const scope = this;   morphTargets.forEach( function ( morphTarget ) {     morphTarget.rawTargets.forEach( function ( rawTarget ) {      const morphGeoNode = fbxTree.Objects.Geometry[ rawTarget.geoID ];      if ( morphGeoNode !== undefined ) {       scope.genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name );      }     } );    } );   }   // a morph geometry node is similar to a standard  node, and the node is also contained  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal  // and a special attribute Index defining which vertices of the original geometry are affected  // Normal and position attributes only have data for the vertices that are affected by the morph  genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, name ) {    const basePositions = parentGeoNode.Vertices !== undefined ? parentGeoNode.Vertices.a : [];   const baseIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : [];    const morphPositionsSparse = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];   const morphIndices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];    const length = parentGeo.attributes.position.count * 3;   const morphPositions = new Float32Array( length );    for ( let i = 0; i < morphIndices.length; i ++ ) {     const morphIndex = morphIndices[ i ] * 3;     morphPositions[ morphIndex ] = morphPositionsSparse[ i * 3 ];    morphPositions[ morphIndex + 1 ] = morphPositionsSparse[ i * 3 + 1 ];    morphPositions[ morphIndex + 2 ] = morphPositionsSparse[ i * 3 + 2 ];    }    // TODO: add morph normal support   const morphGeoInfo = {    vertexIndices: baseIndices,    vertexPositions: morphPositions,    baseVertexPositions: basePositions   };    const morphBuffers = this.genBuffers( morphGeoInfo );    const positionAttribute = new Float32BufferAttribute( morphBuffers.vertex, 3 );   positionAttribute.name = name || morphGeoNode.attrName;    positionAttribute.applyMatrix4( preTransform );    parentGeo.morphAttributes.position.push( positionAttribute );   }   // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists  parseNormals( NormalNode ) {    const mappingType = NormalNode.MappingInformationType;   const referenceType = NormalNode.ReferenceInformationType;   const buffer = NormalNode.Normals.a;   let indexBuffer = [];   if ( referenceType === 'IndexToDirect' ) {     if ( 'NormalIndex' in NormalNode ) {      indexBuffer = NormalNode.NormalIndex.a;     } else if ( 'NormalsIndex' in NormalNode ) {      indexBuffer = NormalNode.NormalsIndex.a;     }    }    return {    dataSize: 3,    buffer: buffer,    indices: indexBuffer,    mappingType: mappingType,    referenceType: referenceType   };   }   // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists  parseUVs( UVNode ) {    const mappingType = UVNode.MappingInformationType;   const referenceType = UVNode.ReferenceInformationType;   const buffer = UVNode.UV.a;   let indexBuffer = [];   if ( referenceType === 'IndexToDirect' ) {     indexBuffer = UVNode.UVIndex.a;    }    return {    dataSize: 2,    buffer: buffer,    indices: indexBuffer,    mappingType: mappingType,    referenceType: referenceType   };   }   // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists  parseVertexColors( ColorNode ) {    const mappingType = ColorNode.MappingInformationType;   const referenceType = ColorNode.ReferenceInformationType;   const buffer = ColorNode.Colors.a;   let indexBuffer = [];   if ( referenceType === 'IndexToDirect' ) {     indexBuffer = ColorNode.ColorIndex.a;    }    for ( let i = 0, c = new Color(); i < buffer.length; i += 4 ) {     c.fromArray( buffer, i );    ColorManagement.toWorkingColorSpace( c, SRGBColorSpace );    c.toArray( buffer, i );    }    return {    dataSize: 4,    buffer: buffer,    indices: indexBuffer,    mappingType: mappingType,    referenceType: referenceType   };   }   // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists  parseMaterialIndices( MaterialNode ) {    const mappingType = MaterialNode.MappingInformationType;   const referenceType = MaterialNode.ReferenceInformationType;    if ( mappingType === 'NoMappingInformation' ) {     return {     dataSize: 1,     buffer: [ 0 ],     indices: [ 0 ],     mappingType: 'AllSame',     referenceType: referenceType    };    }    const materialIndexBuffer = MaterialNode.Materials.a;    // Since materials are stored as indices, there's a bit of a mismatch between FBX and what   // we expect.So we create an intermediate buffer that points to the index in the buffer,   // for conforming with the other functions we've written for other data.   const materialIndices = [];    for ( let i = 0; i < materialIndexBuffer.length; ++ i ) {     materialIndices.push( i );    }    return {    dataSize: 1,    buffer: materialIndexBuffer,    indices: materialIndices,    mappingType: mappingType,    referenceType: referenceType   };   }   // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry  parseNurbsGeometry( geoNode ) {    const order = parseInt( geoNode.Order );    if ( isNaN( order ) ) {     console.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );    return new BufferGeometry();    }    const degree = order - 1;    const knots = geoNode.KnotVector.a;   const controlPoints = [];   const pointsValues = geoNode.Points.a;    for ( let i = 0, l = pointsValues.length; i < l; i += 4 ) {     controlPoints.push( new Vector4().fromArray( pointsValues, i ) );    }    let startKnot, endKnot;    if ( geoNode.Form === 'Closed' ) {     controlPoints.push( controlPoints[ 0 ] );    } else if ( geoNode.Form === 'Periodic' ) {     startKnot = degree;    endKnot = knots.length - 1 - startKnot;     for ( let i = 0; i < degree; ++ i ) {      controlPoints.push( controlPoints[ i ] );     }    }    const curve = new NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );   const points = curve.getPoints( controlPoints.length * 12 );    return new BufferGeometry().setFromPoints( points );   }  }  // parse animation data from FBXTree class AnimationParser {   // take raw animation clips and turn them into three.js animation clips  parse() {    const animationClips = [];    const rawClips = this.parseClips();    if ( rawClips !== undefined ) {     for ( const key in rawClips ) {      const rawClip = rawClips[ key ];      const clip = this.addClip( rawClip );      animationClips.push( clip );     }    }    return animationClips;   }   parseClips() {    // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,   // if this is undefined we can safely assume there are no animations   if ( fbxTree.Objects.AnimationCurve === undefined ) return undefined;    const curveNodesMap = this.parseAnimationCurveNodes();    this.parseAnimationCurves( curveNodesMap );    const layersMap = this.parseAnimationLayers( curveNodesMap );   const rawClips = this.parseAnimStacks( layersMap );    return rawClips;   }   // parse nodes in FBXTree.Objects.AnimationCurveNode  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )  // and is referenced by an AnimationLayer  parseAnimationCurveNodes() {    const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;    const curveNodesMap = new Map();    for ( const nodeID in rawCurveNodes ) {     const rawCurveNode = rawCurveNodes[ nodeID ];     if ( rawCurveNode.attrName.match( /S|R|T|DeformPercent/ ) !== null ) {      const curveNode = {       id: rawCurveNode.id,      attr: rawCurveNode.attrName,      curves: {},      };      curveNodesMap.set( curveNode.id, curveNode );     }    }    return curveNodesMap;   }   // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated  // axis ( e.g. times and values of x rotation)  parseAnimationCurves( curveNodesMap ) {    const rawCurves = fbxTree.Objects.AnimationCurve;    // TODO: Many values are identical up to roundoff error, but won't be optimised   // e.g. position times: [0, 0.4, 0. 8]   // position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]   // clearly, this should be optimised to   // times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]   // this shows up in nearly every FBX file, and generally time array is length > 100    for ( const nodeID in rawCurves ) {     const animationCurve = {      id: rawCurves[ nodeID ].id,     times: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),     values: rawCurves[ nodeID ].KeyValueFloat.a,     };     const relationships = connections.get( animationCurve.id );     if ( relationships !== undefined ) {      const animationCurveID = relationships.parents[ 0 ].ID;     const animationCurveRelationship = relationships.parents[ 0 ].relationship;      if ( animationCurveRelationship.match( /X/ ) ) {       curveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;      } else if ( animationCurveRelationship.match( /Y/ ) ) {       curveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;      } else if ( animationCurveRelationship.match( /Z/ ) ) {       curveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;      } else if ( animationCurveRelationship.match( /DeformPercent/ ) && curveNodesMap.has( animationCurveID ) ) {       curveNodesMap.get( animationCurveID ).curves[ 'morph' ] = animationCurve;      }     }    }   }   // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references  // to various AnimationCurveNodes and is referenced by an AnimationStack node  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack  parseAnimationLayers( curveNodesMap ) {    const rawLayers = fbxTree.Objects.AnimationLayer;    const layersMap = new Map();    for ( const nodeID in rawLayers ) {     const layerCurveNodes = [];     const connection = connections.get( parseInt( nodeID ) );     if ( connection !== undefined ) {      // all the animationCurveNodes used in the layer     const children = connection.children;      children.forEach( function ( child, i ) {       if ( curveNodesMap.has( child.ID ) ) {        const curveNode = curveNodesMap.get( child.ID );        // check that the curves are defined for at least one axis, otherwise ignore the curveNode       if ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {         if ( layerCurveNodes[ i ] === undefined ) {          const modelID = connections.get( child.ID ).parents.filter( function ( parent ) {           return parent.relationship !== undefined;          } )[ 0 ].ID;          if ( modelID !== undefined ) {           const rawModel = fbxTree.Objects.Model[ modelID.toString() ];           if ( rawModel === undefined ) {            console.warn( 'THREE.FBXLoader: Encountered a unused curve.', child );           return;           }           const node = {            modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',           ID: rawModel.id,           initialPosition: [ 0, 0, 0 ],           initialRotation: [ 0, 0, 0 ],           initialScale: [ 1, 1, 1 ],           };           sceneGraph.traverse( function ( child ) {            if ( child.ID === rawModel.id ) {             node.transform = child.matrix;             if ( child.userData.transformData ) node.eulerOrder = child.userData.transformData.eulerOrder;            }           } );           if ( ! node.transform ) node.transform = new Matrix4();           // if the animated model is pre rotated, we'll have to apply the pre rotations to every          // animation value as well          if ( 'PreRotation' in rawModel ) node.preRotation = rawModel.PreRotation.value;          if ( 'PostRotation' in rawModel ) node.postRotation = rawModel.PostRotation.value;           layerCurveNodes[ i ] = node;          }         }         if ( layerCurveNodes[ i ] ) layerCurveNodes[ i ][ curveNode.attr ] = curveNode;        } else if ( curveNode.curves.morph !== undefined ) {         if ( layerCurveNodes[ i ] === undefined ) {          const deformerID = connections.get( child.ID ).parents.filter( function ( parent ) {           return parent.relationship !== undefined;          } )[ 0 ].ID;          const morpherID = connections.get( deformerID ).parents[ 0 ].ID;         const geoID = connections.get( morpherID ).parents[ 0 ].ID;          // assuming geometry is not used in more than one model         const modelID = connections.get( geoID ).parents[ 0 ].ID;          const rawModel = fbxTree.Objects.Model[ modelID ];          const node = {           modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',          morphName: fbxTree.Objects.Deformer[ deformerID ].attrName,          };          layerCurveNodes[ i ] = node;         }         layerCurveNodes[ i ][ curveNode.attr ] = curveNode;        }       }      } );      layersMap.set( parseInt( nodeID ), layerCurveNodes );     }    }    return layersMap;   }   // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation  // hierarchy. Each Stack node will be used to create a AnimationClip  parseAnimStacks( layersMap ) {    const rawStacks = fbxTree.Objects.AnimationStack;    // connect the stacks (clips) up to the layers   const rawClips = {};    for ( const nodeID in rawStacks ) {     const children = connections.get( parseInt( nodeID ) ).children;     if ( children.length > 1 ) {      // it seems like stacks will always be associated with a single layer. But just in case there are files     // where there are multiple layers per stack, we'll display a warning     console.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );     }     const layer = layersMap.get( children[ 0 ].ID );     rawClips[ nodeID ] = {      name: rawStacks[ nodeID ].attrName,     layer: layer,     };    }    return rawClips;   }   addClip( rawClip ) {    let tracks = [];    const scope = this;   rawClip.layer.forEach( function ( rawTracks ) {     tracks = tracks.concat( scope.generateTracks( rawTracks ) );    } );    return new AnimationClip( rawClip.name, - 1, tracks );   }   generateTracks( rawTracks ) {    const tracks = [];    let initialPosition = new Vector3();   let initialScale = new Vector3();    if ( rawTracks.transform ) rawTracks.transform.decompose( initialPosition, new Quaternion(), initialScale );    initialPosition = initialPosition.toArray();   initialScale = initialScale.toArray();    if ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {     const positionTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position' );    if ( positionTrack !== undefined ) tracks.push( positionTrack );    }    if ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {     const rotationTrack = this.generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder );    if ( rotationTrack !== undefined ) tracks.push( rotationTrack );    }    if ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {     const scaleTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale' );    if ( scaleTrack !== undefined ) tracks.push( scaleTrack );    }    if ( rawTracks.DeformPercent !== undefined ) {     const morphTrack = this.generateMorphTrack( rawTracks );    if ( morphTrack !== undefined ) tracks.push( morphTrack );    }    return tracks;   }   generateVectorTrack( modelName, curves, initialValue, type ) {    const times = this.getTimesForAllAxes( curves );   const values = this.getKeyframeTrackValues( times, curves, initialValue );    return new VectorKeyframeTrack( modelName + '.' + type, times, values );   }   generateRotationTrack( modelName, curves, preRotation, postRotation, eulerOrder ) {    let times;   let values;    if ( curves.x !== undefined && curves.y !== undefined && curves.z !== undefined ) {     const result = this.interpolateRotations( curves.x, curves.y, curves.z, eulerOrder );     times = result[ 0 ];    values = result[ 1 ];    }    // For Maya models using "Joint Orient", Euler order only applies to rotation, not pre/post-rotations   const defaultEulerOrder = getEulerOrder( 0 );    if ( preRotation !== undefined ) {     preRotation = preRotation.map( MathUtils.degToRad );    preRotation.push( defaultEulerOrder );     preRotation = new Euler().fromArray( preRotation );    preRotation = new Quaternion().setFromEuler( preRotation );    }    if ( postRotation !== undefined ) {     postRotation = postRotation.map( MathUtils.degToRad );    postRotation.push( defaultEulerOrder );     postRotation = new Euler().fromArray( postRotation );    postRotation = new Quaternion().setFromEuler( postRotation ).invert();    }    const quaternion = new Quaternion();   const euler = new Euler();    const quaternionValues = [];    if ( ! values || ! times ) return new QuaternionKeyframeTrack( modelName + '.quaternion', [ 0 ], [ 0 ] );    for ( let i = 0; i < values.length; i += 3 ) {     euler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], eulerOrder );    quaternion.setFromEuler( euler );     if ( preRotation !== undefined ) quaternion.premultiply( preRotation );    if ( postRotation !== undefined ) quaternion.multiply( postRotation );     // Check unroll    if ( i > 2 ) {      const prevQuat = new Quaternion().fromArray(      quaternionValues,      ( ( i - 3 ) / 3 ) * 4     );      if ( prevQuat.dot( quaternion ) < 0 ) {       quaternion.set( - quaternion.x, - quaternion.y, - quaternion.z, - quaternion.w );      }     }     quaternion.toArray( quaternionValues, ( i / 3 ) * 4 );    }    return new QuaternionKeyframeTrack( modelName + '.quaternion', times, quaternionValues );   }   generateMorphTrack( rawTracks ) {    const curves = rawTracks.DeformPercent.curves.morph;   const values = curves.values.map( function ( val ) {     return val / 100;    } );    const morphNum = sceneGraph.getObjectByName( rawTracks.modelName ).morphTargetDictionary[ rawTracks.morphName ];    return new NumberKeyframeTrack( rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values );   }   // For all animated objects, times are defined separately for each axis  // Here we'll combine the times into one sorted array without duplicates  getTimesForAllAxes( curves ) {    let times = [];    // first join together the times for each axis, if defined   if ( curves.x !== undefined ) times = times.concat( curves.x.times );   if ( curves.y !== undefined ) times = times.concat( curves.y.times );   if ( curves.z !== undefined ) times = times.concat( curves.z.times );    // then sort them   times = times.sort( function ( a, b ) {     return a - b;    } );    // and remove duplicates   if ( times.length > 1 ) {     let targetIndex = 1;    let lastValue = times[ 0 ];    for ( let i = 1; i < times.length; i ++ ) {      const currentValue = times[ i ];     if ( currentValue !== lastValue ) {       times[ targetIndex ] = currentValue;      lastValue = currentValue;      targetIndex ++;      }     }     times = times.slice( 0, targetIndex );    }    return times;   }   getKeyframeTrackValues( times, curves, initialValue ) {    const prevValue = initialValue;    const values = [];    let xIndex = - 1;   let yIndex = - 1;   let zIndex = - 1;    times.forEach( function ( time ) {     if ( curves.x ) xIndex = curves.x.times.indexOf( time );    if ( curves.y ) yIndex = curves.y.times.indexOf( time );    if ( curves.z ) zIndex = curves.z.times.indexOf( time );     // if there is an x value defined for this frame, use that    if ( xIndex !== - 1 ) {      const xValue = curves.x.values[ xIndex ];     values.push( xValue );     prevValue[ 0 ] = xValue;     } else {      // otherwise use the x value from the previous frame     values.push( prevValue[ 0 ] );     }     if ( yIndex !== - 1 ) {      const yValue = curves.y.values[ yIndex ];     values.push( yValue );     prevValue[ 1 ] = yValue;     } else {      values.push( prevValue[ 1 ] );     }     if ( zIndex !== - 1 ) {      const zValue = curves.z.values[ zIndex ];     values.push( zValue );     prevValue[ 2 ] = zValue;     } else {      values.push( prevValue[ 2 ] );     }    } );    return values;   }   // Rotations are defined as Euler angles which can have values  of any size  // These will be converted to quaternions which don't support values greater than  // PI, so we'll interpolate large rotations  interpolateRotations( curvex, curvey, curvez, eulerOrder ) {    const times = [];   const values = [];    // Add first frame   times.push( curvex.times[ 0 ] );   values.push( MathUtils.degToRad( curvex.values[ 0 ] ) );   values.push( MathUtils.degToRad( curvey.values[ 0 ] ) );   values.push( MathUtils.degToRad( curvez.values[ 0 ] ) );    for ( let i = 1; i < curvex.values.length; i ++ ) {     const initialValue = [     curvex.values[ i - 1 ],     curvey.values[ i - 1 ],     curvez.values[ i - 1 ],    ];     if ( isNaN( initialValue[ 0 ] ) || isNaN( initialValue[ 1 ] ) || isNaN( initialValue[ 2 ] ) ) {      continue;     }     const initialValueRad = initialValue.map( MathUtils.degToRad );     const currentValue = [     curvex.values[ i ],     curvey.values[ i ],     curvez.values[ i ],    ];     if ( isNaN( currentValue[ 0 ] ) || isNaN( currentValue[ 1 ] ) || isNaN( currentValue[ 2 ] ) ) {      continue;     }     const currentValueRad = currentValue.map( MathUtils.degToRad );     const valuesSpan = [     currentValue[ 0 ] - initialValue[ 0 ],     currentValue[ 1 ] - initialValue[ 1 ],     currentValue[ 2 ] - initialValue[ 2 ],    ];     const absoluteSpan = [     Math.abs( valuesSpan[ 0 ] ),     Math.abs( valuesSpan[ 1 ] ),     Math.abs( valuesSpan[ 2 ] ),    ];     if ( absoluteSpan[ 0 ] >= 180 || absoluteSpan[ 1 ] >= 180 || absoluteSpan[ 2 ] >= 180 ) {      const maxAbsSpan = Math.max( ...absoluteSpan );      const numSubIntervals = maxAbsSpan / 180;      const E1 = new Euler( ...initialValueRad, eulerOrder );     const E2 = new Euler( ...currentValueRad, eulerOrder );      const Q1 = new Quaternion().setFromEuler( E1 );     const Q2 = new Quaternion().setFromEuler( E2 );      // Check unroll     if ( Q1.dot( Q2 ) ) {       Q2.set( - Q2.x, - Q2.y, - Q2.z, - Q2.w );      }      // Interpolate     const initialTime = curvex.times[ i - 1 ];     const timeSpan = curvex.times[ i ] - initialTime;      const Q = new Quaternion();     const E = new Euler();     for ( let t = 0; t < 1; t += 1 / numSubIntervals ) {       Q.copy( Q1.clone().slerp( Q2.clone(), t ) );       times.push( initialTime + t * timeSpan );      E.setFromQuaternion( Q, eulerOrder );       values.push( E.x );      values.push( E.y );      values.push( E.z );      }     } else {      times.push( curvex.times[ i ] );     values.push( MathUtils.degToRad( curvex.values[ i ] ) );     values.push( MathUtils.degToRad( curvey.values[ i ] ) );     values.push( MathUtils.degToRad( curvez.values[ i ] ) );     }    }    return [ times, values ];   }  }  // parse an FBX file in ASCII format class TextParser {   getPrevNode() {    return this.nodeStack[ this.currentIndent - 2 ];   }   getCurrentNode() {    return this.nodeStack[ this.currentIndent - 1 ];   }   getCurrentProp() {    return this.currentProp;   }   pushStack( node ) {    this.nodeStack.push( node );   this.currentIndent += 1;   }   popStack() {    this.nodeStack.pop();   this.currentIndent -= 1;   }   setCurrentProp( val, name ) {    this.currentProp = val;   this.currentPropName = name;   }   parse( text ) {    this.currentIndent = 0;    this.allNodes = new FBXTree();   this.nodeStack = [];   this.currentProp = [];   this.currentPropName = '';    const scope = this;    const split = text.split( /[|r|n]+/ );    split.forEach( function ( line, i ) {     const matchComment = line.match( /^[|s|t]*;/ );    const matchEmpty = line.match( /^[|s|t]*$/ );     if ( matchComment || matchEmpty ) return;     const matchBeginning = line.match( '^||t{' + scope.currentIndent + '}(||w+):(.*){', '' );    const matchProperty = line.match( '^||t{' + ( scope.currentIndent ) + '}(||w+):[||s||t||r||n](.*)' );    const matchEnd = line.match( '^||t{' + ( scope.currentIndent - 1 ) + '}}' );     if ( matchBeginning ) {      scope.parseNodeBegin( line, matchBeginning );     } else if ( matchProperty ) {      scope.parseNodeProperty( line, matchProperty, split[ ++ i ] );     } else if ( matchEnd ) {      scope.popStack();     } else if ( line.match( /^[^|s|t}]/ ) ) {      // large arrays are split over multiple lines terminated with a ',' character     // if this is encountered the line needs to be joined to the previous line     scope.parseNodePropertyContinued( line );     }    } );    return this.allNodes;   }   parseNodeBegin( line, property ) {    const nodeName = property[ 1 ].trim().replace( /^"/, '' ).replace( /"$/, '' );    const nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {     return attr.trim().replace( /^"/, '' ).replace( /"$/, '' );    } );    const node = { name: nodeName };   const attrs = this.parseNodeAttr( nodeAttrs );    const currentNode = this.getCurrentNode();    // a top node   if ( this.currentIndent === 0 ) {     this.allNodes.add( nodeName, node );    } else { // a subnode     // if the subnode already exists, append it    if ( nodeName in currentNode ) {      // special case Pose needs PoseNodes as an array     if ( nodeName === 'PoseNode' ) {       currentNode.PoseNode.push( node );      } else if ( currentNode[ nodeName ].id !== undefined ) {       currentNode[ nodeName ] = {};      currentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];      }      if ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node;     } else if ( typeof attrs.id === 'number' ) {      currentNode[ nodeName ] = {};     currentNode[ nodeName ][ attrs.id ] = node;     } else if ( nodeName !== 'Properties70' ) {      if ( nodeName === 'PoseNode' ) currentNode[ nodeName ] = [ node ];     else currentNode[ nodeName ] = node;     }    }    if ( typeof attrs.id === 'number' ) node.id = attrs.id;   if ( attrs.name !== '' ) node.attrName = attrs.name;   if ( attrs.type !== '' ) node.attrType = attrs.type;    this.pushStack( node );   }   parseNodeAttr( attrs ) {    let id = attrs[ 0 ];    if ( attrs[ 0 ] !== '' ) {     id = parseInt( attrs[ 0 ] );     if ( isNaN( id ) ) {      id = attrs[ 0 ];     }    }    let name = '', type = '';    if ( attrs.length > 1 ) {     name = attrs[ 1 ].replace( /^(|w+)::/, '' );    type = attrs[ 2 ];    }    return { id: id, name: name, type: type };   }   parseNodeProperty( line, property, contentLine ) {    let propName = property[ 1 ].replace( /^"/, '' ).replace( /"$/, '' ).trim();   let propValue = property[ 2 ].replace( /^"/, '' ).replace( /"$/, '' ).trim();    // for special case: base64 image data follows "Content: ," line   // Content: ,   //  "/9j/4RDaRXhpZgAATU0A..."   if ( propName === 'Content' && propValue === ',' ) {     propValue = contentLine.replace( /"/g, '' ).replace( /,$/, '' ).trim();    }    const currentNode = this.getCurrentNode();   const parentName = currentNode.name;    if ( parentName === 'Properties70' ) {     this.parseNodeSpecialProperty( line, propName, propValue );    return;    }    // Connections   if ( propName === 'C' ) {     const connProps = propValue.split( ',' ).slice( 1 );    const from = parseInt( connProps[ 0 ] );    const to = parseInt( connProps[ 1 ] );     let rest = propValue.split( ',' ).slice( 3 );     rest = rest.map( function ( elem ) {      return elem.trim().replace( /^"/, '' );     } );     propName = 'connections';    propValue = [ from, to ];    append( propValue, rest );     if ( currentNode[ propName ] === undefined ) {      currentNode[ propName ] = [];     }    }    // Node   if ( propName === 'Node' ) currentNode.id = propValue;    // connections   if ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {     currentNode[ propName ].push( propValue );    } else {     if ( propName !== 'a' ) currentNode[ propName ] = propValue;    else currentNode.a = propValue;    }    this.setCurrentProp( currentNode, propName );    // convert string to array, unless it ends in ',' in which case more will be added to it   if ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) {     currentNode.a = parseNumberArray( propValue );    }   }   parseNodePropertyContinued( line ) {    const currentNode = this.getCurrentNode();    currentNode.a += line;    // if the line doesn't end in ',' we have reached the end of the property value   // so convert the string to an array   if ( line.slice( - 1 ) !== ',' ) {     currentNode.a = parseNumberArray( currentNode.a );    }   }   // parse "Property70"  parseNodeSpecialProperty( line, propName, propValue ) {    // split this   // P: "Lcl Scaling", "Lcl Scaling", "", "A",1,1,1   // into array like below   // ["Lcl Scaling", "Lcl Scaling", "", "A", "1,1,1" ]   const props = propValue.split( '",' ).map( function ( prop ) {     return prop.trim().replace( /^|"/, '' ).replace( /|s/, '_' );    } );    const innerPropName = props[ 0 ];   const innerPropType1 = props[ 1 ];   const innerPropType2 = props[ 2 ];   const innerPropFlag = props[ 3 ];   let innerPropValue = props[ 4 ];    // cast values where needed, otherwise leave as strings   switch ( innerPropType1 ) {     case 'int':    case 'enum':    case 'bool':    case 'ULongLong':    case 'double':    case 'Number':    case 'FieldOfView':     innerPropValue = parseFloat( innerPropValue );     break;     case 'Color':    case 'ColorRGB':    case 'Vector3D':    case 'Lcl_Translation':    case 'Lcl_Rotation':    case 'Lcl_Scaling':     innerPropValue = parseNumberArray( innerPropValue );     break;    }    // CAUTION: these props must append to parent's parent   this.getPrevNode()[ innerPropName ] = {     'type': innerPropType1,    'type2': innerPropType2,    'flag': innerPropFlag,    'value': innerPropValue    };    this.setCurrentProp( this.getPrevNode(), innerPropName );   }  }  // Parse an FBX file in Binary format class BinaryParser {   parse( buffer ) {    const reader = new BinaryReader( buffer );   reader.skip( 23 ); // skip magic 23 bytes    const version = reader.getUint32();    if ( version < 6400 ) {     throw new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + version );    }    const allNodes = new FBXTree();    while ( ! this.endOfContent( reader ) ) {     const node = this.parseNode( reader, version );    if ( node !== null ) allNodes.add( node.name, node );    }    return allNodes;   }   // Check if reader has reached the end of content.  endOfContent( reader ) {    // footer size: 160bytes + 16-byte alignment padding   // - 16bytes: magic   // - padding til 16-byte alignment (at least 1byte?)   // (seems like some exporters embed fixed 15 or 16bytes?)   // - 4bytes: magic   // - 4bytes: version   // - 120bytes: zero   // - 16bytes: magic   if ( reader.size() % 16 === 0 ) {     return ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();    } else {     return reader.getOffset() + 160 + 16 >= reader.size();    }   }   // recursively parse nodes until the end of the file is reached  parseNode( reader, version ) {    const node = {};    // The first three data sizes depends on version.   const endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();   const numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();    ( version >= 7500 ) ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used    const nameLen = reader.getUint8();   const name = reader.getString( nameLen );    // Regards this node as NULL-record if endOffset is zero   if ( endOffset === 0 ) return null;    const propertyList = [];    for ( let i = 0; i < numProperties; i ++ ) {     propertyList.push( this.parseProperty( reader ) );    }    // Regards the first three elements in propertyList as id, attrName, and attrType   const id = propertyList.length > 0 ? propertyList[ 0 ] : '';   const attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';   const attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';    // check if this node represents just a single property   // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}   node.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;    while ( endOffset > reader.getOffset() ) {     const subNode = this.parseNode( reader, version );     if ( subNode !== null ) this.parseSubNode( name, node, subNode );    }    node.propertyList = propertyList; // raw property list used by parent    if ( typeof id === 'number' ) node.id = id;   if ( attrName !== '' ) node.attrName = attrName;   if ( attrType !== '' ) node.attrType = attrType;   if ( name !== '' ) node.name = name;    return node;   }   parseSubNode( name, node, subNode ) {    // special case: child node is single property   if ( subNode.singleProperty === true ) {     const value = subNode.propertyList[ 0 ];     if ( Array.isArray( value ) ) {      node[ subNode.name ] = subNode;      subNode.a = value;     } else {      node[ subNode.name ] = value;     }    } else if ( name === 'Connections' && subNode.name === 'C' ) {     const array = [];     subNode.propertyList.forEach( function ( property, i ) {      // first Connection is FBX type (OO, OP, etc.). We'll discard these     if ( i !== 0 ) array.push( property );     } );     if ( node.connections === undefined ) {      node.connections = [];     }     node.connections.push( array );    } else if ( subNode.name === 'Properties70' ) {     const keys = Object.keys( subNode );     keys.forEach( function ( key ) {      node[ key ] = subNode[ key ];     } );    } else if ( name === 'Properties70' && subNode.name === 'P' ) {     let innerPropName = subNode.propertyList[ 0 ];    let innerPropType1 = subNode.propertyList[ 1 ];    const innerPropType2 = subNode.propertyList[ 2 ];    const innerPropFlag = subNode.propertyList[ 3 ];    let innerPropValue;     if ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );    if ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );     if ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {      innerPropValue = [      subNode.propertyList[ 4 ],      subNode.propertyList[ 5 ],      subNode.propertyList[ 6 ]     ];     } else {      innerPropValue = subNode.propertyList[ 4 ];     }     // this will be copied to parent, see above    node[ innerPropName ] = {      'type': innerPropType1,     'type2': innerPropType2,     'flag': innerPropFlag,     'value': innerPropValue     };    } else if ( node[ subNode.name ] === undefined ) {     if ( typeof subNode.id === 'number' ) {      node[ subNode.name ] = {};     node[ subNode.name ][ subNode.id ] = subNode;     } else {      node[ subNode.name ] = subNode;     }    } else {     if ( subNode.name === 'PoseNode' ) {      if ( ! Array.isArray( node[ subNode.name ] ) ) {       node[ subNode.name ] = [ node[ subNode.name ] ];      }      node[ subNode.name ].push( subNode );     } else if ( node[ subNode.name ][ subNode.id ] === undefined ) {      node[ subNode.name ][ subNode.id ] = subNode;     }    }   }   parseProperty( reader ) {    const type = reader.getString( 1 );   let length;    switch ( type ) {     case 'C':     return reader.getBoolean();     case 'D':     return reader.getFloat64();     case 'F':     return reader.getFloat32();     case 'I':     return reader.getInt32();     case 'L':     return reader.getInt64();     case 'R':     length = reader.getUint32();     return reader.getArrayBuffer( length );     case 'S':     length = reader.getUint32();     return reader.getString( length );     case 'Y':     return reader.getInt16();     case 'b':    case 'c':    case 'd':    case 'f':    case 'i':    case 'l':      const arrayLength = reader.getUint32();     const encoding = reader.getUint32(); // 0: non-compressed, 1: compressed     const compressedLength = reader.getUint32();      if ( encoding === 0 ) {       switch ( type ) {        case 'b':       case 'c':        return reader.getBooleanArray( arrayLength );        case 'd':        return reader.getFloat64Array( arrayLength );        case 'f':        return reader.getFloat32Array( arrayLength );        case 'i':        return reader.getInt32Array( arrayLength );        case 'l':        return reader.getInt64Array( arrayLength );       }      }      const data = fflate.unzlibSync( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) );     const reader2 = new BinaryReader( data.buffer );      switch ( type ) {       case 'b':      case 'c':       return reader2.getBooleanArray( arrayLength );       case 'd':       return reader2.getFloat64Array( arrayLength );       case 'f':       return reader2.getFloat32Array( arrayLength );       case 'i':       return reader2.getInt32Array( arrayLength );       case 'l':       return reader2.getInt64Array( arrayLength );      }      break; // cannot happen but is required by the DeepScan     default:     throw new Error( 'THREE.FBXLoader: Unknown property type ' + type );    }   }  }  class BinaryReader {   constructor( buffer, littleEndian ) {    this.dv = new DataView( buffer );   this.offset = 0;   this.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;   this._textDecoder = new TextDecoder();   }   getOffset() {    return this.offset;   }   size() {    return this.dv.buffer.byteLength;   }   skip( length ) {    this.offset += length;   }   // seems like true/false representation depends on exporter.  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)  // then sees LSB.  getBoolean() {    return ( this.getUint8() & 1 ) === 1;   }   getBooleanArray( size ) {    const a = [];    for ( let i = 0; i < size; i ++ ) {     a.push( this.getBoolean() );    }    return a;   }   getUint8() {    const value = this.dv.getUint8( this.offset );   this.offset += 1;   return value;   }   getInt16() {    const value = this.dv.getInt16( this.offset, this.littleEndian );   this.offset += 2;   return value;   }   getInt32() {    const value = this.dv.getInt32( this.offset, this.littleEndian );   this.offset += 4;   return value;   }   getInt32Array( size ) {    const a = [];    for ( let i = 0; i < size; i ++ ) {     a.push( this.getInt32() );    }    return a;   }   getUint32() {    const value = this.dv.getUint32( this.offset, this.littleEndian );   this.offset += 4;   return value;   }   // JavaScript doesn't support 64-bit integer so calculate this here  // 1 << 32 will return 1 so using multiply operation instead here.  // There's a possibility that this method returns wrong value if the value  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.  // TODO: safely handle 64-bit integer  getInt64() {    let low, high;    if ( this.littleEndian ) {     low = this.getUint32();    high = this.getUint32();    } else {     high = this.getUint32();    low = this.getUint32();    }    // calculate negative value   if ( high & 0x80000000 ) {     high = ~ high & 0xFFFFFFFF;    low = ~ low & 0xFFFFFFFF;     if ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;     low = ( low + 1 ) & 0xFFFFFFFF;     return - ( high * 0x100000000 + low );    }    return high * 0x100000000 + low;   }   getInt64Array( size ) {    const a = [];    for ( let i = 0; i < size; i ++ ) {     a.push( this.getInt64() );    }    return a;   }   // Note: see getInt64() comment  getUint64() {    let low, high;    if ( this.littleEndian ) {     low = this.getUint32();    high = this.getUint32();    } else {     high = this.getUint32();    low = this.getUint32();    }    return high * 0x100000000 + low;   }   getFloat32() {    const value = this.dv.getFloat32( this.offset, this.littleEndian );   this.offset += 4;   return value;   }   getFloat32Array( size ) {    const a = [];    for ( let i = 0; i < size; i ++ ) {     a.push( this.getFloat32() );    }    return a;   }   getFloat64() {    const value = this.dv.getFloat64( this.offset, this.littleEndian );   this.offset += 8;   return value;   }   getFloat64Array( size ) {    const a = [];    for ( let i = 0; i < size; i ++ ) {     a.push( this.getFloat64() );    }    return a;   }   getArrayBuffer( size ) {    const value = this.dv.buffer.slice( this.offset, this.offset + size );   this.offset += size;   return value;   }   getString( size ) {    const start = this.offset;   let a = new Uint8Array( this.dv.buffer, start, size );    this.skip( size );    const nullByte = a.indexOf( 0 );   if ( nullByte >= 0 ) a = new Uint8Array( this.dv.buffer, start, nullByte );    return this._textDecoder.decode( a );   }  }  // FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format) // and BinaryParser( FBX Binary format) class FBXTree {   add( key, val ) {    this[ key ] = val;   }  }  // ************** UTILITY FUNCTIONS **************  function isFbxFormatBinary( buffer ) {   const CORRECT = 'Kaydara|u0020FBX|u0020Binary|u0020|u0020|0';   return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );  }  function isFbxFormatASCII( text ) {   const CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '||', 'F', 'B', 'X', '||', 'B', 'i', 'n', 'a', 'r', 'y', '||', '||' ];   let cursor = 0;   function read( offset ) {    const result = text[ offset - 1 ];   text = text.slice( cursor + offset );   cursor ++;   return result;   }   for ( let i = 0; i < CORRECT.length; ++ i ) {    const num = read( 1 );   if ( num === CORRECT[ i ] ) {     return false;    }   }   return true;  }  function getFbxVersion( text ) {   const versionRegExp = /FBXVersion: (|d+)/;  const match = text.match( versionRegExp );   if ( match ) {    const version = parseInt( match[ 1 ] );   return version;   }   throw new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' );  }  // Converts FBX ticks into real time seconds. function convertFBXTimeToSeconds( time ) {   return time / 46186158000;  }  const dataArray = [];  // extracts the data from the correct position in the FBX array based on indexing type function getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {   let index;   switch ( infoObject.mappingType ) {    case 'ByPolygonVertex' :    index = polygonVertexIndex;    break;   case 'ByPolygon' :    index = polygonIndex;    break;   case 'ByVertice' :    index = vertexIndex;    break;   case 'AllSame' :    index = infoObject.indices[ 0 ];    break;   default :    console.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );   }   if ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];   const from = index * infoObject.dataSize;  const to = from + infoObject.dataSize;   return slice( dataArray, infoObject.buffer, from, to );  }  const tempEuler = new Euler(); const tempVec = new Vector3();  // generate transformation from FBX transform data // ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm // ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e function generateTransform( transformData ) {   const lTranslationM = new Matrix4();  const lPreRotationM = new Matrix4();  const lRotationM = new Matrix4();  const lPostRotationM = new Matrix4();   const lScalingM = new Matrix4();  const lScalingPivotM = new Matrix4();  const lScalingOffsetM = new Matrix4();  const lRotationOffsetM = new Matrix4();  const lRotationPivotM = new Matrix4();   const lParentGX = new Matrix4();  const lParentLX = new Matrix4();  const lGlobalT = new Matrix4();   const inheritType = ( transformData.inheritType ) ? transformData.inheritType : 0;   if ( transformData.translation ) lTranslationM.setPosition( tempVec.fromArray( transformData.translation ) );   // For Maya models using "Joint Orient", Euler order only applies to rotation, not pre/post-rotations  const defaultEulerOrder = getEulerOrder( 0 );   if ( transformData.preRotation ) {    const array = transformData.preRotation.map( MathUtils.degToRad );   array.push( defaultEulerOrder );   lPreRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );   }   if ( transformData.rotation ) {    const array = transformData.rotation.map( MathUtils.degToRad );   array.push( transformData.eulerOrder || defaultEulerOrder );   lRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );   }   if ( transformData.postRotation ) {    const array = transformData.postRotation.map( MathUtils.degToRad );   array.push( defaultEulerOrder );   lPostRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );   lPostRotationM.invert();   }   if ( transformData.scale ) lScalingM.scale( tempVec.fromArray( transformData.scale ) );   // Pivots and offsets  if ( transformData.scalingOffset ) lScalingOffsetM.setPosition( tempVec.fromArray( transformData.scalingOffset ) );  if ( transformData.scalingPivot ) lScalingPivotM.setPosition( tempVec.fromArray( transformData.scalingPivot ) );  if ( transformData.rotationOffset ) lRotationOffsetM.setPosition( tempVec.fromArray( transformData.rotationOffset ) );  if ( transformData.rotationPivot ) lRotationPivotM.setPosition( tempVec.fromArray( transformData.rotationPivot ) );   // parent transform  if ( transformData.parentMatrixWorld ) {    lParentLX.copy( transformData.parentMatrix );   lParentGX.copy( transformData.parentMatrixWorld );   }   const lLRM = lPreRotationM.clone().multiply( lRotationM ).multiply( lPostRotationM );  // Global Rotation  const lParentGRM = new Matrix4();  lParentGRM.extractRotation( lParentGX );   // Global Shear*Scaling  const lParentTM = new Matrix4();  lParentTM.copyPosition( lParentGX );   const lParentGRSM = lParentTM.clone().invert().multiply( lParentGX );  const lParentGSM = lParentGRM.clone().invert().multiply( lParentGRSM );  const lLSM = lScalingM;   const lGlobalRS = new Matrix4();   if ( inheritType === 0 ) {    lGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM ).multiply( lLSM );   } else if ( inheritType === 1 ) {    lGlobalRS.copy( lParentGRM ).multiply( lParentGSM ).multiply( lLRM ).multiply( lLSM );   } else {    const lParentLSM = new Matrix4().scale( new Vector3().setFromMatrixScale( lParentLX ) );   const lParentLSM_inv = lParentLSM.clone().invert();   const lParentGSM_noLocal = lParentGSM.clone().multiply( lParentLSM_inv );    lGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM_noLocal ).multiply( lLSM );   }   const lRotationPivotM_inv = lRotationPivotM.clone().invert();  const lScalingPivotM_inv = lScalingPivotM.clone().invert();  // Calculate the local transform matrix  let lTransform = lTranslationM.clone().multiply( lRotationOffsetM ).multiply( lRotationPivotM ).multiply( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM ).multiply( lRotationPivotM_inv ).multiply( lScalingOffsetM ).multiply( lScalingPivotM ).multiply( lScalingM ).multiply( lScalingPivotM_inv );   const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition( lTransform );   const lGlobalTranslation = lParentGX.clone().multiply( lLocalTWithAllPivotAndOffsetInfo );  lGlobalT.copyPosition( lGlobalTranslation );   lTransform = lGlobalT.clone().multiply( lGlobalRS );   // from global to local  lTransform.premultiply( lParentGX.invert() );   return lTransform;  }  // Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order // ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html function getEulerOrder( order ) {   order = order || 0;   const enums = [   'ZYX', // -> XYZ extrinsic   'YZX', // -> XZY extrinsic   'XZY', // -> YZX extrinsic   'ZXY', // -> YXZ extrinsic   'YXZ', // -> ZXY extrinsic   'XYZ', // -> ZYX extrinsic   //'SphericXYZ', // not possible to support  ];   if ( order === 6 ) {    console.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );   return enums[ 0 ];   }   return enums[ order ];  }  // Parses comma separated list of numbers and returns them an array. // Used internally by the TextParser function parseNumberArray( value ) {   const array = value.split( ',' ).map( function ( val ) {    return parseFloat( val );   } );   return array;  }  function convertArrayBufferToString( buffer, from, to ) {   if ( from === undefined ) from = 0;  if ( to === undefined ) to = buffer.byteLength;   return new TextDecoder().decode( new Uint8Array( buffer, from, to ) );  }  function append( a, b ) {   for ( let i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {    a[ j ] = b[ i ];   }  }  function slice( a, b, from, to ) {   for ( let i = from, j = 0; i < to; i ++, j ++ ) {    a[ j ] = b[ i ];   }   return a;  }   export { FBXLoader }; 
^..^ FILENAME ^..^
addons|loaders|FontLoader.js
^..^ CONTENTS ^..^
import {  FileLoader,  Loader,  ShapePath } from 'three';  class FontLoader extends Loader {   constructor( manager ) {    super( manager );   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( this.manager );   loader.setPath( this.path );   loader.setRequestHeader( this.requestHeader );   loader.setWithCredentials( this.withCredentials );   loader.load( url, function ( text ) {     const font = scope.parse( JSON.parse( text ) );     if ( onLoad ) onLoad( font );    }, onProgress, onError );   }   parse( json ) {    return new Font( json );   }  }  //  class Font {   constructor( data ) {    this.isFont = true;    this.type = 'Font';    this.data = data;   }   generateShapes( text, size = 100 ) {    const shapes = [];   const paths = createPaths( text, size, this.data );    for ( let p = 0, pl = paths.length; p < pl; p ++ ) {     shapes.push( ...paths[ p ].toShapes() );    }    return shapes;   }  }  function createPaths( text, size, data ) {   const chars = Array.from( text );  const scale = size / data.resolution;  const line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;   const paths = [];   let offsetX = 0, offsetY = 0;   for ( let i = 0; i < chars.length; i ++ ) {    const char = chars[ i ];    if ( char === '|n' ) {     offsetX = 0;    offsetY -= line_height;    } else {     const ret = createPath( char, scale, offsetX, offsetY, data );    offsetX += ret.offsetX;    paths.push( ret.path );    }   }   return paths;  }  function createPath( char, scale, offsetX, offsetY, data ) {   const glyph = data.glyphs[ char ] || data.glyphs[ '?' ];   if ( ! glyph ) {    console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );    return;   }   const path = new ShapePath();   let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;   if ( glyph.o ) {    const outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );    for ( let i = 0, l = outline.length; i < l; ) {     const action = outline[ i ++ ];     switch ( action ) {      case 'm': // moveTo       x = outline[ i ++ ] * scale + offsetX;      y = outline[ i ++ ] * scale + offsetY;       path.moveTo( x, y );       break;      case 'l': // lineTo       x = outline[ i ++ ] * scale + offsetX;      y = outline[ i ++ ] * scale + offsetY;       path.lineTo( x, y );       break;      case 'q': // quadraticCurveTo       cpx = outline[ i ++ ] * scale + offsetX;      cpy = outline[ i ++ ] * scale + offsetY;      cpx1 = outline[ i ++ ] * scale + offsetX;      cpy1 = outline[ i ++ ] * scale + offsetY;       path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );       break;      case 'b': // bezierCurveTo       cpx = outline[ i ++ ] * scale + offsetX;      cpy = outline[ i ++ ] * scale + offsetY;      cpx1 = outline[ i ++ ] * scale + offsetX;      cpy1 = outline[ i ++ ] * scale + offsetY;      cpx2 = outline[ i ++ ] * scale + offsetX;      cpy2 = outline[ i ++ ] * scale + offsetY;       path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );       break;     }    }   }   return { offsetX: glyph.ha * scale, path: path };  }  export { FontLoader, Font }; 
^..^ FILENAME ^..^
addons|loaders|GCodeLoader.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  FileLoader,  Float32BufferAttribute,  Group,  LineBasicMaterial,  LineSegments,  Loader } from 'three';  /**  * GCodeLoader is used to load gcode files usually used for 3D printing or CNC applications.  *  * Gcode files are composed by commands used by machines to create objects.  *  * @class GCodeLoader  * @param {Manager} manager Loading manager.  */  class GCodeLoader extends Loader {   constructor( manager ) {    super( manager );    this.splitLayer = false;   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( scope.manager );   loader.setPath( scope.path );   loader.setRequestHeader( scope.requestHeader );   loader.setWithCredentials( scope.withCredentials );   loader.load( url, function ( text ) {     try {      onLoad( scope.parse( text ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( data ) {    let state = { x: 0, y: 0, z: 0, e: 0, f: 0, extruding: false, relative: false };   const layers = [];    let currentLayer = undefined;    const pathMaterial = new LineBasicMaterial( { color: 0xFF0000 } );   pathMaterial.name = 'path';    const extrudingMaterial = new LineBasicMaterial( { color: 0x00FF00 } );   extrudingMaterial.name = 'extruded';    function newLayer( line ) {     currentLayer = { vertex: [], pathVertex: [], z: line.z };    layers.push( currentLayer );    }    //Create lie segment between p1 and p2   function addSegment( p1, p2 ) {     if ( currentLayer === undefined ) {      newLayer( p1 );     }     if ( state.extruding ) {      currentLayer.vertex.push( p1.x, p1.y, p1.z );     currentLayer.vertex.push( p2.x, p2.y, p2.z );     } else {      currentLayer.pathVertex.push( p1.x, p1.y, p1.z );     currentLayer.pathVertex.push( p2.x, p2.y, p2.z );     }    }    function delta( v1, v2 ) {     return state.relative ? v2 : v2 - v1;    }    function absolute( v1, v2 ) {     return state.relative ? v1 + v2 : v2;    }    const lines = data.replace( /;.+/g, '' ).split( '|n' );    for ( let i = 0; i < lines.length; i ++ ) {     const tokens = lines[ i ].split( ' ' );    const cmd = tokens[ 0 ].toUpperCase();     //Argumments    const args = {};    tokens.splice( 1 ).forEach( function ( token ) {      if ( token[ 0 ] !== undefined ) {       const key = token[ 0 ].toLowerCase();      const value = parseFloat( token.substring( 1 ) );      args[ key ] = value;      }     } );     //Process commands    //G0/G1 ?" Linear Movement    if ( cmd === 'G0' || cmd === 'G1' ) {      const line = {      x: args.x !== undefined ? absolute( state.x, args.x ) : state.x,      y: args.y !== undefined ? absolute( state.y, args.y ) : state.y,      z: args.z !== undefined ? absolute( state.z, args.z ) : state.z,      e: args.e !== undefined ? absolute( state.e, args.e ) : state.e,      f: args.f !== undefined ? absolute( state.f, args.f ) : state.f,     };      //Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position     if ( delta( state.e, line.e ) > 0 ) {       state.extruding = delta( state.e, line.e ) > 0;       if ( currentLayer == undefined || line.z != currentLayer.z ) {        newLayer( line );       }      }      addSegment( state, line );     state = line;     } else if ( cmd === 'G2' || cmd === 'G3' ) {      //G2/G3 - Arc Movement ( G2 clock wise and G3 counter clock wise )     //console.warn( 'THREE.GCodeLoader: Arc command not supported' );     } else if ( cmd === 'G90' ) {      //G90: Set to Absolute Positioning     state.relative = false;     } else if ( cmd === 'G91' ) {      //G91: Set to state.relative Positioning     state.relative = true;     } else if ( cmd === 'G92' ) {      //G92: Set Position     const line = state;     line.x = args.x !== undefined ? args.x : line.x;     line.y = args.y !== undefined ? args.y : line.y;     line.z = args.z !== undefined ? args.z : line.z;     line.e = args.e !== undefined ? args.e : line.e;     } else {      //console.warn( 'THREE.GCodeLoader: Command not supported:' + cmd );     }    }    function addObject( vertex, extruding, i ) {     const geometry = new BufferGeometry();    geometry.setAttribute( 'position', new Float32BufferAttribute( vertex, 3 ) );    const segments = new LineSegments( geometry, extruding ? extrudingMaterial : pathMaterial );    segments.name = 'layer' + i;    object.add( segments );    }    const object = new Group();   object.name = 'gcode';    if ( this.splitLayer ) {     for ( let i = 0; i < layers.length; i ++ ) {      const layer = layers[ i ];     addObject( layer.vertex, true, i );     addObject( layer.pathVertex, false, i );     }    } else {     const vertex = [],     pathVertex = [];     for ( let i = 0; i < layers.length; i ++ ) {      const layer = layers[ i ];     const layerVertex = layer.vertex;     const layerPathVertex = layer.pathVertex;      for ( let j = 0; j < layerVertex.length; j ++ ) {       vertex.push( layerVertex[ j ] );      }      for ( let j = 0; j < layerPathVertex.length; j ++ ) {       pathVertex.push( layerPathVertex[ j ] );      }     }     addObject( vertex, true, layers.length );    addObject( pathVertex, false, layers.length );    }    object.rotation.set( - Math.PI / 2, 0, 0 );    return object;   }  }  export { GCodeLoader }; 
^..^ FILENAME ^..^
addons|loaders|GLTFLoader.js
^..^ CONTENTS ^..^
import {  AnimationClip,  Bone,  Box3,  BufferAttribute,  BufferGeometry,  ClampToEdgeWrapping,  Color,  ColorManagement,  DirectionalLight,  DoubleSide,  FileLoader,  FrontSide,  Group,  ImageBitmapLoader,  InstancedMesh,  InterleavedBuffer,  InterleavedBufferAttribute,  Interpolant,  InterpolateDiscrete,  InterpolateLinear,  Line,  LineBasicMaterial,  LineLoop,  LineSegments,  LinearFilter,  LinearMipmapLinearFilter,  LinearMipmapNearestFilter,  LinearSRGBColorSpace,  Loader,  LoaderUtils,  Material,  MathUtils,  Matrix4,  Mesh,  MeshBasicMaterial,  MeshPhysicalMaterial,  MeshStandardMaterial,  MirroredRepeatWrapping,  NearestFilter,  NearestMipmapLinearFilter,  NearestMipmapNearestFilter,  NumberKeyframeTrack,  Object3D,  OrthographicCamera,  PerspectiveCamera,  PointLight,  Points,  PointsMaterial,  PropertyBinding,  Quaternion,  QuaternionKeyframeTrack,  RepeatWrapping,  Skeleton,  SkinnedMesh,  Sphere,  SpotLight,  Texture,  TextureLoader,  TriangleFanDrawMode,  TriangleStripDrawMode,  Vector2,  Vector3,  VectorKeyframeTrack,  SRGBColorSpace,  InstancedBufferAttribute } from 'three'; import { toTrianglesDrawMode } from '../utils/BufferGeometryUtils.js';  class GLTFLoader extends Loader {   constructor( manager ) {    super( manager );    this.dracoLoader = null;   this.ktx2Loader = null;   this.meshoptDecoder = null;    this.pluginCallbacks = [];    this.register( function ( parser ) {     return new GLTFMaterialsClearcoatExtension( parser );    } );    this.register( function ( parser ) {     return new GLTFMaterialsDispersionExtension( parser );    } );    this.register( function ( parser ) {     return new GLTFTextureBasisUExtension( parser );    } );    this.register( function ( parser ) {     return new GLTFTextureWebPExtension( parser );    } );    this.register( function ( parser ) {     return new GLTFTextureAVIFExtension( parser );    } );    this.register( function ( parser ) {     return new GLTFMaterialsSheenExtension( parser );    } );    this.register( function ( parser ) {     return new GLTFMaterialsTransmissionExtension( parser );    } );    this.register( function ( parser ) {     return new GLTFMaterialsVolumeExtension( parser );    } );    this.register( function ( parser ) {     return new GLTFMaterialsIorExtension( parser );    } );    this.register( function ( parser ) {     return new GLTFMaterialsEmissiveStrengthExtension( parser );    } );    this.register( function ( parser ) {     return new GLTFMaterialsSpecularExtension( parser );    } );    this.register( function ( parser ) {     return new GLTFMaterialsIridescenceExtension( parser );    } );    this.register( function ( parser ) {     return new GLTFMaterialsAnisotropyExtension( parser );    } );    this.register( function ( parser ) {     return new GLTFMaterialsBumpExtension( parser );    } );    this.register( function ( parser ) {     return new GLTFLightsExtension( parser );    } );    this.register( function ( parser ) {     return new GLTFMeshoptCompression( parser );    } );    this.register( function ( parser ) {     return new GLTFMeshGpuInstancing( parser );    } );   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    let resourcePath;    if ( this.resourcePath !== '' ) {     resourcePath = this.resourcePath;    } else if ( this.path !== '' ) {     // If a base path is set, resources will be relative paths from that plus the relative path of the gltf file    // Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'    // resourcePath = 'https://my-cnd-server.com/assets/models/'    // referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'    // referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'    const relativeUrl = LoaderUtils.extractUrlBase( url );    resourcePath = LoaderUtils.resolveURL( relativeUrl, this.path );    } else {     resourcePath = LoaderUtils.extractUrlBase( url );    }    // Tells the LoadingManager to track an extra item, which resolves after   // the model is fully loaded. This means the count of items loaded will   // be incorrect, but ensures manager.onLoad() does not fire early.   this.manager.itemStart( url );    const _onError = function ( e ) {     if ( onError ) {      onError( e );     } else {      console.error( e );     }     scope.manager.itemError( url );    scope.manager.itemEnd( url );    };    const loader = new FileLoader( this.manager );    loader.setPath( this.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( this.requestHeader );   loader.setWithCredentials( this.withCredentials );    loader.load( url, function ( data ) {     try {      scope.parse( data, resourcePath, function ( gltf ) {       onLoad( gltf );       scope.manager.itemEnd( url );      }, _onError );     } catch ( e ) {      _onError( e );     }    }, onProgress, _onError );   }   setDRACOLoader( dracoLoader ) {    this.dracoLoader = dracoLoader;   return this;   }   setKTX2Loader( ktx2Loader ) {    this.ktx2Loader = ktx2Loader;   return this;   }   setMeshoptDecoder( meshoptDecoder ) {    this.meshoptDecoder = meshoptDecoder;   return this;   }   register( callback ) {    if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {     this.pluginCallbacks.push( callback );    }    return this;   }   unregister( callback ) {    if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {     this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );    }    return this;   }   parse( data, path, onLoad, onError ) {    let json;   const extensions = {};   const plugins = {};   const textDecoder = new TextDecoder();    if ( typeof data === 'string' ) {     json = JSON.parse( data );    } else if ( data instanceof ArrayBuffer ) {     const magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );     if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {      try {       extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );      } catch ( error ) {       if ( onError ) onError( error );      return;      }      json = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );     } else {      json = JSON.parse( textDecoder.decode( data ) );     }    } else {     json = data;    }    if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {     if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );    return;    }    const parser = new GLTFParser( json, {     path: path || this.resourcePath || '',    crossOrigin: this.crossOrigin,    requestHeader: this.requestHeader,    manager: this.manager,    ktx2Loader: this.ktx2Loader,    meshoptDecoder: this.meshoptDecoder    } );    parser.fileLoader.setRequestHeader( this.requestHeader );    for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {     const plugin = this.pluginCallbacks[ i ]( parser );     if ( ! plugin.name ) console.error( 'THREE.GLTFLoader: Invalid plugin found: missing name' );     plugins[ plugin.name ] = plugin;     // Workaround to avoid determining as unknown extension    // in addUnknownExtensionsToUserData().    // Remove this workaround if we move all the existing    // extension handlers to plugin system    extensions[ plugin.name ] = true;    }    if ( json.extensionsUsed ) {     for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {      const extensionName = json.extensionsUsed[ i ];     const extensionsRequired = json.extensionsRequired || [];      switch ( extensionName ) {       case EXTENSIONS.KHR_MATERIALS_UNLIT:       extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();       break;       case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:       extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );       break;       case EXTENSIONS.KHR_TEXTURE_TRANSFORM:       extensions[ extensionName ] = new GLTFTextureTransformExtension();       break;       case EXTENSIONS.KHR_MESH_QUANTIZATION:       extensions[ extensionName ] = new GLTFMeshQuantizationExtension();       break;       default:        if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {         console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );        }      }     }    }    parser.setExtensions( extensions );   parser.setPlugins( plugins );   parser.parse( onLoad, onError );   }   parseAsync( data, path ) {    const scope = this;    return new Promise( function ( resolve, reject ) {     scope.parse( data, path, resolve, reject );    } );   }  }  /* GLTFREGISTRY */  function GLTFRegistry() {   let objects = {};   return {    get: function ( key ) {     return objects[ key ];    },    add: function ( key, object ) {     objects[ key ] = object;    },    remove: function ( key ) {     delete objects[ key ];    },    removeAll: function () {     objects = {};    }   };  }  /*********************************/ /********** EXTENSIONS ***********/ /*********************************/  const EXTENSIONS = {  KHR_BINARY_GLTF: 'KHR_binary_glTF',  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',  KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',  KHR_MATERIALS_IOR: 'KHR_materials_ior',  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',  KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',  EXT_MATERIALS_BUMP: 'EXT_materials_bump',  EXT_TEXTURE_WEBP: 'EXT_texture_webp',  EXT_TEXTURE_AVIF: 'EXT_texture_avif',  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',  EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing' };  /**  * Punctual Lights Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual  */ class GLTFLightsExtension {   constructor( parser ) {    this.parser = parser;   this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;    // Object3D instance caches   this.cache = { refs: {}, uses: {} };   }   _markDefs() {    const parser = this.parser;   const nodeDefs = this.parser.json.nodes || [];    for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {     const nodeDef = nodeDefs[ nodeIndex ];     if ( nodeDef.extensions      && nodeDef.extensions[ this.name ]      && nodeDef.extensions[ this.name ].light !== undefined ) {      parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );     }    }   }   _loadLight( lightIndex ) {    const parser = this.parser;   const cacheKey = 'light:' + lightIndex;   let dependency = parser.cache.get( cacheKey );    if ( dependency ) return dependency;    const json = parser.json;   const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};   const lightDefs = extensions.lights || [];   const lightDef = lightDefs[ lightIndex ];   let lightNode;    const color = new Color( 0xffffff );    if ( lightDef.color !== undefined ) color.setRGB( lightDef.color[ 0 ], lightDef.color[ 1 ], lightDef.color[ 2 ], LinearSRGBColorSpace );    const range = lightDef.range !== undefined ? lightDef.range : 0;    switch ( lightDef.type ) {     case 'directional':     lightNode = new DirectionalLight( color );     lightNode.target.position.set( 0, 0, - 1 );     lightNode.add( lightNode.target );     break;     case 'point':     lightNode = new PointLight( color );     lightNode.distance = range;     break;     case 'spot':     lightNode = new SpotLight( color );     lightNode.distance = range;     // Handle spotlight properties.     lightDef.spot = lightDef.spot || {};     lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;     lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;     lightNode.angle = lightDef.spot.outerConeAngle;     lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;     lightNode.target.position.set( 0, 0, - 1 );     lightNode.add( lightNode.target );     break;     default:     throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );    }    // Some lights (e.g. spot) default to a position other than the origin. Reset the position   // here, because node-level parsing will only override position if explicitly specified.   lightNode.position.set( 0, 0, 0 );    lightNode.decay = 2;    assignExtrasToUserData( lightNode, lightDef );    if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;    lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );    dependency = Promise.resolve( lightNode );    parser.cache.add( cacheKey, dependency );    return dependency;   }   getDependency( type, index ) {    if ( type !== 'light' ) return;    return this._loadLight( index );   }   createNodeAttachment( nodeIndex ) {    const self = this;   const parser = this.parser;   const json = parser.json;   const nodeDef = json.nodes[ nodeIndex ];   const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};   const lightIndex = lightDef.light;    if ( lightIndex === undefined ) return null;    return this._loadLight( lightIndex ).then( function ( light ) {     return parser._getNodeRef( self.cache, lightIndex, light );    } );   }  }  /**  * Unlit Materials Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit  */ class GLTFMaterialsUnlitExtension {   constructor() {    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;   }   getMaterialType() {    return MeshBasicMaterial;   }   extendParams( materialParams, materialDef, parser ) {    const pending = [];    materialParams.color = new Color( 1.0, 1.0, 1.0 );   materialParams.opacity = 1.0;    const metallicRoughness = materialDef.pbrMetallicRoughness;    if ( metallicRoughness ) {     if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {      const array = metallicRoughness.baseColorFactor;      materialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );     materialParams.opacity = array[ 3 ];     }     if ( metallicRoughness.baseColorTexture !== undefined ) {      pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );     }    }    return Promise.all( pending );   }  }  /**  * Materials Emissive Strength Extension  *  * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md  */ class GLTFMaterialsEmissiveStrengthExtension {   constructor( parser ) {    this.parser = parser;   this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;   }   extendMaterialParams( materialIndex, materialParams ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {     return Promise.resolve();    }    const emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;    if ( emissiveStrength !== undefined ) {     materialParams.emissiveIntensity = emissiveStrength;    }    return Promise.resolve();   }  }  /**  * Clearcoat Materials Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat  */ class GLTFMaterialsClearcoatExtension {   constructor( parser ) {    this.parser = parser;   this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;   }   getMaterialType( materialIndex ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;    return MeshPhysicalMaterial;   }   extendMaterialParams( materialIndex, materialParams ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {     return Promise.resolve();    }    const pending = [];    const extension = materialDef.extensions[ this.name ];    if ( extension.clearcoatFactor !== undefined ) {     materialParams.clearcoat = extension.clearcoatFactor;    }    if ( extension.clearcoatTexture !== undefined ) {     pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );    }    if ( extension.clearcoatRoughnessFactor !== undefined ) {     materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;    }    if ( extension.clearcoatRoughnessTexture !== undefined ) {     pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );    }    if ( extension.clearcoatNormalTexture !== undefined ) {     pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );     if ( extension.clearcoatNormalTexture.scale !== undefined ) {      const scale = extension.clearcoatNormalTexture.scale;      materialParams.clearcoatNormalScale = new Vector2( scale, scale );     }    }    return Promise.all( pending );   }  }  /**  * Materials dispersion Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion  */ class GLTFMaterialsDispersionExtension {   constructor( parser ) {    this.parser = parser;   this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;   }   getMaterialType( materialIndex ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;    return MeshPhysicalMaterial;   }   extendMaterialParams( materialIndex, materialParams ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {     return Promise.resolve();    }    const extension = materialDef.extensions[ this.name ];    materialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0;    return Promise.resolve();   }  }  /**  * Iridescence Materials Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence  */ class GLTFMaterialsIridescenceExtension {   constructor( parser ) {    this.parser = parser;   this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;   }   getMaterialType( materialIndex ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;    return MeshPhysicalMaterial;   }   extendMaterialParams( materialIndex, materialParams ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {     return Promise.resolve();    }    const pending = [];    const extension = materialDef.extensions[ this.name ];    if ( extension.iridescenceFactor !== undefined ) {     materialParams.iridescence = extension.iridescenceFactor;    }    if ( extension.iridescenceTexture !== undefined ) {     pending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );    }    if ( extension.iridescenceIor !== undefined ) {     materialParams.iridescenceIOR = extension.iridescenceIor;    }    if ( materialParams.iridescenceThicknessRange === undefined ) {     materialParams.iridescenceThicknessRange = [ 100, 400 ];    }    if ( extension.iridescenceThicknessMinimum !== undefined ) {     materialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;    }    if ( extension.iridescenceThicknessMaximum !== undefined ) {     materialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;    }    if ( extension.iridescenceThicknessTexture !== undefined ) {     pending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );    }    return Promise.all( pending );   }  }  /**  * Sheen Materials Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen  */ class GLTFMaterialsSheenExtension {   constructor( parser ) {    this.parser = parser;   this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;   }   getMaterialType( materialIndex ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;    return MeshPhysicalMaterial;   }   extendMaterialParams( materialIndex, materialParams ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {     return Promise.resolve();    }    const pending = [];    materialParams.sheenColor = new Color( 0, 0, 0 );   materialParams.sheenRoughness = 0;   materialParams.sheen = 1;    const extension = materialDef.extensions[ this.name ];    if ( extension.sheenColorFactor !== undefined ) {     const colorFactor = extension.sheenColorFactor;    materialParams.sheenColor.setRGB( colorFactor[ 0 ], colorFactor[ 1 ], colorFactor[ 2 ], LinearSRGBColorSpace );    }    if ( extension.sheenRoughnessFactor !== undefined ) {     materialParams.sheenRoughness = extension.sheenRoughnessFactor;    }    if ( extension.sheenColorTexture !== undefined ) {     pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) );    }    if ( extension.sheenRoughnessTexture !== undefined ) {     pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );    }    return Promise.all( pending );   }  }  /**  * Transmission Materials Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission  * Draft: https://github.com/KhronosGroup/glTF/pull/1698  */ class GLTFMaterialsTransmissionExtension {   constructor( parser ) {    this.parser = parser;   this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;   }   getMaterialType( materialIndex ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;    return MeshPhysicalMaterial;   }   extendMaterialParams( materialIndex, materialParams ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {     return Promise.resolve();    }    const pending = [];    const extension = materialDef.extensions[ this.name ];    if ( extension.transmissionFactor !== undefined ) {     materialParams.transmission = extension.transmissionFactor;    }    if ( extension.transmissionTexture !== undefined ) {     pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );    }    return Promise.all( pending );   }  }  /**  * Materials Volume Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume  */ class GLTFMaterialsVolumeExtension {   constructor( parser ) {    this.parser = parser;   this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;   }   getMaterialType( materialIndex ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;    return MeshPhysicalMaterial;   }   extendMaterialParams( materialIndex, materialParams ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {     return Promise.resolve();    }    const pending = [];    const extension = materialDef.extensions[ this.name ];    materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;    if ( extension.thicknessTexture !== undefined ) {     pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );    }    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;    const colorArray = extension.attenuationColor || [ 1, 1, 1 ];   materialParams.attenuationColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );    return Promise.all( pending );   }  }  /**  * Materials ior Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior  */ class GLTFMaterialsIorExtension {   constructor( parser ) {    this.parser = parser;   this.name = EXTENSIONS.KHR_MATERIALS_IOR;   }   getMaterialType( materialIndex ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;    return MeshPhysicalMaterial;   }   extendMaterialParams( materialIndex, materialParams ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {     return Promise.resolve();    }    const extension = materialDef.extensions[ this.name ];    materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;    return Promise.resolve();   }  }  /**  * Materials specular Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular  */ class GLTFMaterialsSpecularExtension {   constructor( parser ) {    this.parser = parser;   this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;   }   getMaterialType( materialIndex ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;    return MeshPhysicalMaterial;   }   extendMaterialParams( materialIndex, materialParams ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {     return Promise.resolve();    }    const pending = [];    const extension = materialDef.extensions[ this.name ];    materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;    if ( extension.specularTexture !== undefined ) {     pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );    }    const colorArray = extension.specularColorFactor || [ 1, 1, 1 ];   materialParams.specularColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );    if ( extension.specularColorTexture !== undefined ) {     pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) );    }    return Promise.all( pending );   }  }   /**  * Materials bump Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump  */ class GLTFMaterialsBumpExtension {   constructor( parser ) {    this.parser = parser;   this.name = EXTENSIONS.EXT_MATERIALS_BUMP;   }   getMaterialType( materialIndex ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;    return MeshPhysicalMaterial;   }   extendMaterialParams( materialIndex, materialParams ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {     return Promise.resolve();    }    const pending = [];    const extension = materialDef.extensions[ this.name ];    materialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0;    if ( extension.bumpTexture !== undefined ) {     pending.push( parser.assignTexture( materialParams, 'bumpMap', extension.bumpTexture ) );    }    return Promise.all( pending );   }  }  /**  * Materials anisotropy Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy  */ class GLTFMaterialsAnisotropyExtension {   constructor( parser ) {    this.parser = parser;   this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;   }   getMaterialType( materialIndex ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;    return MeshPhysicalMaterial;   }   extendMaterialParams( materialIndex, materialParams ) {    const parser = this.parser;   const materialDef = parser.json.materials[ materialIndex ];    if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {     return Promise.resolve();    }    const pending = [];    const extension = materialDef.extensions[ this.name ];    if ( extension.anisotropyStrength !== undefined ) {     materialParams.anisotropy = extension.anisotropyStrength;    }    if ( extension.anisotropyRotation !== undefined ) {     materialParams.anisotropyRotation = extension.anisotropyRotation;    }    if ( extension.anisotropyTexture !== undefined ) {     pending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) );    }    return Promise.all( pending );   }  }  /**  * BasisU Texture Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu  */ class GLTFTextureBasisUExtension {   constructor( parser ) {    this.parser = parser;   this.name = EXTENSIONS.KHR_TEXTURE_BASISU;   }   loadTexture( textureIndex ) {    const parser = this.parser;   const json = parser.json;    const textureDef = json.textures[ textureIndex ];    if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {     return null;    }    const extension = textureDef.extensions[ this.name ];   const loader = parser.options.ktx2Loader;    if ( ! loader ) {     if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {      throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );     } else {      // Assumes that the extension is optional and that a fallback texture is present     return null;     }    }    return parser.loadTextureImage( textureIndex, extension.source, loader );   }  }  /**  * WebP Texture Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp  */ class GLTFTextureWebPExtension {   constructor( parser ) {    this.parser = parser;   this.name = EXTENSIONS.EXT_TEXTURE_WEBP;   this.isSupported = null;   }   loadTexture( textureIndex ) {    const name = this.name;   const parser = this.parser;   const json = parser.json;    const textureDef = json.textures[ textureIndex ];    if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {     return null;    }    const extension = textureDef.extensions[ name ];   const source = json.images[ extension.source ];    let loader = parser.textureLoader;   if ( source.uri ) {     const handler = parser.options.manager.getHandler( source.uri );    if ( handler !== null ) loader = handler;    }    return this.detectSupport().then( function ( isSupported ) {     if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );     if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {      throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );     }     // Fall back to PNG or JPEG.    return parser.loadTexture( textureIndex );    } );   }   detectSupport() {    if ( ! this.isSupported ) {     this.isSupported = new Promise( function ( resolve ) {      const image = new Image();      // Lossy test image. Support for lossy images doesn't guarantee support for all     // WebP images, unfortunately.     image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';      image.onload = image.onerror = function () {       resolve( image.height === 1 );      };     } );    }    return this.isSupported;   }  }  /**  * AVIF Texture Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif  */ class GLTFTextureAVIFExtension {   constructor( parser ) {    this.parser = parser;   this.name = EXTENSIONS.EXT_TEXTURE_AVIF;   this.isSupported = null;   }   loadTexture( textureIndex ) {    const name = this.name;   const parser = this.parser;   const json = parser.json;    const textureDef = json.textures[ textureIndex ];    if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {     return null;    }    const extension = textureDef.extensions[ name ];   const source = json.images[ extension.source ];    let loader = parser.textureLoader;   if ( source.uri ) {     const handler = parser.options.manager.getHandler( source.uri );    if ( handler !== null ) loader = handler;    }    return this.detectSupport().then( function ( isSupported ) {     if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );     if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {      throw new Error( 'THREE.GLTFLoader: AVIF required by asset but unsupported.' );     }     // Fall back to PNG or JPEG.    return parser.loadTexture( textureIndex );    } );   }   detectSupport() {    if ( ! this.isSupported ) {     this.isSupported = new Promise( function ( resolve ) {      const image = new Image();      // Lossy test image.     image.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=';     image.onload = image.onerror = function () {       resolve( image.height === 1 );      };     } );    }    return this.isSupported;   }  }  /**  * meshopt BufferView Compression Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression  */ class GLTFMeshoptCompression {   constructor( parser ) {    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;   this.parser = parser;   }   loadBufferView( index ) {    const json = this.parser.json;   const bufferView = json.bufferViews[ index ];    if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {     const extensionDef = bufferView.extensions[ this.name ];     const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );    const decoder = this.parser.options.meshoptDecoder;     if ( ! decoder || ! decoder.supported ) {      if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {       throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );      } else {       // Assumes that the extension is optional and that fallback buffer data is present      return null;      }     }     return buffer.then( function ( res ) {      const byteOffset = extensionDef.byteOffset || 0;     const byteLength = extensionDef.byteLength || 0;      const count = extensionDef.count;     const stride = extensionDef.byteStride;      const source = new Uint8Array( res, byteOffset, byteLength );      if ( decoder.decodeGltfBufferAsync ) {       return decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {        return res.buffer;       } );      } else {       // Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync      return decoder.ready.then( function () {        const result = new ArrayBuffer( count * stride );       decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );       return result;       } );      }     } );    } else {     return null;    }   }  }  /**  * GPU Instancing Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing  *  */ class GLTFMeshGpuInstancing {   constructor( parser ) {    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;   this.parser = parser;   }   createNodeMesh( nodeIndex ) {    const json = this.parser.json;   const nodeDef = json.nodes[ nodeIndex ];    if ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||    nodeDef.mesh === undefined ) {     return null;    }    const meshDef = json.meshes[ nodeDef.mesh ];    // No Points or Lines + Instancing support yet    for ( const primitive of meshDef.primitives ) {     if ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&      primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&      primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&      primitive.mode !== undefined ) {      return null;     }    }    const extensionDef = nodeDef.extensions[ this.name ];   const attributesDef = extensionDef.attributes;    // @TODO: Can we support InstancedMesh + SkinnedMesh?    const pending = [];   const attributes = {};    for ( const key in attributesDef ) {     pending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {      attributes[ key ] = accessor;     return attributes[ key ];     } ) );    }    if ( pending.length < 1 ) {     return null;    }    pending.push( this.parser.createNodeMesh( nodeIndex ) );    return Promise.all( pending ).then( results => {     const nodeObject = results.pop();    const meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];    const count = results[ 0 ].count; // All attribute counts should be same    const instancedMeshes = [];     for ( const mesh of meshes ) {      // Temporal variables     const m = new Matrix4();     const p = new Vector3();     const q = new Quaternion();     const s = new Vector3( 1, 1, 1 );      const instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );      for ( let i = 0; i < count; i ++ ) {       if ( attributes.TRANSLATION ) {        p.fromBufferAttribute( attributes.TRANSLATION, i );       }       if ( attributes.ROTATION ) {        q.fromBufferAttribute( attributes.ROTATION, i );       }       if ( attributes.SCALE ) {        s.fromBufferAttribute( attributes.SCALE, i );       }       instancedMesh.setMatrixAt( i, m.compose( p, q, s ) );      }      // Add instance attributes to the geometry, excluding TRS.     for ( const attributeName in attributes ) {       if ( attributeName === '_COLOR_0' ) {        const attr = attributes[ attributeName ];       instancedMesh.instanceColor = new InstancedBufferAttribute( attr.array, attr.itemSize, attr.normalized );       } else if ( attributeName !== 'TRANSLATION' &&        attributeName !== 'ROTATION' &&        attributeName !== 'SCALE' ) {        mesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );       }      }      // Just in case     Object3D.prototype.copy.call( instancedMesh, mesh );      this.parser.assignFinalMaterial( instancedMesh );      instancedMeshes.push( instancedMesh );     }     if ( nodeObject.isGroup ) {      nodeObject.clear();      nodeObject.add( ... instancedMeshes );      return nodeObject;     }     return instancedMeshes[ 0 ];    } );   }  }  /* BINARY EXTENSION */ const BINARY_EXTENSION_HEADER_MAGIC = 'glTF'; const BINARY_EXTENSION_HEADER_LENGTH = 12; const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };  class GLTFBinaryExtension {   constructor( data ) {    this.name = EXTENSIONS.KHR_BINARY_GLTF;   this.content = null;   this.body = null;    const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );   const textDecoder = new TextDecoder();    this.header = {    magic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),    version: headerView.getUint32( 4, true ),    length: headerView.getUint32( 8, true )   };    if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {     throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );    } else if ( this.header.version < 2.0 ) {     throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );    }    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;   const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );   let chunkIndex = 0;    while ( chunkIndex < chunkContentsLength ) {     const chunkLength = chunkView.getUint32( chunkIndex, true );    chunkIndex += 4;     const chunkType = chunkView.getUint32( chunkIndex, true );    chunkIndex += 4;     if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {      const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );     this.content = textDecoder.decode( contentArray );     } else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {      const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;     this.body = data.slice( byteOffset, byteOffset + chunkLength );     }     // Clients must ignore chunks with unknown types.     chunkIndex += chunkLength;    }    if ( this.content === null ) {     throw new Error( 'THREE.GLTFLoader: JSON content not found.' );    }   }  }  /**  * DRACO Mesh Compression Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression  */ class GLTFDracoMeshCompressionExtension {   constructor( json, dracoLoader ) {    if ( ! dracoLoader ) {     throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );    }    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;   this.json = json;   this.dracoLoader = dracoLoader;   this.dracoLoader.preload();   }   decodePrimitive( primitive, parser ) {    const json = this.json;   const dracoLoader = this.dracoLoader;   const bufferViewIndex = primitive.extensions[ this.name ].bufferView;   const gltfAttributeMap = primitive.extensions[ this.name ].attributes;   const threeAttributeMap = {};   const attributeNormalizedMap = {};   const attributeTypeMap = {};    for ( const attributeName in gltfAttributeMap ) {     const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();     threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];    }    for ( const attributeName in primitive.attributes ) {     const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();     if ( gltfAttributeMap[ attributeName ] !== undefined ) {      const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];     const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];      attributeTypeMap[ threeAttributeName ] = componentType.name;     attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;     }    }    return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {     return new Promise( function ( resolve, reject ) {      dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {       for ( const attributeName in geometry.attributes ) {        const attribute = geometry.attributes[ attributeName ];       const normalized = attributeNormalizedMap[ attributeName ];        if ( normalized !== undefined ) attribute.normalized = normalized;       }       resolve( geometry );      }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject );     } );    } );   }  }  /**  * Texture Transform Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform  */ class GLTFTextureTransformExtension {   constructor() {    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;   }   extendTexture( texture, transform ) {    if ( ( transform.texCoord === undefined || transform.texCoord === texture.channel )    && transform.offset === undefined    && transform.rotation === undefined    && transform.scale === undefined ) {     // See https://github.com/mrdoob/three.js/issues/21819.    return texture;    }    texture = texture.clone();    if ( transform.texCoord !== undefined ) {     texture.channel = transform.texCoord;    }    if ( transform.offset !== undefined ) {     texture.offset.fromArray( transform.offset );    }    if ( transform.rotation !== undefined ) {     texture.rotation = transform.rotation;    }    if ( transform.scale !== undefined ) {     texture.repeat.fromArray( transform.scale );    }    texture.needsUpdate = true;    return texture;   }  }  /**  * Mesh Quantization Extension  *  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization  */ class GLTFMeshQuantizationExtension {   constructor() {    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;   }  }  /*********************************/ /********** INTERPOLATION ********/ /*********************************/  // Spline Interpolation // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation class GLTFCubicSplineInterpolant extends Interpolant {   constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {    super( parameterPositions, sampleValues, sampleSize, resultBuffer );   }   copySampleValue_( index ) {    // Copies a sample value to the result buffer. See description of glTF   // CUBICSPLINE values layout in interpolate_() function below.    const result = this.resultBuffer,    values = this.sampleValues,    valueSize = this.valueSize,    offset = index * valueSize * 3 + valueSize;    for ( let i = 0; i !== valueSize; i ++ ) {     result[ i ] = values[ offset + i ];    }    return result;   }   interpolate_( i1, t0, t, t1 ) {    const result = this.resultBuffer;   const values = this.sampleValues;   const stride = this.valueSize;    const stride2 = stride * 2;   const stride3 = stride * 3;    const td = t1 - t0;    const p = ( t - t0 ) / td;   const pp = p * p;   const ppp = pp * p;    const offset1 = i1 * stride3;   const offset0 = offset1 - stride3;    const s2 = - 2 * ppp + 3 * pp;   const s3 = ppp - pp;   const s0 = 1 - s2;   const s1 = s3 - pp + p;    // Layout of keyframe output values for CUBICSPLINE animations:   //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]   for ( let i = 0; i !== stride; i ++ ) {     const p0 = values[ offset0 + i + stride ]; // splineVertex_k    const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)    const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1    const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)     result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;    }    return result;   }  }  const _q = new Quaternion();  class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {   interpolate_( i1, t0, t, t1 ) {    const result = super.interpolate_( i1, t0, t, t1 );    _q.fromArray( result ).normalize().toArray( result );    return result;   }  }   /*********************************/ /********** INTERNALS ************/ /*********************************/  /* CONSTANTS */  const WEBGL_CONSTANTS = {  FLOAT: 5126,  //FLOAT_MAT2: 35674,  FLOAT_MAT3: 35675,  FLOAT_MAT4: 35676,  FLOAT_VEC2: 35664,  FLOAT_VEC3: 35665,  FLOAT_VEC4: 35666,  LINEAR: 9729,  REPEAT: 10497,  SAMPLER_2D: 35678,  POINTS: 0,  LINES: 1,  LINE_LOOP: 2,  LINE_STRIP: 3,  TRIANGLES: 4,  TRIANGLE_STRIP: 5,  TRIANGLE_FAN: 6,  UNSIGNED_BYTE: 5121,  UNSIGNED_SHORT: 5123 };  const WEBGL_COMPONENT_TYPES = {  5120: Int8Array,  5121: Uint8Array,  5122: Int16Array,  5123: Uint16Array,  5125: Uint32Array,  5126: Float32Array };  const WEBGL_FILTERS = {  9728: NearestFilter,  9729: LinearFilter,  9984: NearestMipmapNearestFilter,  9985: LinearMipmapNearestFilter,  9986: NearestMipmapLinearFilter,  9987: LinearMipmapLinearFilter };  const WEBGL_WRAPPINGS = {  33071: ClampToEdgeWrapping,  33648: MirroredRepeatWrapping,  10497: RepeatWrapping };  const WEBGL_TYPE_SIZES = {  'SCALAR': 1,  'VEC2': 2,  'VEC3': 3,  'VEC4': 4,  'MAT2': 4,  'MAT3': 9,  'MAT4': 16 };  const ATTRIBUTES = {  POSITION: 'position',  NORMAL: 'normal',  TANGENT: 'tangent',  TEXCOORD_0: 'uv',  TEXCOORD_1: 'uv1',  TEXCOORD_2: 'uv2',  TEXCOORD_3: 'uv3',  COLOR_0: 'color',  WEIGHTS_0: 'skinWeight',  JOINTS_0: 'skinIndex', };  const PATH_PROPERTIES = {  scale: 'scale',  translation: 'position',  rotation: 'quaternion',  weights: 'morphTargetInfluences' };  const INTERPOLATION = {  CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each                           // keyframe track will be initialized with a default interpolation type, then modified.  LINEAR: InterpolateLinear,  STEP: InterpolateDiscrete };  const ALPHA_MODES = {  OPAQUE: 'OPAQUE',  MASK: 'MASK',  BLEND: 'BLEND' };  /**  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material  */ function createDefaultMaterial( cache ) {   if ( cache[ 'DefaultMaterial' ] === undefined ) {    cache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {    color: 0xFFFFFF,    emissive: 0x000000,    metalness: 1,    roughness: 1,    transparent: false,    depthTest: true,    side: FrontSide   } );   }   return cache[ 'DefaultMaterial' ];  }  function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {   // Add unknown glTF extensions to an object's userData.   for ( const name in objectDef.extensions ) {    if ( knownExtensions[ name ] === undefined ) {     object.userData.gltfExtensions = object.userData.gltfExtensions || {};    object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];    }   }  }  /**  * @param {Object3D|Material|BufferGeometry} object  * @param {GLTF.definition} gltfDef  */ function assignExtrasToUserData( object, gltfDef ) {   if ( gltfDef.extras !== undefined ) {    if ( typeof gltfDef.extras === 'object' ) {     Object.assign( object.userData, gltfDef.extras );    } else {     console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );    }   }  }  /**  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets  *  * @param {BufferGeometry} geometry  * @param {Array<GLTF.Target>} targets  * @param {GLTFParser} parser  * @return {Promise<BufferGeometry>}  */ function addMorphTargets( geometry, targets, parser ) {   let hasMorphPosition = false;  let hasMorphNormal = false;  let hasMorphColor = false;   for ( let i = 0, il = targets.length; i < il; i ++ ) {    const target = targets[ i ];    if ( target.POSITION !== undefined ) hasMorphPosition = true;   if ( target.NORMAL !== undefined ) hasMorphNormal = true;   if ( target.COLOR_0 !== undefined ) hasMorphColor = true;    if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;   }   if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );   const pendingPositionAccessors = [];  const pendingNormalAccessors = [];  const pendingColorAccessors = [];   for ( let i = 0, il = targets.length; i < il; i ++ ) {    const target = targets[ i ];    if ( hasMorphPosition ) {     const pendingAccessor = target.POSITION !== undefined     ? parser.getDependency( 'accessor', target.POSITION )     : geometry.attributes.position;     pendingPositionAccessors.push( pendingAccessor );    }    if ( hasMorphNormal ) {     const pendingAccessor = target.NORMAL !== undefined     ? parser.getDependency( 'accessor', target.NORMAL )     : geometry.attributes.normal;     pendingNormalAccessors.push( pendingAccessor );    }    if ( hasMorphColor ) {     const pendingAccessor = target.COLOR_0 !== undefined     ? parser.getDependency( 'accessor', target.COLOR_0 )     : geometry.attributes.color;     pendingColorAccessors.push( pendingAccessor );    }   }   return Promise.all( [   Promise.all( pendingPositionAccessors ),   Promise.all( pendingNormalAccessors ),   Promise.all( pendingColorAccessors )  ] ).then( function ( accessors ) {    const morphPositions = accessors[ 0 ];   const morphNormals = accessors[ 1 ];   const morphColors = accessors[ 2 ];    if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;   if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;   if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;   geometry.morphTargetsRelative = true;    return geometry;   } );  }  /**  * @param {Mesh} mesh  * @param {GLTF.Mesh} meshDef  */ function updateMorphTargets( mesh, meshDef ) {   mesh.updateMorphTargets();   if ( meshDef.weights !== undefined ) {    for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {     mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];    }   }   // .extras has user-defined data, so check that .extras.targetNames is an array.  if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {    const targetNames = meshDef.extras.targetNames;    if ( mesh.morphTargetInfluences.length === targetNames.length ) {     mesh.morphTargetDictionary = {};     for ( let i = 0, il = targetNames.length; i < il; i ++ ) {      mesh.morphTargetDictionary[ targetNames[ i ] ] = i;     }    } else {     console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );    }   }  }  function createPrimitiveKey( primitiveDef ) {   let geometryKey;   const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];   if ( dracoExtension ) {    geometryKey = 'draco:' + dracoExtension.bufferView     + ':' + dracoExtension.indices     + ':' + createAttributesKey( dracoExtension.attributes );   } else {    geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;   }   if ( primitiveDef.targets !== undefined ) {    for ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) {     geometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] );    }   }   return geometryKey;  }  function createAttributesKey( attributes ) {   let attributesKey = '';   const keys = Object.keys( attributes ).sort();   for ( let i = 0, il = keys.length; i < il; i ++ ) {    attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';   }   return attributesKey;  }  function getNormalizedComponentScale( constructor ) {   // Reference:  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data   switch ( constructor ) {    case Int8Array:    return 1 / 127;    case Uint8Array:    return 1 / 255;    case Int16Array:    return 1 / 32767;    case Uint16Array:    return 1 / 65535;    default:    throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );   }  }  function getImageURIMimeType( uri ) {   if ( uri.search( /|.jpe?g($||?)/i ) > 0 || uri.search( /^data|:image|/jpeg/ ) === 0 ) return 'image/jpeg';  if ( uri.search( /|.webp($||?)/i ) > 0 || uri.search( /^data|:image|/webp/ ) === 0 ) return 'image/webp';   return 'image/png';  }  const _identityMatrix = new Matrix4();  /* GLTF PARSER */  class GLTFParser {   constructor( json = {}, options = {} ) {    this.json = json;   this.extensions = {};   this.plugins = {};   this.options = options;    // loader object cache   this.cache = new GLTFRegistry();    // associations between Three.js objects and glTF elements   this.associations = new Map();    // BufferGeometry caching   this.primitiveCache = {};    // Node cache   this.nodeCache = {};    // Object3D instance caches   this.meshCache = { refs: {}, uses: {} };   this.cameraCache = { refs: {}, uses: {} };   this.lightCache = { refs: {}, uses: {} };    this.sourceCache = {};   this.textureCache = {};    // Track node names, to ensure no duplicates   this.nodeNamesUsed = {};    // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the   // expensive work of uploading a texture to the GPU off the main thread.    let isSafari = false;   let safariVersion = - 1;   let isFirefox = false;   let firefoxVersion = - 1;    if ( typeof navigator !== 'undefined' ) {     const userAgent = navigator.userAgent;     isSafari = /^((?!chrome|android).)*safari/i.test( userAgent ) === true;    const safariMatch = userAgent.match( /Version|/(|d+)/ );    safariVersion = isSafari && safariMatch ? parseInt( safariMatch[ 1 ], 10 ) : - 1;     isFirefox = userAgent.indexOf( 'Firefox' ) > - 1;    firefoxVersion = isFirefox ? userAgent.match( /Firefox|/([0-9]+)|./ )[ 1 ] : - 1;    }    if ( typeof createImageBitmap === 'undefined' || ( isSafari && safariVersion < 17 ) || ( isFirefox && firefoxVersion < 98 ) ) {     this.textureLoader = new TextureLoader( this.options.manager );    } else {     this.textureLoader = new ImageBitmapLoader( this.options.manager );    }    this.textureLoader.setCrossOrigin( this.options.crossOrigin );   this.textureLoader.setRequestHeader( this.options.requestHeader );    this.fileLoader = new FileLoader( this.options.manager );   this.fileLoader.setResponseType( 'arraybuffer' );    if ( this.options.crossOrigin === 'use-credentials' ) {     this.fileLoader.setWithCredentials( true );    }   }   setExtensions( extensions ) {    this.extensions = extensions;   }   setPlugins( plugins ) {    this.plugins = plugins;   }   parse( onLoad, onError ) {    const parser = this;   const json = this.json;   const extensions = this.extensions;    // Clear the loader cache   this.cache.removeAll();   this.nodeCache = {};    // Mark the special nodes/meshes in json for efficient parse   this._invokeAll( function ( ext ) {     return ext._markDefs && ext._markDefs();    } );    Promise.all( this._invokeAll( function ( ext ) {     return ext.beforeRoot && ext.beforeRoot();    } ) ).then( function () {     return Promise.all( [      parser.getDependencies( 'scene' ),     parser.getDependencies( 'animation' ),     parser.getDependencies( 'camera' ),     ] );    } ).then( function ( dependencies ) {     const result = {     scene: dependencies[ 0 ][ json.scene || 0 ],     scenes: dependencies[ 0 ],     animations: dependencies[ 1 ],     cameras: dependencies[ 2 ],     asset: json.asset,     parser: parser,     userData: {}    };     addUnknownExtensionsToUserData( extensions, result, json );     assignExtrasToUserData( result, json );     return Promise.all( parser._invokeAll( function ( ext ) {      return ext.afterRoot && ext.afterRoot( result );     } ) ).then( function () {      for ( const scene of result.scenes ) {       scene.updateMatrixWorld();      }      onLoad( result );     } );    } ).catch( onError );   }   /**   * Marks the special nodes/meshes in json for efficient parse.   */  _markDefs() {    const nodeDefs = this.json.nodes || [];   const skinDefs = this.json.skins || [];   const meshDefs = this.json.meshes || [];    // Nothing in the node definition indicates whether it is a Bone or an   // Object3D. Use the skins' joint references to mark bones.   for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {     const joints = skinDefs[ skinIndex ].joints;     for ( let i = 0, il = joints.length; i < il; i ++ ) {      nodeDefs[ joints[ i ] ].isBone = true;     }    }    // Iterate over all nodes, marking references to shared resources,   // as well as skeleton joints.   for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {     const nodeDef = nodeDefs[ nodeIndex ];     if ( nodeDef.mesh !== undefined ) {      this._addNodeRef( this.meshCache, nodeDef.mesh );      // Nothing in the mesh definition indicates whether it is     // a SkinnedMesh or Mesh. Use the node's mesh reference     // to mark SkinnedMesh if node has skin.     if ( nodeDef.skin !== undefined ) {       meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;      }     }     if ( nodeDef.camera !== undefined ) {      this._addNodeRef( this.cameraCache, nodeDef.camera );     }    }   }   /**   * Counts references to shared node / Object3D resources. These resources   * can be reused, or "instantiated", at multiple nodes in the scene   * hierarchy. Mesh, Camera, and Light instances are instantiated and must   * be marked. Non-scenegraph resources (like Materials, Geometries, and   * Textures) can be reused directly and are not marked here.   *   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.   */  _addNodeRef( cache, index ) {    if ( index === undefined ) return;    if ( cache.refs[ index ] === undefined ) {     cache.refs[ index ] = cache.uses[ index ] = 0;    }    cache.refs[ index ] ++;   }   /** Returns a reference to a shared resource, cloning it if necessary. */  _getNodeRef( cache, index, object ) {    if ( cache.refs[ index ] <= 1 ) return object;    const ref = object.clone();    // Propagates mappings to the cloned object, prevents mappings on the   // original object from being lost.   const updateMappings = ( original, clone ) => {     const mappings = this.associations.get( original );    if ( mappings != null ) {      this.associations.set( clone, mappings );     }     for ( const [ i, child ] of original.children.entries() ) {      updateMappings( child, clone.children[ i ] );     }    };    updateMappings( object, ref );    ref.name += '_instance_' + ( cache.uses[ index ] ++ );    return ref;   }   _invokeOne( func ) {    const extensions = Object.values( this.plugins );   extensions.push( this );    for ( let i = 0; i < extensions.length; i ++ ) {     const result = func( extensions[ i ] );     if ( result ) return result;    }    return null;   }   _invokeAll( func ) {    const extensions = Object.values( this.plugins );   extensions.unshift( this );    const pending = [];    for ( let i = 0; i < extensions.length; i ++ ) {     const result = func( extensions[ i ] );     if ( result ) pending.push( result );    }    return pending;   }   /**   * Requests the specified dependency asynchronously, with caching.   * @param {string} type   * @param {number} index   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}   */  getDependency( type, index ) {    const cacheKey = type + ':' + index;   let dependency = this.cache.get( cacheKey );    if ( ! dependency ) {     switch ( type ) {      case 'scene':      dependency = this.loadScene( index );      break;      case 'node':      dependency = this._invokeOne( function ( ext ) {        return ext.loadNode && ext.loadNode( index );       } );      break;      case 'mesh':      dependency = this._invokeOne( function ( ext ) {        return ext.loadMesh && ext.loadMesh( index );       } );      break;      case 'accessor':      dependency = this.loadAccessor( index );      break;      case 'bufferView':      dependency = this._invokeOne( function ( ext ) {        return ext.loadBufferView && ext.loadBufferView( index );       } );      break;      case 'buffer':      dependency = this.loadBuffer( index );      break;      case 'material':      dependency = this._invokeOne( function ( ext ) {        return ext.loadMaterial && ext.loadMaterial( index );       } );      break;      case 'texture':      dependency = this._invokeOne( function ( ext ) {        return ext.loadTexture && ext.loadTexture( index );       } );      break;      case 'skin':      dependency = this.loadSkin( index );      break;      case 'animation':      dependency = this._invokeOne( function ( ext ) {        return ext.loadAnimation && ext.loadAnimation( index );       } );      break;      case 'camera':      dependency = this.loadCamera( index );      break;      default:      dependency = this._invokeOne( function ( ext ) {        return ext != this && ext.getDependency && ext.getDependency( type, index );       } );       if ( ! dependency ) {        throw new Error( 'Unknown type: ' + type );       }       break;     }     this.cache.add( cacheKey, dependency );    }    return dependency;   }   /**   * Requests all dependencies of the specified type asynchronously, with caching.   * @param {string} type   * @return {Promise<Array<Object>>}   */  getDependencies( type ) {    let dependencies = this.cache.get( type );    if ( ! dependencies ) {     const parser = this;    const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];     dependencies = Promise.all( defs.map( function ( def, index ) {      return parser.getDependency( type, index );     } ) );     this.cache.add( type, dependencies );    }    return dependencies;   }   /**   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views   * @param {number} bufferIndex   * @return {Promise<ArrayBuffer>}   */  loadBuffer( bufferIndex ) {    const bufferDef = this.json.buffers[ bufferIndex ];   const loader = this.fileLoader;    if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {     throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );    }    // If present, GLB container is required to be the first buffer.   if ( bufferDef.uri === undefined && bufferIndex === 0 ) {     return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );    }    const options = this.options;    return new Promise( function ( resolve, reject ) {     loader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {      reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );     } );    } );   }   /**   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views   * @param {number} bufferViewIndex   * @return {Promise<ArrayBuffer>}   */  loadBufferView( bufferViewIndex ) {    const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];    return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {     const byteLength = bufferViewDef.byteLength || 0;    const byteOffset = bufferViewDef.byteOffset || 0;    return buffer.slice( byteOffset, byteOffset + byteLength );    } );   }   /**   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors   * @param {number} accessorIndex   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}   */  loadAccessor( accessorIndex ) {    const parser = this;   const json = this.json;    const accessorDef = this.json.accessors[ accessorIndex ];    if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {     const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];    const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];    const normalized = accessorDef.normalized === true;     const array = new TypedArray( accessorDef.count * itemSize );    return Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );    }    const pendingBufferViews = [];    if ( accessorDef.bufferView !== undefined ) {     pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );    } else {     pendingBufferViews.push( null );    }    if ( accessorDef.sparse !== undefined ) {     pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );    pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );    }    return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {     const bufferView = bufferViews[ 0 ];     const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];    const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];     // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.    const elementBytes = TypedArray.BYTES_PER_ELEMENT;    const itemBytes = elementBytes * itemSize;    const byteOffset = accessorDef.byteOffset || 0;    const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;    const normalized = accessorDef.normalized === true;    let array, bufferAttribute;     // The buffer is not interleaved if the stride is the item size in bytes.    if ( byteStride && byteStride !== itemBytes ) {      // Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer     // This makes sure that IBA.count reflects accessor.count properly     const ibSlice = Math.floor( byteOffset / byteStride );     const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;     let ib = parser.cache.get( ibCacheKey );      if ( ! ib ) {       array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );       // Integer parameters to IB/IBA are in array elements, not bytes.      ib = new InterleavedBuffer( array, byteStride / elementBytes );       parser.cache.add( ibCacheKey, ib );      }      bufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );     } else {      if ( bufferView === null ) {       array = new TypedArray( accessorDef.count * itemSize );      } else {       array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );      }      bufferAttribute = new BufferAttribute( array, itemSize, normalized );     }     // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors    if ( accessorDef.sparse !== undefined ) {      const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;     const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];      const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;     const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;      const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );     const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );      if ( bufferView !== null ) {       // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.      bufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );      }      // Ignore normalized since we copy from sparse     bufferAttribute.normalized = false;      for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {       const index = sparseIndices[ i ];       bufferAttribute.setX( index, sparseValues[ i * itemSize ] );      if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );      if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );      if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );      if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );      }      bufferAttribute.normalized = normalized;     }     return bufferAttribute;    } );   }   /**   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures   * @param {number} textureIndex   * @return {Promise<THREE.Texture|null>}   */  loadTexture( textureIndex ) {    const json = this.json;   const options = this.options;   const textureDef = json.textures[ textureIndex ];   const sourceIndex = textureDef.source;   const sourceDef = json.images[ sourceIndex ];    let loader = this.textureLoader;    if ( sourceDef.uri ) {     const handler = options.manager.getHandler( sourceDef.uri );    if ( handler !== null ) loader = handler;    }    return this.loadTextureImage( textureIndex, sourceIndex, loader );   }   loadTextureImage( textureIndex, sourceIndex, loader ) {    const parser = this;   const json = this.json;    const textureDef = json.textures[ textureIndex ];   const sourceDef = json.images[ sourceIndex ];    const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;    if ( this.textureCache[ cacheKey ] ) {     // See https://github.com/mrdoob/three.js/issues/21559.    return this.textureCache[ cacheKey ];    }    const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {     texture.flipY = false;     texture.name = textureDef.name || sourceDef.name || '';     if ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) {      texture.name = sourceDef.uri;     }     const samplers = json.samplers || {};    const sampler = samplers[ textureDef.sampler ] || {};     texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;    texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;    texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;    texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;     parser.associations.set( texture, { textures: textureIndex } );     return texture;    } ).catch( function () {     return null;    } );    this.textureCache[ cacheKey ] = promise;    return promise;   }   loadImageSource( sourceIndex, loader ) {    const parser = this;   const json = this.json;   const options = this.options;    if ( this.sourceCache[ sourceIndex ] !== undefined ) {     return this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );    }    const sourceDef = json.images[ sourceIndex ];    const URL = self.URL || self.webkitURL;    let sourceURI = sourceDef.uri || '';   let isObjectURL = false;    if ( sourceDef.bufferView !== undefined ) {     // Load binary image data from bufferView, if provided.     sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {      isObjectURL = true;     const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );     sourceURI = URL.createObjectURL( blob );     return sourceURI;     } );    } else if ( sourceDef.uri === undefined ) {     throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );    }    const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {     return new Promise( function ( resolve, reject ) {      let onLoad = resolve;      if ( loader.isImageBitmapLoader === true ) {       onLoad = function ( imageBitmap ) {        const texture = new Texture( imageBitmap );       texture.needsUpdate = true;        resolve( texture );       };      }      loader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );     } );    } ).then( function ( texture ) {     // Clean up resources and configure Texture.     if ( isObjectURL === true ) {      URL.revokeObjectURL( sourceURI );     }     assignExtrasToUserData( texture, sourceDef );     texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );     return texture;    } ).catch( function ( error ) {     console.error( 'THREE.GLTFLoader: Couldn|'t load texture', sourceURI );    throw error;    } );    this.sourceCache[ sourceIndex ] = promise;   return promise;   }   /**   * Asynchronously assigns a texture to the given material parameters.   * @param {Object} materialParams   * @param {string} mapName   * @param {Object} mapDef   * @return {Promise<Texture>}   */  assignTexture( materialParams, mapName, mapDef, colorSpace ) {    const parser = this;    return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {     if ( ! texture ) return null;     if ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) {      texture = texture.clone();     texture.channel = mapDef.texCoord;     }     if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {      const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;      if ( transform ) {       const gltfReference = parser.associations.get( texture );      texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );      parser.associations.set( texture, gltfReference );      }     }     if ( colorSpace !== undefined ) {      texture.colorSpace = colorSpace;     }     materialParams[ mapName ] = texture;     return texture;    } );   }   /**   * Assigns final material to a Mesh, Line, or Points instance. The instance   * already has a material (generated from the glTF material options alone)   * but reuse of the same glTF material may require multiple threejs materials   * to accommodate different primitive types, defines, etc. New materials will   * be created if necessary, and reused from a cache.   * @param  {Object3D} mesh Mesh, Line, or Points instance.   */  assignFinalMaterial( mesh ) {    const geometry = mesh.geometry;   let material = mesh.material;    const useDerivativeTangents = geometry.attributes.tangent === undefined;   const useVertexColors = geometry.attributes.color !== undefined;   const useFlatShading = geometry.attributes.normal === undefined;    if ( mesh.isPoints ) {     const cacheKey = 'PointsMaterial:' + material.uuid;     let pointsMaterial = this.cache.get( cacheKey );     if ( ! pointsMaterial ) {      pointsMaterial = new PointsMaterial();     Material.prototype.copy.call( pointsMaterial, material );     pointsMaterial.color.copy( material.color );     pointsMaterial.map = material.map;     pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px      this.cache.add( cacheKey, pointsMaterial );     }     material = pointsMaterial;    } else if ( mesh.isLine ) {     const cacheKey = 'LineBasicMaterial:' + material.uuid;     let lineMaterial = this.cache.get( cacheKey );     if ( ! lineMaterial ) {      lineMaterial = new LineBasicMaterial();     Material.prototype.copy.call( lineMaterial, material );     lineMaterial.color.copy( material.color );     lineMaterial.map = material.map;      this.cache.add( cacheKey, lineMaterial );     }     material = lineMaterial;    }    // Clone the material if it will be modified   if ( useDerivativeTangents || useVertexColors || useFlatShading ) {     let cacheKey = 'ClonedMaterial:' + material.uuid + ':';     if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';    if ( useVertexColors ) cacheKey += 'vertex-colors:';    if ( useFlatShading ) cacheKey += 'flat-shading:';     let cachedMaterial = this.cache.get( cacheKey );     if ( ! cachedMaterial ) {      cachedMaterial = material.clone();      if ( useVertexColors ) cachedMaterial.vertexColors = true;     if ( useFlatShading ) cachedMaterial.flatShading = true;      if ( useDerivativeTangents ) {       // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995      if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;      if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;      }      this.cache.add( cacheKey, cachedMaterial );      this.associations.set( cachedMaterial, this.associations.get( material ) );     }     material = cachedMaterial;    }    mesh.material = material;   }   getMaterialType( /* materialIndex */ ) {    return MeshStandardMaterial;   }   /**   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials   * @param {number} materialIndex   * @return {Promise<Material>}   */  loadMaterial( materialIndex ) {    const parser = this;   const json = this.json;   const extensions = this.extensions;   const materialDef = json.materials[ materialIndex ];    let materialType;   const materialParams = {};   const materialExtensions = materialDef.extensions || {};    const pending = [];    if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {     const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];    materialType = kmuExtension.getMaterialType();    pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );    } else {     // Specification:    // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material     const metallicRoughness = materialDef.pbrMetallicRoughness || {};     materialParams.color = new Color( 1.0, 1.0, 1.0 );    materialParams.opacity = 1.0;     if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {      const array = metallicRoughness.baseColorFactor;      materialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );     materialParams.opacity = array[ 3 ];     }     if ( metallicRoughness.baseColorTexture !== undefined ) {      pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );     }     materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;    materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;     if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {      pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );     pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );     }     materialType = this._invokeOne( function ( ext ) {      return ext.getMaterialType && ext.getMaterialType( materialIndex );     } );     pending.push( Promise.all( this._invokeAll( function ( ext ) {      return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );     } ) ) );    }    if ( materialDef.doubleSided === true ) {     materialParams.side = DoubleSide;    }    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;    if ( alphaMode === ALPHA_MODES.BLEND ) {     materialParams.transparent = true;     // See: https://github.com/mrdoob/three.js/issues/17706    materialParams.depthWrite = false;    } else {     materialParams.transparent = false;     if ( alphaMode === ALPHA_MODES.MASK ) {      materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;     }    }    if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {     pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );     materialParams.normalScale = new Vector2( 1, 1 );     if ( materialDef.normalTexture.scale !== undefined ) {      const scale = materialDef.normalTexture.scale;      materialParams.normalScale.set( scale, scale );     }    }    if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {     pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );     if ( materialDef.occlusionTexture.strength !== undefined ) {      materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;     }    }    if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {     const emissiveFactor = materialDef.emissiveFactor;    materialParams.emissive = new Color().setRGB( emissiveFactor[ 0 ], emissiveFactor[ 1 ], emissiveFactor[ 2 ], LinearSRGBColorSpace );    }    if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {     pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) );    }    return Promise.all( pending ).then( function () {     const material = new materialType( materialParams );     if ( materialDef.name ) material.name = materialDef.name;     assignExtrasToUserData( material, materialDef );     parser.associations.set( material, { materials: materialIndex } );     if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );     return material;    } );   }   /** When Object3D instances are targeted by animation, they need unique names. */  createUniqueName( originalName ) {    const sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );    if ( sanitizedName in this.nodeNamesUsed ) {     return sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] );    } else {     this.nodeNamesUsed[ sanitizedName ] = 0;     return sanitizedName;    }   }   /**   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry   *   * Creates BufferGeometries from primitives.   *   * @param {Array<GLTF.Primitive>} primitives   * @return {Promise<Array<BufferGeometry>>}   */  loadGeometries( primitives ) {    const parser = this;   const extensions = this.extensions;   const cache = this.primitiveCache;    function createDracoPrimitive( primitive ) {     return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]     .decodePrimitive( primitive, parser )     .then( function ( geometry ) {       return addPrimitiveAttributes( geometry, primitive, parser );      } );    }    const pending = [];    for ( let i = 0, il = primitives.length; i < il; i ++ ) {     const primitive = primitives[ i ];    const cacheKey = createPrimitiveKey( primitive );     // See if we've already created this geometry    const cached = cache[ cacheKey ];     if ( cached ) {      // Use the cached geometry if it exists     pending.push( cached.promise );     } else {      let geometryPromise;      if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {       // Use DRACO geometry if available      geometryPromise = createDracoPrimitive( primitive );      } else {       // Otherwise create a new geometry      geometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );      }      // Cache this geometry     cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };      pending.push( geometryPromise );     }    }    return Promise.all( pending );   }   /**   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes   * @param {number} meshIndex   * @return {Promise<Group|Mesh|SkinnedMesh>}   */  loadMesh( meshIndex ) {    const parser = this;   const json = this.json;   const extensions = this.extensions;    const meshDef = json.meshes[ meshIndex ];   const primitives = meshDef.primitives;    const pending = [];    for ( let i = 0, il = primitives.length; i < il; i ++ ) {     const material = primitives[ i ].material === undefined     ? createDefaultMaterial( this.cache )     : this.getDependency( 'material', primitives[ i ].material );     pending.push( material );    }    pending.push( parser.loadGeometries( primitives ) );    return Promise.all( pending ).then( function ( results ) {     const materials = results.slice( 0, results.length - 1 );    const geometries = results[ results.length - 1 ];     const meshes = [];     for ( let i = 0, il = geometries.length; i < il; i ++ ) {      const geometry = geometries[ i ];     const primitive = primitives[ i ];      // 1. create Mesh      let mesh;      const material = materials[ i ];      if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||       primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||       primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||       primitive.mode === undefined ) {       // .isSkinnedMesh isn't in glTF spec. See ._markDefs()      mesh = meshDef.isSkinnedMesh === true       ? new SkinnedMesh( geometry, material )       : new Mesh( geometry, material );       if ( mesh.isSkinnedMesh === true ) {        // normalize skin weights to fix malformed assets (see #15319)       mesh.normalizeSkinWeights();       }       if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {        mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );       } else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {        mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );       }      } else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {       mesh = new LineSegments( geometry, material );      } else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {       mesh = new Line( geometry, material );      } else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {       mesh = new LineLoop( geometry, material );      } else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {       mesh = new Points( geometry, material );      } else {       throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );      }      if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {       updateMorphTargets( mesh, meshDef );      }      mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );      assignExtrasToUserData( mesh, meshDef );      if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );      parser.assignFinalMaterial( mesh );      meshes.push( mesh );     }     for ( let i = 0, il = meshes.length; i < il; i ++ ) {      parser.associations.set( meshes[ i ], {      meshes: meshIndex,      primitives: i     } );     }     if ( meshes.length === 1 ) {      if ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef );      return meshes[ 0 ];     }     const group = new Group();     if ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef );     parser.associations.set( group, { meshes: meshIndex } );     for ( let i = 0, il = meshes.length; i < il; i ++ ) {      group.add( meshes[ i ] );     }     return group;    } );   }   /**   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras   * @param {number} cameraIndex   * @return {Promise<THREE.Camera>}   */  loadCamera( cameraIndex ) {    let camera;   const cameraDef = this.json.cameras[ cameraIndex ];   const params = cameraDef[ cameraDef.type ];    if ( ! params ) {     console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );    return;    }    if ( cameraDef.type === 'perspective' ) {     camera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );    } else if ( cameraDef.type === 'orthographic' ) {     camera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );    }    if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );    assignExtrasToUserData( camera, cameraDef );    return Promise.resolve( camera );   }   /**   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins   * @param {number} skinIndex   * @return {Promise<Skeleton>}   */  loadSkin( skinIndex ) {    const skinDef = this.json.skins[ skinIndex ];    const pending = [];    for ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {     pending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );    }    if ( skinDef.inverseBindMatrices !== undefined ) {     pending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );    } else {     pending.push( null );    }    return Promise.all( pending ).then( function ( results ) {     const inverseBindMatrices = results.pop();    const jointNodes = results;     // Note that bones (joint nodes) may or may not be in the    // scene graph at this time.     const bones = [];    const boneInverses = [];     for ( let i = 0, il = jointNodes.length; i < il; i ++ ) {      const jointNode = jointNodes[ i ];      if ( jointNode ) {       bones.push( jointNode );       const mat = new Matrix4();       if ( inverseBindMatrices !== null ) {        mat.fromArray( inverseBindMatrices.array, i * 16 );       }       boneInverses.push( mat );      } else {       console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[ i ] );      }     }     return new Skeleton( bones, boneInverses );    } );   }   /**   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations   * @param {number} animationIndex   * @return {Promise<AnimationClip>}   */  loadAnimation( animationIndex ) {    const json = this.json;   const parser = this;    const animationDef = json.animations[ animationIndex ];   const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;    const pendingNodes = [];   const pendingInputAccessors = [];   const pendingOutputAccessors = [];   const pendingSamplers = [];   const pendingTargets = [];    for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {     const channel = animationDef.channels[ i ];    const sampler = animationDef.samplers[ channel.sampler ];    const target = channel.target;    const name = target.node;    const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;    const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;     if ( target.node === undefined ) continue;     pendingNodes.push( this.getDependency( 'node', name ) );    pendingInputAccessors.push( this.getDependency( 'accessor', input ) );    pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );    pendingSamplers.push( sampler );    pendingTargets.push( target );    }    return Promise.all( [     Promise.all( pendingNodes ),    Promise.all( pendingInputAccessors ),    Promise.all( pendingOutputAccessors ),    Promise.all( pendingSamplers ),    Promise.all( pendingTargets )    ] ).then( function ( dependencies ) {     const nodes = dependencies[ 0 ];    const inputAccessors = dependencies[ 1 ];    const outputAccessors = dependencies[ 2 ];    const samplers = dependencies[ 3 ];    const targets = dependencies[ 4 ];     const tracks = [];     for ( let i = 0, il = nodes.length; i < il; i ++ ) {      const node = nodes[ i ];     const inputAccessor = inputAccessors[ i ];     const outputAccessor = outputAccessors[ i ];     const sampler = samplers[ i ];     const target = targets[ i ];      if ( node === undefined ) continue;      if ( node.updateMatrix ) {       node.updateMatrix();      }      const createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );      if ( createdTracks ) {       for ( let k = 0; k < createdTracks.length; k ++ ) {        tracks.push( createdTracks[ k ] );       }      }     }     return new AnimationClip( animationName, undefined, tracks );    } );   }   createNodeMesh( nodeIndex ) {    const json = this.json;   const parser = this;   const nodeDef = json.nodes[ nodeIndex ];    if ( nodeDef.mesh === undefined ) return null;    return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {     const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );     // if weights are provided on the node, override weights on the mesh.    if ( nodeDef.weights !== undefined ) {      node.traverse( function ( o ) {       if ( ! o.isMesh ) return;       for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {        o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];       }      } );     }     return node;    } );   }   /**   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy   * @param {number} nodeIndex   * @return {Promise<Object3D>}   */  loadNode( nodeIndex ) {    const json = this.json;   const parser = this;    const nodeDef = json.nodes[ nodeIndex ];    const nodePending = parser._loadNodeShallow( nodeIndex );    const childPending = [];   const childrenDef = nodeDef.children || [];    for ( let i = 0, il = childrenDef.length; i < il; i ++ ) {     childPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );    }    const skeletonPending = nodeDef.skin === undefined    ? Promise.resolve( null )    : parser.getDependency( 'skin', nodeDef.skin );    return Promise.all( [    nodePending,    Promise.all( childPending ),    skeletonPending   ] ).then( function ( results ) {     const node = results[ 0 ];    const children = results[ 1 ];    const skeleton = results[ 2 ];     if ( skeleton !== null ) {      // This full traverse should be fine because     // child glTF nodes have not been added to this node yet.     node.traverse( function ( mesh ) {       if ( ! mesh.isSkinnedMesh ) return;       mesh.bind( skeleton, _identityMatrix );      } );     }     for ( let i = 0, il = children.length; i < il; i ++ ) {      node.add( children[ i ] );     }     return node;    } );   }   // ._loadNodeShallow() parses a single node.  // skin and child nodes are created and added in .loadNode() (no '_' prefix).  _loadNodeShallow( nodeIndex ) {    const json = this.json;   const extensions = this.extensions;   const parser = this;    // This method is called from .loadNode() and .loadSkin().   // Cache a node to avoid duplication.    if ( this.nodeCache[ nodeIndex ] !== undefined ) {     return this.nodeCache[ nodeIndex ];    }    const nodeDef = json.nodes[ nodeIndex ];    // reserve node's name before its dependencies, so the root has the intended name.   const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';    const pending = [];    const meshPromise = parser._invokeOne( function ( ext ) {     return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );    } );    if ( meshPromise ) {     pending.push( meshPromise );    }    if ( nodeDef.camera !== undefined ) {     pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {      return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );     } ) );    }    parser._invokeAll( function ( ext ) {     return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );    } ).forEach( function ( promise ) {     pending.push( promise );    } );    this.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {     let node;     // .isBone isn't in glTF spec. See ._markDefs    if ( nodeDef.isBone === true ) {      node = new Bone();     } else if ( objects.length > 1 ) {      node = new Group();     } else if ( objects.length === 1 ) {      node = objects[ 0 ];     } else {      node = new Object3D();     }     if ( node !== objects[ 0 ] ) {      for ( let i = 0, il = objects.length; i < il; i ++ ) {       node.add( objects[ i ] );      }     }     if ( nodeDef.name ) {      node.userData.name = nodeDef.name;     node.name = nodeName;     }     assignExtrasToUserData( node, nodeDef );     if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );     if ( nodeDef.matrix !== undefined ) {      const matrix = new Matrix4();     matrix.fromArray( nodeDef.matrix );     node.applyMatrix4( matrix );     } else {      if ( nodeDef.translation !== undefined ) {       node.position.fromArray( nodeDef.translation );      }      if ( nodeDef.rotation !== undefined ) {       node.quaternion.fromArray( nodeDef.rotation );      }      if ( nodeDef.scale !== undefined ) {       node.scale.fromArray( nodeDef.scale );      }     }     if ( ! parser.associations.has( node ) ) {      parser.associations.set( node, {} );     }     parser.associations.get( node ).nodes = nodeIndex;     return node;    } );    return this.nodeCache[ nodeIndex ];   }   /**   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes   * @param {number} sceneIndex   * @return {Promise<Group>}   */  loadScene( sceneIndex ) {    const extensions = this.extensions;   const sceneDef = this.json.scenes[ sceneIndex ];   const parser = this;    // Loader returns Group, not Scene.   // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172   const scene = new Group();   if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );    assignExtrasToUserData( scene, sceneDef );    if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );    const nodeIds = sceneDef.nodes || [];    const pending = [];    for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {     pending.push( parser.getDependency( 'node', nodeIds[ i ] ) );    }    return Promise.all( pending ).then( function ( nodes ) {     for ( let i = 0, il = nodes.length; i < il; i ++ ) {      scene.add( nodes[ i ] );     }     // Removes dangling associations, associations that reference a node that    // didn't make it into the scene.    const reduceAssociations = ( node ) => {      const reducedAssociations = new Map();      for ( const [ key, value ] of parser.associations ) {       if ( key instanceof Material || key instanceof Texture ) {        reducedAssociations.set( key, value );       }      }      node.traverse( ( node ) => {       const mappings = parser.associations.get( node );       if ( mappings != null ) {        reducedAssociations.set( node, mappings );       }      } );      return reducedAssociations;     };     parser.associations = reduceAssociations( scene );     return scene;    } );   }   _createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) {    const tracks = [];    const targetName = node.name ? node.name : node.uuid;   const targetNames = [];    if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {     node.traverse( function ( object ) {      if ( object.morphTargetInfluences ) {       targetNames.push( object.name ? object.name : object.uuid );      }     } );    } else {     targetNames.push( targetName );    }    let TypedKeyframeTrack;    switch ( PATH_PROPERTIES[ target.path ] ) {     case PATH_PROPERTIES.weights:      TypedKeyframeTrack = NumberKeyframeTrack;     break;     case PATH_PROPERTIES.rotation:      TypedKeyframeTrack = QuaternionKeyframeTrack;     break;     case PATH_PROPERTIES.position:    case PATH_PROPERTIES.scale:      TypedKeyframeTrack = VectorKeyframeTrack;     break;     default:      switch ( outputAccessor.itemSize ) {       case 1:       TypedKeyframeTrack = NumberKeyframeTrack;       break;      case 2:      case 3:      default:       TypedKeyframeTrack = VectorKeyframeTrack;       break;      }      break;    }    const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;     const outputArray = this._getArrayFromAccessor( outputAccessor );    for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {     const track = new TypedKeyframeTrack(     targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],     inputAccessor.array,     outputArray,     interpolation    );     // Override interpolation with custom factory method.    if ( sampler.interpolation === 'CUBICSPLINE' ) {      this._createCubicSplineTrackInterpolant( track );     }     tracks.push( track );    }    return tracks;   }   _getArrayFromAccessor( accessor ) {    let outputArray = accessor.array;    if ( accessor.normalized ) {     const scale = getNormalizedComponentScale( outputArray.constructor );    const scaled = new Float32Array( outputArray.length );     for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {      scaled[ j ] = outputArray[ j ] * scale;     }     outputArray = scaled;    }    return outputArray;   }   _createCubicSplineTrackInterpolant( track ) {    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {     // A CUBICSPLINE keyframe in glTF has three output values for each input value,    // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()    // must be divided by three to get the interpolant's sampleSize argument.     const interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;     return new interpolantType( this.times, this.values, this.getValueSize() / 3, result );    };    // Mark as CUBICSPLINE. |track.getInterpolation()| doesn't support custom interpolants.   track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;   }  }  /**  * @param {BufferGeometry} geometry  * @param {GLTF.Primitive} primitiveDef  * @param {GLTFParser} parser  */ function computeBounds( geometry, primitiveDef, parser ) {   const attributes = primitiveDef.attributes;   const box = new Box3();   if ( attributes.POSITION !== undefined ) {    const accessor = parser.json.accessors[ attributes.POSITION ];    const min = accessor.min;   const max = accessor.max;    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.    if ( min !== undefined && max !== undefined ) {     box.set(     new Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),     new Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )    );     if ( accessor.normalized ) {      const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );     box.min.multiplyScalar( boxScale );     box.max.multiplyScalar( boxScale );     }    } else {     console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );     return;    }   } else {    return;   }   const targets = primitiveDef.targets;   if ( targets !== undefined ) {    const maxDisplacement = new Vector3();   const vector = new Vector3();    for ( let i = 0, il = targets.length; i < il; i ++ ) {     const target = targets[ i ];     if ( target.POSITION !== undefined ) {      const accessor = parser.json.accessors[ target.POSITION ];     const min = accessor.min;     const max = accessor.max;      // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.      if ( min !== undefined && max !== undefined ) {       // we need to get max of absolute components because target weight is [-1,1]      vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );      vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );      vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );        if ( accessor.normalized ) {        const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );       vector.multiplyScalar( boxScale );       }       // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative      // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets      // are used to implement key-frame animations and as such only two are active at a time - this results in very large      // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.      maxDisplacement.max( vector );      } else {       console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );      }     }    }    // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.   box.expandByVector( maxDisplacement );   }   geometry.boundingBox = box;   const sphere = new Sphere();   box.getCenter( sphere.center );  sphere.radius = box.min.distanceTo( box.max ) / 2;   geometry.boundingSphere = sphere;  }  /**  * @param {BufferGeometry} geometry  * @param {GLTF.Primitive} primitiveDef  * @param {GLTFParser} parser  * @return {Promise<BufferGeometry>}  */ function addPrimitiveAttributes( geometry, primitiveDef, parser ) {   const attributes = primitiveDef.attributes;   const pending = [];   function assignAttributeAccessor( accessorIndex, attributeName ) {    return parser.getDependency( 'accessor', accessorIndex )    .then( function ( accessor ) {      geometry.setAttribute( attributeName, accessor );     } );   }   for ( const gltfAttributeName in attributes ) {    const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();    // Skip attributes already provided by e.g. Draco extension.   if ( threeAttributeName in geometry.attributes ) continue;    pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );   }   if ( primitiveDef.indices !== undefined && ! geometry.index ) {    const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {     geometry.setIndex( accessor );    } );    pending.push( accessor );   }   if ( ColorManagement.workingColorSpace !== LinearSRGBColorSpace && 'COLOR_0' in attributes ) {    console.warn( |THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "|ColorManagement.workingColorSpace}" not supported.| );   }   assignExtrasToUserData( geometry, primitiveDef );   computeBounds( geometry, primitiveDef, parser );   return Promise.all( pending ).then( function () {    return primitiveDef.targets !== undefined    ? addMorphTargets( geometry, primitiveDef.targets, parser )    : geometry;   } );  }  export { GLTFLoader }; 
^..^ FILENAME ^..^
addons|loaders|HDRCubeTextureLoader.js
^..^ CONTENTS ^..^
import {  CubeTexture,  DataTexture,  FileLoader,  FloatType,  HalfFloatType,  LinearFilter,  LinearSRGBColorSpace,  Loader } from 'three'; import { RGBELoader } from '../loaders/RGBELoader.js';  class HDRCubeTextureLoader extends Loader {   constructor( manager ) {    super( manager );    this.hdrLoader = new RGBELoader();   this.type = HalfFloatType;   }   load( urls, onLoad, onProgress, onError ) {    const texture = new CubeTexture();    texture.type = this.type;    switch ( texture.type ) {     case FloatType:      texture.colorSpace = LinearSRGBColorSpace;     texture.minFilter = LinearFilter;     texture.magFilter = LinearFilter;     texture.generateMipmaps = false;     break;     case HalfFloatType:      texture.colorSpace = LinearSRGBColorSpace;     texture.minFilter = LinearFilter;     texture.magFilter = LinearFilter;     texture.generateMipmaps = false;     break;    }    const scope = this;    let loaded = 0;    function loadHDRData( i, onLoad, onProgress, onError ) {     new FileLoader( scope.manager )     .setPath( scope.path )     .setResponseType( 'arraybuffer' )     .setWithCredentials( scope.withCredentials )     .load( urls[ i ], function ( buffer ) {       loaded ++;       const texData = scope.hdrLoader.parse( buffer );       if ( ! texData ) return;       if ( texData.data !== undefined ) {        const dataTexture = new DataTexture( texData.data, texData.width, texData.height );        dataTexture.type = texture.type;       dataTexture.colorSpace = texture.colorSpace;       dataTexture.format = texture.format;       dataTexture.minFilter = texture.minFilter;       dataTexture.magFilter = texture.magFilter;       dataTexture.generateMipmaps = texture.generateMipmaps;        texture.images[ i ] = dataTexture;       }       if ( loaded === 6 ) {        texture.needsUpdate = true;       if ( onLoad ) onLoad( texture );       }      }, onProgress, onError );    }    for ( let i = 0; i < urls.length; i ++ ) {     loadHDRData( i, onLoad, onProgress, onError );    }    return texture;   }   setDataType( value ) {    this.type = value;   this.hdrLoader.setDataType( value );    return this;   }  }  export { HDRCubeTextureLoader }; 
^..^ FILENAME ^..^
addons|loaders|IESLoader.js
^..^ CONTENTS ^..^
import {  DataTexture,  FileLoader,  FloatType,  RedFormat,  MathUtils,  Loader,  UnsignedByteType,  LinearFilter,  HalfFloatType,  DataUtils } from 'three';  class IESLoader extends Loader {   constructor( manager ) {    super( manager );    this.type = HalfFloatType;   }   _getIESValues( iesLamp, type ) {    const width = 360;   const height = 180;   const size = width * height;    const data = new Array( size );    function interpolateCandelaValues( phi, theta ) {     let phiIndex = 0, thetaIndex = 0;    let startTheta = 0, endTheta = 0, startPhi = 0, endPhi = 0;     for ( let i = 0; i < iesLamp.numHorAngles - 1; ++ i ) { // numHorAngles = horAngles.length-1 because of extra padding, so this wont cause an out of bounds error      if ( theta < iesLamp.horAngles[ i + 1 ] || i == iesLamp.numHorAngles - 2 ) {       thetaIndex = i;      startTheta = iesLamp.horAngles[ i ];      endTheta = iesLamp.horAngles[ i + 1 ];       break;      }     }     for ( let i = 0; i < iesLamp.numVerAngles - 1; ++ i ) {      if ( phi < iesLamp.verAngles[ i + 1 ] || i == iesLamp.numVerAngles - 2 ) {       phiIndex = i;      startPhi = iesLamp.verAngles[ i ];      endPhi = iesLamp.verAngles[ i + 1 ];       break;      }     }     const deltaTheta = endTheta - startTheta;    const deltaPhi = endPhi - startPhi;     if ( deltaPhi === 0 ) // Outside range     return 0;     const t1 = deltaTheta === 0 ? 0 : ( theta - startTheta ) / deltaTheta;    const t2 = ( phi - startPhi ) / deltaPhi;     const nextThetaIndex = deltaTheta === 0 ? thetaIndex : thetaIndex + 1;     const v1 = MathUtils.lerp( iesLamp.candelaValues[ thetaIndex ][ phiIndex ], iesLamp.candelaValues[ nextThetaIndex ][ phiIndex ], t1 );    const v2 = MathUtils.lerp( iesLamp.candelaValues[ thetaIndex ][ phiIndex + 1 ], iesLamp.candelaValues[ nextThetaIndex ][ phiIndex + 1 ], t1 );    const v = MathUtils.lerp( v1, v2, t2 );     return v;    }    const startTheta = iesLamp.horAngles[ 0 ], endTheta = iesLamp.horAngles[ iesLamp.numHorAngles - 1 ];    for ( let i = 0; i < size; ++ i ) {     let theta = i % width;    const phi = Math.floor( i / width );     if ( endTheta - startTheta !== 0 && ( theta < startTheta || theta >= endTheta ) ) { // Handle symmetry for hor angles      theta %= endTheta * 2;      if ( theta > endTheta )      theta = endTheta * 2 - theta;     }     data[ phi + theta * height ] = interpolateCandelaValues( phi, theta );    }    let result = null;    if ( type === UnsignedByteType ) result = Uint8Array.from( data.map( v => Math.min( v * 0xFF, 0xFF ) ) );   else if ( type === HalfFloatType ) result = Uint16Array.from( data.map( v => DataUtils.toHalfFloat( v ) ) );   else if ( type === FloatType ) result = Float32Array.from( data );   else console.error( 'IESLoader: Unsupported type:', type );    return result;   }   load( url, onLoad, onProgress, onError ) {    const loader = new FileLoader( this.manager );   loader.setResponseType( 'text' );   loader.setCrossOrigin( this.crossOrigin );   loader.setWithCredentials( this.withCredentials );   loader.setPath( this.path );   loader.setRequestHeader( this.requestHeader );    loader.load( url, text => {     onLoad( this.parse( text ) );    }, onProgress, onError );   }   parse( text ) {    const type = this.type;    const iesLamp = new IESLamp( text );   const data = this._getIESValues( iesLamp, type );    const texture = new DataTexture( data, 180, 1, RedFormat, type );   texture.minFilter = LinearFilter;   texture.magFilter = LinearFilter;   texture.needsUpdate = true;    return texture;   }  }   function IESLamp( text ) {   const _self = this;   const textArray = text.split( '|n' );   let lineNumber = 0;  let line;   _self.verAngles = [ ];  _self.horAngles = [ ];   _self.candelaValues = [ ];   _self.tiltData = { };  _self.tiltData.angles = [ ];  _self.tiltData.mulFactors = [ ];   function textToArray( text ) {    text = text.replace( /^|s+||s+$/g, '' ); // remove leading or trailing spaces   text = text.replace( /,/g, ' ' ); // replace commas with spaces   text = text.replace( /|s|s+/g, ' ' ); // replace white space/tabs etc by single whitespace    const array = text.split( ' ' );    return array;   }   function readArray( count, array ) {    while ( true ) {     const line = textArray[ lineNumber ++ ];    const lineData = textToArray( line );     for ( let i = 0; i < lineData.length; ++ i ) {      array.push( Number( lineData[ i ] ) );     }     if ( array.length === count )     break;    }   }   function readTilt() {    let line = textArray[ lineNumber ++ ];   let lineData = textToArray( line );    _self.tiltData.lampToLumGeometry = Number( lineData[ 0 ] );    line = textArray[ lineNumber ++ ];   lineData = textToArray( line );    _self.tiltData.numAngles = Number( lineData[ 0 ] );    readArray( _self.tiltData.numAngles, _self.tiltData.angles );   readArray( _self.tiltData.numAngles, _self.tiltData.mulFactors );   }   function readLampValues() {    const values = [ ];   readArray( 10, values );    _self.count = Number( values[ 0 ] );   _self.lumens = Number( values[ 1 ] );   _self.multiplier = Number( values[ 2 ] );   _self.numVerAngles = Number( values[ 3 ] );   _self.numHorAngles = Number( values[ 4 ] );   _self.gonioType = Number( values[ 5 ] );   _self.units = Number( values[ 6 ] );   _self.width = Number( values[ 7 ] );   _self.length = Number( values[ 8 ] );   _self.height = Number( values[ 9 ] );   }   function readLampFactors() {    const values = [ ];   readArray( 3, values );    _self.ballFactor = Number( values[ 0 ] );   _self.blpFactor = Number( values[ 1 ] );   _self.inputWatts = Number( values[ 2 ] );   }   while ( true ) {    line = textArray[ lineNumber ++ ];    if ( line.includes( 'TILT' ) ) {     break;    }   }   if ( ! line.includes( 'NONE' ) ) {    if ( line.includes( 'INCLUDE' ) ) {     readTilt();    } else {     // TODO:: Read tilt data from a file    }   }   readLampValues();   readLampFactors();   // Initialize candela value array  for ( let i = 0; i < _self.numHorAngles; ++ i ) {    _self.candelaValues.push( [ ] );   }   // Parse Angles  readArray( _self.numVerAngles, _self.verAngles );  readArray( _self.numHorAngles, _self.horAngles );   // Parse Candela values  for ( let i = 0; i < _self.numHorAngles; ++ i ) {    readArray( _self.numVerAngles, _self.candelaValues[ i ] );   }   // Calculate actual candela values, and normalize.  for ( let i = 0; i < _self.numHorAngles; ++ i ) {    for ( let j = 0; j < _self.numVerAngles; ++ j ) {     _self.candelaValues[ i ][ j ] *= _self.candelaValues[ i ][ j ] * _self.multiplier     * _self.ballFactor * _self.blpFactor;    }   }   let maxVal = - 1;  for ( let i = 0; i < _self.numHorAngles; ++ i ) {    for ( let j = 0; j < _self.numVerAngles; ++ j ) {     const value = _self.candelaValues[ i ][ j ];    maxVal = maxVal < value ? value : maxVal;    }   }   const bNormalize = true;  if ( bNormalize && maxVal > 0 ) {    for ( let i = 0; i < _self.numHorAngles; ++ i ) {     for ( let j = 0; j < _self.numVerAngles; ++ j ) {      _self.candelaValues[ i ][ j ] /= maxVal;     }    }   }  }   export { IESLoader }; 
^..^ FILENAME ^..^
addons|loaders|KMZLoader.js
^..^ CONTENTS ^..^
import {  FileLoader,  Group,  Loader,  LoadingManager } from 'three'; import { ColladaLoader } from '../loaders/ColladaLoader.js'; import * as fflate from '../libs/fflate.module.js';  class KMZLoader extends Loader {   constructor( manager ) {    super( manager );   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( scope.manager );   loader.setPath( scope.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( scope.requestHeader );   loader.setWithCredentials( scope.withCredentials );   loader.load( url, function ( text ) {     try {      onLoad( scope.parse( text ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( data ) {    function findFile( url ) {     for ( const path in zip ) {      if ( path.slice( - url.length ) === url ) {       return zip[ path ];      }     }    }    const manager = new LoadingManager();   manager.setURLModifier( function ( url ) {     const image = findFile( url );     if ( image ) {      console.log( 'Loading', url );      const blob = new Blob( [ image.buffer ], { type: 'application/octet-stream' } );     return URL.createObjectURL( blob );     }     return url;    } );    //    const zip = fflate.unzipSync( new Uint8Array( data ) );    if ( zip[ 'doc.kml' ] ) {     const xml = new DOMParser().parseFromString( fflate.strFromU8( zip[ 'doc.kml' ] ), 'application/xml' );     const model = xml.querySelector( 'Placemark Model Link href' );     if ( model ) {      const loader = new ColladaLoader( manager );     return loader.parse( fflate.strFromU8( zip[ model.textContent ] ) );     }    } else {     console.warn( 'KMZLoader: Missing doc.kml file.' );     for ( const path in zip ) {      const extension = path.split( '.' ).pop().toLowerCase();      if ( extension === 'dae' ) {       const loader = new ColladaLoader( manager );      return loader.parse( fflate.strFromU8( zip[ path ] ) );      }     }    }    console.error( 'KMZLoader: Couldn|'t find .dae file.' );   return { scene: new Group() };   }  }  export { KMZLoader }; 
^..^ FILENAME ^..^
addons|loaders|KTX2Loader.js
^..^ CONTENTS ^..^
/**  * Loader for KTX 2.0 GPU Texture containers.  *  * KTX 2.0 is a container format for various GPU texture formats. The loader  * supports Basis Universal GPU textures, which can be quickly transcoded to  * a wide variety of GPU texture compression formats, as well as some  * uncompressed DataTexture and Data3DTexture formats.  *  * References:  * - KTX: http://github.khronos.org/KTX-Specification/  * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor  * - BasisU HDR: https://github.com/BinomialLLC/basis_universal/wiki/UASTC-HDR-Texture-Specification-v1.0  */  import {  CompressedTexture,  CompressedArrayTexture,  CompressedCubeTexture,  Data3DTexture,  DataTexture,  DisplayP3ColorSpace,  FileLoader,  FloatType,  HalfFloatType,  NoColorSpace,  LinearFilter,  LinearMipmapLinearFilter,  LinearDisplayP3ColorSpace,  LinearSRGBColorSpace,  Loader,  RedFormat,  RGB_ETC1_Format,  RGB_ETC2_Format,  RGB_PVRTC_4BPPV1_Format,  RGBA_ASTC_4x4_Format,  RGBA_ASTC_6x6_Format,  RGBA_BPTC_Format,  RGBA_ETC2_EAC_Format,  RGBA_PVRTC_4BPPV1_Format,  RGBA_S3TC_DXT5_Format,  RGBA_S3TC_DXT1_Format,  RGBAFormat,  RGFormat,  SRGBColorSpace,  UnsignedByteType, } from 'three'; import { WorkerPool } from '../utils/WorkerPool.js'; import {  read,  KHR_DF_FLAG_ALPHA_PREMULTIPLIED,  KHR_DF_TRANSFER_SRGB,  KHR_SUPERCOMPRESSION_NONE,  KHR_SUPERCOMPRESSION_ZSTD,  VK_FORMAT_UNDEFINED,  VK_FORMAT_R16_SFLOAT,  VK_FORMAT_R16G16_SFLOAT,  VK_FORMAT_R16G16B16A16_SFLOAT,  VK_FORMAT_R32_SFLOAT,  VK_FORMAT_R32G32_SFLOAT,  VK_FORMAT_R32G32B32A32_SFLOAT,  VK_FORMAT_R8_SRGB,  VK_FORMAT_R8_UNORM,  VK_FORMAT_R8G8_SRGB,  VK_FORMAT_R8G8_UNORM,  VK_FORMAT_R8G8B8A8_SRGB,  VK_FORMAT_R8G8B8A8_UNORM,  VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT,  VK_FORMAT_ASTC_6x6_SRGB_BLOCK,  VK_FORMAT_ASTC_6x6_UNORM_BLOCK,  KHR_DF_PRIMARIES_UNSPECIFIED,  KHR_DF_PRIMARIES_BT709,  KHR_DF_PRIMARIES_DISPLAYP3 } from '../libs/ktx-parse.module.js'; import { ZSTDDecoder } from '../libs/zstddec.module.js';  const _taskCache = new WeakMap();  let _activeLoaders = 0;  let _zstd;  class KTX2Loader extends Loader {   constructor( manager ) {    super( manager );    this.transcoderPath = '';   this.transcoderBinary = null;   this.transcoderPending = null;    this.workerPool = new WorkerPool();   this.workerSourceURL = '';   this.workerConfig = null;    if ( typeof MSC_TRANSCODER !== 'undefined' ) {     console.warn(      'THREE.KTX2Loader: Please update to latest "basis_transcoder".'     + ' "msc_basis_transcoder" is no longer supported in three.js r125+.'     );    }   }   setTranscoderPath( path ) {    this.transcoderPath = path;    return this;   }   setWorkerLimit( num ) {    this.workerPool.setWorkerLimit( num );    return this;   }   async detectSupportAsync( renderer ) {    this.workerConfig = {    astcSupported: await renderer.hasFeatureAsync( 'texture-compression-astc' ),    etc1Supported: await renderer.hasFeatureAsync( 'texture-compression-etc1' ),    etc2Supported: await renderer.hasFeatureAsync( 'texture-compression-etc2' ),    dxtSupported: await renderer.hasFeatureAsync( 'texture-compression-bc' ),    bptcSupported: await renderer.hasFeatureAsync( 'texture-compression-bptc' ),    pvrtcSupported: await renderer.hasFeatureAsync( 'texture-compression-pvrtc' )   };    return this;   }   detectSupport( renderer ) {    if ( renderer.isWebGPURenderer === true ) {     this.workerConfig = {     astcSupported: renderer.hasFeature( 'texture-compression-astc' ),     etc1Supported: renderer.hasFeature( 'texture-compression-etc1' ),     etc2Supported: renderer.hasFeature( 'texture-compression-etc2' ),     dxtSupported: renderer.hasFeature( 'texture-compression-bc' ),     bptcSupported: renderer.hasFeature( 'texture-compression-bptc' ),     pvrtcSupported: renderer.hasFeature( 'texture-compression-pvrtc' )    };    } else {     this.workerConfig = {     astcSupported: renderer.extensions.has( 'WEBGL_compressed_texture_astc' ),     etc1Supported: renderer.extensions.has( 'WEBGL_compressed_texture_etc1' ),     etc2Supported: renderer.extensions.has( 'WEBGL_compressed_texture_etc' ),     dxtSupported: renderer.extensions.has( 'WEBGL_compressed_texture_s3tc' ),     bptcSupported: renderer.extensions.has( 'EXT_texture_compression_bptc' ),     pvrtcSupported: renderer.extensions.has( 'WEBGL_compressed_texture_pvrtc' )      || renderer.extensions.has( 'WEBKIT_WEBGL_compressed_texture_pvrtc' )    };    }    return this;   }   init() {    if ( ! this.transcoderPending ) {     // Load transcoder wrapper.    const jsLoader = new FileLoader( this.manager );    jsLoader.setPath( this.transcoderPath );    jsLoader.setWithCredentials( this.withCredentials );    const jsContent = jsLoader.loadAsync( 'basis_transcoder.js' );     // Load transcoder WASM binary.    const binaryLoader = new FileLoader( this.manager );    binaryLoader.setPath( this.transcoderPath );    binaryLoader.setResponseType( 'arraybuffer' );    binaryLoader.setWithCredentials( this.withCredentials );    const binaryContent = binaryLoader.loadAsync( 'basis_transcoder.wasm' );     this.transcoderPending = Promise.all( [ jsContent, binaryContent ] )     .then( ( [ jsContent, binaryContent ] ) => {       const fn = KTX2Loader.BasisWorker.toString();       const body = [       '/* constants */',       'let _EngineFormat = ' + JSON.stringify( KTX2Loader.EngineFormat ),       'let _TranscoderFormat = ' + JSON.stringify( KTX2Loader.TranscoderFormat ),       'let _BasisFormat = ' + JSON.stringify( KTX2Loader.BasisFormat ),       '/* basis_transcoder.js */',       jsContent,       '/* worker */',       fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )      ].join( '|n' );       this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );      this.transcoderBinary = binaryContent;       this.workerPool.setWorkerCreator( () => {        const worker = new Worker( this.workerSourceURL );       const transcoderBinary = this.transcoderBinary.slice( 0 );        worker.postMessage( { type: 'init', config: this.workerConfig, transcoderBinary }, [ transcoderBinary ] );        return worker;       } );      } );     if ( _activeLoaders > 0 ) {      // Each instance loads a transcoder and allocates workers, increasing network and memory cost.      console.warn(       'THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues.'      + ' Use a single KTX2Loader instance, or call .dispose() on old instances.'      );     }     _activeLoaders ++;    }    return this.transcoderPending;   }   load( url, onLoad, onProgress, onError ) {    if ( this.workerConfig === null ) {     throw new Error( 'THREE.KTX2Loader: Missing initialization with |.detectSupport( renderer )|.' );    }    const loader = new FileLoader( this.manager );    loader.setResponseType( 'arraybuffer' );   loader.setWithCredentials( this.withCredentials );    loader.load( url, ( buffer ) => {     this.parse( buffer, onLoad, onError );    }, onProgress, onError );   }   parse( buffer, onLoad, onError ) {    if ( this.workerConfig === null ) {     throw new Error( 'THREE.KTX2Loader: Missing initialization with |.detectSupport( renderer )|.' );    }    // Check for an existing task using this buffer. A transferred buffer cannot be transferred   // again from this thread.   if ( _taskCache.has( buffer ) ) {     const cachedTask = _taskCache.get( buffer );     return cachedTask.promise.then( onLoad ).catch( onError );    }    this._createTexture( buffer )    .then( ( texture ) => onLoad ? onLoad( texture ) : null )    .catch( onError );   }   _createTextureFrom( transcodeResult, container ) {    const { faces, width, height, format, type, error, dfdFlags } = transcodeResult;    if ( type === 'error' ) return Promise.reject( error );    let texture;    if ( container.faceCount === 6 ) {     texture = new CompressedCubeTexture( faces, format, UnsignedByteType );    } else {     const mipmaps = faces[ 0 ].mipmaps;     texture = container.layerCount > 1     ? new CompressedArrayTexture( mipmaps, width, height, container.layerCount, format, UnsignedByteType )     : new CompressedTexture( mipmaps, width, height, format, UnsignedByteType );    }    texture.minFilter = faces[ 0 ].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;   texture.magFilter = LinearFilter;   texture.generateMipmaps = false;    texture.needsUpdate = true;   texture.colorSpace = parseColorSpace( container );   texture.premultiplyAlpha = !! ( dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED );    return texture;   }   /**   * @param {ArrayBuffer} buffer   * @param {object?} config   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}   */  async _createTexture( buffer, config = {} ) {    const container = read( new Uint8Array( buffer ) );    if ( container.vkFormat !== VK_FORMAT_UNDEFINED ) {     return createRawTexture( container );    }    //   const taskConfig = config;   const texturePending = this.init().then( () => {     return this.workerPool.postMessage( { type: 'transcode', buffer, taskConfig: taskConfig }, [ buffer ] );    } ).then( ( e ) => this._createTextureFrom( e.data, container ) );    // Cache the task result.   _taskCache.set( buffer, { promise: texturePending } );    return texturePending;   }   dispose() {    this.workerPool.dispose();   if ( this.workerSourceURL ) URL.revokeObjectURL( this.workerSourceURL );    _activeLoaders --;    return this;   }  }   /* CONSTANTS */  KTX2Loader.BasisFormat = {  ETC1S: 0,  UASTC_4x4: 1, };  KTX2Loader.TranscoderFormat = {  ETC1: 0,  ETC2: 1,  BC1: 2,  BC3: 3,  BC4: 4,  BC5: 5,  BC7_M6_OPAQUE_ONLY: 6,  BC7_M5: 7,  PVRTC1_4_RGB: 8,  PVRTC1_4_RGBA: 9,  ASTC_4x4: 10,  ATC_RGB: 11,  ATC_RGBA_INTERPOLATED_ALPHA: 12,  RGBA32: 13,  RGB565: 14,  BGR565: 15,  RGBA4444: 16, };  KTX2Loader.EngineFormat = {  RGBAFormat: RGBAFormat,  RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,  RGBA_BPTC_Format: RGBA_BPTC_Format,  RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,  RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,  RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,  RGB_ETC1_Format: RGB_ETC1_Format,  RGB_ETC2_Format: RGB_ETC2_Format,  RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,  RGBA_S3TC_DXT1_Format: RGBA_S3TC_DXT1_Format, };   /* WEB WORKER */  KTX2Loader.BasisWorker = function () {   let config;  let transcoderPending;  let BasisModule;   const EngineFormat = _EngineFormat; // eslint-disable-line no-undef  const TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef  const BasisFormat = _BasisFormat; // eslint-disable-line no-undef   self.addEventListener( 'message', function ( e ) {    const message = e.data;    switch ( message.type ) {     case 'init':     config = message.config;     init( message.transcoderBinary );     break;     case 'transcode':     transcoderPending.then( () => {       try {        const { faces, buffers, width, height, hasAlpha, format, dfdFlags } = transcode( message.buffer );        self.postMessage( { type: 'transcode', id: message.id, faces, width, height, hasAlpha, format, dfdFlags }, buffers );       } catch ( error ) {        console.error( error );        self.postMessage( { type: 'error', id: message.id, error: error.message } );       }      } );     break;    }   } );   function init( wasmBinary ) {    transcoderPending = new Promise( ( resolve ) => {     BasisModule = { wasmBinary, onRuntimeInitialized: resolve };    BASIS( BasisModule ); // eslint-disable-line no-undef    } ).then( () => {     BasisModule.initializeBasis();     if ( BasisModule.KTX2File === undefined ) {      console.warn( 'THREE.KTX2Loader: Please update Basis Universal transcoder.' );     }    } );   }   function transcode( buffer ) {    const ktx2File = new BasisModule.KTX2File( new Uint8Array( buffer ) );    function cleanup() {     ktx2File.close();    ktx2File.delete();    }    if ( ! ktx2File.isValid() ) {     cleanup();    throw new Error( 'THREE.KTX2Loader: Invalid or unsupported .ktx2 file' );    }    const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;   const width = ktx2File.getWidth();   const height = ktx2File.getHeight();   const layerCount = ktx2File.getLayers() || 1;   const levelCount = ktx2File.getLevels();   const faceCount = ktx2File.getFaces();   const hasAlpha = ktx2File.getHasAlpha();   const dfdFlags = ktx2File.getDFDFlags();    const { transcoderFormat, engineFormat } = getTranscoderFormat( basisFormat, width, height, hasAlpha );    if ( ! width || ! height || ! levelCount ) {     cleanup();    throw new Error( 'THREE.KTX2Loader: Invalid texture' );    }    if ( ! ktx2File.startTranscoding() ) {     cleanup();    throw new Error( 'THREE.KTX2Loader: .startTranscoding failed' );    }    const faces = [];   const buffers = [];    for ( let face = 0; face < faceCount; face ++ ) {     const mipmaps = [];     for ( let mip = 0; mip < levelCount; mip ++ ) {      const layerMips = [];      let mipWidth, mipHeight;      for ( let layer = 0; layer < layerCount; layer ++ ) {       const levelInfo = ktx2File.getImageLevelInfo( mip, layer, face );       if ( face === 0 && mip === 0 && layer === 0 && ( levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0 ) ) {        console.warn( 'THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.' );       }       if ( levelCount > 1 ) {        mipWidth = levelInfo.origWidth;       mipHeight = levelInfo.origHeight;       } else {        // Handles non-multiple-of-four dimensions in textures without mipmaps. Textures with       // mipmaps must use multiple-of-four dimensions, for some texture formats and APIs.       // See mrdoob/three.js#25908.       mipWidth = levelInfo.width;       mipHeight = levelInfo.height;       }       const dst = new Uint8Array( ktx2File.getImageTranscodedSizeInBytes( mip, layer, 0, transcoderFormat ) );      const status = ktx2File.transcodeImage( dst, mip, layer, face, transcoderFormat, 0, - 1, - 1 );       if ( ! status ) {        cleanup();       throw new Error( 'THREE.KTX2Loader: .transcodeImage failed.' );       }       layerMips.push( dst );      }      const mipData = concat( layerMips );      mipmaps.push( { data: mipData, width: mipWidth, height: mipHeight } );     buffers.push( mipData.buffer );     }     faces.push( { mipmaps, width, height, format: engineFormat } );    }    cleanup();    return { faces, buffers, width, height, hasAlpha, format: engineFormat, dfdFlags };   }   //   // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),  // device capabilities, and texture dimensions. The list below ranks the formats separately  // for ETC1S and UASTC.  //  // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at  // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently  // chooses RGBA32 only as a last resort and does not expose that option to the caller.  const FORMAT_OPTIONS = [   {    if: 'astcSupported',    basisFormat: [ BasisFormat.UASTC_4x4 ],    transcoderFormat: [ TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4 ],    engineFormat: [ EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format ],    priorityETC1S: Infinity,    priorityUASTC: 1,    needsPowerOfTwo: false,   },   {    if: 'bptcSupported',    basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],    transcoderFormat: [ TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5 ],    engineFormat: [ EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format ],    priorityETC1S: 3,    priorityUASTC: 2,    needsPowerOfTwo: false,   },   {    if: 'dxtSupported',    basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],    transcoderFormat: [ TranscoderFormat.BC1, TranscoderFormat.BC3 ],    engineFormat: [ EngineFormat.RGBA_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format ],    priorityETC1S: 4,    priorityUASTC: 5,    needsPowerOfTwo: false,   },   {    if: 'etc2Supported',    basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],    transcoderFormat: [ TranscoderFormat.ETC1, TranscoderFormat.ETC2 ],    engineFormat: [ EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format ],    priorityETC1S: 1,    priorityUASTC: 3,    needsPowerOfTwo: false,   },   {    if: 'etc1Supported',    basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],    transcoderFormat: [ TranscoderFormat.ETC1 ],    engineFormat: [ EngineFormat.RGB_ETC1_Format ],    priorityETC1S: 2,    priorityUASTC: 4,    needsPowerOfTwo: false,   },   {    if: 'pvrtcSupported',    basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],    transcoderFormat: [ TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA ],    engineFormat: [ EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format ],    priorityETC1S: 5,    priorityUASTC: 6,    needsPowerOfTwo: true,   },  ];   const ETC1S_OPTIONS = FORMAT_OPTIONS.sort( function ( a, b ) {    return a.priorityETC1S - b.priorityETC1S;   } );  const UASTC_OPTIONS = FORMAT_OPTIONS.sort( function ( a, b ) {    return a.priorityUASTC - b.priorityUASTC;   } );   function getTranscoderFormat( basisFormat, width, height, hasAlpha ) {    let transcoderFormat;   let engineFormat;    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;    for ( let i = 0; i < options.length; i ++ ) {     const opt = options[ i ];     if ( ! config[ opt.if ] ) continue;    if ( ! opt.basisFormat.includes( basisFormat ) ) continue;    if ( hasAlpha && opt.transcoderFormat.length < 2 ) continue;    if ( opt.needsPowerOfTwo && ! ( isPowerOfTwo( width ) && isPowerOfTwo( height ) ) ) continue;     transcoderFormat = opt.transcoderFormat[ hasAlpha ? 1 : 0 ];    engineFormat = opt.engineFormat[ hasAlpha ? 1 : 0 ];     return { transcoderFormat, engineFormat };    }    console.warn( 'THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.' );    transcoderFormat = TranscoderFormat.RGBA32;   engineFormat = EngineFormat.RGBAFormat;    return { transcoderFormat, engineFormat };   }   function isPowerOfTwo( value ) {    if ( value <= 2 ) return true;    return ( value & ( value - 1 ) ) === 0 && value !== 0;   }   /** Concatenates N byte arrays. */  function concat( arrays ) {    if ( arrays.length === 1 ) return arrays[ 0 ];    let totalByteLength = 0;    for ( let i = 0; i < arrays.length; i ++ ) {     const array = arrays[ i ];    totalByteLength += array.byteLength;    }    const result = new Uint8Array( totalByteLength );    let byteOffset = 0;    for ( let i = 0; i < arrays.length; i ++ ) {     const array = arrays[ i ];    result.set( array, byteOffset );     byteOffset += array.byteLength;    }    return result;   }  };  // Parsing for non-Basis textures. These textures may have supercompression // like Zstd, but they do not require transcoding.  const UNCOMPRESSED_FORMATS = new Set( [ RGBAFormat, RGFormat, RedFormat ] );  const FORMAT_MAP = {   [ VK_FORMAT_R32G32B32A32_SFLOAT ]: RGBAFormat,  [ VK_FORMAT_R16G16B16A16_SFLOAT ]: RGBAFormat,  [ VK_FORMAT_R8G8B8A8_UNORM ]: RGBAFormat,  [ VK_FORMAT_R8G8B8A8_SRGB ]: RGBAFormat,   [ VK_FORMAT_R32G32_SFLOAT ]: RGFormat,  [ VK_FORMAT_R16G16_SFLOAT ]: RGFormat,  [ VK_FORMAT_R8G8_UNORM ]: RGFormat,  [ VK_FORMAT_R8G8_SRGB ]: RGFormat,   [ VK_FORMAT_R32_SFLOAT ]: RedFormat,  [ VK_FORMAT_R16_SFLOAT ]: RedFormat,  [ VK_FORMAT_R8_SRGB ]: RedFormat,  [ VK_FORMAT_R8_UNORM ]: RedFormat,   [ VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT ]: RGBA_ASTC_4x4_Format,  [ VK_FORMAT_ASTC_6x6_SRGB_BLOCK ]: RGBA_ASTC_6x6_Format,  [ VK_FORMAT_ASTC_6x6_UNORM_BLOCK ]: RGBA_ASTC_6x6_Format,  };  const TYPE_MAP = {   [ VK_FORMAT_R32G32B32A32_SFLOAT ]: FloatType,  [ VK_FORMAT_R16G16B16A16_SFLOAT ]: HalfFloatType,  [ VK_FORMAT_R8G8B8A8_UNORM ]: UnsignedByteType,  [ VK_FORMAT_R8G8B8A8_SRGB ]: UnsignedByteType,   [ VK_FORMAT_R32G32_SFLOAT ]: FloatType,  [ VK_FORMAT_R16G16_SFLOAT ]: HalfFloatType,  [ VK_FORMAT_R8G8_UNORM ]: UnsignedByteType,  [ VK_FORMAT_R8G8_SRGB ]: UnsignedByteType,   [ VK_FORMAT_R32_SFLOAT ]: FloatType,  [ VK_FORMAT_R16_SFLOAT ]: HalfFloatType,  [ VK_FORMAT_R8_SRGB ]: UnsignedByteType,  [ VK_FORMAT_R8_UNORM ]: UnsignedByteType,   [ VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT ]: HalfFloatType,  [ VK_FORMAT_ASTC_6x6_SRGB_BLOCK ]: UnsignedByteType,  [ VK_FORMAT_ASTC_6x6_UNORM_BLOCK ]: UnsignedByteType,  };  async function createRawTexture( container ) {   const { vkFormat } = container;   if ( FORMAT_MAP[ vkFormat ] === undefined ) {    throw new Error( 'THREE.KTX2Loader: Unsupported vkFormat.' );   }   //   let zstd;   if ( container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD ) {    if ( ! _zstd ) {     _zstd = new Promise( async ( resolve ) => {      const zstd = new ZSTDDecoder();     await zstd.init();     resolve( zstd );     } );    }    zstd = await _zstd;   }   //   const mipmaps = [];    for ( let levelIndex = 0; levelIndex < container.levels.length; levelIndex ++ ) {    const levelWidth = Math.max( 1, container.pixelWidth >> levelIndex );   const levelHeight = Math.max( 1, container.pixelHeight >> levelIndex );   const levelDepth = container.pixelDepth ? Math.max( 1, container.pixelDepth >> levelIndex ) : 0;    const level = container.levels[ levelIndex ];    let levelData;    if ( container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE ) {     levelData = level.levelData;    } else if ( container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD ) {     levelData = zstd.decode( level.levelData, level.uncompressedByteLength );    } else {     throw new Error( 'THREE.KTX2Loader: Unsupported supercompressionScheme.' );    }    let data;    if ( TYPE_MAP[ vkFormat ] === FloatType ) {     data = new Float32Array(      levelData.buffer,     levelData.byteOffset,     levelData.byteLength / Float32Array.BYTES_PER_ELEMENT     );    } else if ( TYPE_MAP[ vkFormat ] === HalfFloatType ) {     data = new Uint16Array(      levelData.buffer,     levelData.byteOffset,     levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT     );    } else {     data = levelData;    }    mipmaps.push( {     data: data,    width: levelWidth,    height: levelHeight,    depth: levelDepth,    } );   }   let texture;   if ( UNCOMPRESSED_FORMATS.has( FORMAT_MAP[ vkFormat ] ) ) {    texture = container.pixelDepth === 0    ? new DataTexture( mipmaps[ 0 ].data, container.pixelWidth, container.pixelHeight )    : new Data3DTexture( mipmaps[ 0 ].data, container.pixelWidth, container.pixelHeight, container.pixelDepth );   } else {    if ( container.pixelDepth > 0 ) throw new Error( 'THREE.KTX2Loader: Unsupported pixelDepth.' );    texture = new CompressedTexture( mipmaps, container.pixelWidth, container.pixelHeight );   }   texture.mipmaps = mipmaps;   texture.type = TYPE_MAP[ vkFormat ];  texture.format = FORMAT_MAP[ vkFormat ];  texture.colorSpace = parseColorSpace( container );  texture.needsUpdate = true;   //   return Promise.resolve( texture );  }  function parseColorSpace( container ) {   const dfd = container.dataFormatDescriptor[ 0 ];   if ( dfd.colorPrimaries === KHR_DF_PRIMARIES_BT709 ) {    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? SRGBColorSpace : LinearSRGBColorSpace;   } else if ( dfd.colorPrimaries === KHR_DF_PRIMARIES_DISPLAYP3 ) {    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace;   } else if ( dfd.colorPrimaries === KHR_DF_PRIMARIES_UNSPECIFIED ) {    return NoColorSpace;   } else {    console.warn( |THREE.KTX2Loader: Unsupported color primaries, "| dfd.colorPrimaries }"| );   return NoColorSpace;   }  }  export { KTX2Loader }; 
^..^ FILENAME ^..^
addons|loaders|KTXLoader.js
^..^ CONTENTS ^..^
import {  CompressedTextureLoader } from 'three';  /**  * for description see https://www.khronos.org/opengles/sdk/tools/KTX/  * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/  *  * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Misc/khronosTextureContainer.ts  */   class KTXLoader extends CompressedTextureLoader {   constructor( manager ) {    super( manager );   }   parse( buffer, loadMipmaps ) {    const ktx = new KhronosTextureContainer( buffer, 1 );    return {    mipmaps: ktx.mipmaps( loadMipmaps ),    width: ktx.pixelWidth,    height: ktx.pixelHeight,    format: ktx.glInternalFormat,    isCubemap: ktx.numberOfFaces === 6,    mipmapCount: ktx.numberOfMipmapLevels   };   }  }   const HEADER_LEN = 12 + ( 13 * 4 ); // identifier + header elements (not including key value meta-data pairs) // load types const COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D() //const COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D() //const TEX_2D = 2; // uses a gl.texImage2D() //const TEX_3D = 3; // uses a gl.texImage3D()  class KhronosTextureContainer {   /**   * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file   * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or   * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented   * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented   */  constructor( arrayBuffer, facesExpected /*, threeDExpected, textureArrayExpected */ ) {    this.arrayBuffer = arrayBuffer;    // Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:   // '?', 'K', 'T', 'X', ' ', '1', '1', '', '|r', '|n', '|x1A', '|n'   // 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A   const identifier = new Uint8Array( this.arrayBuffer, 0, 12 );   if ( identifier[ 0 ] !== 0xAB ||    identifier[ 1 ] !== 0x4B ||    identifier[ 2 ] !== 0x54 ||    identifier[ 3 ] !== 0x58 ||    identifier[ 4 ] !== 0x20 ||    identifier[ 5 ] !== 0x31 ||    identifier[ 6 ] !== 0x31 ||    identifier[ 7 ] !== 0xBB ||    identifier[ 8 ] !== 0x0D ||    identifier[ 9 ] !== 0x0A ||    identifier[ 10 ] !== 0x1A ||    identifier[ 11 ] !== 0x0A ) {     console.error( 'texture missing KTX identifier' );    return;    }    // load the reset of the header in native 32 bit uint   const dataSize = Uint32Array.BYTES_PER_ELEMENT;   const headerDataView = new DataView( this.arrayBuffer, 12, 13 * dataSize );   const endianness = headerDataView.getUint32( 0, true );   const littleEndian = endianness === 0x04030201;    this.glType = headerDataView.getUint32( 1 * dataSize, littleEndian ); // must be 0 for compressed textures   this.glTypeSize = headerDataView.getUint32( 2 * dataSize, littleEndian ); // must be 1 for compressed textures   this.glFormat = headerDataView.getUint32( 3 * dataSize, littleEndian ); // must be 0 for compressed textures   this.glInternalFormat = headerDataView.getUint32( 4 * dataSize, littleEndian ); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)   this.glBaseInternalFormat = headerDataView.getUint32( 5 * dataSize, littleEndian ); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)   this.pixelWidth = headerDataView.getUint32( 6 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)   this.pixelHeight = headerDataView.getUint32( 7 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)   this.pixelDepth = headerDataView.getUint32( 8 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)   this.numberOfArrayElements = headerDataView.getUint32( 9 * dataSize, littleEndian ); // used for texture arrays   this.numberOfFaces = headerDataView.getUint32( 10 * dataSize, littleEndian ); // used for cubemap textures, should either be 1 or 6   this.numberOfMipmapLevels = headerDataView.getUint32( 11 * dataSize, littleEndian ); // number of levels; disregard possibility of 0 for compressed textures   this.bytesOfKeyValueData = headerDataView.getUint32( 12 * dataSize, littleEndian ); // the amount of space after the header for meta-data    // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.   if ( this.glType !== 0 ) {     console.warn( 'only compressed formats currently supported' );    return;    } else {     // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.    this.numberOfMipmapLevels = Math.max( 1, this.numberOfMipmapLevels );    }    if ( this.pixelHeight === 0 || this.pixelDepth !== 0 ) {     console.warn( 'only 2D textures currently supported' );    return;    }    if ( this.numberOfArrayElements !== 0 ) {     console.warn( 'texture arrays not currently supported' );    return;    }    if ( this.numberOfFaces !== facesExpected ) {     console.warn( 'number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces );    return;    }    // we now have a completely validated file, so could use existence of loadType as success   // would need to make this more elaborate & adjust checks above to support more than one load type   this.loadType = COMPRESSED_2D;   }   mipmaps( loadMipmaps ) {    const mipmaps = [];    // initialize width & height for level 1   let dataOffset = HEADER_LEN + this.bytesOfKeyValueData;   let width = this.pixelWidth;   let height = this.pixelHeight;   const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;    for ( let level = 0; level < mipmapCount; level ++ ) {     const imageSize = new Int32Array( this.arrayBuffer, dataOffset, 1 )[ 0 ]; // size per face, since not supporting array cubemaps    dataOffset += 4; // size of the image + 4 for the imageSize field     for ( let face = 0; face < this.numberOfFaces; face ++ ) {      const byteArray = new Uint8Array( this.arrayBuffer, dataOffset, imageSize );      mipmaps.push( { 'data': byteArray, 'width': width, 'height': height } );      dataOffset += imageSize;     dataOffset += 3 - ( ( imageSize + 3 ) % 4 ); // add padding for odd sized image     }     width = Math.max( 1.0, width * 0.5 );    height = Math.max( 1.0, height * 0.5 );    }    return mipmaps;   }  }  export { KTXLoader }; 
^..^ FILENAME ^..^
addons|loaders|LDrawLoader.js
^..^ CONTENTS ^..^
import {  BufferAttribute,  BufferGeometry,  Color,  FileLoader,  Group,  LineBasicMaterial,  LineSegments,  Loader,  Matrix4,  Mesh,  MeshStandardMaterial,  ShaderMaterial,  SRGBColorSpace,  UniformsLib,  UniformsUtils,  Vector3,  Ray } from 'three';  // Special surface finish tag types. // Note: "MATERIAL" tag (e.g. GLITTER, SPECKLE) is not implemented const FINISH_TYPE_DEFAULT = 0; const FINISH_TYPE_CHROME = 1; const FINISH_TYPE_PEARLESCENT = 2; const FINISH_TYPE_RUBBER = 3; const FINISH_TYPE_MATTE_METALLIC = 4; const FINISH_TYPE_METAL = 5;  // State machine to search a subobject path. // The LDraw standard establishes these various possible subfolders. const FILE_LOCATION_TRY_PARTS = 0; const FILE_LOCATION_TRY_P = 1; const FILE_LOCATION_TRY_MODELS = 2; const FILE_LOCATION_AS_IS = 3; const FILE_LOCATION_TRY_RELATIVE = 4; const FILE_LOCATION_TRY_ABSOLUTE = 5; const FILE_LOCATION_NOT_FOUND = 6;  const MAIN_COLOUR_CODE = '16'; const MAIN_EDGE_COLOUR_CODE = '24';  const COLOR_SPACE_LDRAW = SRGBColorSpace;  const _tempVec0 = new Vector3(); const _tempVec1 = new Vector3();  class LDrawConditionalLineMaterial extends ShaderMaterial {   constructor( parameters ) {    super( {     uniforms: UniformsUtils.merge( [     UniformsLib.fog,     {      diffuse: {       value: new Color()      },      opacity: {       value: 1.0      }     }    ] ),     vertexShader: /* glsl */|     attribute vec3 control0;     attribute vec3 control1;     attribute vec3 direction;     varying float discardFlag;      #include <common>     #include <color_pars_vertex>     #include <fog_pars_vertex>     #include <logdepthbuf_pars_vertex>     #include <clipping_planes_pars_vertex>     void main() {      #include <color_vertex>       vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );      gl_Position = projectionMatrix * mvPosition;       // Transform the line segment ends and control points into camera clip space      vec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );      vec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );      vec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );      vec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );       c0.xy /= c0.w;      c1.xy /= c1.w;      p0.xy /= p0.w;      p1.xy /= p1.w;       // Get the direction of the segment and an orthogonal vector      vec2 dir = p1.xy - p0.xy;      vec2 norm = vec2( -dir.y, dir.x );       // Get control point directions from the line      vec2 c0dir = c0.xy - p1.xy;      vec2 c1dir = c1.xy - p1.xy;       // If the vectors to the controls points are pointed in different directions away      // from the line segment then the line should not be drawn.      float d0 = dot( normalize( norm ), normalize( c0dir ) );      float d1 = dot( normalize( norm ), normalize( c1dir ) );      discardFlag = float( sign( d0 ) != sign( d1 ) );       #include <logdepthbuf_vertex>      #include <clipping_planes_vertex>      #include <fog_vertex>     }    |,     fragmentShader: /* glsl */|    uniform vec3 diffuse;    uniform float opacity;    varying float discardFlag;     #include <common>    #include <color_pars_fragment>    #include <fog_pars_fragment>    #include <logdepthbuf_pars_fragment>    #include <clipping_planes_pars_fragment>    void main() {      if ( discardFlag > 0.5 ) discard;      #include <clipping_planes_fragment>     vec3 outgoingLight = vec3( 0.0 );     vec4 diffuseColor = vec4( diffuse, opacity );     #include <logdepthbuf_fragment>     #include <color_fragment>     outgoingLight = diffuseColor.rgb; // simple shader     gl_FragColor = vec4( outgoingLight, diffuseColor.a );     #include <tonemapping_fragment>     #include <colorspace_fragment>     #include <fog_fragment>     #include <premultiplied_alpha_fragment>    }    |,    } );    Object.defineProperties( this, {     opacity: {     get: function () {       return this.uniforms.opacity.value;      },      set: function ( value ) {       this.uniforms.opacity.value = value;      }    },     color: {     get: function () {       return this.uniforms.diffuse.value;      }    }    } );    this.setValues( parameters );   this.isLDrawConditionalLineMaterial = true;   }  }  class ConditionalLineSegments extends LineSegments {   constructor( geometry, material ) {    super( geometry, material );   this.isConditionalLine = true;   }  }  function generateFaceNormals( faces ) {   for ( let i = 0, l = faces.length; i < l; i ++ ) {    const face = faces[ i ];   const vertices = face.vertices;   const v0 = vertices[ 0 ];   const v1 = vertices[ 1 ];   const v2 = vertices[ 2 ];    _tempVec0.subVectors( v1, v0 );   _tempVec1.subVectors( v2, v1 );   face.faceNormal = new Vector3()    .crossVectors( _tempVec0, _tempVec1 )    .normalize();   }  }  const _ray = new Ray(); function smoothNormals( faces, lineSegments, checkSubSegments = false ) {   // NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because  // it allows edges to be smoothed as expected (see minifig arms).  // --  // And the vector values are initialize multiplied by 1 + 1e-10 to account for floating  // point errors on vertices along quantization boundaries. Ie after matrix multiplication  // vertices that should be merged might be set to "1.7" and "1.6999..." meaning they won't  // get merged. This added epsilon attempts to push these error values to the same quantized  // value for the sake of hashing. See "AT-ST mini" dishes. See mrdoob/three#23169.   const hashMultiplier = ( 1 + 1e-10 ) * 1e2;  function hashVertex( v ) {    const x = ~ ~ ( v.x * hashMultiplier );   const y = ~ ~ ( v.y * hashMultiplier );   const z = ~ ~ ( v.z * hashMultiplier );    return || x },| y },| z }|;   }   function hashEdge( v0, v1 ) {    return || hashVertex( v0 ) }_| hashVertex( v1 ) }|;   }   // converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected  // onto the original line.  function toNormalizedRay( v0, v1, targetRay ) {    targetRay.direction.subVectors( v1, v0 ).normalize();    const scalar = v0.dot( targetRay.direction );   targetRay.origin.copy( v0 ).addScaledVector( targetRay.direction, - scalar );    return targetRay;   }   function hashRay( ray ) {    return hashEdge( ray.origin, ray.direction );   }   const hardEdges = new Set();  const hardEdgeRays = new Map();  const halfEdgeList = {};  const normals = [];   // Save the list of hard edges by hash  for ( let i = 0, l = lineSegments.length; i < l; i ++ ) {    const ls = lineSegments[ i ];   const vertices = ls.vertices;   const v0 = vertices[ 0 ];   const v1 = vertices[ 1 ];   hardEdges.add( hashEdge( v0, v1 ) );   hardEdges.add( hashEdge( v1, v0 ) );    // only generate the hard edge ray map if we're checking subsegments because it's more expensive to check   // and requires more memory.   if ( checkSubSegments ) {     // add both ray directions to the map    const ray = toNormalizedRay( v0, v1, new Ray() );    const rh1 = hashRay( ray );    if ( ! hardEdgeRays.has( rh1 ) ) {      toNormalizedRay( v1, v0, ray );     const rh2 = hashRay( ray );      const info = {      ray,      distances: [],     };      hardEdgeRays.set( rh1, info );     hardEdgeRays.set( rh2, info );     }     // store both segments ends in min, max order in the distances array to check if a face edge is a    // subsegment later.    const info = hardEdgeRays.get( rh1 );    let d0 = info.ray.direction.dot( v0 );    let d1 = info.ray.direction.dot( v1 );    if ( d0 > d1 ) {      [ d0, d1 ] = [ d1, d0 ];     }     info.distances.push( d0, d1 );    }   }   // track the half edges associated with each triangle  for ( let i = 0, l = faces.length; i < l; i ++ ) {    const tri = faces[ i ];   const vertices = tri.vertices;   const vertCount = vertices.length;   for ( let i2 = 0; i2 < vertCount; i2 ++ ) {     const index = i2;    const next = ( i2 + 1 ) % vertCount;    const v0 = vertices[ index ];    const v1 = vertices[ next ];    const hash = hashEdge( v0, v1 );     // don't add the triangle if the edge is supposed to be hard    if ( hardEdges.has( hash ) ) {      continue;     }     // if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds    if ( checkSubSegments ) {      toNormalizedRay( v0, v1, _ray );      const rayHash = hashRay( _ray );     if ( hardEdgeRays.has( rayHash ) ) {       const info = hardEdgeRays.get( rayHash );      const { ray, distances } = info;      let d0 = ray.direction.dot( v0 );      let d1 = ray.direction.dot( v1 );       if ( d0 > d1 ) {        [ d0, d1 ] = [ d1, d0 ];       }       // return early if the face edge is found to be a subsegment of a line edge meaning the edge will have "hard" normals      let found = false;      for ( let i = 0, l = distances.length; i < l; i += 2 ) {        if ( d0 >= distances[ i ] && d1 <= distances[ i + 1 ] ) {         found = true;        break;        }       }       if ( found ) {        continue;       }      }     }     const info = {     index: index,     tri: tri    };    halfEdgeList[ hash ] = info;    }   }   // Iterate until we've tried to connect all faces to share normals  while ( true ) {    // Stop if there are no more faces left   let halfEdge = null;   for ( const key in halfEdgeList ) {     halfEdge = halfEdgeList[ key ];    break;    }    if ( halfEdge === null ) {     break;    }    // Exhaustively find all connected faces   const queue = [ halfEdge ];   while ( queue.length > 0 ) {     // initialize all vertex normals in this triangle    const tri = queue.pop().tri;    const vertices = tri.vertices;    const vertNormals = tri.normals;    const faceNormal = tri.faceNormal;     // Check if any edge is connected to another triangle edge    const vertCount = vertices.length;    for ( let i2 = 0; i2 < vertCount; i2 ++ ) {      const index = i2;     const next = ( i2 + 1 ) % vertCount;     const v0 = vertices[ index ];     const v1 = vertices[ next ];      // delete this triangle from the list so it won't be found again     const hash = hashEdge( v0, v1 );     delete halfEdgeList[ hash ];      const reverseHash = hashEdge( v1, v0 );     const otherInfo = halfEdgeList[ reverseHash ];     if ( otherInfo ) {       const otherTri = otherInfo.tri;      const otherIndex = otherInfo.index;      const otherNormals = otherTri.normals;      const otherVertCount = otherNormals.length;      const otherFaceNormal = otherTri.faceNormal;       // NOTE: If the angle between faces is > 67.5 degrees then assume it's      // hard edge. There are some cases where the line segments do not line up exactly      // with or span multiple triangle edges (see Lunar Vehicle wheels).      if ( Math.abs( otherTri.faceNormal.dot( tri.faceNormal ) ) < 0.25 ) {        continue;       }       // if this triangle has already been traversed then it won't be in      // the halfEdgeList. If it has not then add it to the queue and delete      // it so it won't be found again.      if ( reverseHash in halfEdgeList ) {        queue.push( otherInfo );       delete halfEdgeList[ reverseHash ];       }       // share the first normal      const otherNext = ( otherIndex + 1 ) % otherVertCount;      if (       vertNormals[ index ] && otherNormals[ otherNext ] &&       vertNormals[ index ] !== otherNormals[ otherNext ]      ) {        otherNormals[ otherNext ].norm.add( vertNormals[ index ].norm );       vertNormals[ index ].norm = otherNormals[ otherNext ].norm;       }       let sharedNormal1 = vertNormals[ index ] || otherNormals[ otherNext ];      if ( sharedNormal1 === null ) {        // it's possible to encounter an edge of a triangle that has already been traversed meaning       // both edges already have different normals defined and shared. To work around this we create       // a wrapper object so when those edges are merged the normals can be updated everywhere.       sharedNormal1 = { norm: new Vector3() };       normals.push( sharedNormal1.norm );       }       if ( vertNormals[ index ] === null ) {        vertNormals[ index ] = sharedNormal1;       sharedNormal1.norm.add( faceNormal );       }       if ( otherNormals[ otherNext ] === null ) {        otherNormals[ otherNext ] = sharedNormal1;       sharedNormal1.norm.add( otherFaceNormal );       }       // share the second normal      if (       vertNormals[ next ] && otherNormals[ otherIndex ] &&       vertNormals[ next ] !== otherNormals[ otherIndex ]      ) {        otherNormals[ otherIndex ].norm.add( vertNormals[ next ].norm );       vertNormals[ next ].norm = otherNormals[ otherIndex ].norm;       }       let sharedNormal2 = vertNormals[ next ] || otherNormals[ otherIndex ];      if ( sharedNormal2 === null ) {        sharedNormal2 = { norm: new Vector3() };       normals.push( sharedNormal2.norm );       }       if ( vertNormals[ next ] === null ) {        vertNormals[ next ] = sharedNormal2;       sharedNormal2.norm.add( faceNormal );       }       if ( otherNormals[ otherIndex ] === null ) {        otherNormals[ otherIndex ] = sharedNormal2;       sharedNormal2.norm.add( otherFaceNormal );       }      }     }    }   }   // The normals of each face have been added up so now we average them by normalizing the vector.  for ( let i = 0, l = normals.length; i < l; i ++ ) {    normals[ i ].normalize();   }  }  function isPartType( type ) {   return type === 'Part' || type === 'Unofficial_Part';  }  function isPrimitiveType( type ) {   return /primitive/i.test( type ) || type === 'Subpart';  }  class LineParser {   constructor( line, lineNumber ) {    this.line = line;   this.lineLength = line.length;   this.currentCharIndex = 0;   this.currentChar = ' ';   this.lineNumber = lineNumber;   }   seekNonSpace() {    while ( this.currentCharIndex < this.lineLength ) {     this.currentChar = this.line.charAt( this.currentCharIndex );     if ( this.currentChar !== ' ' && this.currentChar !== '|t' ) {      return;     }     this.currentCharIndex ++;    }   }   getToken() {    const pos0 = this.currentCharIndex ++;    // Seek space   while ( this.currentCharIndex < this.lineLength ) {     this.currentChar = this.line.charAt( this.currentCharIndex );     if ( this.currentChar === ' ' || this.currentChar === '|t' ) {      break;     }     this.currentCharIndex ++;    }    const pos1 = this.currentCharIndex;    this.seekNonSpace();    return this.line.substring( pos0, pos1 );   }   getVector() {    return new Vector3( parseFloat( this.getToken() ), parseFloat( this.getToken() ), parseFloat( this.getToken() ) );   }   getRemainingString() {    return this.line.substring( this.currentCharIndex, this.lineLength );   }   isAtTheEnd() {    return this.currentCharIndex >= this.lineLength;   }   setToEnd() {    this.currentCharIndex = this.lineLength;   }   getLineNumberString() {    return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';   }  }  // Fetches and parses an intermediate representation of LDraw parts files. class LDrawParsedCache {   constructor( loader ) {    this.loader = loader;   this._cache = {};   }   cloneResult( original ) {    const result = {};    // vertices are transformed and normals computed before being converted to geometry   // so these pieces must be cloned.   result.faces = original.faces.map( face => {     return {     colorCode: face.colorCode,     material: face.material,     vertices: face.vertices.map( v => v.clone() ),     normals: face.normals.map( () => null ),     faceNormal: null    };    } );    result.conditionalSegments = original.conditionalSegments.map( face => {     return {     colorCode: face.colorCode,     material: face.material,     vertices: face.vertices.map( v => v.clone() ),     controlPoints: face.controlPoints.map( v => v.clone() )    };    } );    result.lineSegments = original.lineSegments.map( face => {     return {     colorCode: face.colorCode,     material: face.material,     vertices: face.vertices.map( v => v.clone() )    };    } );    // none if this is subsequently modified   result.type = original.type;   result.category = original.category;   result.keywords = original.keywords;   result.author = original.author;   result.subobjects = original.subobjects;   result.fileName = original.fileName;   result.totalFaces = original.totalFaces;   result.startingBuildingStep = original.startingBuildingStep;   result.materials = original.materials;   result.group = null;   return result;   }   async fetchData( fileName ) {    let triedLowerCase = false;   let locationState = FILE_LOCATION_TRY_PARTS;   while ( locationState !== FILE_LOCATION_NOT_FOUND ) {     let subobjectURL = fileName;    switch ( locationState ) {      case FILE_LOCATION_AS_IS:      locationState = locationState + 1;      break;      case FILE_LOCATION_TRY_PARTS:      subobjectURL = 'parts/' + subobjectURL;      locationState = locationState + 1;      break;      case FILE_LOCATION_TRY_P:      subobjectURL = 'p/' + subobjectURL;      locationState = locationState + 1;      break;      case FILE_LOCATION_TRY_MODELS:      subobjectURL = 'models/' + subobjectURL;      locationState = locationState + 1;      break;      case FILE_LOCATION_TRY_RELATIVE:      subobjectURL = fileName.substring( 0, fileName.lastIndexOf( '/' ) + 1 ) + subobjectURL;      locationState = locationState + 1;      break;      case FILE_LOCATION_TRY_ABSOLUTE:       if ( triedLowerCase ) {        // Try absolute path       locationState = FILE_LOCATION_NOT_FOUND;       } else {        // Next attempt is lower case       fileName = fileName.toLowerCase();       subobjectURL = fileName;       triedLowerCase = true;       locationState = FILE_LOCATION_TRY_PARTS;       }       break;     }     const loader = this.loader;    const fileLoader = new FileLoader( loader.manager );    fileLoader.setPath( loader.partsLibraryPath );    fileLoader.setRequestHeader( loader.requestHeader );    fileLoader.setWithCredentials( loader.withCredentials );     try {      const text = await fileLoader.loadAsync( subobjectURL );     return text;     } catch ( _ ) {      continue;     }    }    throw new Error( 'LDrawLoader: Subobject "' + fileName + '" could not be loaded.' );   }   parse( text, fileName = null ) {    const loader = this.loader;    // final results   const faces = [];   const lineSegments = [];   const conditionalSegments = [];   const subobjects = [];   const materials = {};    const getLocalMaterial = colorCode => {     return materials[ colorCode ] || null;    };    let type = 'Model';   let category = null;   let keywords = null;   let author = null;   let totalFaces = 0;    // split into lines   if ( text.indexOf( '|r|n' ) !== - 1 ) {     // This is faster than String.split with regex that splits on both    text = text.replace( /|r|n/g, '|n' );    }    const lines = text.split( '|n' );   const numLines = lines.length;    let parsingEmbeddedFiles = false;   let currentEmbeddedFileName = null;   let currentEmbeddedText = null;    let bfcCertified = false;   let bfcCCW = true;   let bfcInverted = false;   let bfcCull = true;    let startingBuildingStep = false;    // Parse all line commands   for ( let lineIndex = 0; lineIndex < numLines; lineIndex ++ ) {     const line = lines[ lineIndex ];     if ( line.length === 0 ) continue;     if ( parsingEmbeddedFiles ) {      if ( line.startsWith( '0 FILE ' ) ) {       // Save previous embedded file in the cache      this.setData( currentEmbeddedFileName, currentEmbeddedText );       // New embedded text file      currentEmbeddedFileName = line.substring( 7 );      currentEmbeddedText = '';      } else {       currentEmbeddedText += line + '|n';      }      continue;     }     const lp = new LineParser( line, lineIndex + 1 );    lp.seekNonSpace();     if ( lp.isAtTheEnd() ) {      // Empty line     continue;     }     // Parse the line type    const lineType = lp.getToken();     let material;    let colorCode;    let segment;    let ccw;    let doubleSided;    let v0, v1, v2, v3, c0, c1;     switch ( lineType ) {      // Line type 0: Comment or META     case '0':       // Parse meta directive      const meta = lp.getToken();       if ( meta ) {        switch ( meta ) {         case '!LDRAW_ORG':          type = lp.getToken();         break;         case '!COLOUR':          material = loader.parseColorMetaDirective( lp );         if ( material ) {           materials[ material.userData.code ] = material;          } else {           console.warn( 'LDrawLoader: Error parsing material' + lp.getLineNumberString() );          }          break;         case '!CATEGORY':          category = lp.getToken();         break;         case '!KEYWORDS':          const newKeywords = lp.getRemainingString().split( ',' );         if ( newKeywords.length > 0 ) {           if ( ! keywords ) {            keywords = [];           }           newKeywords.forEach( function ( keyword ) {            keywords.push( keyword.trim() );           } );          }          break;         case 'FILE':          if ( lineIndex > 0 ) {           // Start embedded text files parsing          parsingEmbeddedFiles = true;          currentEmbeddedFileName = lp.getRemainingString();          currentEmbeddedText = '';           bfcCertified = false;          bfcCCW = true;          }          break;         case 'BFC':          // Changes to the backface culling state         while ( ! lp.isAtTheEnd() ) {           const token = lp.getToken();           switch ( token ) {            case 'CERTIFY':           case 'NOCERTIFY':             bfcCertified = token === 'CERTIFY';            bfcCCW = true;             break;            case 'CW':           case 'CCW':             bfcCCW = token === 'CCW';             break;            case 'INVERTNEXT':             bfcInverted = true;             break;            case 'CLIP':           case 'NOCLIP':             bfcCull = token === 'CLIP';             break;            default:             console.warn( 'THREE.LDrawLoader: BFC directive "' + token + '" is unknown.' );             break;           }          }          break;         case 'STEP':          startingBuildingStep = true;          break;         case 'Author:':          author = lp.getToken();          break;         default:         // Other meta directives are not implemented         break;        }       }       break;       // Line type 1: Sub-object file     case '1':       colorCode = lp.getToken();      material = getLocalMaterial( colorCode );       const posX = parseFloat( lp.getToken() );      const posY = parseFloat( lp.getToken() );      const posZ = parseFloat( lp.getToken() );      const m0 = parseFloat( lp.getToken() );      const m1 = parseFloat( lp.getToken() );      const m2 = parseFloat( lp.getToken() );      const m3 = parseFloat( lp.getToken() );      const m4 = parseFloat( lp.getToken() );      const m5 = parseFloat( lp.getToken() );      const m6 = parseFloat( lp.getToken() );      const m7 = parseFloat( lp.getToken() );      const m8 = parseFloat( lp.getToken() );       const matrix = new Matrix4().set(       m0, m1, m2, posX,       m3, m4, m5, posY,       m6, m7, m8, posZ,       0, 0, 0, 1      );       let fileName = lp.getRemainingString().trim().replace( /||/g, '/' );       if ( loader.fileMap[ fileName ] ) {        // Found the subobject path in the preloaded file path map       fileName = loader.fileMap[ fileName ];       } else {        // Standardized subfolders       if ( fileName.startsWith( 's/' ) ) {         fileName = 'parts/' + fileName;        } else if ( fileName.startsWith( '48/' ) ) {         fileName = 'p/' + fileName;        }       }       subobjects.push( {       material: material,       colorCode: colorCode,       matrix: matrix,       fileName: fileName,       inverted: bfcInverted,       startingBuildingStep: startingBuildingStep      } );       startingBuildingStep = false;      bfcInverted = false;       break;       // Line type 2: Line segment     case '2':       colorCode = lp.getToken();      material = getLocalMaterial( colorCode );      v0 = lp.getVector();      v1 = lp.getVector();       segment = {       material: material,       colorCode: colorCode,       vertices: [ v0, v1 ],      };       lineSegments.push( segment );       break;       // Line type 5: Conditional Line segment     case '5':       colorCode = lp.getToken();      material = getLocalMaterial( colorCode );      v0 = lp.getVector();      v1 = lp.getVector();      c0 = lp.getVector();      c1 = lp.getVector();       segment = {       material: material,       colorCode: colorCode,       vertices: [ v0, v1 ],       controlPoints: [ c0, c1 ],      };       conditionalSegments.push( segment );       break;       // Line type 3: Triangle     case '3':       colorCode = lp.getToken();      material = getLocalMaterial( colorCode );      ccw = bfcCCW;      doubleSided = ! bfcCertified || ! bfcCull;       if ( ccw === true ) {        v0 = lp.getVector();       v1 = lp.getVector();       v2 = lp.getVector();       } else {        v2 = lp.getVector();       v1 = lp.getVector();       v0 = lp.getVector();       }       faces.push( {       material: material,       colorCode: colorCode,       faceNormal: null,       vertices: [ v0, v1, v2 ],       normals: [ null, null, null ],      } );      totalFaces ++;       if ( doubleSided === true ) {        faces.push( {        material: material,        colorCode: colorCode,        faceNormal: null,        vertices: [ v2, v1, v0 ],        normals: [ null, null, null ],       } );       totalFaces ++;       }       break;       // Line type 4: Quadrilateral     case '4':       colorCode = lp.getToken();      material = getLocalMaterial( colorCode );      ccw = bfcCCW;      doubleSided = ! bfcCertified || ! bfcCull;       if ( ccw === true ) {        v0 = lp.getVector();       v1 = lp.getVector();       v2 = lp.getVector();       v3 = lp.getVector();       } else {        v3 = lp.getVector();       v2 = lp.getVector();       v1 = lp.getVector();       v0 = lp.getVector();       }       // specifically place the triangle diagonal in the v0 and v1 slots so we can      // account for the doubling of vertices later when smoothing normals.      faces.push( {       material: material,       colorCode: colorCode,       faceNormal: null,       vertices: [ v0, v1, v2, v3 ],       normals: [ null, null, null, null ],      } );      totalFaces += 2;       if ( doubleSided === true ) {        faces.push( {        material: material,        colorCode: colorCode,        faceNormal: null,        vertices: [ v3, v2, v1, v0 ],        normals: [ null, null, null, null ],       } );       totalFaces += 2;       }       break;      default:      throw new Error( 'LDrawLoader: Unknown line type "' + lineType + '"' + lp.getLineNumberString() + '.' );     }    }    if ( parsingEmbeddedFiles ) {     this.setData( currentEmbeddedFileName, currentEmbeddedText );    }    return {    faces,    conditionalSegments,    lineSegments,    type,    category,    keywords,    author,    subobjects,    totalFaces,    startingBuildingStep,    materials,    fileName,    group: null   };   }   // returns an (optionally cloned) instance of the data  getData( fileName, clone = true ) {    const key = fileName.toLowerCase();   const result = this._cache[ key ];   if ( result === null || result instanceof Promise ) {     return null;    }    if ( clone ) {     return this.cloneResult( result );    } else {     return result;    }   }   // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when  // the data is ready to use and can be retrieved synchronously with "getData".  async ensureDataLoaded( fileName ) {    const key = fileName.toLowerCase();   if ( ! ( key in this._cache ) ) {     // replace the promise with a copy of the parsed data for immediate processing    this._cache[ key ] = this.fetchData( fileName ).then( text => {      const info = this.parse( text, fileName );     this._cache[ key ] = info;     return info;     } );    }    await this._cache[ key ];   }   // sets the data in the cache from parsed data  setData( fileName, text ) {    const key = fileName.toLowerCase();   this._cache[ key ] = this.parse( text, fileName );   }  }  // returns the material for an associated color code. If the color code is 16 for a face or 24 for // an edge then the passthroughColorCode is used. function getMaterialFromCode( colorCode, parentColorCode, materialHierarchy, forEdge ) {   const isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;  if ( isPassthrough ) {    colorCode = parentColorCode;   }   return materialHierarchy[ colorCode ] || null;  }  // Class used to parse and build LDraw parts as three.js objects and cache them if they're a "Part" type. class LDrawPartsGeometryCache {   constructor( loader ) {    this.loader = loader;   this.parseCache = new LDrawParsedCache( loader );   this._cache = {};   }   // Convert the given file information into a mesh by processing subobjects.  async processIntoMesh( info ) {    const loader = this.loader;   const parseCache = this.parseCache;   const faceMaterials = new Set();    // Processes the part subobject information to load child parts and merge geometry onto part   // piece object.   const processInfoSubobjects = async ( info, subobject = null ) => {     const subobjects = info.subobjects;    const promises = [];     // Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate    // group which lets instruction steps apply correctly.    for ( let i = 0, l = subobjects.length; i < l; i ++ ) {      const subobject = subobjects[ i ];     const promise = parseCache.ensureDataLoaded( subobject.fileName ).then( () => {       const subobjectInfo = parseCache.getData( subobject.fileName, false );      if ( ! isPrimitiveType( subobjectInfo.type ) ) {        return this.loadModel( subobject.fileName ).catch( error => {         console.warn( error );        return null;        } );       }       return processInfoSubobjects( parseCache.getData( subobject.fileName ), subobject );      } );      promises.push( promise );     }     const group = new Group();    group.userData.category = info.category;    group.userData.keywords = info.keywords;    group.userData.author = info.author;    group.userData.type = info.type;    group.userData.fileName = info.fileName;    info.group = group;     const subobjectInfos = await Promise.all( promises );    for ( let i = 0, l = subobjectInfos.length; i < l; i ++ ) {      const subobject = info.subobjects[ i ];     const subobjectInfo = subobjectInfos[ i ];      if ( subobjectInfo === null ) {       // the subobject failed to load      continue;      }      // if the subobject was loaded as a separate group then apply the parent scopes materials     if ( subobjectInfo.isGroup ) {       const subobjectGroup = subobjectInfo;      subobject.matrix.decompose( subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale );      subobjectGroup.userData.startingBuildingStep = subobject.startingBuildingStep;      subobjectGroup.name = subobject.fileName;       loader.applyMaterialsToMesh( subobjectGroup, subobject.colorCode, info.materials );      subobjectGroup.userData.colorCode = subobject.colorCode;       group.add( subobjectGroup );      continue;      }      // add the subobject group if it has children in case it has both children and primitives     if ( subobjectInfo.group.children.length ) {       group.add( subobjectInfo.group );      }      // transform the primitives into the local space of the parent piece and append them to     // to the parent primitives list.     const parentLineSegments = info.lineSegments;     const parentConditionalSegments = info.conditionalSegments;     const parentFaces = info.faces;      const lineSegments = subobjectInfo.lineSegments;     const conditionalSegments = subobjectInfo.conditionalSegments;      const faces = subobjectInfo.faces;     const matrix = subobject.matrix;     const inverted = subobject.inverted;     const matrixScaleInverted = matrix.determinant() < 0;     const colorCode = subobject.colorCode;      const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;     for ( let i = 0, l = lineSegments.length; i < l; i ++ ) {       const ls = lineSegments[ i ];      const vertices = ls.vertices;      vertices[ 0 ].applyMatrix4( matrix );      vertices[ 1 ].applyMatrix4( matrix );      ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;      ls.material = ls.material || getMaterialFromCode( ls.colorCode, ls.colorCode, info.materials, true );       parentLineSegments.push( ls );      }      for ( let i = 0, l = conditionalSegments.length; i < l; i ++ ) {       const os = conditionalSegments[ i ];      const vertices = os.vertices;      const controlPoints = os.controlPoints;      vertices[ 0 ].applyMatrix4( matrix );      vertices[ 1 ].applyMatrix4( matrix );      controlPoints[ 0 ].applyMatrix4( matrix );      controlPoints[ 1 ].applyMatrix4( matrix );      os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;      os.material = os.material || getMaterialFromCode( os.colorCode, os.colorCode, info.materials, true );       parentConditionalSegments.push( os );      }      for ( let i = 0, l = faces.length; i < l; i ++ ) {       const tri = faces[ i ];      const vertices = tri.vertices;      for ( let i = 0, l = vertices.length; i < l; i ++ ) {        vertices[ i ].applyMatrix4( matrix );       }       tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;      tri.material = tri.material || getMaterialFromCode( tri.colorCode, colorCode, info.materials, false );      faceMaterials.add( tri.colorCode );       // If the scale of the object is negated then the triangle winding order      // needs to be flipped.      if ( matrixScaleInverted !== inverted ) {        vertices.reverse();       }       parentFaces.push( tri );      }      info.totalFaces += subobjectInfo.totalFaces;     }     // Apply the parent subobjects pass through material code to this object. This is done several times due    // to material scoping.    if ( subobject ) {      loader.applyMaterialsToMesh( group, subobject.colorCode, info.materials );     group.userData.colorCode = subobject.colorCode;     }     return info;    };    // Track material use to see if we need to use the normal smooth slow path for hard edges.   for ( let i = 0, l = info.faces; i < l; i ++ ) {     faceMaterials.add( info.faces[ i ].colorCode );    }    await processInfoSubobjects( info );    if ( loader.smoothNormals ) {     const checkSubSegments = faceMaterials.size > 1;    generateFaceNormals( info.faces );    smoothNormals( info.faces, info.lineSegments, checkSubSegments );    }    // Add the primitive objects and metadata.   const group = info.group;   if ( info.faces.length > 0 ) {     group.add( createObject( this.loader, info.faces, 3, false, info.totalFaces ) );    }    if ( info.lineSegments.length > 0 ) {     group.add( createObject( this.loader, info.lineSegments, 2 ) );    }    if ( info.conditionalSegments.length > 0 ) {     group.add( createObject( this.loader, info.conditionalSegments, 2, true ) );    }    return group;   }   hasCachedModel( fileName ) {    return fileName !== null && fileName.toLowerCase() in this._cache;   }   async getCachedModel( fileName ) {    if ( fileName !== null && this.hasCachedModel( fileName ) ) {     const key = fileName.toLowerCase();    const group = await this._cache[ key ];    return group.clone();    } else {     return null;    }   }   // Loads and parses the model with the given file name. Returns a cached copy if available.  async loadModel( fileName ) {    const parseCache = this.parseCache;   const key = fileName.toLowerCase();   if ( this.hasCachedModel( fileName ) ) {     // Return cached model if available.    return this.getCachedModel( fileName );    } else {     // Otherwise parse a new model.    // Ensure the file data is loaded and pre parsed.    await parseCache.ensureDataLoaded( fileName );     const info = parseCache.getData( fileName );    const promise = this.processIntoMesh( info );     // Now that the file has loaded it's possible that another part parse has been waiting in parallel    // so check the cache again to see if it's been added since the last async operation so we don't    // do unnecessary work.    if ( this.hasCachedModel( fileName ) ) {      return this.getCachedModel( fileName );     }     // Cache object if it's a part so it can be reused later.    if ( isPartType( info.type ) ) {      this._cache[ key ] = promise;     }     // return a copy    const group = await promise;    return group.clone();    }   }   // parses the given model text into a renderable object. Returns cached copy if available.  async parseModel( text ) {    const parseCache = this.parseCache;   const info = parseCache.parse( text );   if ( isPartType( info.type ) && this.hasCachedModel( info.fileName ) ) {     return this.getCachedModel( info.fileName );    }    return this.processIntoMesh( info );   }  }  function sortByMaterial( a, b ) {   if ( a.colorCode === b.colorCode ) {    return 0;   }   if ( a.colorCode < b.colorCode ) {    return - 1;   }   return 1;  }  function createObject( loader, elements, elementSize, isConditionalSegments = false, totalElements = null ) {   // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )  // With per face / segment material, implemented with mesh groups and materials array   // Sort the faces or line segments by color code to make later the mesh groups  elements.sort( sortByMaterial );   if ( totalElements === null ) {    totalElements = elements.length;   }   const positions = new Float32Array( elementSize * totalElements * 3 );  const normals = elementSize === 3 ? new Float32Array( elementSize * totalElements * 3 ) : null;  const materials = [];   const quadArray = new Array( 6 );  const bufferGeometry = new BufferGeometry();  let prevMaterial = null;  let index0 = 0;  let numGroupVerts = 0;  let offset = 0;   for ( let iElem = 0, nElem = elements.length; iElem < nElem; iElem ++ ) {    const elem = elements[ iElem ];   let vertices = elem.vertices;   if ( vertices.length === 4 ) {     quadArray[ 0 ] = vertices[ 0 ];    quadArray[ 1 ] = vertices[ 1 ];    quadArray[ 2 ] = vertices[ 2 ];    quadArray[ 3 ] = vertices[ 0 ];    quadArray[ 4 ] = vertices[ 2 ];    quadArray[ 5 ] = vertices[ 3 ];    vertices = quadArray;    }    for ( let j = 0, l = vertices.length; j < l; j ++ ) {     const v = vertices[ j ];    const index = offset + j * 3;    positions[ index + 0 ] = v.x;    positions[ index + 1 ] = v.y;    positions[ index + 2 ] = v.z;    }    // create the normals array if this is a set of faces   if ( elementSize === 3 ) {     if ( ! elem.faceNormal ) {      const v0 = vertices[ 0 ];     const v1 = vertices[ 1 ];     const v2 = vertices[ 2 ];     _tempVec0.subVectors( v1, v0 );     _tempVec1.subVectors( v2, v1 );     elem.faceNormal = new Vector3()      .crossVectors( _tempVec0, _tempVec1 )      .normalize();     }     let elemNormals = elem.normals;    if ( elemNormals.length === 4 ) {      quadArray[ 0 ] = elemNormals[ 0 ];     quadArray[ 1 ] = elemNormals[ 1 ];     quadArray[ 2 ] = elemNormals[ 2 ];     quadArray[ 3 ] = elemNormals[ 0 ];     quadArray[ 4 ] = elemNormals[ 2 ];     quadArray[ 5 ] = elemNormals[ 3 ];     elemNormals = quadArray;     }     for ( let j = 0, l = elemNormals.length; j < l; j ++ ) {      // use face normal if a vertex normal is not provided     let n = elem.faceNormal;     if ( elemNormals[ j ] ) {       n = elemNormals[ j ].norm;      }      const index = offset + j * 3;     normals[ index + 0 ] = n.x;     normals[ index + 1 ] = n.y;     normals[ index + 2 ] = n.z;     }    }    if ( prevMaterial !== elem.colorCode ) {     if ( prevMaterial !== null ) {      bufferGeometry.addGroup( index0, numGroupVerts, materials.length - 1 );     }     const material = elem.material;     if ( material !== null ) {      if ( elementSize === 3 ) {       materials.push( material );      } else if ( elementSize === 2 ) {       if ( isConditionalSegments ) {        const edgeMaterial = loader.edgeMaterialCache.get( material );        materials.push( loader.conditionalEdgeMaterialCache.get( edgeMaterial ) );       } else {        materials.push( loader.edgeMaterialCache.get( material ) );       }      }     } else {      // If a material has not been made available yet then keep the color code string in the material array     // to save the spot for the material once a parent scopes materials are being applied to the object.     materials.push( elem.colorCode );     }     prevMaterial = elem.colorCode;    index0 = offset / 3;    numGroupVerts = vertices.length;    } else {     numGroupVerts += vertices.length;    }    offset += 3 * vertices.length;   }   if ( numGroupVerts > 0 ) {    bufferGeometry.addGroup( index0, Infinity, materials.length - 1 );   }   bufferGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );   if ( normals !== null ) {    bufferGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );   }   let object3d = null;   if ( elementSize === 2 ) {    if ( isConditionalSegments ) {     object3d = new ConditionalLineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );    } else {     object3d = new LineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );    }   } else if ( elementSize === 3 ) {    object3d = new Mesh( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );   }   if ( isConditionalSegments ) {    object3d.isConditionalLine = true;    const controlArray0 = new Float32Array( elements.length * 3 * 2 );   const controlArray1 = new Float32Array( elements.length * 3 * 2 );   const directionArray = new Float32Array( elements.length * 3 * 2 );   for ( let i = 0, l = elements.length; i < l; i ++ ) {     const os = elements[ i ];    const vertices = os.vertices;    const controlPoints = os.controlPoints;    const c0 = controlPoints[ 0 ];    const c1 = controlPoints[ 1 ];    const v0 = vertices[ 0 ];    const v1 = vertices[ 1 ];    const index = i * 3 * 2;    controlArray0[ index + 0 ] = c0.x;    controlArray0[ index + 1 ] = c0.y;    controlArray0[ index + 2 ] = c0.z;    controlArray0[ index + 3 ] = c0.x;    controlArray0[ index + 4 ] = c0.y;    controlArray0[ index + 5 ] = c0.z;     controlArray1[ index + 0 ] = c1.x;    controlArray1[ index + 1 ] = c1.y;    controlArray1[ index + 2 ] = c1.z;    controlArray1[ index + 3 ] = c1.x;    controlArray1[ index + 4 ] = c1.y;    controlArray1[ index + 5 ] = c1.z;     directionArray[ index + 0 ] = v1.x - v0.x;    directionArray[ index + 1 ] = v1.y - v0.y;    directionArray[ index + 2 ] = v1.z - v0.z;    directionArray[ index + 3 ] = v1.x - v0.x;    directionArray[ index + 4 ] = v1.y - v0.y;    directionArray[ index + 5 ] = v1.z - v0.z;    }    bufferGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );   bufferGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );   bufferGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );   }   return object3d;  }  //  class LDrawLoader extends Loader {   constructor( manager ) {    super( manager );    // Array of THREE.Material   this.materials = [];   this.materialLibrary = {};   this.edgeMaterialCache = new WeakMap();   this.conditionalEdgeMaterialCache = new WeakMap();    // This also allows to handle the embedded text files ("0 FILE" lines)   this.partsCache = new LDrawPartsGeometryCache( this );    // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.   this.fileMap = {};    // Initializes the materials library with default materials   this.setMaterials( [] );    // If this flag is set to true the vertex normals will be smoothed.   this.smoothNormals = true;    // The path to load parts from the LDraw parts library from.   this.partsLibraryPath = '';    // Material assigned to not available colors for meshes and edges   this.missingColorMaterial = new MeshStandardMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF, roughness: 0.3, metalness: 0 } );   this.missingEdgeColorMaterial = new LineBasicMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF } );   this.missingConditionalEdgeColorMaterial = new LDrawConditionalLineMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, fog: true, color: 0xFF00FF } );   this.edgeMaterialCache.set( this.missingColorMaterial, this.missingEdgeColorMaterial );   this.conditionalEdgeMaterialCache.set( this.missingEdgeColorMaterial, this.missingConditionalEdgeColorMaterial );   }   setPartsLibraryPath( path ) {    this.partsLibraryPath = path;   return this;   }   async preloadMaterials( url ) {    const fileLoader = new FileLoader( this.manager );   fileLoader.setPath( this.path );   fileLoader.setRequestHeader( this.requestHeader );   fileLoader.setWithCredentials( this.withCredentials );    const text = await fileLoader.loadAsync( url );   const colorLineRegex = /^0 !COLOUR/;   const lines = text.split( /[|n|r]/g );   const materials = [];   for ( let i = 0, l = lines.length; i < l; i ++ ) {     const line = lines[ i ];    if ( colorLineRegex.test( line ) ) {      const directive = line.replace( colorLineRegex, '' );     const material = this.parseColorMetaDirective( new LineParser( directive ) );     materials.push( material );     }    }    this.setMaterials( materials );   }   load( url, onLoad, onProgress, onError ) {    const fileLoader = new FileLoader( this.manager );   fileLoader.setPath( this.path );   fileLoader.setRequestHeader( this.requestHeader );   fileLoader.setWithCredentials( this.withCredentials );   fileLoader.load( url, text => {     this.partsCache     .parseModel( text, this.materialLibrary )     .then( group => {       this.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );      this.computeBuildingSteps( group );      group.userData.fileName = url;      onLoad( group );      } )     .catch( onError );    }, onProgress, onError );   }   parse( text, onLoad, onError ) {    this.partsCache    .parseModel( text, this.materialLibrary )    .then( group => {      this.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );     this.computeBuildingSteps( group );     group.userData.fileName = '';     onLoad( group );     } )    .catch( onError );   }   setMaterials( materials ) {    this.materialLibrary = {};   this.materials = [];   for ( let i = 0, l = materials.length; i < l; i ++ ) {     this.addMaterial( materials[ i ] );    }    // Add default main triangle and line edge materials (used in pieces that can be colored with a main color)   this.addMaterial( this.parseColorMetaDirective( new LineParser( 'Main_Colour CODE 16 VALUE #FF8080 EDGE #333333' ) ) );   this.addMaterial( this.parseColorMetaDirective( new LineParser( 'Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333' ) ) );    return this;   }   setFileMap( fileMap ) {    this.fileMap = fileMap;    return this;   }   addMaterial( material ) {    // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array    const matLib = this.materialLibrary;   if ( ! matLib[ material.userData.code ] ) {     this.materials.push( material );    matLib[ material.userData.code ] = material;    }    return this;   }   getMaterial( colorCode ) {    if ( colorCode.startsWith( '0x2' ) ) {     // Special 'direct' material value (RGB color)    const color = colorCode.substring( 3 );     return this.parseColorMetaDirective( new LineParser( 'Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + '' ) );    }    return this.materialLibrary[ colorCode ] || null;   }   // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present  // in the material array if they need to be filled in.  applyMaterialsToMesh( group, parentColorCode, materialHierarchy, finalMaterialPass = false ) {    // find any missing materials as indicated by a color code string and replace it with a material from the current material lib   const loader = this;   const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;   group.traverse( c => {     if ( c.isMesh || c.isLineSegments ) {      if ( Array.isArray( c.material ) ) {       for ( let i = 0, l = c.material.length; i < l; i ++ ) {        if ( ! c.material[ i ].isMaterial ) {         c.material[ i ] = getMaterial( c, c.material[ i ] );        }       }      } else if ( ! c.material.isMaterial ) {       c.material = getMaterial( c, c.material );      }     }    } );     // Returns the appropriate material for the object (line or face) given color code. If the code is "pass through"   // (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's   // simply returned for the subsequent material application.   function getMaterial( c, colorCode ) {     // if our parent is a passthrough color code and we don't have the current material color available then    // return early.    if ( parentIsPassthrough && ! ( colorCode in materialHierarchy ) && ! finalMaterialPass ) {      return colorCode;     }     const forEdge = c.isLineSegments || c.isConditionalLine;    const isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;    if ( isPassthrough ) {      colorCode = parentColorCode;     }     let material = null;    if ( colorCode in materialHierarchy ) {      material = materialHierarchy[ colorCode ];     } else if ( finalMaterialPass ) {      // see if we can get the final material from from the "getMaterial" function which will attempt to     // parse the "direct" colors     material = loader.getMaterial( colorCode );     if ( material === null ) {       // otherwise throw a warning if this is final opportunity to set the material      console.warn( |LDrawLoader: Material properties for code | colorCode } not available.| );       // And return the 'missing color' material      material = loader.missingColorMaterial;      }      } else {      return colorCode;     }     if ( c.isLineSegments ) {      material = loader.edgeMaterialCache.get( material );      if ( c.isConditionalLine ) {       material = loader.conditionalEdgeMaterialCache.get( material );      }     }     return material;    }   }   getMainMaterial() {    return this.getMaterial( MAIN_COLOUR_CODE );   }   getMainEdgeMaterial() {    const mat = this.getMaterial( MAIN_EDGE_COLOUR_CODE );   return mat ? this.edgeMaterialCache.get( mat ) : null;   }   parseColorMetaDirective( lineParser ) {    // Parses a color definition and returns a THREE.Material    let code = null;    // Triangle and line colors   let fillColor = '#FF00FF';   let edgeColor = '#FF00FF';    // Transparency   let alpha = 1;   let isTransparent = false;   // Self-illumination:   let luminance = 0;    let finishType = FINISH_TYPE_DEFAULT;    let edgeMaterial = null;    const name = lineParser.getToken();   if ( ! name ) {     throw new Error( 'LDrawLoader: Material name was expected after "!COLOUR tag' + lineParser.getLineNumberString() + '.' );    }    // Parse tag tokens and their parameters   let token = null;   while ( true ) {     token = lineParser.getToken();     if ( ! token ) {      break;     }     if ( ! parseLuminance( token ) ) {      switch ( token.toUpperCase() ) {       case 'CODE':        code = lineParser.getToken();       break;       case 'VALUE':        fillColor = lineParser.getToken();       if ( fillColor.startsWith( '0x' ) ) {         fillColor = '#' + fillColor.substring( 2 );        } else if ( ! fillColor.startsWith( '#' ) ) {         throw new Error( 'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.' );        }        break;       case 'EDGE':        edgeColor = lineParser.getToken();       if ( edgeColor.startsWith( '0x' ) ) {         edgeColor = '#' + edgeColor.substring( 2 );        } else if ( ! edgeColor.startsWith( '#' ) ) {         // Try to see if edge color is a color code        edgeMaterial = this.getMaterial( edgeColor );        if ( ! edgeMaterial ) {          throw new Error( 'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.' );         }         // Get the edge material for this triangle material        edgeMaterial = this.edgeMaterialCache.get( edgeMaterial );        }        break;       case 'ALPHA':        alpha = parseInt( lineParser.getToken() );        if ( isNaN( alpha ) ) {         throw new Error( 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.' );        }        alpha = Math.max( 0, Math.min( 1, alpha / 255 ) );        if ( alpha < 1 ) {         isTransparent = true;        }        break;       case 'LUMINANCE':        if ( ! parseLuminance( lineParser.getToken() ) ) {         throw new Error( 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.' );        }        break;       case 'CHROME':       finishType = FINISH_TYPE_CHROME;       break;       case 'PEARLESCENT':       finishType = FINISH_TYPE_PEARLESCENT;       break;       case 'RUBBER':       finishType = FINISH_TYPE_RUBBER;       break;       case 'MATTE_METALLIC':       finishType = FINISH_TYPE_MATTE_METALLIC;       break;       case 'METAL':       finishType = FINISH_TYPE_METAL;       break;       case 'MATERIAL':       // Not implemented       lineParser.setToEnd();       break;       default:       throw new Error( 'LDrawLoader: Unknown token "' + token + '" while parsing material' + lineParser.getLineNumberString() + '.' );      }     }    }    let material = null;    switch ( finishType ) {     case FINISH_TYPE_DEFAULT:      material = new MeshStandardMaterial( { roughness: 0.3, metalness: 0 } );     break;     case FINISH_TYPE_PEARLESCENT:      // Try to imitate pearlescency by making the surface glossy     material = new MeshStandardMaterial( { roughness: 0.3, metalness: 0.25 } );     break;     case FINISH_TYPE_CHROME:      // Mirror finish surface     material = new MeshStandardMaterial( { roughness: 0, metalness: 1 } );     break;     case FINISH_TYPE_RUBBER:      // Rubber finish     material = new MeshStandardMaterial( { roughness: 0.9, metalness: 0 } );     break;     case FINISH_TYPE_MATTE_METALLIC:      // Brushed metal finish     material = new MeshStandardMaterial( { roughness: 0.8, metalness: 0.4 } );     break;     case FINISH_TYPE_METAL:      // Average metal finish     material = new MeshStandardMaterial( { roughness: 0.2, metalness: 0.85 } );     break;     default:     // Should not happen     break;    }    material.color.setStyle( fillColor, COLOR_SPACE_LDRAW );   material.transparent = isTransparent;   material.premultipliedAlpha = true;   material.opacity = alpha;   material.depthWrite = ! isTransparent;    material.polygonOffset = true;   material.polygonOffsetFactor = 1;    if ( luminance !== 0 ) {     material.emissive.setStyle( fillColor, COLOR_SPACE_LDRAW ).multiplyScalar( luminance );    }    if ( ! edgeMaterial ) {     // This is the material used for edges    edgeMaterial = new LineBasicMaterial( {     color: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ),     transparent: isTransparent,     opacity: alpha,     depthWrite: ! isTransparent    } );    edgeMaterial.color;    edgeMaterial.userData.code = code;    edgeMaterial.name = name + ' - Edge';     // This is the material used for conditional edges    const conditionalEdgeMaterial = new LDrawConditionalLineMaterial( {      fog: true,     transparent: isTransparent,     depthWrite: ! isTransparent,     color: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ),     opacity: alpha,     } );    conditionalEdgeMaterial.userData.code = code;    conditionalEdgeMaterial.name = name + ' - Conditional Edge';     this.conditionalEdgeMaterialCache.set( edgeMaterial, conditionalEdgeMaterial );    }    material.userData.code = code;   material.name = name;    this.edgeMaterialCache.set( material, edgeMaterial );    this.addMaterial( material );    return material;    function parseLuminance( token ) {     // Returns success     let lum;     if ( token.startsWith( 'LUMINANCE' ) ) {      lum = parseInt( token.substring( 9 ) );     } else {      lum = parseInt( token );     }     if ( isNaN( lum ) ) {      return false;     }     luminance = Math.max( 0, Math.min( 1, lum / 255 ) );     return true;    }   }   computeBuildingSteps( model ) {    // Sets userdata.buildingStep number in Group objects and userData.numBuildingSteps number in the root Group object.    let stepNumber = 0;    model.traverse( c => {     if ( c.isGroup ) {      if ( c.userData.startingBuildingStep ) {       stepNumber ++;      }      c.userData.buildingStep = stepNumber;     }    } );    model.userData.numBuildingSteps = stepNumber + 1;   }  }  export { LDrawLoader }; 
^..^ FILENAME ^..^
addons|loaders|LottieLoader.js
^..^ CONTENTS ^..^
import {  FileLoader,  Loader,  CanvasTexture,  NearestFilter,  SRGBColorSpace } from 'three';  import lottie from '../libs/lottie_canvas.module.js';  class LottieLoader extends Loader {   setQuality( value ) {    this._quality = value;   }   load( url, onLoad, onProgress, onError ) {    const quality = this._quality || 1;    const texture = new CanvasTexture();   texture.minFilter = NearestFilter;   texture.colorSpace = SRGBColorSpace;    const loader = new FileLoader( this.manager );   loader.setPath( this.path );   loader.setWithCredentials( this.withCredentials );    loader.load( url, function ( text ) {     const data = JSON.parse( text );     // lottie uses container.offetWidth and offsetHeight    // to define width/height     const container = document.createElement( 'div' );    container.style.width = data.w + 'px';    container.style.height = data.h + 'px';    document.body.appendChild( container );     const animation = lottie.loadAnimation( {     container: container,     animType: 'canvas',     loop: true,     autoplay: true,     animationData: data,     rendererSettings: { dpr: quality }    } );     texture.animation = animation;    texture.image = animation.container;     animation.addEventListener( 'enterFrame', function () {      texture.needsUpdate = true;     } );     container.style.display = 'none';     if ( onLoad !== undefined ) {      onLoad( texture );     }    }, onProgress, onError );    return texture;   }  }  export { LottieLoader }; 
^..^ FILENAME ^..^
addons|loaders|LUT3dlLoader.js
^..^ CONTENTS ^..^
// http://download.autodesk.com/us/systemdocs/help/2011/lustre/index.html?url=./files/WSc4e151a45a3b785a24c3d9a411df9298473-7ffd.htm,topicNumber=d0e9492 // https://community.foundry.com/discuss/topic/103636/format-spec-for-3dl?mode=Post&postID=895258  import {  ClampToEdgeWrapping,  Data3DTexture,  FileLoader,  FloatType,  LinearFilter,  Loader,  RGBAFormat,  UnsignedByteType, } from 'three';  export class LUT3dlLoader extends Loader {   constructor( manager ) {    super( manager );    this.type = UnsignedByteType;   }   setType( type ) {    if ( type !== UnsignedByteType && type !== FloatType ) {     throw new Error( 'LUT3dlLoader: Unsupported type' );    }    this.type = type;    return this;   }   load( url, onLoad, onProgress, onError ) {    const loader = new FileLoader( this.manager );   loader.setPath( this.path );   loader.setResponseType( 'text' );   loader.load( url, text => {     try {      onLoad( this.parse( text ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      this.manager.itemError( url );     }    }, onProgress, onError );   }   parse( input ) {    const regExpGridInfo = /^[|d ]+$/m;   const regExpDataPoints = /^([|d.e+-]+) +([|d.e+-]+) +([|d.e+-]+) *$/gm;    // The first line describes the positions of values on the LUT grid.   let result = regExpGridInfo.exec( input );    if ( result === null ) {     throw new Error( 'LUT3dlLoader: Missing grid information' );    }    const gridLines = result[ 0 ].trim().split( /|s+/g ).map( Number );   const gridStep = gridLines[ 1 ] - gridLines[ 0 ];   const size = gridLines.length;   const sizeSq = size ** 2;    for ( let i = 1, l = gridLines.length; i < l; ++ i ) {     if ( gridStep !== ( gridLines[ i ] - gridLines[ i - 1 ] ) ) {      throw new Error( 'LUT3dlLoader: Inconsistent grid size' );     }    }    const dataFloat = new Float32Array( size ** 3 * 4 );   let maxValue = 0.0;   let index = 0;    while ( ( result = regExpDataPoints.exec( input ) ) !== null ) {     const r = Number( result[ 1 ] );    const g = Number( result[ 2 ] );    const b = Number( result[ 3 ] );     maxValue = Math.max( maxValue, r, g, b );     const bLayer = index % size;    const gLayer = Math.floor( index / size ) % size;    const rLayer = Math.floor( index / ( sizeSq ) ) % size;     // b grows first, then g, then r.    const d4 = ( bLayer * sizeSq + gLayer * size + rLayer ) * 4;    dataFloat[ d4 + 0 ] = r;    dataFloat[ d4 + 1 ] = g;    dataFloat[ d4 + 2 ] = b;     ++ index;    }    // Determine the bit depth to scale the values to [0.0, 1.0].   const bits = Math.ceil( Math.log2( maxValue ) );   const maxBitValue = Math.pow( 2, bits );    const data = this.type === UnsignedByteType ? new Uint8Array( dataFloat.length ) : dataFloat;   const scale = this.type === UnsignedByteType ? 255 : 1;    for ( let i = 0, l = data.length; i < l; i += 4 ) {     const i1 = i + 1;    const i2 = i + 2;    const i3 = i + 3;     // Note: data is dataFloat when type is FloatType.    data[ i ] = dataFloat[ i ] / maxBitValue * scale;    data[ i1 ] = dataFloat[ i1 ] / maxBitValue * scale;    data[ i2 ] = dataFloat[ i2 ] / maxBitValue * scale;    data[ i3 ] = scale;    }    const texture3D = new Data3DTexture();   texture3D.image.data = data;   texture3D.image.width = size;   texture3D.image.height = size;   texture3D.image.depth = size;   texture3D.format = RGBAFormat;   texture3D.type = this.type;   texture3D.magFilter = LinearFilter;   texture3D.minFilter = LinearFilter;   texture3D.wrapS = ClampToEdgeWrapping;   texture3D.wrapT = ClampToEdgeWrapping;   texture3D.wrapR = ClampToEdgeWrapping;   texture3D.generateMipmaps = false;   texture3D.needsUpdate = true;    return {    size,    texture3D,   };   }  } 
^..^ FILENAME ^..^
addons|loaders|LUTCubeLoader.js
^..^ CONTENTS ^..^
// https://wwwimages2.adobe.com/content/dam/acom/en/products/speedgrade/cc/pdfs/cube-lut-specification-1.0.pdf  import {  ClampToEdgeWrapping,  Data3DTexture,  FileLoader,  FloatType,  LinearFilter,  Loader,  UnsignedByteType,  Vector3, } from 'three';  export class LUTCubeLoader extends Loader {   constructor( manager ) {    super( manager );    this.type = UnsignedByteType;   }   setType( type ) {    if ( type !== UnsignedByteType && type !== FloatType ) {     throw new Error( 'LUTCubeLoader: Unsupported type' );    }    this.type = type;    return this;   }   load( url, onLoad, onProgress, onError ) {    const loader = new FileLoader( this.manager );   loader.setPath( this.path );   loader.setResponseType( 'text' );   loader.load( url, text => {     try {      onLoad( this.parse( text ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      this.manager.itemError( url );     }    }, onProgress, onError );   }   parse( input ) {    const regExpTitle = /TITLE +"([^"]*)"/;   const regExpSize = /LUT_3D_SIZE +(|d+)/;   const regExpDomainMin = /DOMAIN_MIN +([|d.]+) +([|d.]+) +([|d.]+)/;   const regExpDomainMax = /DOMAIN_MAX +([|d.]+) +([|d.]+) +([|d.]+)/;   const regExpDataPoints = /^([|d.e+-]+) +([|d.e+-]+) +([|d.e+-]+) *$/gm;    let result = regExpTitle.exec( input );   const title = ( result !== null ) ? result[ 1 ] : null;    result = regExpSize.exec( input );    if ( result === null ) {     throw new Error( 'LUTCubeLoader: Missing LUT_3D_SIZE information' );    }    const size = Number( result[ 1 ] );   const length = size ** 3 * 4;   const data = this.type === UnsignedByteType ? new Uint8Array( length ) : new Float32Array( length );    const domainMin = new Vector3( 0, 0, 0 );   const domainMax = new Vector3( 1, 1, 1 );    result = regExpDomainMin.exec( input );    if ( result !== null ) {     domainMin.set( Number( result[ 1 ] ), Number( result[ 2 ] ), Number( result[ 3 ] ) );    }    result = regExpDomainMax.exec( input );    if ( result !== null ) {     domainMax.set( Number( result[ 1 ] ), Number( result[ 2 ] ), Number( result[ 3 ] ) );    }    if ( domainMin.x > domainMax.x || domainMin.y > domainMax.y || domainMin.z > domainMax.z ) {     throw new Error( 'LUTCubeLoader: Invalid input domain' );    }    const scale = this.type === UnsignedByteType ? 255 : 1;   let i = 0;    while ( ( result = regExpDataPoints.exec( input ) ) !== null ) {     data[ i ++ ] = Number( result[ 1 ] ) * scale;    data[ i ++ ] = Number( result[ 2 ] ) * scale;    data[ i ++ ] = Number( result[ 3 ] ) * scale;    data[ i ++ ] = scale;    }    const texture3D = new Data3DTexture();   texture3D.image.data = data;   texture3D.image.width = size;   texture3D.image.height = size;   texture3D.image.depth = size;   texture3D.type = this.type;   texture3D.magFilter = LinearFilter;   texture3D.minFilter = LinearFilter;   texture3D.wrapS = ClampToEdgeWrapping;   texture3D.wrapT = ClampToEdgeWrapping;   texture3D.wrapR = ClampToEdgeWrapping;   texture3D.generateMipmaps = false;   texture3D.needsUpdate = true;    return {    title,    size,    domainMin,    domainMax,    texture3D,   };   }  } 
^..^ FILENAME ^..^
addons|loaders|LUTImageLoader.js
^..^ CONTENTS ^..^
import {  Loader,  TextureLoader,  Data3DTexture,  RGBAFormat,  UnsignedByteType,  ClampToEdgeWrapping,  LinearFilter, } from 'three';  export class LUTImageLoader extends Loader {   constructor( flipVertical = false ) {    //The NeutralLUT.png has green at the bottom for Unreal ang green at the top for Unity URP Color Lookup   //post-processing. If you're using lut image strips from a Unity pipeline then pass true to the constructor    super();    this.flip = flipVertical;   }   load( url, onLoad, onProgress, onError ) {    const loader = new TextureLoader( this.manager );    loader.setCrossOrigin( this.crossOrigin );    loader.setPath( this.path );   loader.load( url, texture => {     try {      let imageData;      if ( texture.image.width < texture.image.height ) {       imageData = this.getImageData( texture );      } else {       imageData = this.horz2Vert( texture );      }      onLoad( this.parse( imageData.data, Math.min( texture.image.width, texture.image.height ) ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      this.manager.itemError( url );     }    }, onProgress, onError );   }   getImageData( texture ) {    const width = texture.image.width;   const height = texture.image.height;    const canvas = document.createElement( 'canvas' );   canvas.width = width;   canvas.height = height;    const context = canvas.getContext( '2d' );    if ( this.flip === true ) {     context.scale( 1, - 1 );    context.translate( 0, - height );    }    context.drawImage( texture.image, 0, 0 );    return context.getImageData( 0, 0, width, height );   }   horz2Vert( texture ) {    const width = texture.image.height;   const height = texture.image.width;    const canvas = document.createElement( 'canvas' );   canvas.width = width;   canvas.height = height;    const context = canvas.getContext( '2d' );    if ( this.flip === true ) {     context.scale( 1, - 1 );    context.translate( 0, - height );    }    for ( let i = 0; i < width; i ++ ) {     const sy = i * width;    const dy = ( this.flip ) ? height - i * width : i * width;    context.drawImage( texture.image, sy, 0, width, width, 0, dy, width, width );    }    return context.getImageData( 0, 0, width, height );   }   parse( dataArray, size ) {    const data = new Uint8Array( dataArray );    const texture3D = new Data3DTexture();   texture3D.image.data = data;   texture3D.image.width = size;   texture3D.image.height = size;   texture3D.image.depth = size;   texture3D.format = RGBAFormat;   texture3D.type = UnsignedByteType;   texture3D.magFilter = LinearFilter;   texture3D.minFilter = LinearFilter;   texture3D.wrapS = ClampToEdgeWrapping;   texture3D.wrapT = ClampToEdgeWrapping;   texture3D.wrapR = ClampToEdgeWrapping;   texture3D.generateMipmaps = false;   texture3D.needsUpdate = true;    return {    size,    texture3D,   };   }  } 
^..^ FILENAME ^..^
addons|loaders|LWOLoader.js
^..^ CONTENTS ^..^
/**  * @version 1.1.1  *  * @desc Load files in LWO3 and LWO2 format on Three.js  *  * LWO3 format specification:  *  https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo3.html  *  * LWO2 format specification:  *  https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo2.html  *  **/  import {  AddOperation,  BackSide,  BufferGeometry,  ClampToEdgeWrapping,  Color,  DoubleSide,  EquirectangularReflectionMapping,  EquirectangularRefractionMapping,  FileLoader,  Float32BufferAttribute,  FrontSide,  LineBasicMaterial,  LineSegments,  Loader,  Mesh,  MeshPhongMaterial,  MeshPhysicalMaterial,  MeshStandardMaterial,  MirroredRepeatWrapping,  Points,  PointsMaterial,  RepeatWrapping,  SRGBColorSpace,  TextureLoader,  Vector2 } from 'three';  import { IFFParser } from './lwo/IFFParser.js';  let _lwoTree;  class LWOLoader extends Loader {   constructor( manager, parameters = {} ) {    super( manager );    this.resourcePath = ( parameters.resourcePath !== undefined ) ? parameters.resourcePath : '';   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const path = ( scope.path === '' ) ? extractParentUrl( url, 'Objects' ) : scope.path;    // give the mesh a default name based on the filename   const modelName = url.split( path ).pop().split( '.' )[ 0 ];    const loader = new FileLoader( this.manager );   loader.setPath( scope.path );   loader.setResponseType( 'arraybuffer' );    loader.load( url, function ( buffer ) {     // console.time( 'Total parsing: ' );     try {      onLoad( scope.parse( buffer, path, modelName ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }     // console.timeEnd( 'Total parsing: ' );    }, onProgress, onError );   }   parse( iffBuffer, path, modelName ) {    _lwoTree = new IFFParser().parse( iffBuffer );    // console.log( 'lwoTree', lwoTree );    const textureLoader = new TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );    return new LWOTreeParser( textureLoader ).parse( modelName );   }  }  // Parse the lwoTree object class LWOTreeParser {   constructor( textureLoader ) {    this.textureLoader = textureLoader;   }   parse( modelName ) {    this.materials = new MaterialParser( this.textureLoader ).parse();   this.defaultLayerName = modelName;    this.meshes = this.parseLayers();    return {    materials: this.materials,    meshes: this.meshes,   };   }   parseLayers() {    // array of all meshes for building hierarchy   const meshes = [];    // final array containing meshes with scene graph hierarchy set up   const finalMeshes = [];    const geometryParser = new GeometryParser();    const scope = this;   _lwoTree.layers.forEach( function ( layer ) {     const geometry = geometryParser.parse( layer.geometry, layer );     const mesh = scope.parseMesh( geometry, layer );     meshes[ layer.number ] = mesh;     if ( layer.parent === - 1 ) finalMeshes.push( mesh );    else meshes[ layer.parent ].add( mesh );     } );    this.applyPivots( finalMeshes );    return finalMeshes;   }   parseMesh( geometry, layer ) {    let mesh;    const materials = this.getMaterials( geometry.userData.matNames, layer.geometry.type );    if ( layer.geometry.type === 'points' ) mesh = new Points( geometry, materials );   else if ( layer.geometry.type === 'lines' ) mesh = new LineSegments( geometry, materials );   else mesh = new Mesh( geometry, materials );    if ( layer.name ) mesh.name = layer.name;   else mesh.name = this.defaultLayerName + '_layer_' + layer.number;    mesh.userData.pivot = layer.pivot;    return mesh;   }   // TODO: may need to be reversed in z to convert LWO to three.js coordinates  applyPivots( meshes ) {    meshes.forEach( function ( mesh ) {     mesh.traverse( function ( child ) {      const pivot = child.userData.pivot;      child.position.x += pivot[ 0 ];     child.position.y += pivot[ 1 ];     child.position.z += pivot[ 2 ];      if ( child.parent ) {       const parentPivot = child.parent.userData.pivot;       child.position.x -= parentPivot[ 0 ];      child.position.y -= parentPivot[ 1 ];      child.position.z -= parentPivot[ 2 ];      }     } );    } );   }   getMaterials( namesArray, type ) {    const materials = [];    const scope = this;    namesArray.forEach( function ( name, i ) {     materials[ i ] = scope.getMaterialByName( name );    } );    // convert materials to line or point mats if required   if ( type === 'points' || type === 'lines' ) {     materials.forEach( function ( mat, i ) {      const spec = {      color: mat.color,     };      if ( type === 'points' ) {       spec.size = 0.1;      spec.map = mat.map;      materials[ i ] = new PointsMaterial( spec );      } else if ( type === 'lines' ) {       materials[ i ] = new LineBasicMaterial( spec );      }     } );    }    // if there is only one material, return that directly instead of array   const filtered = materials.filter( Boolean );   if ( filtered.length === 1 ) return filtered[ 0 ];    return materials;   }   getMaterialByName( name ) {    return this.materials.filter( function ( m ) {     return m.name === name;    } )[ 0 ];   }  }  class MaterialParser {   constructor( textureLoader ) {    this.textureLoader = textureLoader;   }   parse() {    const materials = [];   this.textures = {};    for ( const name in _lwoTree.materials ) {     if ( _lwoTree.format === 'LWO3' ) {      materials.push( this.parseMaterial( _lwoTree.materials[ name ], name, _lwoTree.textures ) );     } else if ( _lwoTree.format === 'LWO2' ) {      materials.push( this.parseMaterialLwo2( _lwoTree.materials[ name ], name, _lwoTree.textures ) );     }    }    return materials;   }   parseMaterial( materialData, name, textures ) {    let params = {    name: name,    side: this.getSide( materialData.attributes ),    flatShading: this.getSmooth( materialData.attributes ),   };    const connections = this.parseConnections( materialData.connections, materialData.nodes );    const maps = this.parseTextureNodes( connections.maps );    this.parseAttributeImageMaps( connections.attributes, textures, maps, materialData.maps );    const attributes = this.parseAttributes( connections.attributes, maps );    this.parseEnvMap( connections, maps, attributes );    params = Object.assign( maps, params );   params = Object.assign( params, attributes );    const materialType = this.getMaterialType( connections.attributes );    if ( materialType !== MeshPhongMaterial ) delete params.refractionRatio; // PBR materials do not support "refractionRatio"    return new materialType( params );   }   parseMaterialLwo2( materialData, name/*, textures*/ ) {    let params = {    name: name,    side: this.getSide( materialData.attributes ),    flatShading: this.getSmooth( materialData.attributes ),   };    const attributes = this.parseAttributes( materialData.attributes, {} );   params = Object.assign( params, attributes );   return new MeshPhongMaterial( params );   }   // Note: converting from left to right handed coords by switching x -> -x in vertices, and  // then switching mat FrontSide -> BackSide  // NB: this means that FrontSide and BackSide have been switched!  getSide( attributes ) {    if ( ! attributes.side ) return BackSide;    switch ( attributes.side ) {     case 0:    case 1:     return BackSide;    case 2: return FrontSide;    case 3: return DoubleSide;    }   }   getSmooth( attributes ) {    if ( ! attributes.smooth ) return true;   return ! attributes.smooth;   }   parseConnections( connections, nodes ) {    const materialConnections = {    maps: {}   };    const inputName = connections.inputName;   const inputNodeName = connections.inputNodeName;   const nodeName = connections.nodeName;    const scope = this;   inputName.forEach( function ( name, index ) {     if ( name === 'Material' ) {      const matNode = scope.getNodeByRefName( inputNodeName[ index ], nodes );     materialConnections.attributes = matNode.attributes;     materialConnections.envMap = matNode.fileName;     materialConnections.name = inputNodeName[ index ];     }    } );    nodeName.forEach( function ( name, index ) {     if ( name === materialConnections.name ) {      materialConnections.maps[ inputName[ index ] ] = scope.getNodeByRefName( inputNodeName[ index ], nodes );     }    } );    return materialConnections;   }   getNodeByRefName( refName, nodes ) {    for ( const name in nodes ) {     if ( nodes[ name ].refName === refName ) return nodes[ name ];    }   }   parseTextureNodes( textureNodes ) {    const maps = {};    for ( const name in textureNodes ) {     const node = textureNodes[ name ];    const path = node.fileName;     if ( ! path ) return;     const texture = this.loadTexture( path );     if ( node.widthWrappingMode !== undefined ) texture.wrapS = this.getWrappingType( node.widthWrappingMode );    if ( node.heightWrappingMode !== undefined ) texture.wrapT = this.getWrappingType( node.heightWrappingMode );     switch ( name ) {      case 'Color':      maps.map = texture;      maps.map.colorSpace = SRGBColorSpace;      break;     case 'Roughness':      maps.roughnessMap = texture;      maps.roughness = 1;      break;     case 'Specular':      maps.specularMap = texture;      maps.specularMap.colorSpace = SRGBColorSpace;      maps.specular = 0xffffff;      break;     case 'Luminous':      maps.emissiveMap = texture;      maps.emissiveMap.colorSpace = SRGBColorSpace;      maps.emissive = 0x808080;      break;     case 'Luminous Color':      maps.emissive = 0x808080;      break;     case 'Metallic':      maps.metalnessMap = texture;      maps.metalness = 1;      break;     case 'Transparency':     case 'Alpha':      maps.alphaMap = texture;      maps.transparent = true;      break;     case 'Normal':      maps.normalMap = texture;      if ( node.amplitude !== undefined ) maps.normalScale = new Vector2( node.amplitude, node.amplitude );      break;     case 'Bump':      maps.bumpMap = texture;      break;     }    }    // LWO BSDF materials can have both spec and rough, but this is not valid in three   if ( maps.roughnessMap && maps.specularMap ) delete maps.specularMap;    return maps;   }   // maps can also be defined on individual material attributes, parse those here  // This occurs on Standard (Phong) surfaces  parseAttributeImageMaps( attributes, textures, maps ) {    for ( const name in attributes ) {     const attribute = attributes[ name ];     if ( attribute.maps ) {      const mapData = attribute.maps[ 0 ];      const path = this.getTexturePathByIndex( mapData.imageIndex, textures );     if ( ! path ) return;      const texture = this.loadTexture( path );      if ( mapData.wrap !== undefined ) texture.wrapS = this.getWrappingType( mapData.wrap.w );     if ( mapData.wrap !== undefined ) texture.wrapT = this.getWrappingType( mapData.wrap.h );      switch ( name ) {       case 'Color':       maps.map = texture;       maps.map.colorSpace = SRGBColorSpace;       break;      case 'Diffuse':       maps.aoMap = texture;       break;      case 'Roughness':       maps.roughnessMap = texture;       maps.roughness = 1;       break;      case 'Specular':       maps.specularMap = texture;       maps.specularMap.colorSpace = SRGBColorSpace;       maps.specular = 0xffffff;       break;      case 'Luminosity':       maps.emissiveMap = texture;       maps.emissiveMap.colorSpace = SRGBColorSpace;       maps.emissive = 0x808080;       break;      case 'Metallic':       maps.metalnessMap = texture;       maps.metalness = 1;       break;      case 'Transparency':      case 'Alpha':       maps.alphaMap = texture;       maps.transparent = true;       break;      case 'Normal':       maps.normalMap = texture;       break;      case 'Bump':       maps.bumpMap = texture;       break;      }     }    }   }   parseAttributes( attributes, maps ) {    const params = {};    // don't use color data if color map is present   if ( attributes.Color && ! maps.map ) {     params.color = new Color().fromArray( attributes.Color.value );    } else {     params.color = new Color();    }     if ( attributes.Transparency && attributes.Transparency.value !== 0 ) {     params.opacity = 1 - attributes.Transparency.value;    params.transparent = true;    }    if ( attributes[ 'Bump Height' ] ) params.bumpScale = attributes[ 'Bump Height' ].value * 0.1;    this.parsePhysicalAttributes( params, attributes, maps );   this.parseStandardAttributes( params, attributes, maps );   this.parsePhongAttributes( params, attributes, maps );    return params;   }   parsePhysicalAttributes( params, attributes/*, maps*/ ) {    if ( attributes.Clearcoat && attributes.Clearcoat.value > 0 ) {     params.clearcoat = attributes.Clearcoat.value;     if ( attributes[ 'Clearcoat Gloss' ] ) {      params.clearcoatRoughness = 0.5 * ( 1 - attributes[ 'Clearcoat Gloss' ].value );     }    }   }   parseStandardAttributes( params, attributes, maps ) {     if ( attributes.Luminous ) {     params.emissiveIntensity = attributes.Luminous.value;     if ( attributes[ 'Luminous Color' ] && ! maps.emissive ) {      params.emissive = new Color().fromArray( attributes[ 'Luminous Color' ].value );     } else {      params.emissive = new Color( 0x808080 );     }    }    if ( attributes.Roughness && ! maps.roughnessMap ) params.roughness = attributes.Roughness.value;   if ( attributes.Metallic && ! maps.metalnessMap ) params.metalness = attributes.Metallic.value;   }   parsePhongAttributes( params, attributes, maps ) {    if ( attributes[ 'Refraction Index' ] ) params.refractionRatio = 0.98 / attributes[ 'Refraction Index' ].value;    if ( attributes.Diffuse ) params.color.multiplyScalar( attributes.Diffuse.value );    if ( attributes.Reflection ) {     params.reflectivity = attributes.Reflection.value;    params.combine = AddOperation;    }    if ( attributes.Luminosity ) {     params.emissiveIntensity = attributes.Luminosity.value;     if ( ! maps.emissiveMap && ! maps.map ) {      params.emissive = params.color;     } else {      params.emissive = new Color( 0x808080 );     }    }    // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case   if ( ! attributes.Roughness && attributes.Specular && ! maps.specularMap ) {     if ( attributes[ 'Color Highlight' ] ) {      params.specular = new Color().setScalar( attributes.Specular.value ).lerp( params.color.clone().multiplyScalar( attributes.Specular.value ), attributes[ 'Color Highlight' ].value );     } else {      params.specular = new Color().setScalar( attributes.Specular.value );     }    }    if ( params.specular && attributes.Glossiness ) params.shininess = 7 + Math.pow( 2, attributes.Glossiness.value * 12 + 2 );   }   parseEnvMap( connections, maps, attributes ) {    if ( connections.envMap ) {     const envMap = this.loadTexture( connections.envMap );     if ( attributes.transparent && attributes.opacity < 0.999 ) {      envMap.mapping = EquirectangularRefractionMapping;      // Reflectivity and refraction mapping don't work well together in Phong materials     if ( attributes.reflectivity !== undefined ) {       delete attributes.reflectivity;      delete attributes.combine;      }      if ( attributes.metalness !== undefined ) {       attributes.metalness = 1; // For most transparent materials metalness should be set to 1 if not otherwise defined. If set to 0 no refraction will be visible      }      attributes.opacity = 1; // transparency fades out refraction, forcing opacity to 1 ensures a closer visual match to the material in Lightwave.     } else envMap.mapping = EquirectangularReflectionMapping;     maps.envMap = envMap;    }   }   // get texture defined at top level by its index  getTexturePathByIndex( index ) {    let fileName = '';    if ( ! _lwoTree.textures ) return fileName;    _lwoTree.textures.forEach( function ( texture ) {     if ( texture.index === index ) fileName = texture.fileName;    } );    return fileName;   }   loadTexture( path ) {    if ( ! path ) return null;    const texture = this.textureLoader.load(    path,    undefined,    undefined,    function () {      console.warn( 'LWOLoader: non-standard resource hierarchy. Use ||resourcePath|| parameter to specify root content directory.' );     }   );    return texture;   }   // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge  getWrappingType( num ) {    switch ( num ) {     case 0:     console.warn( 'LWOLoader: "Reset" texture wrapping type is not supported in three.js' );     return ClampToEdgeWrapping;    case 1: return RepeatWrapping;    case 2: return MirroredRepeatWrapping;    case 3: return ClampToEdgeWrapping;    }   }   getMaterialType( nodeData ) {    if ( nodeData.Clearcoat && nodeData.Clearcoat.value > 0 ) return MeshPhysicalMaterial;   if ( nodeData.Roughness ) return MeshStandardMaterial;   return MeshPhongMaterial;   }  }  class GeometryParser {   parse( geoData, layer ) {    const geometry = new BufferGeometry();    geometry.setAttribute( 'position', new Float32BufferAttribute( geoData.points, 3 ) );    const indices = this.splitIndices( geoData.vertexIndices, geoData.polygonDimensions );   geometry.setIndex( indices );    this.parseGroups( geometry, geoData );    geometry.computeVertexNormals();    this.parseUVs( geometry, layer, indices );   this.parseMorphTargets( geometry, layer, indices );    // TODO: z may need to be reversed to account for coordinate system change   geometry.translate( - layer.pivot[ 0 ], - layer.pivot[ 1 ], - layer.pivot[ 2 ] );    // let userData = geometry.userData;   // geometry = geometry.toNonIndexed()   // geometry.userData = userData;    return geometry;   }   // split quads into tris  splitIndices( indices, polygonDimensions ) {    const remappedIndices = [];    let i = 0;   polygonDimensions.forEach( function ( dim ) {     if ( dim < 4 ) {      for ( let k = 0; k < dim; k ++ ) remappedIndices.push( indices[ i + k ] );     } else if ( dim === 4 ) {      remappedIndices.push(      indices[ i ],      indices[ i + 1 ],      indices[ i + 2 ],       indices[ i ],      indices[ i + 2 ],      indices[ i + 3 ]      );     } else if ( dim > 4 ) {      for ( let k = 1; k < dim - 1; k ++ ) {       remappedIndices.push( indices[ i ], indices[ i + k ], indices[ i + k + 1 ] );      }      console.warn( 'LWOLoader: polygons with greater than 4 sides are not supported' );     }     i += dim;    } );    return remappedIndices;   }   // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered  parseGroups( geometry, geoData ) {    const tags = _lwoTree.tags;   const matNames = [];    let elemSize = 3;   if ( geoData.type === 'lines' ) elemSize = 2;   if ( geoData.type === 'points' ) elemSize = 1;    const remappedIndices = this.splitMaterialIndices( geoData.polygonDimensions, geoData.materialIndices );    let indexNum = 0; // create new indices in numerical order   const indexPairs = {}; // original indices mapped to numerical indices    let prevMaterialIndex;   let materialIndex;    let prevStart = 0;   let currentCount = 0;    for ( let i = 0; i < remappedIndices.length; i += 2 ) {     materialIndex = remappedIndices[ i + 1 ];     if ( i === 0 ) matNames[ indexNum ] = tags[ materialIndex ];     if ( prevMaterialIndex === undefined ) prevMaterialIndex = materialIndex;     if ( materialIndex !== prevMaterialIndex ) {      let currentIndex;     if ( indexPairs[ tags[ prevMaterialIndex ] ] ) {       currentIndex = indexPairs[ tags[ prevMaterialIndex ] ];      } else {       currentIndex = indexNum;      indexPairs[ tags[ prevMaterialIndex ] ] = indexNum;      matNames[ indexNum ] = tags[ prevMaterialIndex ];      indexNum ++;      }      geometry.addGroup( prevStart, currentCount, currentIndex );      prevStart += currentCount;      prevMaterialIndex = materialIndex;     currentCount = 0;     }     currentCount += elemSize;    }    // the loop above doesn't add the last group, do that here.   if ( geometry.groups.length > 0 ) {     let currentIndex;    if ( indexPairs[ tags[ materialIndex ] ] ) {      currentIndex = indexPairs[ tags[ materialIndex ] ];     } else {      currentIndex = indexNum;     indexPairs[ tags[ materialIndex ] ] = indexNum;     matNames[ indexNum ] = tags[ materialIndex ];     }     geometry.addGroup( prevStart, currentCount, currentIndex );    }    // Mat names from TAGS chunk, used to build up an array of materials for this geometry   geometry.userData.matNames = matNames;   }   splitMaterialIndices( polygonDimensions, indices ) {    const remappedIndices = [];    polygonDimensions.forEach( function ( dim, i ) {     if ( dim <= 3 ) {      remappedIndices.push( indices[ i * 2 ], indices[ i * 2 + 1 ] );     } else if ( dim === 4 ) {      remappedIndices.push( indices[ i * 2 ], indices[ i * 2 + 1 ], indices[ i * 2 ], indices[ i * 2 + 1 ] );     } else {       // ignore > 4 for now     for ( let k = 0; k < dim - 2; k ++ ) {       remappedIndices.push( indices[ i * 2 ], indices[ i * 2 + 1 ] );      }     }    } );    return remappedIndices;   }   // UV maps:  // 1: are defined via index into an array of points, not into a geometry  // - the geometry is also defined by an index into this array, but the indexes may not match  // 2: there can be any number of UV maps for a single geometry. Here these are combined,  //  with preference given to the first map encountered  // 3: UV maps can be partial - that is, defined for only a part of the geometry  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most  // UV maps are defined as partially VMAP and partially VMAD  // VMADs are currently not supported  parseUVs( geometry, layer ) {    // start by creating a UV map set to zero for the whole geometry   const remappedUVs = Array.from( Array( geometry.attributes.position.count * 2 ), function () {     return 0;    } );    for ( const name in layer.uvs ) {     const uvs = layer.uvs[ name ].uvs;    const uvIndices = layer.uvs[ name ].uvIndices;     uvIndices.forEach( function ( i, j ) {      remappedUVs[ i * 2 ] = uvs[ j * 2 ];     remappedUVs[ i * 2 + 1 ] = uvs[ j * 2 + 1 ];     } );    }    geometry.setAttribute( 'uv', new Float32BufferAttribute( remappedUVs, 2 ) );   }   parseMorphTargets( geometry, layer ) {    let num = 0;   for ( const name in layer.morphTargets ) {     const remappedPoints = geometry.attributes.position.array.slice();     if ( ! geometry.morphAttributes.position ) geometry.morphAttributes.position = [];     const morphPoints = layer.morphTargets[ name ].points;    const morphIndices = layer.morphTargets[ name ].indices;    const type = layer.morphTargets[ name ].type;     morphIndices.forEach( function ( i, j ) {      if ( type === 'relative' ) {       remappedPoints[ i * 3 ] += morphPoints[ j * 3 ];      remappedPoints[ i * 3 + 1 ] += morphPoints[ j * 3 + 1 ];      remappedPoints[ i * 3 + 2 ] += morphPoints[ j * 3 + 2 ];      } else {       remappedPoints[ i * 3 ] = morphPoints[ j * 3 ];      remappedPoints[ i * 3 + 1 ] = morphPoints[ j * 3 + 1 ];      remappedPoints[ i * 3 + 2 ] = morphPoints[ j * 3 + 2 ];      }     } );     geometry.morphAttributes.position[ num ] = new Float32BufferAttribute( remappedPoints, 3 );    geometry.morphAttributes.position[ num ].name = name;     num ++;    }    geometry.morphTargetsRelative = false;   }  }   // ************** UTILITY FUNCTIONS **************  function extractParentUrl( url, dir ) {   const index = url.indexOf( dir );   if ( index === - 1 ) return './';   return url.slice( 0, index );  }  export { LWOLoader }; 
^..^ FILENAME ^..^
addons|loaders|MaterialXLoader.js
^..^ CONTENTS ^..^
import { FileLoader, Loader, TextureLoader, MeshBasicNodeMaterial, MeshPhysicalNodeMaterial, RepeatWrapping } from 'three';  import {  float, bool, int, vec2, vec3, vec4, color, texture,  positionLocal, positionWorld, uv, vertexColor,  normalLocal, normalWorld, tangentLocal, tangentWorld,  add, sub, mul, div, mod, abs, sign, floor, ceil, round, pow, sin, cos, tan,  asin, acos, atan2, sqrt, exp, clamp, min, max, normalize, length, dot, cross, normalMap,  remap, smoothstep, luminance, mx_rgbtohsv, mx_hsvtorgb,  mix, split,  mx_ramplr, mx_ramptb, mx_splitlr, mx_splittb,  mx_fractal_noise_float, mx_noise_float, mx_cell_noise_float, mx_worley_noise_float,  mx_transform_uv,  mx_safepower, mx_contrast,  mx_srgb_texture_to_lin_rec709,  saturation,  timerLocal, frameId } from 'three/tsl';  const colorSpaceLib = {  mx_srgb_texture_to_lin_rec709 };  class MXElement {   constructor( name, nodeFunc, params = [] ) {    this.name = name;   this.nodeFunc = nodeFunc;   this.params = params;   }  }  // Ref: https://github.com/mrdoob/three.js/issues/24674  const mx_add = ( in1, in2 = float( 0 ) ) => add( in1, in2 ); const mx_subtract = ( in1, in2 = float( 0 ) ) => sub( in1, in2 ); const mx_multiply = ( in1, in2 = float( 1 ) ) => mul( in1, in2 ); const mx_divide = ( in1, in2 = float( 1 ) ) => div( in1, in2 ); const mx_modulo = ( in1, in2 = float( 1 ) ) => mod( in1, in2 ); const mx_power = ( in1, in2 = float( 1 ) ) => pow( in1, in2 ); const mx_atan2 = ( in1 = float( 0 ), in2 = float( 1 ) ) => atan2( in1, in2 ); const mx_timer = () => timerLocal(); const mx_frame = () => frameId; const mx_invert = ( in1, amount = float( 1 ) ) => sub( amount, in1 );  const separate = ( in1, channel ) => split( in1, channel.at( - 1 ) ); const extract = ( in1, index ) => in1.element( index );  const MXElements = [   // << Math >>  new MXElement( 'add', mx_add, [ 'in1', 'in2' ] ),  new MXElement( 'subtract', mx_subtract, [ 'in1', 'in2' ] ),  new MXElement( 'multiply', mx_multiply, [ 'in1', 'in2' ] ),  new MXElement( 'divide', mx_divide, [ 'in1', 'in2' ] ),  new MXElement( 'modulo', mx_modulo, [ 'in1', 'in2' ] ),  new MXElement( 'absval', abs, [ 'in1', 'in2' ] ),  new MXElement( 'sign', sign, [ 'in1', 'in2' ] ),  new MXElement( 'floor', floor, [ 'in1', 'in2' ] ),  new MXElement( 'ceil', ceil, [ 'in1', 'in2' ] ),  new MXElement( 'round', round, [ 'in1', 'in2' ] ),  new MXElement( 'power', mx_power, [ 'in1', 'in2' ] ),  new MXElement( 'sin', sin, [ 'in' ] ),  new MXElement( 'cos', cos, [ 'in' ] ),  new MXElement( 'tan', tan, [ 'in' ] ),  new MXElement( 'asin', asin, [ 'in' ] ),  new MXElement( 'acos', acos, [ 'in' ] ),  new MXElement( 'atan2', mx_atan2, [ 'in1', 'in2' ] ),  new MXElement( 'sqrt', sqrt, [ 'in' ] ),  //new MtlXElement( 'ln', ... ),  new MXElement( 'exp', exp, [ 'in' ] ),  new MXElement( 'clamp', clamp, [ 'in', 'low', 'high' ] ),  new MXElement( 'min', min, [ 'in1', 'in2' ] ),  new MXElement( 'max', max, [ 'in1', 'in2' ] ),  new MXElement( 'normalize', normalize, [ 'in' ] ),  new MXElement( 'magnitude', length, [ 'in1', 'in2' ] ),  new MXElement( 'dotproduct', dot, [ 'in1', 'in2' ] ),  new MXElement( 'crossproduct', cross, [ 'in' ] ),  new MXElement( 'invert', mx_invert, [ 'in', 'amount' ] ),  //new MtlXElement( 'transformpoint', ... ),  //new MtlXElement( 'transformvector', ... ),  //new MtlXElement( 'transformnormal', ... ),  //new MtlXElement( 'transformmatrix', ... ),  new MXElement( 'normalmap', normalMap, [ 'in', 'scale' ] ),  //new MtlXElement( 'transpose', ... ),  //new MtlXElement( 'determinant', ... ),  //new MtlXElement( 'invertmatrix', ... ),  //new MtlXElement( 'rotate2d', rotateUV, [ 'in', radians( 'amount' )** ] ),  //new MtlXElement( 'rotate3d', ... ),  //new MtlXElement( 'arrayappend', ... ),  //new MtlXElement( 'dot', ... ),   // << Adjustment >>  new MXElement( 'remap', remap, [ 'in', 'inlow', 'inhigh', 'outlow', 'outhigh' ] ),  new MXElement( 'smoothstep', smoothstep, [ 'in', 'low', 'high' ] ),  //new MtlXElement( 'curveadjust', ... ),  //new MtlXElement( 'curvelookup', ... ),  new MXElement( 'luminance', luminance, [ 'in', 'lumacoeffs' ] ),  new MXElement( 'rgbtohsv', mx_rgbtohsv, [ 'in' ] ),  new MXElement( 'hsvtorgb', mx_hsvtorgb, [ 'in' ] ),   // << Mix >>  new MXElement( 'mix', mix, [ 'bg', 'fg', 'mix' ] ),   // << Channel >>  new MXElement( 'combine2', vec2, [ 'in1', 'in2' ] ),  new MXElement( 'combine3', vec3, [ 'in1', 'in2', 'in3' ] ),  new MXElement( 'combine4', vec4, [ 'in1', 'in2', 'in3', 'in4' ] ),   // << Procedural >>  new MXElement( 'ramplr', mx_ramplr, [ 'valuel', 'valuer', 'texcoord' ] ),  new MXElement( 'ramptb', mx_ramptb, [ 'valuet', 'valueb', 'texcoord' ] ),  new MXElement( 'splitlr', mx_splitlr, [ 'valuel', 'valuer', 'texcoord' ] ),  new MXElement( 'splittb', mx_splittb, [ 'valuet', 'valueb', 'texcoord' ] ),  new MXElement( 'noise2d', mx_noise_float, [ 'texcoord', 'amplitude', 'pivot' ] ),  new MXElement( 'noise3d', mx_noise_float, [ 'texcoord', 'amplitude', 'pivot' ] ),  new MXElement( 'fractal3d', mx_fractal_noise_float, [ 'position', 'octaves', 'lacunarity', 'diminish', 'amplitude' ] ),  new MXElement( 'cellnoise2d', mx_cell_noise_float, [ 'texcoord' ] ),  new MXElement( 'cellnoise3d', mx_cell_noise_float, [ 'texcoord' ] ),  new MXElement( 'worleynoise2d', mx_worley_noise_float, [ 'texcoord', 'jitter' ] ),  new MXElement( 'worleynoise3d', mx_worley_noise_float, [ 'texcoord', 'jitter' ] ),   // << Supplemental >>  //new MtlXElement( 'tiledimage', ... ),  //new MtlXElement( 'triplanarprojection', triplanarTextures, [ 'filex', 'filey', 'filez' ] ),  //new MtlXElement( 'ramp4', ... ),  //new MtlXElement( 'place2d', mx_place2d, [ 'texcoord', 'pivot', 'scale', 'rotate', 'offset' ] ),  new MXElement( 'safepower', mx_safepower, [ 'in1', 'in2' ] ),  new MXElement( 'contrast', mx_contrast, [ 'in', 'amount', 'pivot' ] ),  //new MtlXElement( 'hsvadjust', ... ),  new MXElement( 'saturate', saturation, [ 'in', 'amount' ] ),  new MXElement( 'extract', extract, [ 'in', 'index' ] ),  new MXElement( 'separate2', separate, [ 'in' ] ),  new MXElement( 'separate3', separate, [ 'in' ] ),  new MXElement( 'separate4', separate, [ 'in' ] ),   new MXElement( 'time', mx_timer ),  new MXElement( 'frame', mx_frame )  ];  const MtlXLibrary = {}; MXElements.forEach( element => MtlXLibrary[ element.name ] = element );  class MaterialXLoader extends Loader {   constructor( manager ) {    super( manager );   }   load( url, onLoad, onProgress, onError ) {    const _onError = function ( e ) {     if ( onError ) {      onError( e );     } else {      console.error( e );     }    };    new FileLoader( this.manager )    .setPath( this.path )    .load( url, async ( text ) => {      try {       onLoad( this.parse( text ) );      } catch ( e ) {       _onError( e );      }     }, onProgress, _onError );    return this;   }   parse( text ) {    return new MaterialX( this.manager, this.path ).parse( text );   }  }  class MaterialXNode {   constructor( materialX, nodeXML, nodePath = '' ) {    this.materialX = materialX;   this.nodeXML = nodeXML;   this.nodePath = nodePath ? nodePath + '/' + this.name : this.name;    this.parent = null;    this.node = null;    this.children = [];   }   get element() {    return this.nodeXML.nodeName;   }   get nodeGraph() {    return this.getAttribute( 'nodegraph' );   }   get nodeName() {    return this.getAttribute( 'nodename' );   }   get interfaceName() {    return this.getAttribute( 'interfacename' );   }   get output() {    return this.getAttribute( 'output' );   }   get name() {    return this.getAttribute( 'name' );   }   get type() {    return this.getAttribute( 'type' );   }   get value() {    return this.getAttribute( 'value' );   }   getNodeGraph() {    let nodeX = this;    while ( nodeX !== null ) {     if ( nodeX.element === 'nodegraph' ) {      break;     }     nodeX = nodeX.parent;    }    return nodeX;   }   getRoot() {    let nodeX = this;    while ( nodeX.parent !== null ) {     nodeX = nodeX.parent;    }    return nodeX;   }   get referencePath() {    let referencePath = null;    if ( this.nodeGraph !== null && this.output !== null ) {     referencePath = this.nodeGraph + '/' + this.output;    } else if ( this.nodeName !== null || this.interfaceName !== null ) {     referencePath = this.getNodeGraph().nodePath + '/' + ( this.nodeName || this.interfaceName );    }    return referencePath;   }   get hasReference() {    return this.referencePath !== null;   }   get isConst() {    return this.element === 'input' && this.value !== null && this.type !== 'filename';   }   getColorSpaceNode() {    const csSource = this.getAttribute( 'colorspace' );   const csTarget = this.getRoot().getAttribute( 'colorspace' );    const nodeName = |mx_| csSource }_to_| csTarget }|;    return colorSpaceLib[ nodeName ];   }   getTexture() {    const filePrefix = this.getRecursiveAttribute( 'fileprefix' ) || '';    let loader = this.materialX.textureLoader;   const uri = filePrefix + this.value;    if ( uri ) {     const handler = this.materialX.manager.getHandler( uri );    if ( handler !== null ) loader = handler;    }    const texture = loader.load( uri );   texture.wrapS = texture.wrapT = RepeatWrapping;   texture.flipY = false;    return texture;   }   getClassFromType( type ) {    let nodeClass = null;    if ( type === 'integer' ) nodeClass = int;   else if ( type === 'float' ) nodeClass = float;   else if ( type === 'vector2' ) nodeClass = vec2;   else if ( type === 'vector3' ) nodeClass = vec3;   else if ( type === 'vector4' || type === 'color4' ) nodeClass = vec4;   else if ( type === 'color3' ) nodeClass = color;   else if ( type === 'boolean' ) nodeClass = bool;    return nodeClass;   }   getNode( out = null ) {    let node = this.node;    if ( node !== null && out === null ) {     return node;    }    //    const type = this.type;    if ( this.isConst ) {     const nodeClass = this.getClassFromType( type );     node = nodeClass( ...this.getVector() );    } else if ( this.hasReference ) {     if ( this.element === 'output' && this.output && out === null  ) {      out = this.output;     }     node = this.materialX.getMaterialXNode( this.referencePath ).getNode( out );    } else {     const element = this.element;     if ( element === 'convert' ) {      const nodeClass = this.getClassFromType( type );      node = nodeClass( this.getNodeByName( 'in' ) );     } else if ( element === 'constant' ) {      node = this.getNodeByName( 'value' );     } else if ( element === 'position' ) {      const space = this.getAttribute( 'space' );     node = space === 'world' ? positionWorld : positionLocal;     } else if ( element === 'normal' ) {      const space = this.getAttribute( 'space' );     node = space === 'world' ? normalWorld : normalLocal;     } else if ( element === 'tangent' ) {      const space = this.getAttribute( 'space' );     node = space === 'world' ? tangentWorld : tangentLocal;     } else if ( element === 'texcoord' ) {      const indexNode = this.getChildByName( 'index' );     const index = indexNode ? parseInt( indexNode.value ) : 0;      node = uv( index );     } else if ( element === 'geomcolor' ) {      const indexNode = this.getChildByName( 'index' );     const index = indexNode ? parseInt( indexNode.value ) : 0;      node = vertexColor( index );     } else if ( element === 'tiledimage' ) {      const file = this.getChildByName( 'file' );      const textureFile = file.getTexture();     const uvTiling = mx_transform_uv( ...this.getNodesByNames( [ 'uvtiling', 'uvoffset' ] ) );      node = texture( textureFile, uvTiling );      const colorSpaceNode = file.getColorSpaceNode();      if ( colorSpaceNode ) {       node = colorSpaceNode( node );      }     } else if ( element === 'image' ) {      const file = this.getChildByName( 'file' );     const uvNode = this.getNodeByName( 'texcoord' );      const textureFile = file.getTexture();      node = texture( textureFile, uvNode );      const colorSpaceNode = file.getColorSpaceNode();      if ( colorSpaceNode ) {       node = colorSpaceNode( node );      }     } else if ( MtlXLibrary[ element ] !== undefined ) {      const nodeElement = MtlXLibrary[ element ];      if ( out !== null ) {       node = nodeElement.nodeFunc( ...this.getNodesByNames( ...nodeElement.params ), out );      } else {       node = nodeElement.nodeFunc( ...this.getNodesByNames( ...nodeElement.params ) );      }     }    }    //    if ( node === null ) {     console.warn( |THREE.MaterialXLoader: Unexpected node | new XMLSerializer().serializeToString( this.nodeXML ) }.| );     node = float( 0 );    }    //    const nodeToTypeClass = this.getClassFromType( type );    if ( nodeToTypeClass !== null ) {     node = nodeToTypeClass( node );    }    node.name = this.name;    this.node = node;    return node;   }   getChildByName( name ) {    for ( const input of this.children ) {     if ( input.name === name ) {      return input;     }    }   }   getNodes() {    const nodes = {};    for ( const input of this.children ) {     const node = input.getNode();     nodes[ node.name ] = node;    }    return nodes;   }   getNodeByName( name ) {    const child = this.getChildByName( name );    return child ? child.getNode( child.output ) : undefined;   }   getNodesByNames( ...names ) {    const nodes = [];    for ( const name of names ) {     const node = this.getNodeByName( name );     if ( node ) nodes.push( node );    }    return nodes;   }   getValue() {    return this.value.trim();   }   getVector() {    const vector = [];    for ( const val of this.getValue().split( /[,||s]/ ) ) {     if ( val !== '' ) {      vector.push( Number( val.trim() ) );     }    }    return vector;   }   getAttribute( name ) {    return this.nodeXML.getAttribute( name );   }   getRecursiveAttribute( name ) {    let attribute = this.nodeXML.getAttribute( name );    if ( attribute === null && this.parent !== null ) {     attribute = this.parent.getRecursiveAttribute( name );    }    return attribute;   }   setStandardSurfaceToGltfPBR( material ) {    const inputs = this.getNodes();    //    let colorNode = null;    if ( inputs.base && inputs.base_color ) colorNode = mul( inputs.base, inputs.base_color );   else if ( inputs.base ) colorNode = inputs.base;   else if ( inputs.base_color ) colorNode = inputs.base_color;    //    let roughnessNode = null;    if ( inputs.specular_roughness ) roughnessNode = inputs.specular_roughness;    //    let metalnessNode = null;    if ( inputs.metalness ) metalnessNode = inputs.metalness;    //    let clearcoatNode = null;   let clearcoatRoughnessNode = null;    if ( inputs.coat ) clearcoatNode = inputs.coat;   if ( inputs.coat_roughness ) clearcoatRoughnessNode = inputs.coat_roughness;    if ( inputs.coat_color ) {     colorNode = colorNode ? mul( colorNode, inputs.coat_color ) : colorNode;    }    //    let normalNode = null;    if ( inputs.normal ) normalNode = inputs.normal;    //    let emissiveNode = null;    if ( inputs.emission ) emissiveNode = inputs.emission;   if ( inputs.emissionColor ) {     emissiveNode = emissiveNode ? mul( emissiveNode, inputs.emissionColor ) : emissiveNode;    }    //    material.colorNode = colorNode || color( 0.8, 0.8, 0.8 );   material.roughnessNode = roughnessNode || float( 0.2 );   material.metalnessNode = metalnessNode || float( 0 );   material.clearcoatNode = clearcoatNode || float( 0 );   material.clearcoatRoughnessNode = clearcoatRoughnessNode || float( 0 );   if ( normalNode ) material.normalNode = normalNode;   if ( emissiveNode ) material.emissiveNode = emissiveNode;   }   /*setGltfPBR( material ) {    const inputs = this.getNodes();    console.log( inputs );   }*/   setMaterial( material ) {    const element = this.element;    if ( element === 'gltf_pbr' ) {     //this.setGltfPBR( material );    } else if ( element === 'standard_surface' ) {     this.setStandardSurfaceToGltfPBR( material );    }   }   toBasicMaterial() {    const material = new MeshBasicNodeMaterial();   material.name = this.name;    for ( const nodeX of this.children.toReversed() ) {     if ( nodeX.name === 'out' ) {      material.colorNode = nodeX.getNode();      break;     }    }    return material;   }   toPhysicalMaterial() {    const material = new MeshPhysicalNodeMaterial();   material.name = this.name;    for ( const nodeX of this.children ) {     const shaderProperties = this.materialX.getMaterialXNode( nodeX.nodeName );    shaderProperties.setMaterial( material );    }    return material;   }   toMaterials() {    const materials = {};    let isUnlit = true;    for ( const nodeX of this.children ) {     if ( nodeX.element === 'surfacematerial' ) {      const material = nodeX.toPhysicalMaterial();      materials[ material.name ] = material;      isUnlit = false;     }    }    if ( isUnlit ) {     for ( const nodeX of this.children ) {      if ( nodeX.element === 'nodegraph' ) {       const material = nodeX.toBasicMaterial();       materials[ material.name ] = material;      }     }    }    return materials;   }   add( materialXNode ) {    materialXNode.parent = this;    this.children.push( materialXNode );   }  }  class MaterialX {   constructor( manager, path ) {    this.manager = manager;   this.path = path;   this.resourcePath = '';    this.nodesXLib = new Map();   //this.nodesXRefLib = new WeakMap();    this.textureLoader = new TextureLoader( manager );   }   addMaterialXNode( materialXNode ) {    this.nodesXLib.set( materialXNode.nodePath, materialXNode );   }   /*getMaterialXNodeFromXML( xmlNode ) {          return this.nodesXRefLib.get( xmlNode );      }*/   getMaterialXNode( ...names ) {    return this.nodesXLib.get( names.join( '/' ) );   }   parseNode( nodeXML, nodePath = '' ) {    const materialXNode = new MaterialXNode( this, nodeXML, nodePath );   if ( materialXNode.nodePath ) this.addMaterialXNode( materialXNode );    for ( const childNodeXML of nodeXML.children ) {     const childMXNode = this.parseNode( childNodeXML, materialXNode.nodePath );    materialXNode.add( childMXNode );    }    return materialXNode;   }   parse( text ) {    const rootXML = new DOMParser().parseFromString( text, 'application/xml' ).documentElement;    this.textureLoader.setPath( this.path );    //    const materials = this.parseNode( rootXML ).toMaterials();    return { materials };   }  }  export { MaterialXLoader }; 
^..^ FILENAME ^..^
addons|loaders|MD2Loader.js
^..^ CONTENTS ^..^
import {  AnimationClip,  BufferGeometry,  FileLoader,  Float32BufferAttribute,  Loader,  Vector3 } from 'three';  const _normalData = [  [ - 0.525731, 0.000000, 0.850651 ], [ - 0.442863, 0.238856, 0.864188 ],  [ - 0.295242, 0.000000, 0.955423 ], [ - 0.309017, 0.500000, 0.809017 ],  [ - 0.162460, 0.262866, 0.951056 ], [ 0.000000, 0.000000, 1.000000 ],  [ 0.000000, 0.850651, 0.525731 ], [ - 0.147621, 0.716567, 0.681718 ],  [ 0.147621, 0.716567, 0.681718 ], [ 0.000000, 0.525731, 0.850651 ],  [ 0.309017, 0.500000, 0.809017 ], [ 0.525731, 0.000000, 0.850651 ],  [ 0.295242, 0.000000, 0.955423 ], [ 0.442863, 0.238856, 0.864188 ],  [ 0.162460, 0.262866, 0.951056 ], [ - 0.681718, 0.147621, 0.716567 ],  [ - 0.809017, 0.309017, 0.500000 ], [ - 0.587785, 0.425325, 0.688191 ],  [ - 0.850651, 0.525731, 0.000000 ], [ - 0.864188, 0.442863, 0.238856 ],  [ - 0.716567, 0.681718, 0.147621 ], [ - 0.688191, 0.587785, 0.425325 ],  [ - 0.500000, 0.809017, 0.309017 ], [ - 0.238856, 0.864188, 0.442863 ],  [ - 0.425325, 0.688191, 0.587785 ], [ - 0.716567, 0.681718, - 0.147621 ],  [ - 0.500000, 0.809017, - 0.309017 ], [ - 0.525731, 0.850651, 0.000000 ],  [ 0.000000, 0.850651, - 0.525731 ], [ - 0.238856, 0.864188, - 0.442863 ],  [ 0.000000, 0.955423, - 0.295242 ], [ - 0.262866, 0.951056, - 0.162460 ],  [ 0.000000, 1.000000, 0.000000 ], [ 0.000000, 0.955423, 0.295242 ],  [ - 0.262866, 0.951056, 0.162460 ], [ 0.238856, 0.864188, 0.442863 ],  [ 0.262866, 0.951056, 0.162460 ], [ 0.500000, 0.809017, 0.309017 ],  [ 0.238856, 0.864188, - 0.442863 ], [ 0.262866, 0.951056, - 0.162460 ],  [ 0.500000, 0.809017, - 0.309017 ], [ 0.850651, 0.525731, 0.000000 ],  [ 0.716567, 0.681718, 0.147621 ], [ 0.716567, 0.681718, - 0.147621 ],  [ 0.525731, 0.850651, 0.000000 ], [ 0.425325, 0.688191, 0.587785 ],  [ 0.864188, 0.442863, 0.238856 ], [ 0.688191, 0.587785, 0.425325 ],  [ 0.809017, 0.309017, 0.500000 ], [ 0.681718, 0.147621, 0.716567 ],  [ 0.587785, 0.425325, 0.688191 ], [ 0.955423, 0.295242, 0.000000 ],  [ 1.000000, 0.000000, 0.000000 ], [ 0.951056, 0.162460, 0.262866 ],  [ 0.850651, - 0.525731, 0.000000 ], [ 0.955423, - 0.295242, 0.000000 ],  [ 0.864188, - 0.442863, 0.238856 ], [ 0.951056, - 0.162460, 0.262866 ],  [ 0.809017, - 0.309017, 0.500000 ], [ 0.681718, - 0.147621, 0.716567 ],  [ 0.850651, 0.000000, 0.525731 ], [ 0.864188, 0.442863, - 0.238856 ],  [ 0.809017, 0.309017, - 0.500000 ], [ 0.951056, 0.162460, - 0.262866 ],  [ 0.525731, 0.000000, - 0.850651 ], [ 0.681718, 0.147621, - 0.716567 ],  [ 0.681718, - 0.147621, - 0.716567 ], [ 0.850651, 0.000000, - 0.525731 ],  [ 0.809017, - 0.309017, - 0.500000 ], [ 0.864188, - 0.442863, - 0.238856 ],  [ 0.951056, - 0.162460, - 0.262866 ], [ 0.147621, 0.716567, - 0.681718 ],  [ 0.309017, 0.500000, - 0.809017 ], [ 0.425325, 0.688191, - 0.587785 ],  [ 0.442863, 0.238856, - 0.864188 ], [ 0.587785, 0.425325, - 0.688191 ],  [ 0.688191, 0.587785, - 0.425325 ], [ - 0.147621, 0.716567, - 0.681718 ],  [ - 0.309017, 0.500000, - 0.809017 ], [ 0.000000, 0.525731, - 0.850651 ],  [ - 0.525731, 0.000000, - 0.850651 ], [ - 0.442863, 0.238856, - 0.864188 ],  [ - 0.295242, 0.000000, - 0.955423 ], [ - 0.162460, 0.262866, - 0.951056 ],  [ 0.000000, 0.000000, - 1.000000 ], [ 0.295242, 0.000000, - 0.955423 ],  [ 0.162460, 0.262866, - 0.951056 ], [ - 0.442863, - 0.238856, - 0.864188 ],  [ - 0.309017, - 0.500000, - 0.809017 ], [ - 0.162460, - 0.262866, - 0.951056 ],  [ 0.000000, - 0.850651, - 0.525731 ], [ - 0.147621, - 0.716567, - 0.681718 ],  [ 0.147621, - 0.716567, - 0.681718 ], [ 0.000000, - 0.525731, - 0.850651 ],  [ 0.309017, - 0.500000, - 0.809017 ], [ 0.442863, - 0.238856, - 0.864188 ],  [ 0.162460, - 0.262866, - 0.951056 ], [ 0.238856, - 0.864188, - 0.442863 ],  [ 0.500000, - 0.809017, - 0.309017 ], [ 0.425325, - 0.688191, - 0.587785 ],  [ 0.716567, - 0.681718, - 0.147621 ], [ 0.688191, - 0.587785, - 0.425325 ],  [ 0.587785, - 0.425325, - 0.688191 ], [ 0.000000, - 0.955423, - 0.295242 ],  [ 0.000000, - 1.000000, 0.000000 ], [ 0.262866, - 0.951056, - 0.162460 ],  [ 0.000000, - 0.850651, 0.525731 ], [ 0.000000, - 0.955423, 0.295242 ],  [ 0.238856, - 0.864188, 0.442863 ], [ 0.262866, - 0.951056, 0.162460 ],  [ 0.500000, - 0.809017, 0.309017 ], [ 0.716567, - 0.681718, 0.147621 ],  [ 0.525731, - 0.850651, 0.000000 ], [ - 0.238856, - 0.864188, - 0.442863 ],  [ - 0.500000, - 0.809017, - 0.309017 ], [ - 0.262866, - 0.951056, - 0.162460 ],  [ - 0.850651, - 0.525731, 0.000000 ], [ - 0.716567, - 0.681718, - 0.147621 ],  [ - 0.716567, - 0.681718, 0.147621 ], [ - 0.525731, - 0.850651, 0.000000 ],  [ - 0.500000, - 0.809017, 0.309017 ], [ - 0.238856, - 0.864188, 0.442863 ],  [ - 0.262866, - 0.951056, 0.162460 ], [ - 0.864188, - 0.442863, 0.238856 ],  [ - 0.809017, - 0.309017, 0.500000 ], [ - 0.688191, - 0.587785, 0.425325 ],  [ - 0.681718, - 0.147621, 0.716567 ], [ - 0.442863, - 0.238856, 0.864188 ],  [ - 0.587785, - 0.425325, 0.688191 ], [ - 0.309017, - 0.500000, 0.809017 ],  [ - 0.147621, - 0.716567, 0.681718 ], [ - 0.425325, - 0.688191, 0.587785 ],  [ - 0.162460, - 0.262866, 0.951056 ], [ 0.442863, - 0.238856, 0.864188 ],  [ 0.162460, - 0.262866, 0.951056 ], [ 0.309017, - 0.500000, 0.809017 ],  [ 0.147621, - 0.716567, 0.681718 ], [ 0.000000, - 0.525731, 0.850651 ],  [ 0.425325, - 0.688191, 0.587785 ], [ 0.587785, - 0.425325, 0.688191 ],  [ 0.688191, - 0.587785, 0.425325 ], [ - 0.955423, 0.295242, 0.000000 ],  [ - 0.951056, 0.162460, 0.262866 ], [ - 1.000000, 0.000000, 0.000000 ],  [ - 0.850651, 0.000000, 0.525731 ], [ - 0.955423, - 0.295242, 0.000000 ],  [ - 0.951056, - 0.162460, 0.262866 ], [ - 0.864188, 0.442863, - 0.238856 ],  [ - 0.951056, 0.162460, - 0.262866 ], [ - 0.809017, 0.309017, - 0.500000 ],  [ - 0.864188, - 0.442863, - 0.238856 ], [ - 0.951056, - 0.162460, - 0.262866 ],  [ - 0.809017, - 0.309017, - 0.500000 ], [ - 0.681718, 0.147621, - 0.716567 ],  [ - 0.681718, - 0.147621, - 0.716567 ], [ - 0.850651, 0.000000, - 0.525731 ],  [ - 0.688191, 0.587785, - 0.425325 ], [ - 0.587785, 0.425325, - 0.688191 ],  [ - 0.425325, 0.688191, - 0.587785 ], [ - 0.425325, - 0.688191, - 0.587785 ],  [ - 0.587785, - 0.425325, - 0.688191 ], [ - 0.688191, - 0.587785, - 0.425325 ] ];  class MD2Loader extends Loader {   constructor( manager ) {    super( manager );   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( scope.manager );   loader.setPath( scope.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( scope.requestHeader );   loader.setWithCredentials( scope.withCredentials );   loader.load( url, function ( buffer ) {     try {      onLoad( scope.parse( buffer ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( buffer ) {    const data = new DataView( buffer );    // http://tfc.duke.free.fr/coding/md2-specs-en.html    const header = {};   const headerNames = [    'ident', 'version',    'skinwidth', 'skinheight',    'framesize',    'num_skins', 'num_vertices', 'num_st', 'num_tris', 'num_glcmds', 'num_frames',    'offset_skins', 'offset_st', 'offset_tris', 'offset_frames', 'offset_glcmds', 'offset_end'   ];    for ( let i = 0; i < headerNames.length; i ++ ) {     header[ headerNames[ i ] ] = data.getInt32( i * 4, true );    }    if ( header.ident !== 844121161 || header.version !== 8 ) {     console.error( 'Not a valid MD2 file' );    return;    }    if ( header.offset_end !== data.byteLength ) {     console.error( 'Corrupted MD2 file' );    return;    }    //    const geometry = new BufferGeometry();    // uvs    const uvsTemp = [];   let offset = header.offset_st;    for ( let i = 0, l = header.num_st; i < l; i ++ ) {     const u = data.getInt16( offset + 0, true );    const v = data.getInt16( offset + 2, true );     uvsTemp.push( u / header.skinwidth, 1 - ( v / header.skinheight ) );     offset += 4;    }    // triangles    offset = header.offset_tris;    const vertexIndices = [];   const uvIndices = [];    for ( let i = 0, l = header.num_tris; i < l; i ++ ) {     vertexIndices.push(     data.getUint16( offset + 0, true ),     data.getUint16( offset + 2, true ),     data.getUint16( offset + 4, true )    );     uvIndices.push(     data.getUint16( offset + 6, true ),     data.getUint16( offset + 8, true ),     data.getUint16( offset + 10, true )    );     offset += 12;    }    // frames    const translation = new Vector3();   const scale = new Vector3();    const frames = [];    offset = header.offset_frames;    for ( let i = 0, l = header.num_frames; i < l; i ++ ) {     scale.set(     data.getFloat32( offset + 0, true ),     data.getFloat32( offset + 4, true ),     data.getFloat32( offset + 8, true )    );     translation.set(     data.getFloat32( offset + 12, true ),     data.getFloat32( offset + 16, true ),     data.getFloat32( offset + 20, true )    );     offset += 24;     const string = [];     for ( let j = 0; j < 16; j ++ ) {      const character = data.getUint8( offset + j );     if ( character === 0 ) break;      string[ j ] = character;     }     const frame = {     name: String.fromCharCode.apply( null, string ),     vertices: [],     normals: []    };     offset += 16;     for ( let j = 0; j < header.num_vertices; j ++ ) {      let x = data.getUint8( offset ++ );     let y = data.getUint8( offset ++ );     let z = data.getUint8( offset ++ );     const n = _normalData[ data.getUint8( offset ++ ) ];      x = x * scale.x + translation.x;     y = y * scale.y + translation.y;     z = z * scale.z + translation.z;      frame.vertices.push( x, z, y ); // convert to Y-up     frame.normals.push( n[ 0 ], n[ 2 ], n[ 1 ] ); // convert to Y-up     }     frames.push( frame );    }    // static    const positions = [];   const normals = [];   const uvs = [];    const verticesTemp = frames[ 0 ].vertices;   const normalsTemp = frames[ 0 ].normals;    for ( let i = 0, l = vertexIndices.length; i < l; i ++ ) {     const vertexIndex = vertexIndices[ i ];    let stride = vertexIndex * 3;     //     const x = verticesTemp[ stride ];    const y = verticesTemp[ stride + 1 ];    const z = verticesTemp[ stride + 2 ];     positions.push( x, y, z );     //     const nx = normalsTemp[ stride ];    const ny = normalsTemp[ stride + 1 ];    const nz = normalsTemp[ stride + 2 ];     normals.push( nx, ny, nz );     //     const uvIndex = uvIndices[ i ];    stride = uvIndex * 2;     const u = uvsTemp[ stride ];    const v = uvsTemp[ stride + 1 ];     uvs.push( u, v );    }    geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );   geometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );   geometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );    // animation    const morphPositions = [];   const morphNormals = [];    for ( let i = 0, l = frames.length; i < l; i ++ ) {     const frame = frames[ i ];    const attributeName = frame.name;     if ( frame.vertices.length > 0 ) {      const positions = [];      for ( let j = 0, jl = vertexIndices.length; j < jl; j ++ ) {       const vertexIndex = vertexIndices[ j ];      const stride = vertexIndex * 3;       const x = frame.vertices[ stride ];      const y = frame.vertices[ stride + 1 ];      const z = frame.vertices[ stride + 2 ];       positions.push( x, y, z );      }      const positionAttribute = new Float32BufferAttribute( positions, 3 );     positionAttribute.name = attributeName;      morphPositions.push( positionAttribute );     }     if ( frame.normals.length > 0 ) {      const normals = [];      for ( let j = 0, jl = vertexIndices.length; j < jl; j ++ ) {       const vertexIndex = vertexIndices[ j ];      const stride = vertexIndex * 3;       const nx = frame.normals[ stride ];      const ny = frame.normals[ stride + 1 ];      const nz = frame.normals[ stride + 2 ];       normals.push( nx, ny, nz );      }      const normalAttribute = new Float32BufferAttribute( normals, 3 );     normalAttribute.name = attributeName;      morphNormals.push( normalAttribute );     }    }    geometry.morphAttributes.position = morphPositions;   geometry.morphAttributes.normal = morphNormals;   geometry.morphTargetsRelative = false;    geometry.animations = AnimationClip.CreateClipsFromMorphTargetSequences( frames, 10 );    return geometry;   }  }  export { MD2Loader }; 
^..^ FILENAME ^..^
addons|loaders|MDDLoader.js
^..^ CONTENTS ^..^
/**  * MDD is a special format that stores a position for every vertex in a model for every frame in an animation.  * Similar to BVH, it can be used to transfer animation data between different 3D applications or engines.  *  * MDD stores its data in binary format (big endian) in the following way:  *  * number of frames (a single uint32)  * number of vertices (a single uint32)  * time values for each frame (sequence of float32)  * vertex data for each frame (sequence of float32)  */  import {  AnimationClip,  BufferAttribute,  FileLoader,  Loader,  NumberKeyframeTrack } from 'three';  class MDDLoader extends Loader {   constructor( manager ) {    super( manager );   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( this.manager );   loader.setPath( this.path );   loader.setResponseType( 'arraybuffer' );   loader.load( url, function ( data ) {     onLoad( scope.parse( data ) );    }, onProgress, onError );   }   parse( data ) {    const view = new DataView( data );    const totalFrames = view.getUint32( 0 );   const totalPoints = view.getUint32( 4 );    let offset = 8;    // animation clip    const times = new Float32Array( totalFrames );   const values = new Float32Array( totalFrames * totalFrames ).fill( 0 );    for ( let i = 0; i < totalFrames; i ++ ) {     times[ i ] = view.getFloat32( offset ); offset += 4;    values[ ( totalFrames * i ) + i ] = 1;    }    const track = new NumberKeyframeTrack( '.morphTargetInfluences', times, values );   const clip = new AnimationClip( 'default', times[ times.length - 1 ], [ track ] );    // morph targets    const morphTargets = [];    for ( let i = 0; i < totalFrames; i ++ ) {     const morphTarget = new Float32Array( totalPoints * 3 );     for ( let j = 0; j < totalPoints; j ++ ) {      const stride = ( j * 3 );      morphTarget[ stride + 0 ] = view.getFloat32( offset ); offset += 4; // x     morphTarget[ stride + 1 ] = view.getFloat32( offset ); offset += 4; // y     morphTarget[ stride + 2 ] = view.getFloat32( offset ); offset += 4; // z     }     const attribute = new BufferAttribute( morphTarget, 3 );    attribute.name = 'morph_' + i;     morphTargets.push( attribute );    }    return {    morphTargets: morphTargets,    clip: clip   };   }  }  export { MDDLoader }; 
^..^ FILENAME ^..^
addons|loaders|MMDLoader.js
^..^ CONTENTS ^..^
import {  AddOperation,  AnimationClip,  Bone,  BufferGeometry,  Color,  CustomBlending,  TangentSpaceNormalMap,  DoubleSide,  DstAlphaFactor,  Euler,  FileLoader,  Float32BufferAttribute,  FrontSide,  Interpolant,  Loader,  LoaderUtils,  UniformsUtils,  ShaderMaterial,  MultiplyOperation,  NearestFilter,  NumberKeyframeTrack,  OneMinusSrcAlphaFactor,  Quaternion,  QuaternionKeyframeTrack,  RepeatWrapping,  Skeleton,  SkinnedMesh,  SrcAlphaFactor,  SRGBColorSpace,  TextureLoader,  Uint16BufferAttribute,  Vector3,  VectorKeyframeTrack,  RGB_S3TC_DXT1_Format,  RGB_PVRTC_4BPPV1_Format,  RGB_PVRTC_2BPPV1_Format,  RGB_ETC1_Format,  RGB_ETC2_Format } from 'three'; import { MMDToonShader } from '../shaders/MMDToonShader.js'; import { TGALoader } from '../loaders/TGALoader.js'; import { MMDParser } from '../libs/mmdparser.module.js';  /**  * Dependencies  *  - mmd-parser https://github.com/takahirox/mmd-parser  *  - TGALoader  *  - OutlineEffect  *  * MMDLoader creates Three.js Objects from MMD resources as  * PMD, PMX, VMD, and VPD files.  *  * PMD/PMX is a model data format, VMD is a motion data format  * VPD is a posing data format used in MMD(Miku Miku Dance).  *  * MMD official site  *  - https://sites.google.com/view/evpvp/  *  * PMD, VMD format (in Japanese)  *  - http://blog.goo.ne.jp/torisu_tetosuki/e/209ad341d3ece2b1b4df24abf619d6e4  *  * PMX format  *  - https://gist.github.com/felixjones/f8a06bd48f9da9a4539f  *  * TODO  *  - light motion in vmd support.  *  - SDEF support.  *  - uv/material/bone morphing support.  *  - more precise grant skinning support.  *  - shadow support.  */  /**  * @param {THREE.LoadingManager} manager  */ class MMDLoader extends Loader {   constructor( manager ) {    super( manager );    this.loader = new FileLoader( this.manager );    this.parser = null; // lazy generation   this.meshBuilder = new MeshBuilder( this.manager );   this.animationBuilder = new AnimationBuilder();   }   /**   * @param {string} animationPath   * @return {MMDLoader}   */  setAnimationPath( animationPath ) {    this.animationPath = animationPath;   return this;   }   // Load MMD assets as Three.js Object   /**   * Loads Model file (.pmd or .pmx) as a SkinnedMesh.   *   * @param {string} url - url to Model(.pmd or .pmx) file   * @param {function} onLoad   * @param {function} onProgress   * @param {function} onError   */  load( url, onLoad, onProgress, onError ) {    const builder = this.meshBuilder.setCrossOrigin( this.crossOrigin );    // resource path    let resourcePath;    if ( this.resourcePath !== '' ) {     resourcePath = this.resourcePath;    } else if ( this.path !== '' ) {     resourcePath = this.path;    } else {     resourcePath = LoaderUtils.extractUrlBase( url );    }    const parser = this._getParser();   const extractModelExtension = this._extractModelExtension;    this.loader    .setMimeType( undefined )    .setPath( this.path )    .setResponseType( 'arraybuffer' )    .setRequestHeader( this.requestHeader )    .setWithCredentials( this.withCredentials )    .load( url, function ( buffer ) {      try {       const modelExtension = extractModelExtension( buffer );       if ( modelExtension !== 'pmd' && modelExtension !== 'pmx' ) {        if ( onError ) onError( new Error( 'THREE.MMDLoader: Unknown model file extension .' + modelExtension + '.' ) );        return;       }       const data = modelExtension === 'pmd' ? parser.parsePmd( buffer, true ) : parser.parsePmx( buffer, true );       onLoad( builder.build( data, resourcePath, onProgress, onError ) );      } catch ( e ) {       if ( onError ) onError( e );      }     }, onProgress, onError );   }   /**   * Loads Motion file(s) (.vmd) as a AnimationClip.   * If two or more files are specified, they'll be merged.   *   * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)   * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object   * @param {function} onLoad   * @param {function} onProgress   * @param {function} onError   */  loadAnimation( url, object, onLoad, onProgress, onError ) {    const builder = this.animationBuilder;    this.loadVMD( url, function ( vmd ) {     onLoad( object.isCamera     ? builder.buildCameraAnimation( vmd )     : builder.build( vmd, object ) );    }, onProgress, onError );   }   /**   * Loads mode file and motion file(s) as an object containing   * a SkinnedMesh and a AnimationClip.   * Tracks of AnimationClip are fitting to the model.   *   * @param {string} modelUrl - url to Model(.pmd or .pmx) file   * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file   * @param {function} onLoad   * @param {function} onProgress   * @param {function} onError   */  loadWithAnimation( modelUrl, vmdUrl, onLoad, onProgress, onError ) {    const scope = this;    this.load( modelUrl, function ( mesh ) {     scope.loadAnimation( vmdUrl, mesh, function ( animation ) {      onLoad( {      mesh: mesh,      animation: animation     } );     }, onProgress, onError );    }, onProgress, onError );   }   // Load MMD assets as Object data parsed by MMDParser   /**   * Loads .pmd file as an Object.   *   * @param {string} url - url to .pmd file   * @param {function} onLoad   * @param {function} onProgress   * @param {function} onError   */  loadPMD( url, onLoad, onProgress, onError ) {    const parser = this._getParser();    this.loader    .setMimeType( undefined )    .setPath( this.path )    .setResponseType( 'arraybuffer' )    .setRequestHeader( this.requestHeader )    .setWithCredentials( this.withCredentials )    .load( url, function ( buffer ) {      try {       onLoad( parser.parsePmd( buffer, true ) );      } catch ( e ) {       if ( onError ) onError( e );      }     }, onProgress, onError );   }   /**   * Loads .pmx file as an Object.   *   * @param {string} url - url to .pmx file   * @param {function} onLoad   * @param {function} onProgress   * @param {function} onError   */  loadPMX( url, onLoad, onProgress, onError ) {    const parser = this._getParser();    this.loader    .setMimeType( undefined )    .setPath( this.path )    .setResponseType( 'arraybuffer' )    .setRequestHeader( this.requestHeader )    .setWithCredentials( this.withCredentials )    .load( url, function ( buffer ) {      try {       onLoad( parser.parsePmx( buffer, true ) );      } catch ( e ) {       if ( onError ) onError( e );      }     }, onProgress, onError );   }   /**   * Loads .vmd file as an Object. If two or more files are specified   * they'll be merged.   *   * @param {string|Array<string>} url - url(s) to .vmd file(s)   * @param {function} onLoad   * @param {function} onProgress   * @param {function} onError   */  loadVMD( url, onLoad, onProgress, onError ) {    const urls = Array.isArray( url ) ? url : [ url ];    const vmds = [];   const vmdNum = urls.length;    const parser = this._getParser();    this.loader    .setMimeType( undefined )    .setPath( this.animationPath )    .setResponseType( 'arraybuffer' )    .setRequestHeader( this.requestHeader )    .setWithCredentials( this.withCredentials );    for ( let i = 0, il = urls.length; i < il; i ++ ) {     this.loader.load( urls[ i ], function ( buffer ) {      try {       vmds.push( parser.parseVmd( buffer, true ) );       if ( vmds.length === vmdNum ) onLoad( parser.mergeVmds( vmds ) );      } catch ( e ) {       if ( onError ) onError( e );      }     }, onProgress, onError );    }   }   /**   * Loads .vpd file as an Object.   *   * @param {string} url - url to .vpd file   * @param {boolean} isUnicode   * @param {function} onLoad   * @param {function} onProgress   * @param {function} onError   */  loadVPD( url, isUnicode, onLoad, onProgress, onError ) {    const parser = this._getParser();    this.loader    .setMimeType( isUnicode ? undefined : 'text/plain; charset=shift_jis' )    .setPath( this.animationPath )    .setResponseType( 'text' )    .setRequestHeader( this.requestHeader )    .setWithCredentials( this.withCredentials )    .load( url, function ( text ) {      try {       onLoad( parser.parseVpd( text, true ) );      } catch ( e ) {       if ( onError ) onError( e );      }     }, onProgress, onError );   }   // private methods   _extractModelExtension( buffer ) {    const decoder = new TextDecoder( 'utf-8' );   const bytes = new Uint8Array( buffer, 0, 3 );   return decoder.decode( bytes ).toLowerCase();   }   _getParser() {    if ( this.parser === null ) {     this.parser = new MMDParser.Parser();    }    return this.parser;   }  }  // Utilities  /*   * base64 encoded defalut toon textures toon00.bmp - toon10.bmp.   * We don't need to request external toon image files.   */ const DEFAULT_TOON_TEXTURES = [  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==',  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC',  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==',  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==',  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=',  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=',  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=' ];  const NON_ALPHA_CHANNEL_FORMATS = [  RGB_S3TC_DXT1_Format,  RGB_PVRTC_4BPPV1_Format,  RGB_PVRTC_2BPPV1_Format,  RGB_ETC1_Format,  RGB_ETC2_Format ];  // Builders. They build Three.js object from Object data parsed by MMDParser.  /**  * @param {THREE.LoadingManager} manager  */ class MeshBuilder {   constructor( manager ) {    this.crossOrigin = 'anonymous';   this.geometryBuilder = new GeometryBuilder();   this.materialBuilder = new MaterialBuilder( manager );   }   /**   * @param {string} crossOrigin   * @return {MeshBuilder}   */  setCrossOrigin( crossOrigin ) {    this.crossOrigin = crossOrigin;   return this;   }   /**   * @param {Object} data - parsed PMD/PMX data   * @param {string} resourcePath   * @param {function} onProgress   * @param {function} onError   * @return {SkinnedMesh}   */  build( data, resourcePath, onProgress, onError ) {    const geometry = this.geometryBuilder.build( data );   const material = this.materialBuilder    .setCrossOrigin( this.crossOrigin )    .setResourcePath( resourcePath )    .build( data, geometry, onProgress, onError );    const mesh = new SkinnedMesh( geometry, material );    const skeleton = new Skeleton( initBones( mesh ) );   mesh.bind( skeleton );    // console.log( mesh ); // for console debug    return mesh;   }  }  // TODO: Try to remove this function  function initBones( mesh ) {   const geometry = mesh.geometry;   const bones = [];   if ( geometry && geometry.bones !== undefined ) {    // first, create array of 'Bone' objects from geometry data    for ( let i = 0, il = geometry.bones.length; i < il; i ++ ) {     const gbone = geometry.bones[ i ];     // create new 'Bone' object     const bone = new Bone();    bones.push( bone );     // apply values     bone.name = gbone.name;    bone.position.fromArray( gbone.pos );    bone.quaternion.fromArray( gbone.rotq );    if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );    }    // second, create bone hierarchy    for ( let i = 0, il = geometry.bones.length; i < il; i ++ ) {     const gbone = geometry.bones[ i ];     if ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {      // subsequent bones in the hierarchy      bones[ gbone.parent ].add( bones[ i ] );     } else {      // topmost bone, immediate child of the skinned mesh      mesh.add( bones[ i ] );     }    }   }   // now the bones are part of the scene graph and children of the skinned mesh.  // let's update the corresponding matrices   mesh.updateMatrixWorld( true );   return bones;  }  //  class GeometryBuilder {   /**   * @param {Object} data - parsed PMD/PMX data   * @return {BufferGeometry}   */  build( data ) {    // for geometry   const positions = [];   const uvs = [];   const normals = [];    const indices = [];    const groups = [];    const bones = [];   const skinIndices = [];   const skinWeights = [];    const morphTargets = [];   const morphPositions = [];    const iks = [];   const grants = [];    const rigidBodies = [];   const constraints = [];    // for work   let offset = 0;   const boneTypeTable = {};    // positions, normals, uvs, skinIndices, skinWeights    for ( let i = 0; i < data.metadata.vertexCount; i ++ ) {     const v = data.vertices[ i ];     for ( let j = 0, jl = v.position.length; j < jl; j ++ ) {      positions.push( v.position[ j ] );     }     for ( let j = 0, jl = v.normal.length; j < jl; j ++ ) {      normals.push( v.normal[ j ] );     }     for ( let j = 0, jl = v.uv.length; j < jl; j ++ ) {      uvs.push( v.uv[ j ] );     }     for ( let j = 0; j < 4; j ++ ) {      skinIndices.push( v.skinIndices.length - 1 >= j ? v.skinIndices[ j ] : 0.0 );     }     for ( let j = 0; j < 4; j ++ ) {      skinWeights.push( v.skinWeights.length - 1 >= j ? v.skinWeights[ j ] : 0.0 );     }    }    // indices    for ( let i = 0; i < data.metadata.faceCount; i ++ ) {     const face = data.faces[ i ];     for ( let j = 0, jl = face.indices.length; j < jl; j ++ ) {      indices.push( face.indices[ j ] );     }    }    // groups    for ( let i = 0; i < data.metadata.materialCount; i ++ ) {     const material = data.materials[ i ];     groups.push( {     offset: offset * 3,     count: material.faceCount * 3    } );     offset += material.faceCount;    }    // bones    for ( let i = 0; i < data.metadata.rigidBodyCount; i ++ ) {     const body = data.rigidBodies[ i ];    let value = boneTypeTable[ body.boneIndex ];     // keeps greater number if already value is set without any special reasons    value = value === undefined ? body.type : Math.max( body.type, value );     boneTypeTable[ body.boneIndex ] = value;    }    for ( let i = 0; i < data.metadata.boneCount; i ++ ) {     const boneData = data.bones[ i ];     const bone = {     index: i,     transformationClass: boneData.transformationClass,     parent: boneData.parentIndex,     name: boneData.name,     pos: boneData.position.slice( 0, 3 ),     rotq: [ 0, 0, 0, 1 ],     scl: [ 1, 1, 1 ],     rigidBodyType: boneTypeTable[ i ] !== undefined ? boneTypeTable[ i ] : - 1    };     if ( bone.parent !== - 1 ) {      bone.pos[ 0 ] -= data.bones[ bone.parent ].position[ 0 ];     bone.pos[ 1 ] -= data.bones[ bone.parent ].position[ 1 ];     bone.pos[ 2 ] -= data.bones[ bone.parent ].position[ 2 ];     }     bones.push( bone );    }    // iks    // TODO: remove duplicated codes between PMD and PMX   if ( data.metadata.format === 'pmd' ) {     for ( let i = 0; i < data.metadata.ikCount; i ++ ) {      const ik = data.iks[ i ];      const param = {      target: ik.target,      effector: ik.effector,      iteration: ik.iteration,      maxAngle: ik.maxAngle * 4,      links: []     };      for ( let j = 0, jl = ik.links.length; j < jl; j ++ ) {       const link = {};      link.index = ik.links[ j ].index;      link.enabled = true;       if ( data.bones[ link.index ].name.indexOf( '???-' ) >= 0 ) {        link.limitation = new Vector3( 1.0, 0.0, 0.0 );       }       param.links.push( link );      }      iks.push( param );     }    } else {     for ( let i = 0; i < data.metadata.boneCount; i ++ ) {      const ik = data.bones[ i ].ik;      if ( ik === undefined ) continue;      const param = {      target: i,      effector: ik.effector,      iteration: ik.iteration,      maxAngle: ik.maxAngle,      links: []     };      for ( let j = 0, jl = ik.links.length; j < jl; j ++ ) {       const link = {};      link.index = ik.links[ j ].index;      link.enabled = true;       if ( ik.links[ j ].angleLimitation === 1 ) {        // Revert if rotationMin/Max doesn't work well       // link.limitation = new Vector3( 1.0, 0.0, 0.0 );        const rotationMin = ik.links[ j ].lowerLimitationAngle;       const rotationMax = ik.links[ j ].upperLimitationAngle;        // Convert Left to Right coordinate by myself because       // MMDParser doesn't convert. It's a MMDParser's bug        const tmp1 = - rotationMax[ 0 ];       const tmp2 = - rotationMax[ 1 ];       rotationMax[ 0 ] = - rotationMin[ 0 ];       rotationMax[ 1 ] = - rotationMin[ 1 ];       rotationMin[ 0 ] = tmp1;       rotationMin[ 1 ] = tmp2;        link.rotationMin = new Vector3().fromArray( rotationMin );       link.rotationMax = new Vector3().fromArray( rotationMax );       }       param.links.push( link );      }      iks.push( param );      // Save the reference even from bone data for efficiently     // simulating PMX animation system     bones[ i ].ik = param;     }    }    // grants    if ( data.metadata.format === 'pmx' ) {     // bone index -> grant entry map    const grantEntryMap = {};     for ( let i = 0; i < data.metadata.boneCount; i ++ ) {      const boneData = data.bones[ i ];     const grant = boneData.grant;      if ( grant === undefined ) continue;      const param = {      index: i,      parentIndex: grant.parentIndex,      ratio: grant.ratio,      isLocal: grant.isLocal,      affectRotation: grant.affectRotation,      affectPosition: grant.affectPosition,      transformationClass: boneData.transformationClass     };      grantEntryMap[ i ] = { parent: null, children: [], param: param, visited: false };     }     const rootEntry = { parent: null, children: [], param: null, visited: false };     // Build a tree representing grant hierarchy     for ( const boneIndex in grantEntryMap ) {      const grantEntry = grantEntryMap[ boneIndex ];     const parentGrantEntry = grantEntryMap[ grantEntry.parentIndex ] || rootEntry;      grantEntry.parent = parentGrantEntry;     parentGrantEntry.children.push( grantEntry );     }     // Sort grant parameters from parents to children because    // grant uses parent's transform that parent's grant is already applied    // so grant should be applied in order from parents to children     function traverse( entry ) {      if ( entry.param ) {       grants.push( entry.param );       // Save the reference even from bone data for efficiently      // simulating PMX animation system      bones[ entry.param.index ].grant = entry.param;      }      entry.visited = true;      for ( let i = 0, il = entry.children.length; i < il; i ++ ) {       const child = entry.children[ i ];       // Cut off a loop if exists. (Is a grant loop invalid?)      if ( ! child.visited ) traverse( child );      }     }     traverse( rootEntry );    }    // morph    function updateAttributes( attribute, morph, ratio ) {     for ( let i = 0; i < morph.elementCount; i ++ ) {      const element = morph.elements[ i ];      let index;      if ( data.metadata.format === 'pmd' ) {       index = data.morphs[ 0 ].elements[ element.index ].index;      } else {       index = element.index;      }      attribute.array[ index * 3 + 0 ] += element.position[ 0 ] * ratio;     attribute.array[ index * 3 + 1 ] += element.position[ 1 ] * ratio;     attribute.array[ index * 3 + 2 ] += element.position[ 2 ] * ratio;     }    }    for ( let i = 0; i < data.metadata.morphCount; i ++ ) {     const morph = data.morphs[ i ];    const params = { name: morph.name };     const attribute = new Float32BufferAttribute( data.metadata.vertexCount * 3, 3 );    attribute.name = morph.name;     for ( let j = 0; j < data.metadata.vertexCount * 3; j ++ ) {      attribute.array[ j ] = positions[ j ];     }     if ( data.metadata.format === 'pmd' ) {      if ( i !== 0 ) {       updateAttributes( attribute, morph, 1.0 );      }     } else {      if ( morph.type === 0 ) { // group       for ( let j = 0; j < morph.elementCount; j ++ ) {        const morph2 = data.morphs[ morph.elements[ j ].index ];       const ratio = morph.elements[ j ].ratio;        if ( morph2.type === 1 ) {         updateAttributes( attribute, morph2, ratio );        } else {         // TODO: implement        }       }      } else if ( morph.type === 1 ) { // vertex       updateAttributes( attribute, morph, 1.0 );      } else if ( morph.type === 2 ) { // bone       // TODO: implement      } else if ( morph.type === 3 ) { // uv       // TODO: implement      } else if ( morph.type === 4 ) { // additional uv1       // TODO: implement      } else if ( morph.type === 5 ) { // additional uv2       // TODO: implement      } else if ( morph.type === 6 ) { // additional uv3       // TODO: implement      } else if ( morph.type === 7 ) { // additional uv4       // TODO: implement      } else if ( morph.type === 8 ) { // material       // TODO: implement      }     }     morphTargets.push( params );    morphPositions.push( attribute );    }    // rigid bodies from rigidBodies field.    for ( let i = 0; i < data.metadata.rigidBodyCount; i ++ ) {     const rigidBody = data.rigidBodies[ i ];    const params = {};     for ( const key in rigidBody ) {      params[ key ] = rigidBody[ key ];     }     /*      * RigidBody position parameter in PMX seems global position      * while the one in PMD seems offset from corresponding bone.      * So unify being offset.      */    if ( data.metadata.format === 'pmx' ) {      if ( params.boneIndex !== - 1 ) {       const bone = data.bones[ params.boneIndex ];      params.position[ 0 ] -= bone.position[ 0 ];      params.position[ 1 ] -= bone.position[ 1 ];      params.position[ 2 ] -= bone.position[ 2 ];      }     }     rigidBodies.push( params );    }    // constraints from constraints field.    for ( let i = 0; i < data.metadata.constraintCount; i ++ ) {     const constraint = data.constraints[ i ];    const params = {};     for ( const key in constraint ) {      params[ key ] = constraint[ key ];     }     const bodyA = rigidBodies[ params.rigidBodyIndex1 ];    const bodyB = rigidBodies[ params.rigidBodyIndex2 ];     // Refer to http://www20.atpages.jp/katwat/wp/?p=4135    if ( bodyA.type !== 0 && bodyB.type === 2 ) {      if ( bodyA.boneIndex !== - 1 && bodyB.boneIndex !== - 1 &&           data.bones[ bodyB.boneIndex ].parentIndex === bodyA.boneIndex ) {       bodyB.type = 1;      }     }     constraints.push( params );    }    // build BufferGeometry.    const geometry = new BufferGeometry();    geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );   geometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );   geometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );   geometry.setAttribute( 'skinIndex', new Uint16BufferAttribute( skinIndices, 4 ) );   geometry.setAttribute( 'skinWeight', new Float32BufferAttribute( skinWeights, 4 ) );   geometry.setIndex( indices );    for ( let i = 0, il = groups.length; i < il; i ++ ) {     geometry.addGroup( groups[ i ].offset, groups[ i ].count, i );    }    geometry.bones = bones;    geometry.morphTargets = morphTargets;   geometry.morphAttributes.position = morphPositions;   geometry.morphTargetsRelative = false;    geometry.userData.MMD = {    bones: bones,    iks: iks,    grants: grants,    rigidBodies: rigidBodies,    constraints: constraints,    format: data.metadata.format   };    geometry.computeBoundingSphere();    return geometry;   }  }  //  /**  * @param {THREE.LoadingManager} manager  */ class MaterialBuilder {   constructor( manager ) {    this.manager = manager;    this.textureLoader = new TextureLoader( this.manager );   this.tgaLoader = null; // lazy generation    this.crossOrigin = 'anonymous';   this.resourcePath = undefined;   }   /**   * @param {string} crossOrigin   * @return {MaterialBuilder}   */  setCrossOrigin( crossOrigin ) {    this.crossOrigin = crossOrigin;   return this;   }   /**   * @param {string} resourcePath   * @return {MaterialBuilder}   */  setResourcePath( resourcePath ) {    this.resourcePath = resourcePath;   return this;   }   /**   * @param {Object} data - parsed PMD/PMX data   * @param {BufferGeometry} geometry - some properties are dependend on geometry   * @param {function} onProgress   * @param {function} onError   * @return {Array<MMDToonMaterial>}   */  build( data, geometry /*, onProgress, onError */ ) {    const materials = [];    const textures = {};    this.textureLoader.setCrossOrigin( this.crossOrigin );    // materials    for ( let i = 0; i < data.metadata.materialCount; i ++ ) {     const material = data.materials[ i ];     const params = { userData: { MMD: {} } };     if ( material.name !== undefined ) params.name = material.name;     /*      * Color      *      * MMD         MMDToonMaterial      * ambient  -  emissive * a      *               (a = 1.0 without map texture or 0.2 with map texture)      *      * MMDToonMaterial doesn't have ambient. Set it to emissive instead.      * It'll be too bright if material has map texture so using coef 0.2.      */    params.diffuse = new Color().setRGB(     material.diffuse[ 0 ],     material.diffuse[ 1 ],     material.diffuse[ 2 ],     SRGBColorSpace    );    params.opacity = material.diffuse[ 3 ];    params.specular = new Color().setRGB( ...material.specular, SRGBColorSpace );    params.shininess = material.shininess;    params.emissive = new Color().setRGB( ...material.ambient, SRGBColorSpace );    params.transparent = params.opacity !== 1.0;     //     params.fog = true;     // blend     params.blending = CustomBlending;    params.blendSrc = SrcAlphaFactor;    params.blendDst = OneMinusSrcAlphaFactor;    params.blendSrcAlpha = SrcAlphaFactor;    params.blendDstAlpha = DstAlphaFactor;     // side     if ( data.metadata.format === 'pmx' && ( material.flag & 0x1 ) === 1 ) {      params.side = DoubleSide;     } else {      params.side = params.opacity === 1.0 ? FrontSide : DoubleSide;     }     if ( data.metadata.format === 'pmd' ) {      // map, matcap      if ( material.fileName ) {       const fileName = material.fileName;      const fileNames = fileName.split( '*' );       // fileNames[ 0 ]: mapFileName      // fileNames[ 1 ]: matcapFileName( optional )       params.map = this._loadTexture( fileNames[ 0 ], textures );       if ( fileNames.length > 1 ) {        const extension = fileNames[ 1 ].slice( - 4 ).toLowerCase();        params.matcap = this._loadTexture(        fileNames[ 1 ],        textures       );        params.matcapCombine = extension === '.sph'        ? MultiplyOperation        : AddOperation;       }      }      // gradientMap      const toonFileName = ( material.toonIndex === - 1 )      ? 'toon00.bmp'      : data.toonTextures[ material.toonIndex ].fileName;      params.gradientMap = this._loadTexture(      toonFileName,      textures,      {       isToonTexture: true,       isDefaultToonTexture: this._isDefaultToonTexture( toonFileName )      }     );      // parameters for OutlineEffect      params.userData.outlineParameters = {      thickness: material.edgeFlag === 1 ? 0.003 : 0.0,      color: [ 0, 0, 0 ],      alpha: 1.0,      visible: material.edgeFlag === 1     };     } else {      // map      if ( material.textureIndex !== - 1 ) {       params.map = this._loadTexture( data.textures[ material.textureIndex ], textures );       // Since PMX spec don't have standard to list map files except color map and env map,      // we need to save file name for further mapping, like matching normal map file names after model loaded.      // ref: https://gist.github.com/felixjones/f8a06bd48f9da9a4539f#texture      params.userData.MMD.mapFileName = data.textures[ material.textureIndex ];      }      // matcap TODO: support m.envFlag === 3      if ( material.envTextureIndex !== - 1 && ( material.envFlag === 1 || material.envFlag == 2 ) ) {       params.matcap = this._loadTexture(       data.textures[ material.envTextureIndex ],       textures      );       // Same as color map above, keep file name in userData for further usage.      params.userData.MMD.matcapFileName = data.textures[ material.envTextureIndex ];       params.matcapCombine = material.envFlag === 1       ? MultiplyOperation       : AddOperation;      }      // gradientMap      let toonFileName, isDefaultToon;      if ( material.toonIndex === - 1 || material.toonFlag !== 0 ) {       toonFileName = 'toon' + ( '0' + ( material.toonIndex + 1 ) ).slice( - 2 ) + '.bmp';      isDefaultToon = true;      } else {       toonFileName = data.textures[ material.toonIndex ];      isDefaultToon = false;      }      params.gradientMap = this._loadTexture(      toonFileName,      textures,      {       isToonTexture: true,       isDefaultToonTexture: isDefaultToon      }     );      // parameters for OutlineEffect     params.userData.outlineParameters = {      thickness: material.edgeSize / 300, // TODO: better calculation?      color: material.edgeColor.slice( 0, 3 ),      alpha: material.edgeColor[ 3 ],      visible: ( material.flag & 0x10 ) !== 0 && material.edgeSize > 0.0     };     }     if ( params.map !== undefined ) {      if ( ! params.transparent ) {       this._checkImageTransparency( params.map, geometry, i );      }      params.emissive.multiplyScalar( 0.2 );     }     materials.push( new MMDToonMaterial( params ) );    }    if ( data.metadata.format === 'pmx' ) {     // set transparent true if alpha morph is defined.     function checkAlphaMorph( elements, materials ) {      for ( let i = 0, il = elements.length; i < il; i ++ ) {       const element = elements[ i ];       if ( element.index === - 1 ) continue;       const material = materials[ element.index ];       if ( material.opacity !== element.diffuse[ 3 ] ) {        material.transparent = true;       }      }     }     for ( let i = 0, il = data.morphs.length; i < il; i ++ ) {      const morph = data.morphs[ i ];     const elements = morph.elements;      if ( morph.type === 0 ) {       for ( let j = 0, jl = elements.length; j < jl; j ++ ) {        const morph2 = data.morphs[ elements[ j ].index ];        if ( morph2.type !== 8 ) continue;        checkAlphaMorph( morph2.elements, materials );       }      } else if ( morph.type === 8 ) {       checkAlphaMorph( elements, materials );      }     }    }    return materials;   }   // private methods   _getTGALoader() {    if ( this.tgaLoader === null ) {     if ( TGALoader === undefined ) {      throw new Error( 'THREE.MMDLoader: Import TGALoader' );     }     this.tgaLoader = new TGALoader( this.manager );    }    return this.tgaLoader;   }   _isDefaultToonTexture( name ) {    if ( name.length !== 10 ) return false;    return /toon(10|0[0-9])|.bmp/.test( name );   }   _loadTexture( filePath, textures, params, onProgress, onError ) {    params = params || {};    const scope = this;    let fullPath;    if ( params.isDefaultToonTexture === true ) {     let index;     try {      index = parseInt( filePath.match( /toon([0-9]{2})|.bmp$/ )[ 1 ] );     } catch ( e ) {      console.warn( 'THREE.MMDLoader: ' + filePath + ' seems like a '       + 'not right default texture path. Using toon00.bmp instead.' );      index = 0;     }     fullPath = DEFAULT_TOON_TEXTURES[ index ];    } else {     fullPath = this.resourcePath + filePath;    }    if ( textures[ fullPath ] !== undefined ) return textures[ fullPath ];    let loader = this.manager.getHandler( fullPath );    if ( loader === null ) {     loader = ( filePath.slice( - 4 ).toLowerCase() === '.tga' )     ? this._getTGALoader()     : this.textureLoader;    }    const texture = loader.load( fullPath, function ( t ) {     // MMD toon texture is Axis-Y oriented    // but Three.js gradient map is Axis-X oriented.    // So here replaces the toon texture image with the rotated one.    if ( params.isToonTexture === true ) {      t.image = scope._getRotatedImage( t.image );      t.magFilter = NearestFilter;     t.minFilter = NearestFilter;     }     t.flipY = false;    t.wrapS = RepeatWrapping;    t.wrapT = RepeatWrapping;    t.colorSpace = SRGBColorSpace;     for ( let i = 0; i < texture.readyCallbacks.length; i ++ ) {      texture.readyCallbacks[ i ]( texture );     }     delete texture.readyCallbacks;    }, onProgress, onError );    texture.readyCallbacks = [];    textures[ fullPath ] = texture;    return texture;   }   _getRotatedImage( image ) {    const canvas = document.createElement( 'canvas' );   const context = canvas.getContext( '2d' );    const width = image.width;   const height = image.height;    canvas.width = width;   canvas.height = height;    context.clearRect( 0, 0, width, height );   context.translate( width / 2.0, height / 2.0 );   context.rotate( 0.5 * Math.PI ); // 90.0 * Math.PI / 180.0   context.translate( - width / 2.0, - height / 2.0 );   context.drawImage( image, 0, 0 );    return context.getImageData( 0, 0, width, height );   }   // Check if the partial image area used by the texture is transparent.  _checkImageTransparency( map, geometry, groupIndex ) {    map.readyCallbacks.push( function ( texture ) {     // Is there any efficient ways?    function createImageData( image ) {      const canvas = document.createElement( 'canvas' );     canvas.width = image.width;     canvas.height = image.height;      const context = canvas.getContext( '2d' );     context.drawImage( image, 0, 0 );      return context.getImageData( 0, 0, canvas.width, canvas.height );     }     function detectImageTransparency( image, uvs, indices ) {      const width = image.width;     const height = image.height;     const data = image.data;     const threshold = 253;      if ( data.length / ( width * height ) !== 4 ) return false;      for ( let i = 0; i < indices.length; i += 3 ) {       const centerUV = { x: 0.0, y: 0.0 };       for ( let j = 0; j < 3; j ++ ) {        const index = indices[ i * 3 + j ];       const uv = { x: uvs[ index * 2 + 0 ], y: uvs[ index * 2 + 1 ] };        if ( getAlphaByUv( image, uv ) < threshold ) return true;        centerUV.x += uv.x;       centerUV.y += uv.y;       }       centerUV.x /= 3;      centerUV.y /= 3;       if ( getAlphaByUv( image, centerUV ) < threshold ) return true;      }      return false;     }     /*      * This method expects      *   texture.flipY = false      *   texture.wrapS = RepeatWrapping      *   texture.wrapT = RepeatWrapping      * TODO: more precise      */    function getAlphaByUv( image, uv ) {      const width = image.width;     const height = image.height;      let x = Math.round( uv.x * width ) % width;     let y = Math.round( uv.y * height ) % height;      if ( x < 0 ) x += width;     if ( y < 0 ) y += height;      const index = y * width + x;      return image.data[ index * 4 + 3 ];     }     if ( texture.isCompressedTexture === true ) {      if ( NON_ALPHA_CHANNEL_FORMATS.includes( texture.format ) ) {       map.transparent = false;      } else {       // any other way to check transparency of CompressedTexture?      map.transparent = true;      }      return;     }     const imageData = texture.image.data !== undefined     ? texture.image     : createImageData( texture.image );     const group = geometry.groups[ groupIndex ];     if ( detectImageTransparency(     imageData,     geometry.attributes.uv.array,     geometry.index.array.slice( group.start, group.start + group.count ) ) ) {      map.transparent = true;     }    } );   }  }  //  class AnimationBuilder {   /**   * @param {Object} vmd - parsed VMD data   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh   * @return {AnimationClip}   */  build( vmd, mesh ) {    // combine skeletal and morph animations    const tracks = this.buildSkeletalAnimation( vmd, mesh ).tracks;   const tracks2 = this.buildMorphAnimation( vmd, mesh ).tracks;    for ( let i = 0, il = tracks2.length; i < il; i ++ ) {     tracks.push( tracks2[ i ] );    }    return new AnimationClip( '', - 1, tracks );   }   /**   * @param {Object} vmd - parsed VMD data   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh   * @return {AnimationClip}   */  buildSkeletalAnimation( vmd, mesh ) {    function pushInterpolation( array, interpolation, index ) {     array.push( interpolation[ index + 0 ] / 127 ); // x1    array.push( interpolation[ index + 8 ] / 127 ); // x2    array.push( interpolation[ index + 4 ] / 127 ); // y1    array.push( interpolation[ index + 12 ] / 127 ); // y2    }    const tracks = [];    const motions = {};   const bones = mesh.skeleton.bones;   const boneNameDictionary = {};    for ( let i = 0, il = bones.length; i < il; i ++ ) {     boneNameDictionary[ bones[ i ].name ] = true;    }    for ( let i = 0; i < vmd.metadata.motionCount; i ++ ) {     const motion = vmd.motions[ i ];    const boneName = motion.boneName;     if ( boneNameDictionary[ boneName ] === undefined ) continue;     motions[ boneName ] = motions[ boneName ] || [];    motions[ boneName ].push( motion );    }    for ( const key in motions ) {     const array = motions[ key ];     array.sort( function ( a, b ) {      return a.frameNum - b.frameNum;     } );     const times = [];    const positions = [];    const rotations = [];    const pInterpolations = [];    const rInterpolations = [];     const basePosition = mesh.skeleton.getBoneByName( key ).position.toArray();     for ( let i = 0, il = array.length; i < il; i ++ ) {      const time = array[ i ].frameNum / 30;     const position = array[ i ].position;     const rotation = array[ i ].rotation;     const interpolation = array[ i ].interpolation;      times.push( time );      for ( let j = 0; j < 3; j ++ ) positions.push( basePosition[ j ] + position[ j ] );     for ( let j = 0; j < 4; j ++ ) rotations.push( rotation[ j ] );     for ( let j = 0; j < 3; j ++ ) pushInterpolation( pInterpolations, interpolation, j );      pushInterpolation( rInterpolations, interpolation, 3 );     }     const targetName = '.bones[' + key + ']';     tracks.push( this._createTrack( targetName + '.position', VectorKeyframeTrack, times, positions, pInterpolations ) );    tracks.push( this._createTrack( targetName + '.quaternion', QuaternionKeyframeTrack, times, rotations, rInterpolations ) );    }    return new AnimationClip( '', - 1, tracks );   }   /**   * @param {Object} vmd - parsed VMD data   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh   * @return {AnimationClip}   */  buildMorphAnimation( vmd, mesh ) {    const tracks = [];    const morphs = {};   const morphTargetDictionary = mesh.morphTargetDictionary;    for ( let i = 0; i < vmd.metadata.morphCount; i ++ ) {     const morph = vmd.morphs[ i ];    const morphName = morph.morphName;     if ( morphTargetDictionary[ morphName ] === undefined ) continue;     morphs[ morphName ] = morphs[ morphName ] || [];    morphs[ morphName ].push( morph );    }    for ( const key in morphs ) {     const array = morphs[ key ];     array.sort( function ( a, b ) {      return a.frameNum - b.frameNum;     } );     const times = [];    const values = [];     for ( let i = 0, il = array.length; i < il; i ++ ) {      times.push( array[ i ].frameNum / 30 );     values.push( array[ i ].weight );     }     tracks.push( new NumberKeyframeTrack( '.morphTargetInfluences[' + morphTargetDictionary[ key ] + ']', times, values ) );    }    return new AnimationClip( '', - 1, tracks );   }   /**   * @param {Object} vmd - parsed VMD data   * @return {AnimationClip}   */  buildCameraAnimation( vmd ) {    function pushVector3( array, vec ) {     array.push( vec.x );    array.push( vec.y );    array.push( vec.z );    }    function pushQuaternion( array, q ) {     array.push( q.x );    array.push( q.y );    array.push( q.z );    array.push( q.w );    }    function pushInterpolation( array, interpolation, index ) {     array.push( interpolation[ index * 4 + 0 ] / 127 ); // x1    array.push( interpolation[ index * 4 + 1 ] / 127 ); // x2    array.push( interpolation[ index * 4 + 2 ] / 127 ); // y1    array.push( interpolation[ index * 4 + 3 ] / 127 ); // y2    }    const cameras = vmd.cameras === undefined ? [] : vmd.cameras.slice();    cameras.sort( function ( a, b ) {     return a.frameNum - b.frameNum;    } );    const times = [];   const centers = [];   const quaternions = [];   const positions = [];   const fovs = [];    const cInterpolations = [];   const qInterpolations = [];   const pInterpolations = [];   const fInterpolations = [];    const quaternion = new Quaternion();   const euler = new Euler();   const position = new Vector3();   const center = new Vector3();    for ( let i = 0, il = cameras.length; i < il; i ++ ) {     const motion = cameras[ i ];     const time = motion.frameNum / 30;    const pos = motion.position;    const rot = motion.rotation;    const distance = motion.distance;    const fov = motion.fov;    const interpolation = motion.interpolation;     times.push( time );     position.set( 0, 0, - distance );    center.set( pos[ 0 ], pos[ 1 ], pos[ 2 ] );     euler.set( - rot[ 0 ], - rot[ 1 ], - rot[ 2 ] );    quaternion.setFromEuler( euler );     position.add( center );    position.applyQuaternion( quaternion );     pushVector3( centers, center );    pushQuaternion( quaternions, quaternion );    pushVector3( positions, position );     fovs.push( fov );     for ( let j = 0; j < 3; j ++ ) {      pushInterpolation( cInterpolations, interpolation, j );     }     pushInterpolation( qInterpolations, interpolation, 3 );     // use the same parameter for x, y, z axis.    for ( let j = 0; j < 3; j ++ ) {      pushInterpolation( pInterpolations, interpolation, 4 );     }     pushInterpolation( fInterpolations, interpolation, 5 );    }    const tracks = [];    // I expect an object whose name 'target' exists under THREE.Camera   tracks.push( this._createTrack( 'target.position', VectorKeyframeTrack, times, centers, cInterpolations ) );    tracks.push( this._createTrack( '.quaternion', QuaternionKeyframeTrack, times, quaternions, qInterpolations ) );   tracks.push( this._createTrack( '.position', VectorKeyframeTrack, times, positions, pInterpolations ) );   tracks.push( this._createTrack( '.fov', NumberKeyframeTrack, times, fovs, fInterpolations ) );    return new AnimationClip( '', - 1, tracks );   }   // private method   _createTrack( node, typedKeyframeTrack, times, values, interpolations ) {    /*     * optimizes here not to let KeyframeTrackPrototype optimize     * because KeyframeTrackPrototype optimizes times and values but     * doesn't optimize interpolations.     */   if ( times.length > 2 ) {     times = times.slice();    values = values.slice();    interpolations = interpolations.slice();     const stride = values.length / times.length;    const interpolateStride = interpolations.length / times.length;     let index = 1;     for ( let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex ++ ) {      for ( let i = 0; i < stride; i ++ ) {       if ( values[ index * stride + i ] !== values[ ( index - 1 ) * stride + i ] ||        values[ index * stride + i ] !== values[ aheadIndex * stride + i ] ) {        index ++;       break;       }      }      if ( aheadIndex > index ) {       times[ index ] = times[ aheadIndex ];       for ( let i = 0; i < stride; i ++ ) {        values[ index * stride + i ] = values[ aheadIndex * stride + i ];       }       for ( let i = 0; i < interpolateStride; i ++ ) {        interpolations[ index * interpolateStride + i ] = interpolations[ aheadIndex * interpolateStride + i ];       }      }     }     times.length = index + 1;    values.length = ( index + 1 ) * stride;    interpolations.length = ( index + 1 ) * interpolateStride;    }    const track = new typedKeyframeTrack( node, times, values );    track.createInterpolant = function InterpolantFactoryMethodCubicBezier( result ) {     return new CubicBezierInterpolation( this.times, this.values, this.getValueSize(), result, new Float32Array( interpolations ) );    };    return track;   }  }  // interpolation  class CubicBezierInterpolation extends Interpolant {   constructor( parameterPositions, sampleValues, sampleSize, resultBuffer, params ) {    super( parameterPositions, sampleValues, sampleSize, resultBuffer );    this.interpolationParams = params;   }   interpolate_( i1, t0, t, t1 ) {    const result = this.resultBuffer;   const values = this.sampleValues;   const stride = this.valueSize;   const params = this.interpolationParams;    const offset1 = i1 * stride;   const offset0 = offset1 - stride;    // No interpolation if next key frame is in one frame in 30fps.   // This is from MMD animation spec.   // '1.5' is for precision loss. times are Float32 in Three.js Animation system.   const weight1 = ( ( t1 - t0 ) < 1 / 30 * 1.5 ) ? 0.0 : ( t - t0 ) / ( t1 - t0 );    if ( stride === 4 ) { // Quaternion     const x1 = params[ i1 * 4 + 0 ];    const x2 = params[ i1 * 4 + 1 ];    const y1 = params[ i1 * 4 + 2 ];    const y2 = params[ i1 * 4 + 3 ];     const ratio = this._calculate( x1, x2, y1, y2, weight1 );     Quaternion.slerpFlat( result, 0, values, offset0, values, offset1, ratio );    } else if ( stride === 3 ) { // Vector3     for ( let i = 0; i !== stride; ++ i ) {      const x1 = params[ i1 * 12 + i * 4 + 0 ];     const x2 = params[ i1 * 12 + i * 4 + 1 ];     const y1 = params[ i1 * 12 + i * 4 + 2 ];     const y2 = params[ i1 * 12 + i * 4 + 3 ];      const ratio = this._calculate( x1, x2, y1, y2, weight1 );      result[ i ] = values[ offset0 + i ] * ( 1 - ratio ) + values[ offset1 + i ] * ratio;     }    } else { // Number     const x1 = params[ i1 * 4 + 0 ];    const x2 = params[ i1 * 4 + 1 ];    const y1 = params[ i1 * 4 + 2 ];    const y2 = params[ i1 * 4 + 3 ];     const ratio = this._calculate( x1, x2, y1, y2, weight1 );     result[ 0 ] = values[ offset0 ] * ( 1 - ratio ) + values[ offset1 ] * ratio;    }    return result;   }   _calculate( x1, x2, y1, y2, x ) {    /*     * Cubic Bezier curves     *   https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves     *     * B(t) = ( 1 - t ) ^ 3 * P0     *      + 3 * ( 1 - t ) ^ 2 * t * P1     *      + 3 * ( 1 - t ) * t^2 * P2     *      + t ^ 3 * P3     *      ( 0 <= t <= 1 )     *     * MMD uses Cubic Bezier curves for bone and camera animation interpolation.     *   http://d.hatena.ne.jp/edvakf/20111016/1318716097     *     *    x = ( 1 - t ) ^ 3 * x0     *      + 3 * ( 1 - t ) ^ 2 * t * x1     *      + 3 * ( 1 - t ) * t^2 * x2     *      + t ^ 3 * x3     *    y = ( 1 - t ) ^ 3 * y0     *      + 3 * ( 1 - t ) ^ 2 * t * y1     *      + 3 * ( 1 - t ) * t^2 * y2     *      + t ^ 3 * y3     *      ( x0 = 0, y0 = 0 )     *      ( x3 = 1, y3 = 1 )     *      ( 0 <= t, x1, x2, y1, y2 <= 1 )     *     * Here solves this equation with Bisection method,     *   https://en.wikipedia.org/wiki/Bisection_method     * gets t, and then calculate y.     *     * f(t) = 3 * ( 1 - t ) ^ 2 * t * x1     *      + 3 * ( 1 - t ) * t^2 * x2     *      + t ^ 3 - x = 0     *     * (Another option: Newton's method     *    https://en.wikipedia.org/wiki/Newton%27s_method)     */    let c = 0.5;   let t = c;   let s = 1.0 - t;   const loop = 15;   const eps = 1e-5;   const math = Math;    let sst3, stt3, ttt;    for ( let i = 0; i < loop; i ++ ) {     sst3 = 3.0 * s * s * t;    stt3 = 3.0 * s * t * t;    ttt = t * t * t;     const ft = ( sst3 * x1 ) + ( stt3 * x2 ) + ( ttt ) - x;     if ( math.abs( ft ) < eps ) break;     c /= 2.0;     t += ( ft < 0 ) ? c : - c;    s = 1.0 - t;    }    return ( sst3 * y1 ) + ( stt3 * y2 ) + ttt;   }  }  class MMDToonMaterial extends ShaderMaterial {   constructor( parameters ) {    super();    this.isMMDToonMaterial = true;    this.type = 'MMDToonMaterial';    this._matcapCombine = AddOperation;   this.emissiveIntensity = 1.0;   this.normalMapType = TangentSpaceNormalMap;    this.combine = MultiplyOperation;    this.wireframeLinecap = 'round';   this.wireframeLinejoin = 'round';    this.flatShading = false;    this.lights = true;    this.vertexShader = MMDToonShader.vertexShader;   this.fragmentShader = MMDToonShader.fragmentShader;    this.defines = Object.assign( {}, MMDToonShader.defines );   Object.defineProperty( this, 'matcapCombine', {     get: function () {      return this._matcapCombine;     },     set: function ( value ) {      this._matcapCombine = value;      switch ( value ) {       case MultiplyOperation:       this.defines.MATCAP_BLENDING_MULTIPLY = true;       delete this.defines.MATCAP_BLENDING_ADD;       break;       default:      case AddOperation:       this.defines.MATCAP_BLENDING_ADD = true;       delete this.defines.MATCAP_BLENDING_MULTIPLY;       break;      }     },    } );    this.uniforms = UniformsUtils.clone( MMDToonShader.uniforms );    // merged from MeshToon/Phong/MatcapMaterial   const exposePropertyNames = [    'specular',    'opacity',    'diffuse',     'map',    'matcap',    'gradientMap',     'lightMap',    'lightMapIntensity',     'aoMap',    'aoMapIntensity',     'emissive',    'emissiveMap',     'bumpMap',    'bumpScale',     'normalMap',    'normalScale',     'displacemantBias',    'displacemantMap',    'displacemantScale',     'specularMap',     'alphaMap',     'reflectivity',    'refractionRatio',   ];   for ( const propertyName of exposePropertyNames ) {     Object.defineProperty( this, propertyName, {      get: function () {       return this.uniforms[ propertyName ].value;      },      set: function ( value ) {       this.uniforms[ propertyName ].value = value;      },     } );    }    // Special path for shininess to handle zero shininess properly   this._shininess = 30;   Object.defineProperty( this, 'shininess', {     get: function () {      return this._shininess;     },     set: function ( value ) {      this._shininess = value;     this.uniforms.shininess.value = Math.max( this._shininess, 1e-4 ); // To prevent pow( 0.0, 0.0 )     },    } );    Object.defineProperty(    this,    'color',    Object.getOwnPropertyDescriptor( this, 'diffuse' )   );    this.setValues( parameters );   }   copy( source ) {    super.copy( source );    this.matcapCombine = source.matcapCombine;   this.emissiveIntensity = source.emissiveIntensity;   this.normalMapType = source.normalMapType;    this.combine = source.combine;    this.wireframeLinecap = source.wireframeLinecap;   this.wireframeLinejoin = source.wireframeLinejoin;    this.flatShading = source.flatShading;    return this;   }  }  export { MMDLoader }; 
^..^ FILENAME ^..^
addons|loaders|MTLLoader.js
^..^ CONTENTS ^..^
import {  Color,  ColorManagement,  DefaultLoadingManager,  FileLoader,  FrontSide,  Loader,  LoaderUtils,  MeshPhongMaterial,  RepeatWrapping,  TextureLoader,  Vector2,  SRGBColorSpace } from 'three';  /**  * Loads a Wavefront .mtl file specifying materials  */  class MTLLoader extends Loader {   constructor( manager ) {    super( manager );   }   /**   * Loads and parses a MTL asset from a URL.   *   * @param {String} url - URL to the MTL file.   * @param {Function} [onLoad] - Callback invoked with the loaded object.   * @param {Function} [onProgress] - Callback for download progress.   * @param {Function} [onError] - Callback for download errors.   *   * @see setPath setResourcePath   *   * @note In order for relative texture references to resolve correctly   * you must call setResourcePath() explicitly prior to load.   */  load( url, onLoad, onProgress, onError ) {    const scope = this;    const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;    const loader = new FileLoader( this.manager );   loader.setPath( this.path );   loader.setRequestHeader( this.requestHeader );   loader.setWithCredentials( this.withCredentials );   loader.load( url, function ( text ) {     try {      onLoad( scope.parse( text, path ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   setMaterialOptions( value ) {    this.materialOptions = value;   return this;   }   /**   * Parses a MTL file.   *   * @param {String} text - Content of MTL file   * @return {MaterialCreator}   *   * @see setPath setResourcePath   *   * @note In order for relative texture references to resolve correctly   * you must call setResourcePath() explicitly prior to parse.   */  parse( text, path ) {    const lines = text.split( '|n' );   let info = {};   const delimiter_pattern = /|s+/;   const materialsInfo = {};    for ( let i = 0; i < lines.length; i ++ ) {     let line = lines[ i ];    line = line.trim();     if ( line.length === 0 || line.charAt( 0 ) === '#' ) {      // Blank line or comment ignore     continue;     }     const pos = line.indexOf( ' ' );     let key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;    key = key.toLowerCase();     let value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';    value = value.trim();     if ( key === 'newmtl' ) {      // New material      info = { name: value };     materialsInfo[ value ] = info;     } else {      if ( key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke' ) {       const ss = value.split( delimiter_pattern, 3 );      info[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];      } else {       info[ key ] = value;      }     }    }    const materialCreator = new MaterialCreator( this.resourcePath || path, this.materialOptions );   materialCreator.setCrossOrigin( this.crossOrigin );   materialCreator.setManager( this.manager );   materialCreator.setMaterials( materialsInfo );   return materialCreator;   }  }  /**  * Create a new MTLLoader.MaterialCreator  * @param baseUrl - Url relative to which textures are loaded  * @param options - Set of options on how to construct the materials  *                  side: Which side to apply the material  *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide  *                  wrap: What type of wrapping to apply for textures  *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping  *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255  *                                Default: false, assumed to be already normalized  *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's  *                                  Default: false  * @constructor  */  class MaterialCreator {   constructor( baseUrl = '', options = {} ) {    this.baseUrl = baseUrl;   this.options = options;   this.materialsInfo = {};   this.materials = {};   this.materialsArray = [];   this.nameLookup = {};    this.crossOrigin = 'anonymous';    this.side = ( this.options.side !== undefined ) ? this.options.side : FrontSide;   this.wrap = ( this.options.wrap !== undefined ) ? this.options.wrap : RepeatWrapping;   }   setCrossOrigin( value ) {    this.crossOrigin = value;   return this;   }   setManager( value ) {    this.manager = value;   }   setMaterials( materialsInfo ) {    this.materialsInfo = this.convert( materialsInfo );   this.materials = {};   this.materialsArray = [];   this.nameLookup = {};   }   convert( materialsInfo ) {    if ( ! this.options ) return materialsInfo;    const converted = {};    for ( const mn in materialsInfo ) {     // Convert materials info into normalized form based on options     const mat = materialsInfo[ mn ];     const covmat = {};     converted[ mn ] = covmat;     for ( const prop in mat ) {      let save = true;     let value = mat[ prop ];     const lprop = prop.toLowerCase();      switch ( lprop ) {       case 'kd':      case 'ka':      case 'ks':        // Diffuse color (color under white light) using RGB values        if ( this.options && this.options.normalizeRGB ) {         value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];        }        if ( this.options && this.options.ignoreZeroRGBs ) {         if ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {          // ignore          save = false;         }        }        break;       default:        break;      }      if ( save ) {       covmat[ lprop ] = value;      }     }    }    return converted;   }   preload() {    for ( const mn in this.materialsInfo ) {     this.create( mn );    }   }   getIndex( materialName ) {    return this.nameLookup[ materialName ];   }   getAsArray() {    let index = 0;    for ( const mn in this.materialsInfo ) {     this.materialsArray[ index ] = this.create( mn );    this.nameLookup[ mn ] = index;    index ++;    }    return this.materialsArray;   }   create( materialName ) {    if ( this.materials[ materialName ] === undefined ) {     this.createMaterial_( materialName );    }    return this.materials[ materialName ];   }   createMaterial_( materialName ) {    // Create material    const scope = this;   const mat = this.materialsInfo[ materialName ];   const params = {     name: materialName,    side: this.side    };    function resolveURL( baseUrl, url ) {     if ( typeof url !== 'string' || url === '' )     return '';     // Absolute URL    if ( /^https?:|/|//i.test( url ) ) return url;     return baseUrl + url;    }    function setMapForType( mapType, value ) {     if ( params[ mapType ] ) return; // Keep the first encountered texture     const texParams = scope.getTextureParams( value, params );    const map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );     map.repeat.copy( texParams.scale );    map.offset.copy( texParams.offset );     map.wrapS = scope.wrap;    map.wrapT = scope.wrap;     if ( mapType === 'map' || mapType === 'emissiveMap' ) {      map.colorSpace = SRGBColorSpace;     }     params[ mapType ] = map;    }    for ( const prop in mat ) {     const value = mat[ prop ];    let n;     if ( value === '' ) continue;     switch ( prop.toLowerCase() ) {      // Ns is material specular exponent      case 'kd':       // Diffuse color (color under white light) using RGB values       params.color = ColorManagement.toWorkingColorSpace( new Color().fromArray( value ), SRGBColorSpace );       break;      case 'ks':       // Specular color (color when light is reflected from shiny surface) using RGB values      params.specular = ColorManagement.toWorkingColorSpace( new Color().fromArray( value ), SRGBColorSpace );       break;      case 'ke':       // Emissive using RGB values      params.emissive = ColorManagement.toWorkingColorSpace( new Color().fromArray( value ), SRGBColorSpace );       break;      case 'map_kd':       // Diffuse texture map       setMapForType( 'map', value );       break;      case 'map_ks':       // Specular map       setMapForType( 'specularMap', value );       break;      case 'map_ke':       // Emissive map       setMapForType( 'emissiveMap', value );       break;      case 'norm':       setMapForType( 'normalMap', value );       break;      case 'map_bump':     case 'bump':       // Bump texture map       setMapForType( 'bumpMap', value );       break;      case 'map_d':       // Alpha map       setMapForType( 'alphaMap', value );      params.transparent = true;       break;      case 'ns':       // The specular exponent (defines the focus of the specular highlight)      // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.       params.shininess = parseFloat( value );       break;      case 'd':      n = parseFloat( value );       if ( n < 1 ) {        params.opacity = n;       params.transparent = true;       }       break;      case 'tr':      n = parseFloat( value );       if ( this.options && this.options.invertTrProperty ) n = 1 - n;       if ( n > 0 ) {        params.opacity = 1 - n;       params.transparent = true;       }       break;      default:      break;     }    }    this.materials[ materialName ] = new MeshPhongMaterial( params );   return this.materials[ materialName ];   }   getTextureParams( value, matParams ) {    const texParams = {     scale: new Vector2( 1, 1 ),    offset: new Vector2( 0, 0 )     };    const items = value.split( /|s+/ );   let pos;    pos = items.indexOf( '-bm' );    if ( pos >= 0 ) {     matParams.bumpScale = parseFloat( items[ pos + 1 ] );    items.splice( pos, 2 );    }    pos = items.indexOf( '-s' );    if ( pos >= 0 ) {     texParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );    items.splice( pos, 4 ); // we expect 3 parameters here!    }    pos = items.indexOf( '-o' );    if ( pos >= 0 ) {     texParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );    items.splice( pos, 4 ); // we expect 3 parameters here!    }    texParams.url = items.join( ' ' ).trim();   return texParams;   }   loadTexture( url, mapping, onLoad, onProgress, onError ) {    const manager = ( this.manager !== undefined ) ? this.manager : DefaultLoadingManager;   let loader = manager.getHandler( url );    if ( loader === null ) {     loader = new TextureLoader( manager );    }    if ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );    const texture = loader.load( url, onLoad, onProgress, onError );    if ( mapping !== undefined ) texture.mapping = mapping;    return texture;   }  }  export { MTLLoader }; 
^..^ FILENAME ^..^
addons|loaders|NRRDLoader.js
^..^ CONTENTS ^..^
import {  FileLoader,  Loader,  Matrix4,  Vector3 } from 'three'; import * as fflate from '../libs/fflate.module.js'; import { Volume } from '../misc/Volume.js';  class NRRDLoader extends Loader {   constructor( manager ) {    super( manager );   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( scope.manager );   loader.setPath( scope.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( scope.requestHeader );   loader.setWithCredentials( scope.withCredentials );   loader.load( url, function ( data ) {     try {      onLoad( scope.parse( data ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   /**   *   * @param {boolean} segmentation is a option for user to choose      */  setSegmentation( segmentation ) {       this.segmentation = segmentation;   }   parse( data ) {    // this parser is largely inspired from the XTK NRRD parser : https://github.com/xtk/X    let _data = data;    let _dataPointer = 0;    const _nativeLittleEndian = new Int8Array( new Int16Array( [ 1 ] ).buffer )[ 0 ] > 0;    const _littleEndian = true;    const headerObject = {};    function scan( type, chunks ) {     let _chunkSize = 1;    let _array_type = Uint8Array;     switch ( type ) {      // 1 byte data types     case 'uchar':      break;     case 'schar':      _array_type = Int8Array;      break;     // 2 byte data types     case 'ushort':      _array_type = Uint16Array;      _chunkSize = 2;      break;     case 'sshort':      _array_type = Int16Array;      _chunkSize = 2;      break;     // 4 byte data types     case 'uint':      _array_type = Uint32Array;      _chunkSize = 4;      break;     case 'sint':      _array_type = Int32Array;      _chunkSize = 4;      break;     case 'float':      _array_type = Float32Array;      _chunkSize = 4;      break;     case 'complex':      _array_type = Float64Array;      _chunkSize = 8;      break;     case 'double':      _array_type = Float64Array;      _chunkSize = 8;      break;     }     // increase the data pointer in-place    let _bytes = new _array_type( _data.slice( _dataPointer,     _dataPointer += chunks * _chunkSize ) );     // if required, flip the endianness of the bytes    if ( _nativeLittleEndian != _littleEndian ) {      // we need to flip here since the format doesn't match the native endianness     _bytes = flipEndianness( _bytes, _chunkSize );     }     // return the byte array    return _bytes;    }    //Flips typed array endianness in-place. Based on https://github.com/kig/DataStream.js/blob/master/DataStream.js.    function flipEndianness( array, chunkSize ) {     const u8 = new Uint8Array( array.buffer, array.byteOffset, array.byteLength );    for ( let i = 0; i < array.byteLength; i += chunkSize ) {      for ( let j = i + chunkSize - 1, k = i; j > k; j --, k ++ ) {       const tmp = u8[ k ];      u8[ k ] = u8[ j ];      u8[ j ] = tmp;      }     }     return array;    }    //parse the header   function parseHeader( header ) {     let data, field, fn, i, l, m, _i, _len;    const lines = header.split( /|r?|n/ );    for ( _i = 0, _len = lines.length; _i < _len; _i ++ ) {      l = lines[ _i ];     if ( l.match( /NRRD|d+/ ) ) {       headerObject.isNrrd = true;      } else if ( ! l.match( /^#/ ) && ( m = l.match( /(.*):(.*)/ ) ) ) {       field = m[ 1 ].trim();      data = m[ 2 ].trim();      fn = _fieldFunctions[ field ];      if ( fn ) {        fn.call( headerObject, data );       } else {        headerObject[ field ] = data;       }      }     }     if ( ! headerObject.isNrrd ) {      throw new Error( 'Not an NRRD file' );     }     if ( headerObject.encoding === 'bz2' || headerObject.encoding === 'bzip2' ) {      throw new Error( 'Bzip is not supported' );     }     if ( ! headerObject.vectors ) {      //if no space direction is set, let's use the identity     headerObject.vectors = [ ];     headerObject.vectors.push( [ 1, 0, 0 ] );     headerObject.vectors.push( [ 0, 1, 0 ] );     headerObject.vectors.push( [ 0, 0, 1 ] );      //apply spacing if defined     if ( headerObject.spacings ) {       for ( i = 0; i <= 2; i ++ ) {        if ( ! isNaN( headerObject.spacings[ i ] ) ) {         for ( let j = 0; j <= 2; j ++ ) {          headerObject.vectors[ i ][ j ] *= headerObject.spacings[ i ];         }        }       }      }     }    }    //parse the data when registred as one of this type : 'text', 'ascii', 'txt'   function parseDataAsText( data, start, end ) {     let number = '';    start = start || 0;    end = end || data.length;    let value;    //length of the result is the product of the sizes    const lengthOfTheResult = headerObject.sizes.reduce( function ( previous, current ) {      return previous * current;     }, 1 );     let base = 10;    if ( headerObject.encoding === 'hex' ) {      base = 16;     }     const result = new headerObject.__array( lengthOfTheResult );    let resultIndex = 0;    let parsingFunction = parseInt;    if ( headerObject.__array === Float32Array || headerObject.__array === Float64Array ) {      parsingFunction = parseFloat;     }     for ( let i = start; i < end; i ++ ) {      value = data[ i ];     //if value is not a space     if ( ( value < 9 || value > 13 ) && value !== 32 ) {       number += String.fromCharCode( value );      } else {       if ( number !== '' ) {        result[ resultIndex ] = parsingFunction( number, base );       resultIndex ++;       }       number = '';      }     }     if ( number !== '' ) {      result[ resultIndex ] = parsingFunction( number, base );     resultIndex ++;     }     return result;    }    const _bytes = scan( 'uchar', data.byteLength );   const _length = _bytes.length;   let _header = null;   let _data_start = 0;   let i;   for ( i = 1; i < _length; i ++ ) {     if ( _bytes[ i - 1 ] == 10 && _bytes[ i ] == 10 ) {      // we found two line breaks in a row     // now we know what the header is     _header = this.parseChars( _bytes, 0, i - 2 );     // this is were the data starts     _data_start = i + 1;     break;     }    }    // parse the header   parseHeader( _header );    _data = _bytes.subarray( _data_start ); // the data without header   if ( headerObject.encoding.substring( 0, 2 ) === 'gz' ) {     // we need to decompress the datastream    // here we start the unzipping and get a typed Uint8Array back    _data = fflate.gunzipSync( new Uint8Array( _data ) );    } else if ( headerObject.encoding === 'ascii' || headerObject.encoding === 'text' || headerObject.encoding === 'txt' || headerObject.encoding === 'hex' ) {     _data = parseDataAsText( _data );    } else if ( headerObject.encoding === 'raw' ) {     //we need to copy the array to create a new array buffer, else we retrieve the original arraybuffer with the header    const _copy = new Uint8Array( _data.length );     for ( let i = 0; i < _data.length; i ++ ) {      _copy[ i ] = _data[ i ];     }     _data = _copy;    }    // .. let's use the underlying array buffer   _data = _data.buffer;    const volume = new Volume();   volume.header = headerObject;   volume.segmentation = this.segmentation;   //   // parse the (unzipped) data to a datastream of the correct type   //   volume.data = new headerObject.__array( _data );   // get the min and max intensities   const min_max = volume.computeMinMax();   const min = min_max[ 0 ];   const max = min_max[ 1 ];   // attach the scalar range to the volume   volume.windowLow = min;   volume.windowHigh = max;    // get the image dimensions   volume.dimensions = [ headerObject.sizes[ 0 ], headerObject.sizes[ 1 ], headerObject.sizes[ 2 ] ];   volume.xLength = volume.dimensions[ 0 ];   volume.yLength = volume.dimensions[ 1 ];   volume.zLength = volume.dimensions[ 2 ];    // Identify axis order in the space-directions matrix from the header if possible.   if ( headerObject.vectors ) {     const xIndex = headerObject.vectors.findIndex( vector => vector[ 0 ] !== 0 );    const yIndex = headerObject.vectors.findIndex( vector => vector[ 1 ] !== 0 );    const zIndex = headerObject.vectors.findIndex( vector => vector[ 2 ] !== 0 );     const axisOrder = [];     if ( xIndex !== yIndex && xIndex !== zIndex && yIndex !== zIndex ) {      axisOrder[ xIndex ] = 'x';     axisOrder[ yIndex ] = 'y';     axisOrder[ zIndex ] = 'z';     } else {      axisOrder[ 0 ] = 'x';     axisOrder[ 1 ] = 'y';     axisOrder[ 2 ] = 'z';     }     volume.axisOrder = axisOrder;    } else {     volume.axisOrder = [ 'x', 'y', 'z' ];    }    // spacing   const spacingX = new Vector3().fromArray( headerObject.vectors[ 0 ] ).length();   const spacingY = new Vector3().fromArray( headerObject.vectors[ 1 ] ).length();   const spacingZ = new Vector3().fromArray( headerObject.vectors[ 2 ] ).length();   volume.spacing = [ spacingX, spacingY, spacingZ ];     // Create IJKtoRAS matrix   volume.matrix = new Matrix4();    const transitionMatrix = new Matrix4();    if ( headerObject.space === 'left-posterior-superior' ) {     transitionMatrix.set(     - 1, 0, 0, 0,     0, - 1, 0, 0,     0, 0, 1, 0,     0, 0, 0, 1    );    } else if ( headerObject.space === 'left-anterior-superior' ) {     transitionMatrix.set(     1, 0, 0, 0,     0, 1, 0, 0,     0, 0, - 1, 0,     0, 0, 0, 1    );    }     if ( ! headerObject.vectors ) {     volume.matrix.set(     1, 0, 0, 0,     0, 1, 0, 0,     0, 0, 1, 0,     0, 0, 0, 1 );    } else {     const v = headerObject.vectors;     const ijk_to_transition = new Matrix4().set(     v[ 0 ][ 0 ], v[ 1 ][ 0 ], v[ 2 ][ 0 ], 0,     v[ 0 ][ 1 ], v[ 1 ][ 1 ], v[ 2 ][ 1 ], 0,     v[ 0 ][ 2 ], v[ 1 ][ 2 ], v[ 2 ][ 2 ], 0,     0, 0, 0, 1    );     const transition_to_ras = new Matrix4().multiplyMatrices( ijk_to_transition, transitionMatrix );     volume.matrix = transition_to_ras;    }    volume.inverseMatrix = new Matrix4();   volume.inverseMatrix.copy( volume.matrix ).invert();    volume.RASDimensions = [    Math.floor( volume.xLength * spacingX ),    Math.floor( volume.yLength * spacingY ),    Math.floor( volume.zLength * spacingZ )   ];    // .. and set the default threshold   // only if the threshold was not already set   if ( volume.lowerThreshold === - Infinity ) {     volume.lowerThreshold = min;    }    if ( volume.upperThreshold === Infinity ) {     volume.upperThreshold = max;    }    return volume;   }   parseChars( array, start, end ) {    // without borders, use the whole array   if ( start === undefined ) {     start = 0;    }    if ( end === undefined ) {     end = array.length;    }    let output = '';   // create and append the chars   let i = 0;   for ( i = start; i < end; ++ i ) {     output += String.fromCharCode( array[ i ] );    }    return output;   }  }  const _fieldFunctions = {   type: function ( data ) {    switch ( data ) {     case 'uchar':    case 'unsigned char':    case 'uint8':    case 'uint8_t':     this.__array = Uint8Array;     break;    case 'signed char':    case 'int8':    case 'int8_t':     this.__array = Int8Array;     break;    case 'short':    case 'short int':    case 'signed short':    case 'signed short int':    case 'int16':    case 'int16_t':     this.__array = Int16Array;     break;    case 'ushort':    case 'unsigned short':    case 'unsigned short int':    case 'uint16':    case 'uint16_t':     this.__array = Uint16Array;     break;    case 'int':    case 'signed int':    case 'int32':    case 'int32_t':     this.__array = Int32Array;     break;    case 'uint':    case 'unsigned int':    case 'uint32':    case 'uint32_t':     this.__array = Uint32Array;     break;    case 'float':     this.__array = Float32Array;     break;    case 'double':     this.__array = Float64Array;     break;    default:     throw new Error( 'Unsupported NRRD data type: ' + data );    }    return this.type = data;   },   endian: function ( data ) {    return this.endian = data;   },   encoding: function ( data ) {    return this.encoding = data;   },   dimension: function ( data ) {    return this.dim = parseInt( data, 10 );   },   sizes: function ( data ) {    let i;   return this.sizes = ( function () {     const _ref = data.split( /|s+/ );    const _results = [];     for ( let _i = 0, _len = _ref.length; _i < _len; _i ++ ) {      i = _ref[ _i ];     _results.push( parseInt( i, 10 ) );     }     return _results;    } )();   },   space: function ( data ) {    return this.space = data;   },   'space origin': function ( data ) {    return this.space_origin = data.split( '(' )[ 1 ].split( ')' )[ 0 ].split( ',' );   },   'space directions': function ( data ) {    let f, v;   const parts = data.match( /|(.*?|)/g );   return this.vectors = ( function () {     const _results = [];     for ( let _i = 0, _len = parts.length; _i < _len; _i ++ ) {      v = parts[ _i ];     _results.push( ( function () {       const _ref = v.slice( 1, - 1 ).split( /,/ );      const _results2 = [];       for ( let _j = 0, _len2 = _ref.length; _j < _len2; _j ++ ) {        f = _ref[ _j ];       _results2.push( parseFloat( f ) );       }       return _results2;      } )() );     }     return _results;    } )();   },   spacings: function ( data ) {    let f;   const parts = data.split( /|s+/ );   return this.spacings = ( function () {     const _results = [];     for ( let _i = 0, _len = parts.length; _i < _len; _i ++ ) {      f = parts[ _i ];     _results.push( parseFloat( f ) );     }     return _results;    } )();   }  };  export { NRRDLoader }; 
^..^ FILENAME ^..^
addons|loaders|OBJLoader.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  FileLoader,  Float32BufferAttribute,  Group,  LineBasicMaterial,  LineSegments,  Loader,  Material,  Mesh,  MeshPhongMaterial,  Points,  PointsMaterial,  Vector3,  Color,  SRGBColorSpace } from 'three';  // o object_name | g group_name const _object_pattern = /^[og]|s*(.+)?/; // mtllib file_reference const _material_library_pattern = /^mtllib /; // usemtl material_name const _material_use_pattern = /^usemtl /; // usemap map_name const _map_use_pattern = /^usemap /; const _face_vertex_data_separator_pattern = /|s+/;  const _vA = new Vector3(); const _vB = new Vector3(); const _vC = new Vector3();  const _ab = new Vector3(); const _cb = new Vector3();  const _color = new Color();  function ParserState() {   const state = {   objects: [],   object: {},    vertices: [],   normals: [],   colors: [],   uvs: [],    materials: {},   materialLibraries: [],    startObject: function ( name, fromDeclaration ) {     // If the current object (initial from reset) is not from a g/o declaration in the parsed    // file. We need to use it for the first parsed g/o to keep things in sync.    if ( this.object && this.object.fromDeclaration === false ) {      this.object.name = name;     this.object.fromDeclaration = ( fromDeclaration !== false );     return;     }     const previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );     if ( this.object && typeof this.object._finalize === 'function' ) {      this.object._finalize( true );     }     this.object = {     name: name || '',     fromDeclaration: ( fromDeclaration !== false ),      geometry: {      vertices: [],      normals: [],      colors: [],      uvs: [],      hasUVIndices: false     },     materials: [],     smooth: true,      startMaterial: function ( name, libraries ) {       const previous = this._finalize( false );       // New usemtl declaration overwrites an inherited material, except if faces were declared      // after the material, then it must be preserved for proper MultiMaterial continuation.      if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {        this.materials.splice( previous.index, 1 );       }       const material = {       index: this.materials.length,       name: name || '',       mtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),       smooth: ( previous !== undefined ? previous.smooth : this.smooth ),       groupStart: ( previous !== undefined ? previous.groupEnd : 0 ),       groupEnd: - 1,       groupCount: - 1,       inherited: false,        clone: function ( index ) {         const cloned = {         index: ( typeof index === 'number' ? index : this.index ),         name: this.name,         mtllib: this.mtllib,         smooth: this.smooth,         groupStart: 0,         groupEnd: - 1,         groupCount: - 1,         inherited: false        };        cloned.clone = this.clone.bind( cloned );        return cloned;        }      };       this.materials.push( material );       return material;      },      currentMaterial: function () {       if ( this.materials.length > 0 ) {        return this.materials[ this.materials.length - 1 ];       }       return undefined;      },      _finalize: function ( end ) {       const lastMultiMaterial = this.currentMaterial();      if ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {        lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;       lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;       lastMultiMaterial.inherited = false;       }       // Ignore objects tail materials if no face declarations followed them before a new o/g started.      if ( end && this.materials.length > 1 ) {        for ( let mi = this.materials.length - 1; mi >= 0; mi -- ) {         if ( this.materials[ mi ].groupCount <= 0 ) {          this.materials.splice( mi, 1 );         }        }       }       // Guarantee at least one empty material, this makes the creation later more straight forward.      if ( end && this.materials.length === 0 ) {        this.materials.push( {        name: '',        smooth: this.smooth       } );       }       return lastMultiMaterial;      }    };     // Inherit previous objects material.    // Spec tells us that a declared material must be set to all objects until a new material is declared.    // If a usemtl declaration is encountered while this new object is being parsed, it will    // overwrite the inherited material. Exception being that there was already face declarations    // to the inherited material, then it will be preserved for proper MultiMaterial continuation.     if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {      const declared = previousMaterial.clone( 0 );     declared.inherited = true;     this.object.materials.push( declared );     }     this.objects.push( this.object );    },    finalize: function () {     if ( this.object && typeof this.object._finalize === 'function' ) {      this.object._finalize( true );     }    },    parseVertexIndex: function ( value, len ) {     const index = parseInt( value, 10 );    return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;    },    parseNormalIndex: function ( value, len ) {     const index = parseInt( value, 10 );    return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;    },    parseUVIndex: function ( value, len ) {     const index = parseInt( value, 10 );    return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;    },    addVertex: function ( a, b, c ) {     const src = this.vertices;    const dst = this.object.geometry.vertices;     dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );    dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );    dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );    },    addVertexPoint: function ( a ) {     const src = this.vertices;    const dst = this.object.geometry.vertices;     dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );    },    addVertexLine: function ( a ) {     const src = this.vertices;    const dst = this.object.geometry.vertices;     dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );    },    addNormal: function ( a, b, c ) {     const src = this.normals;    const dst = this.object.geometry.normals;     dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );    dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );    dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );    },    addFaceNormal: function ( a, b, c ) {     const src = this.vertices;    const dst = this.object.geometry.normals;     _vA.fromArray( src, a );    _vB.fromArray( src, b );    _vC.fromArray( src, c );     _cb.subVectors( _vC, _vB );    _ab.subVectors( _vA, _vB );    _cb.cross( _ab );     _cb.normalize();     dst.push( _cb.x, _cb.y, _cb.z );    dst.push( _cb.x, _cb.y, _cb.z );    dst.push( _cb.x, _cb.y, _cb.z );    },    addColor: function ( a, b, c ) {     const src = this.colors;    const dst = this.object.geometry.colors;     if ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );    if ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );    if ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );    },    addUV: function ( a, b, c ) {     const src = this.uvs;    const dst = this.object.geometry.uvs;     dst.push( src[ a + 0 ], src[ a + 1 ] );    dst.push( src[ b + 0 ], src[ b + 1 ] );    dst.push( src[ c + 0 ], src[ c + 1 ] );    },    addDefaultUV: function () {     const dst = this.object.geometry.uvs;     dst.push( 0, 0 );    dst.push( 0, 0 );    dst.push( 0, 0 );    },    addUVLine: function ( a ) {     const src = this.uvs;    const dst = this.object.geometry.uvs;     dst.push( src[ a + 0 ], src[ a + 1 ] );    },    addFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {     const vLen = this.vertices.length;     let ia = this.parseVertexIndex( a, vLen );    let ib = this.parseVertexIndex( b, vLen );    let ic = this.parseVertexIndex( c, vLen );     this.addVertex( ia, ib, ic );    this.addColor( ia, ib, ic );     // normals     if ( na !== undefined && na !== '' ) {      const nLen = this.normals.length;      ia = this.parseNormalIndex( na, nLen );     ib = this.parseNormalIndex( nb, nLen );     ic = this.parseNormalIndex( nc, nLen );      this.addNormal( ia, ib, ic );     } else {      this.addFaceNormal( ia, ib, ic );     }     // uvs     if ( ua !== undefined && ua !== '' ) {      const uvLen = this.uvs.length;      ia = this.parseUVIndex( ua, uvLen );     ib = this.parseUVIndex( ub, uvLen );     ic = this.parseUVIndex( uc, uvLen );      this.addUV( ia, ib, ic );      this.object.geometry.hasUVIndices = true;     } else {      // add placeholder values (for inconsistent face definitions)      this.addDefaultUV();     }    },    addPointGeometry: function ( vertices ) {     this.object.geometry.type = 'Points';     const vLen = this.vertices.length;     for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {      const index = this.parseVertexIndex( vertices[ vi ], vLen );      this.addVertexPoint( index );     this.addColor( index );     }    },    addLineGeometry: function ( vertices, uvs ) {     this.object.geometry.type = 'Line';     const vLen = this.vertices.length;    const uvLen = this.uvs.length;     for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {      this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );     }     for ( let uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {      this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );     }    }   };   state.startObject( '', false );   return state;  }  //  class OBJLoader extends Loader {   constructor( manager ) {    super( manager );    this.materials = null;   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( this.manager );   loader.setPath( this.path );   loader.setRequestHeader( this.requestHeader );   loader.setWithCredentials( this.withCredentials );   loader.load( url, function ( text ) {     try {      onLoad( scope.parse( text ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   setMaterials( materials ) {    this.materials = materials;    return this;   }   parse( text ) {    const state = new ParserState();    if ( text.indexOf( '|r|n' ) !== - 1 ) {     // This is faster than String.split with regex that splits on both    text = text.replace( /|r|n/g, '|n' );    }    if ( text.indexOf( '|||n' ) !== - 1 ) {     // join lines separated by a line continuation character (|)    text = text.replace( /|||n/g, '' );    }    const lines = text.split( '|n' );   let result = [];    for ( let i = 0, l = lines.length; i < l; i ++ ) {     const line = lines[ i ].trimStart();     if ( line.length === 0 ) continue;     const lineFirstChar = line.charAt( 0 );     // @todo invoke passed in handler if any    if ( lineFirstChar === '#' ) continue; // skip comments     if ( lineFirstChar === 'v' ) {      const data = line.split( _face_vertex_data_separator_pattern );      switch ( data[ 0 ] ) {       case 'v':       state.vertices.push(        parseFloat( data[ 1 ] ),        parseFloat( data[ 2 ] ),        parseFloat( data[ 3 ] )       );       if ( data.length >= 7 ) {         _color.setRGB(         parseFloat( data[ 4 ] ),         parseFloat( data[ 5 ] ),         parseFloat( data[ 6 ] ),         SRGBColorSpace        );         state.colors.push( _color.r, _color.g, _color.b );        } else {         // if no colors are defined, add placeholders so color and vertex indices match         state.colors.push( undefined, undefined, undefined );        }        break;      case 'vn':       state.normals.push(        parseFloat( data[ 1 ] ),        parseFloat( data[ 2 ] ),        parseFloat( data[ 3 ] )       );       break;      case 'vt':       state.uvs.push(        parseFloat( data[ 1 ] ),        parseFloat( data[ 2 ] )       );       break;      }     } else if ( lineFirstChar === 'f' ) {      const lineData = line.slice( 1 ).trim();     const vertexData = lineData.split( _face_vertex_data_separator_pattern );     const faceVertices = [];      // Parse the face vertex data into an easy to work with format      for ( let j = 0, jl = vertexData.length; j < jl; j ++ ) {       const vertex = vertexData[ j ];       if ( vertex.length > 0 ) {        const vertexParts = vertex.split( '/' );       faceVertices.push( vertexParts );       }      }      // Draw an edge between the first vertex and all subsequent vertices to form an n-gon      const v1 = faceVertices[ 0 ];      for ( let j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {       const v2 = faceVertices[ j ];      const v3 = faceVertices[ j + 1 ];       state.addFace(       v1[ 0 ], v2[ 0 ], v3[ 0 ],       v1[ 1 ], v2[ 1 ], v3[ 1 ],       v1[ 2 ], v2[ 2 ], v3[ 2 ]      );      }     } else if ( lineFirstChar === 'l' ) {      const lineParts = line.substring( 1 ).trim().split( ' ' );     let lineVertices = [];     const lineUVs = [];      if ( line.indexOf( '/' ) === - 1 ) {       lineVertices = lineParts;      } else {       for ( let li = 0, llen = lineParts.length; li < llen; li ++ ) {        const parts = lineParts[ li ].split( '/' );        if ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] );       if ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] );       }      }      state.addLineGeometry( lineVertices, lineUVs );     } else if ( lineFirstChar === 'p' ) {      const lineData = line.slice( 1 ).trim();     const pointData = lineData.split( ' ' );      state.addPointGeometry( pointData );     } else if ( ( result = _object_pattern.exec( line ) ) !== null ) {      // o object_name     // or     // g group_name      // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869     // let name = result[ 0 ].slice( 1 ).trim();     const name = ( ' ' + result[ 0 ].slice( 1 ).trim() ).slice( 1 );      state.startObject( name );     } else if ( _material_use_pattern.test( line ) ) {      // material      state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );     } else if ( _material_library_pattern.test( line ) ) {      // mtl file      state.materialLibraries.push( line.substring( 7 ).trim() );     } else if ( _map_use_pattern.test( line ) ) {      // the line is parsed but ignored since the loader assumes textures are defined MTL files     // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)      console.warn( 'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.' );     } else if ( lineFirstChar === 's' ) {      result = line.split( ' ' );      // smooth shading      // @todo Handle files that have varying smooth values for a set of faces inside one geometry,     // but does not define a usemtl for each face set.     // This should be detected and a dummy material created (later MultiMaterial and geometry groups).     // This requires some care to not create extra material on each smooth value for "normal" obj files.     // where explicit usemtl defines geometry groups.     // Example asset: examples/models/obj/cerberus/Cerberus.obj      /*       * http://paulbourke.net/dataformats/obj/       *       * From chapter "Grouping" Syntax explanation "s group_number":       * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.       * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form       * surfaces, smoothing groups are either turned on or off; there is no difference between values greater       * than 0."       */     if ( result.length > 1 ) {       const value = result[ 1 ].trim().toLowerCase();      state.object.smooth = ( value !== '0' && value !== 'off' );      } else {       // ZBrush can produce "s" lines #11707      state.object.smooth = true;      }      const material = state.object.currentMaterial();     if ( material ) material.smooth = state.object.smooth;     } else {      // Handle null terminated files without exception     if ( line === '|0' ) continue;      console.warn( 'THREE.OBJLoader: Unexpected line: "' + line + '"' );     }    }    state.finalize();    const container = new Group();   container.materialLibraries = [].concat( state.materialLibraries );    const hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );    if ( hasPrimitives === true ) {     for ( let i = 0, l = state.objects.length; i < l; i ++ ) {      const object = state.objects[ i ];     const geometry = object.geometry;     const materials = object.materials;     const isLine = ( geometry.type === 'Line' );     const isPoints = ( geometry.type === 'Points' );     let hasVertexColors = false;      // Skip o/g line declarations that did not follow with any faces     if ( geometry.vertices.length === 0 ) continue;      const buffergeometry = new BufferGeometry();      buffergeometry.setAttribute( 'position', new Float32BufferAttribute( geometry.vertices, 3 ) );      if ( geometry.normals.length > 0 ) {       buffergeometry.setAttribute( 'normal', new Float32BufferAttribute( geometry.normals, 3 ) );      }      if ( geometry.colors.length > 0 ) {       hasVertexColors = true;      buffergeometry.setAttribute( 'color', new Float32BufferAttribute( geometry.colors, 3 ) );      }      if ( geometry.hasUVIndices === true ) {       buffergeometry.setAttribute( 'uv', new Float32BufferAttribute( geometry.uvs, 2 ) );      }      // Create materials      const createdMaterials = [];      for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {       const sourceMaterial = materials[ mi ];      const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;      let material = state.materials[ materialHash ];       if ( this.materials !== null ) {        material = this.materials.create( sourceMaterial.name );        // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.       if ( isLine && material && ! ( material instanceof LineBasicMaterial ) ) {         const materialLine = new LineBasicMaterial();        Material.prototype.copy.call( materialLine, material );        materialLine.color.copy( material.color );        material = materialLine;        } else if ( isPoints && material && ! ( material instanceof PointsMaterial ) ) {         const materialPoints = new PointsMaterial( { size: 10, sizeAttenuation: false } );        Material.prototype.copy.call( materialPoints, material );        materialPoints.color.copy( material.color );        materialPoints.map = material.map;        material = materialPoints;        }       }       if ( material === undefined ) {        if ( isLine ) {         material = new LineBasicMaterial();        } else if ( isPoints ) {         material = new PointsMaterial( { size: 1, sizeAttenuation: false } );        } else {         material = new MeshPhongMaterial();        }        material.name = sourceMaterial.name;       material.flatShading = sourceMaterial.smooth ? false : true;       material.vertexColors = hasVertexColors;        state.materials[ materialHash ] = material;       }       createdMaterials.push( material );      }      // Create mesh      let mesh;      if ( createdMaterials.length > 1 ) {       for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {        const sourceMaterial = materials[ mi ];       buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );       }       if ( isLine ) {        mesh = new LineSegments( buffergeometry, createdMaterials );       } else if ( isPoints ) {        mesh = new Points( buffergeometry, createdMaterials );       } else {        mesh = new Mesh( buffergeometry, createdMaterials );       }      } else {       if ( isLine ) {        mesh = new LineSegments( buffergeometry, createdMaterials[ 0 ] );       } else if ( isPoints ) {        mesh = new Points( buffergeometry, createdMaterials[ 0 ] );       } else {        mesh = new Mesh( buffergeometry, createdMaterials[ 0 ] );       }      }      mesh.name = object.name;      container.add( mesh );     }    } else {     // if there is only the default parser state object with no geometry data, interpret data as point cloud     if ( state.vertices.length > 0 ) {      const material = new PointsMaterial( { size: 1, sizeAttenuation: false } );      const buffergeometry = new BufferGeometry();      buffergeometry.setAttribute( 'position', new Float32BufferAttribute( state.vertices, 3 ) );      if ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {       buffergeometry.setAttribute( 'color', new Float32BufferAttribute( state.colors, 3 ) );      material.vertexColors = true;      }      const points = new Points( buffergeometry, material );     container.add( points );     }    }    return container;   }  }  export { OBJLoader }; 
^..^ FILENAME ^..^
addons|loaders|PCDLoader.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  Color,  FileLoader,  Float32BufferAttribute,  Int32BufferAttribute,  Loader,  Points,  PointsMaterial,  SRGBColorSpace } from 'three';  class PCDLoader extends Loader {   constructor( manager ) {    super( manager );    this.littleEndian = true;   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( scope.manager );   loader.setPath( scope.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( scope.requestHeader );   loader.setWithCredentials( scope.withCredentials );   loader.load( url, function ( data ) {     try {      onLoad( scope.parse( data ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( data ) {    // from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js    function decompressLZF( inData, outLength ) {     const inLength = inData.length;    const outData = new Uint8Array( outLength );    let inPtr = 0;    let outPtr = 0;    let ctrl;    let len;    let ref;    do {      ctrl = inData[ inPtr ++ ];     if ( ctrl < ( 1 << 5 ) ) {       ctrl ++;      if ( outPtr + ctrl > outLength ) throw new Error( 'Output buffer is not large enough' );      if ( inPtr + ctrl > inLength ) throw new Error( 'Invalid compressed data' );      do {        outData[ outPtr ++ ] = inData[ inPtr ++ ];       } while ( -- ctrl );      } else {       len = ctrl >> 5;      ref = outPtr - ( ( ctrl & 0x1f ) << 8 ) - 1;      if ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );      if ( len === 7 ) {        len += inData[ inPtr ++ ];       if ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );       }       ref -= inData[ inPtr ++ ];      if ( outPtr + len + 2 > outLength ) throw new Error( 'Output buffer is not large enough' );      if ( ref < 0 ) throw new Error( 'Invalid compressed data' );      if ( ref >= outPtr ) throw new Error( 'Invalid compressed data' );      do {        outData[ outPtr ++ ] = outData[ ref ++ ];       } while ( -- len + 2 );      }     } while ( inPtr < inLength );     return outData;    }    function parseHeader( data ) {     const PCDheader = {};    const result1 = data.search( /[|r|n]DATA|s(|S*)|s/i );    const result2 = /[|r|n]DATA|s(|S*)|s/i.exec( data.slice( result1 - 1 ) );     PCDheader.data = result2[ 1 ];    PCDheader.headerLen = result2[ 0 ].length + result1;    PCDheader.str = data.slice( 0, PCDheader.headerLen );     // remove comments     PCDheader.str = PCDheader.str.replace( /#.*/gi, '' );     // parse     PCDheader.version = /^VERSION (.*)/im.exec( PCDheader.str );    PCDheader.fields = /^FIELDS (.*)/im.exec( PCDheader.str );    PCDheader.size = /^SIZE (.*)/im.exec( PCDheader.str );    PCDheader.type = /^TYPE (.*)/im.exec( PCDheader.str );    PCDheader.count = /^COUNT (.*)/im.exec( PCDheader.str );    PCDheader.width = /^WIDTH (.*)/im.exec( PCDheader.str );    PCDheader.height = /^HEIGHT (.*)/im.exec( PCDheader.str );    PCDheader.viewpoint = /^VIEWPOINT (.*)/im.exec( PCDheader.str );    PCDheader.points = /^POINTS (.*)/im.exec( PCDheader.str );     // evaluate     if ( PCDheader.version !== null )     PCDheader.version = parseFloat( PCDheader.version[ 1 ] );     PCDheader.fields = ( PCDheader.fields !== null ) ? PCDheader.fields[ 1 ].split( ' ' ) : [];     if ( PCDheader.type !== null )     PCDheader.type = PCDheader.type[ 1 ].split( ' ' );     if ( PCDheader.width !== null )     PCDheader.width = parseInt( PCDheader.width[ 1 ] );     if ( PCDheader.height !== null )     PCDheader.height = parseInt( PCDheader.height[ 1 ] );     if ( PCDheader.viewpoint !== null )     PCDheader.viewpoint = PCDheader.viewpoint[ 1 ];     if ( PCDheader.points !== null )     PCDheader.points = parseInt( PCDheader.points[ 1 ], 10 );     if ( PCDheader.points === null )     PCDheader.points = PCDheader.width * PCDheader.height;     if ( PCDheader.size !== null ) {      PCDheader.size = PCDheader.size[ 1 ].split( ' ' ).map( function ( x ) {       return parseInt( x, 10 );      } );     }     if ( PCDheader.count !== null ) {      PCDheader.count = PCDheader.count[ 1 ].split( ' ' ).map( function ( x ) {       return parseInt( x, 10 );      } );     } else {      PCDheader.count = [];      for ( let i = 0, l = PCDheader.fields.length; i < l; i ++ ) {       PCDheader.count.push( 1 );      }     }     PCDheader.offset = {};     let sizeSum = 0;     for ( let i = 0, l = PCDheader.fields.length; i < l; i ++ ) {      if ( PCDheader.data === 'ascii' ) {       PCDheader.offset[ PCDheader.fields[ i ] ] = i;      } else {       PCDheader.offset[ PCDheader.fields[ i ] ] = sizeSum;      sizeSum += PCDheader.size[ i ] * PCDheader.count[ i ];      }     }     // for binary only     PCDheader.rowSize = sizeSum;     return PCDheader;    }    const textData = new TextDecoder().decode( data );    // parse header (always ascii format)    const PCDheader = parseHeader( textData );    // parse data    const position = [];   const normal = [];   const color = [];   const intensity = [];   const label = [];    const c = new Color();    // ascii    if ( PCDheader.data === 'ascii' ) {     const offset = PCDheader.offset;    const pcdData = textData.slice( PCDheader.headerLen );    const lines = pcdData.split( '|n' );     for ( let i = 0, l = lines.length; i < l; i ++ ) {      if ( lines[ i ] === '' ) continue;      const line = lines[ i ].split( ' ' );      if ( offset.x !== undefined ) {       position.push( parseFloat( line[ offset.x ] ) );      position.push( parseFloat( line[ offset.y ] ) );      position.push( parseFloat( line[ offset.z ] ) );      }      if ( offset.rgb !== undefined ) {       const rgb_field_index = PCDheader.fields.findIndex( ( field ) => field === 'rgb' );      const rgb_type = PCDheader.type[ rgb_field_index ];       const float = parseFloat( line[ offset.rgb ] );      let rgb = float;       if ( rgb_type === 'F' ) {        // treat float values as int       // https://github.com/daavoo/pyntcloud/pull/204/commits/7b4205e64d5ed09abe708b2e91b615690c24d518       const farr = new Float32Array( 1 );       farr[ 0 ] = float;       rgb = new Int32Array( farr.buffer )[ 0 ];       }       const r = ( ( rgb >> 16 ) & 0x0000ff ) / 255;      const g = ( ( rgb >> 8 ) & 0x0000ff ) / 255;      const b = ( ( rgb >> 0 ) & 0x0000ff ) / 255;       c.setRGB( r, g, b, SRGBColorSpace );       color.push( c.r, c.g, c.b );      }      if ( offset.normal_x !== undefined ) {       normal.push( parseFloat( line[ offset.normal_x ] ) );      normal.push( parseFloat( line[ offset.normal_y ] ) );      normal.push( parseFloat( line[ offset.normal_z ] ) );      }      if ( offset.intensity !== undefined ) {       intensity.push( parseFloat( line[ offset.intensity ] ) );      }      if ( offset.label !== undefined ) {       label.push( parseInt( line[ offset.label ] ) );      }     }    }    // binary-compressed    // normally data in PCD files are organized as array of structures: XYZRGBXYZRGB   // binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB   // that requires a totally different parsing approach compared to non-compressed data    if ( PCDheader.data === 'binary_compressed' ) {     const sizes = new Uint32Array( data.slice( PCDheader.headerLen, PCDheader.headerLen + 8 ) );    const compressedSize = sizes[ 0 ];    const decompressedSize = sizes[ 1 ];    const decompressed = decompressLZF( new Uint8Array( data, PCDheader.headerLen + 8, compressedSize ), decompressedSize );    const dataview = new DataView( decompressed.buffer );     const offset = PCDheader.offset;     for ( let i = 0; i < PCDheader.points; i ++ ) {      if ( offset.x !== undefined ) {       const xIndex = PCDheader.fields.indexOf( 'x' );      const yIndex = PCDheader.fields.indexOf( 'y' );      const zIndex = PCDheader.fields.indexOf( 'z' );      position.push( dataview.getFloat32( ( PCDheader.points * offset.x ) + PCDheader.size[ xIndex ] * i, this.littleEndian ) );      position.push( dataview.getFloat32( ( PCDheader.points * offset.y ) + PCDheader.size[ yIndex ] * i, this.littleEndian ) );      position.push( dataview.getFloat32( ( PCDheader.points * offset.z ) + PCDheader.size[ zIndex ] * i, this.littleEndian ) );      }      if ( offset.rgb !== undefined ) {       const rgbIndex = PCDheader.fields.indexOf( 'rgb' );       const r = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 2 ) / 255.0;      const g = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 1 ) / 255.0;      const b = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 0 ) / 255.0;       c.setRGB( r, g, b, SRGBColorSpace );       color.push( c.r, c.g, c.b );      }      if ( offset.normal_x !== undefined ) {       const xIndex = PCDheader.fields.indexOf( 'normal_x' );      const yIndex = PCDheader.fields.indexOf( 'normal_y' );      const zIndex = PCDheader.fields.indexOf( 'normal_z' );      normal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_x ) + PCDheader.size[ xIndex ] * i, this.littleEndian ) );      normal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_y ) + PCDheader.size[ yIndex ] * i, this.littleEndian ) );      normal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_z ) + PCDheader.size[ zIndex ] * i, this.littleEndian ) );      }      if ( offset.intensity !== undefined ) {       const intensityIndex = PCDheader.fields.indexOf( 'intensity' );      intensity.push( dataview.getFloat32( ( PCDheader.points * offset.intensity ) + PCDheader.size[ intensityIndex ] * i, this.littleEndian ) );      }      if ( offset.label !== undefined ) {       const labelIndex = PCDheader.fields.indexOf( 'label' );      label.push( dataview.getInt32( ( PCDheader.points * offset.label ) + PCDheader.size[ labelIndex ] * i, this.littleEndian ) );      }     }    }    // binary    if ( PCDheader.data === 'binary' ) {     const dataview = new DataView( data, PCDheader.headerLen );    const offset = PCDheader.offset;     for ( let i = 0, row = 0; i < PCDheader.points; i ++, row += PCDheader.rowSize ) {      if ( offset.x !== undefined ) {       position.push( dataview.getFloat32( row + offset.x, this.littleEndian ) );      position.push( dataview.getFloat32( row + offset.y, this.littleEndian ) );      position.push( dataview.getFloat32( row + offset.z, this.littleEndian ) );      }      if ( offset.rgb !== undefined ) {       const r = dataview.getUint8( row + offset.rgb + 2 ) / 255.0;      const g = dataview.getUint8( row + offset.rgb + 1 ) / 255.0;      const b = dataview.getUint8( row + offset.rgb + 0 ) / 255.0;       c.setRGB( r, g, b, SRGBColorSpace );       color.push( c.r, c.g, c.b );      }      if ( offset.normal_x !== undefined ) {       normal.push( dataview.getFloat32( row + offset.normal_x, this.littleEndian ) );      normal.push( dataview.getFloat32( row + offset.normal_y, this.littleEndian ) );      normal.push( dataview.getFloat32( row + offset.normal_z, this.littleEndian ) );      }      if ( offset.intensity !== undefined ) {       intensity.push( dataview.getFloat32( row + offset.intensity, this.littleEndian ) );      }      if ( offset.label !== undefined ) {       label.push( dataview.getInt32( row + offset.label, this.littleEndian ) );      }     }    }    // build geometry    const geometry = new BufferGeometry();    if ( position.length > 0 ) geometry.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );   if ( normal.length > 0 ) geometry.setAttribute( 'normal', new Float32BufferAttribute( normal, 3 ) );   if ( color.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( color, 3 ) );   if ( intensity.length > 0 ) geometry.setAttribute( 'intensity', new Float32BufferAttribute( intensity, 1 ) );   if ( label.length > 0 ) geometry.setAttribute( 'label', new Int32BufferAttribute( label, 1 ) );    geometry.computeBoundingSphere();    // build material    const material = new PointsMaterial( { size: 0.005 } );    if ( color.length > 0 ) {     material.vertexColors = true;    }    // build point cloud    return new Points( geometry, material );   }  }  export { PCDLoader }; 
^..^ FILENAME ^..^
addons|loaders|PDBLoader.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  FileLoader,  Float32BufferAttribute,  Loader,  Color,  SRGBColorSpace } from 'three';  class PDBLoader extends Loader {   constructor( manager ) {    super( manager );   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( scope.manager );   loader.setPath( scope.path );   loader.setRequestHeader( scope.requestHeader );   loader.setWithCredentials( scope.withCredentials );   loader.load( url, function ( text ) {     try {      onLoad( scope.parse( text ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   // Based on CanvasMol PDB parser   parse( text ) {    function trim( text ) {     return text.replace( /^|s|s*/, '' ).replace( /|s|s*$/, '' );    }    function capitalize( text ) {     return text.charAt( 0 ).toUpperCase() + text.slice( 1 ).toLowerCase();    }    function hash( s, e ) {     return 's' + Math.min( s, e ) + 'e' + Math.max( s, e );    }    function parseBond( start, length, satom, i ) {     const eatom = parseInt( lines[ i ].slice( start, start + length ) );     if ( eatom ) {      const h = hash( satom, eatom );      if ( _bhash[ h ] === undefined ) {       _bonds.push( [ satom - 1, eatom - 1, 1 ] );      _bhash[ h ] = _bonds.length - 1;      } else {       // doesn't really work as almost all PDBs      // have just normal bonds appearing multiple      // times instead of being double/triple bonds      // bonds[bhash[h]][2] += 1;      }     }    }    function buildGeometry() {     const build = {     geometryAtoms: new BufferGeometry(),     geometryBonds: new BufferGeometry(),     json: {      atoms: atoms     }    };     const geometryAtoms = build.geometryAtoms;    const geometryBonds = build.geometryBonds;     const verticesAtoms = [];    const colorsAtoms = [];    const verticesBonds = [];     // atoms     const c = new Color();     for ( let i = 0, l = atoms.length; i < l; i ++ ) {      const atom = atoms[ i ];      const x = atom[ 0 ];     const y = atom[ 1 ];     const z = atom[ 2 ];      verticesAtoms.push( x, y, z );      const r = atom[ 3 ][ 0 ] / 255;     const g = atom[ 3 ][ 1 ] / 255;     const b = atom[ 3 ][ 2 ] / 255;      c.setRGB( r, g, b, SRGBColorSpace );      colorsAtoms.push( c.r, c.g, c.b );     }     // bonds     for ( let i = 0, l = _bonds.length; i < l; i ++ ) {      const bond = _bonds[ i ];      const start = bond[ 0 ];     const end = bond[ 1 ];      const startAtom = _atomMap[ start ];     const endAtom = _atomMap[ end ];      let x = startAtom[ 0 ];     let y = startAtom[ 1 ];     let z = startAtom[ 2 ];      verticesBonds.push( x, y, z );      x = endAtom[ 0 ];     y = endAtom[ 1 ];     z = endAtom[ 2 ];      verticesBonds.push( x, y, z );     }     // build geometry     geometryAtoms.setAttribute( 'position', new Float32BufferAttribute( verticesAtoms, 3 ) );    geometryAtoms.setAttribute( 'color', new Float32BufferAttribute( colorsAtoms, 3 ) );     geometryBonds.setAttribute( 'position', new Float32BufferAttribute( verticesBonds, 3 ) );     return build;    }    const CPK = { h: [ 255, 255, 255 ], he: [ 217, 255, 255 ], li: [ 204, 128, 255 ], be: [ 194, 255, 0 ], b: [ 255, 181, 181 ], c: [ 144, 144, 144 ], n: [ 48, 80, 248 ], o: [ 255, 13, 13 ], f: [ 144, 224, 80 ], ne: [ 179, 227, 245 ], na: [ 171, 92, 242 ], mg: [ 138, 255, 0 ], al: [ 191, 166, 166 ], si: [ 240, 200, 160 ], p: [ 255, 128, 0 ], s: [ 255, 255, 48 ], cl: [ 31, 240, 31 ], ar: [ 128, 209, 227 ], k: [ 143, 64, 212 ], ca: [ 61, 255, 0 ], sc: [ 230, 230, 230 ], ti: [ 191, 194, 199 ], v: [ 166, 166, 171 ], cr: [ 138, 153, 199 ], mn: [ 156, 122, 199 ], fe: [ 224, 102, 51 ], co: [ 240, 144, 160 ], ni: [ 80, 208, 80 ], cu: [ 200, 128, 51 ], zn: [ 125, 128, 176 ], ga: [ 194, 143, 143 ], ge: [ 102, 143, 143 ], as: [ 189, 128, 227 ], se: [ 255, 161, 0 ], br: [ 166, 41, 41 ], kr: [ 92, 184, 209 ], rb: [ 112, 46, 176 ], sr: [ 0, 255, 0 ], y: [ 148, 255, 255 ], zr: [ 148, 224, 224 ], nb: [ 115, 194, 201 ], mo: [ 84, 181, 181 ], tc: [ 59, 158, 158 ], ru: [ 36, 143, 143 ], rh: [ 10, 125, 140 ], pd: [ 0, 105, 133 ], ag: [ 192, 192, 192 ], cd: [ 255, 217, 143 ], in: [ 166, 117, 115 ], sn: [ 102, 128, 128 ], sb: [ 158, 99, 181 ], te: [ 212, 122, 0 ], i: [ 148, 0, 148 ], xe: [ 66, 158, 176 ], cs: [ 87, 23, 143 ], ba: [ 0, 201, 0 ], la: [ 112, 212, 255 ], ce: [ 255, 255, 199 ], pr: [ 217, 255, 199 ], nd: [ 199, 255, 199 ], pm: [ 163, 255, 199 ], sm: [ 143, 255, 199 ], eu: [ 97, 255, 199 ], gd: [ 69, 255, 199 ], tb: [ 48, 255, 199 ], dy: [ 31, 255, 199 ], ho: [ 0, 255, 156 ], er: [ 0, 230, 117 ], tm: [ 0, 212, 82 ], yb: [ 0, 191, 56 ], lu: [ 0, 171, 36 ], hf: [ 77, 194, 255 ], ta: [ 77, 166, 255 ], w: [ 33, 148, 214 ], re: [ 38, 125, 171 ], os: [ 38, 102, 150 ], ir: [ 23, 84, 135 ], pt: [ 208, 208, 224 ], au: [ 255, 209, 35 ], hg: [ 184, 184, 208 ], tl: [ 166, 84, 77 ], pb: [ 87, 89, 97 ], bi: [ 158, 79, 181 ], po: [ 171, 92, 0 ], at: [ 117, 79, 69 ], rn: [ 66, 130, 150 ], fr: [ 66, 0, 102 ], ra: [ 0, 125, 0 ], ac: [ 112, 171, 250 ], th: [ 0, 186, 255 ], pa: [ 0, 161, 255 ], u: [ 0, 143, 255 ], np: [ 0, 128, 255 ], pu: [ 0, 107, 255 ], am: [ 84, 92, 242 ], cm: [ 120, 92, 227 ], bk: [ 138, 79, 227 ], cf: [ 161, 54, 212 ], es: [ 179, 31, 212 ], fm: [ 179, 31, 186 ], md: [ 179, 13, 166 ], no: [ 189, 13, 135 ], lr: [ 199, 0, 102 ], rf: [ 204, 0, 89 ], db: [ 209, 0, 79 ], sg: [ 217, 0, 69 ], bh: [ 224, 0, 56 ], hs: [ 230, 0, 46 ], mt: [ 235, 0, 38 ], ds: [ 235, 0, 38 ], rg: [ 235, 0, 38 ], cn: [ 235, 0, 38 ], uut: [ 235, 0, 38 ], uuq: [ 235, 0, 38 ], uup: [ 235, 0, 38 ], uuh: [ 235, 0, 38 ], uus: [ 235, 0, 38 ], uuo: [ 235, 0, 38 ] };    const atoms = [];    const _bonds = [];   const _bhash = {};   const _atomMap = {};    // parse    const lines = text.split( '|n' );    for ( let i = 0, l = lines.length; i < l; i ++ ) {     if ( lines[ i ].slice( 0, 4 ) === 'ATOM' || lines[ i ].slice( 0, 6 ) === 'HETATM' ) {      const x = parseFloat( lines[ i ].slice( 30, 37 ) );     const y = parseFloat( lines[ i ].slice( 38, 45 ) );     const z = parseFloat( lines[ i ].slice( 46, 53 ) );     const index = parseInt( lines[ i ].slice( 6, 11 ) ) - 1;      let e = trim( lines[ i ].slice( 76, 78 ) ).toLowerCase();      if ( e === '' ) {       e = trim( lines[ i ].slice( 12, 14 ) ).toLowerCase();      }      const atomData = [ x, y, z, CPK[ e ], capitalize( e ) ];      atoms.push( atomData );     _atomMap[ index ] = atomData;     } else if ( lines[ i ].slice( 0, 6 ) === 'CONECT' ) {      const satom = parseInt( lines[ i ].slice( 6, 11 ) );      parseBond( 11, 5, satom, i );     parseBond( 16, 5, satom, i );     parseBond( 21, 5, satom, i );     parseBond( 26, 5, satom, i );     }    }    // build and return geometry    return buildGeometry();   }  }  export { PDBLoader }; 
^..^ FILENAME ^..^
addons|loaders|PLYLoader.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  FileLoader,  Float32BufferAttribute,  Loader,  Color,  SRGBColorSpace } from 'three';  /**  * Description: A THREE loader for PLY ASCII files (known as the Polygon  * File Format or the Stanford Triangle Format).  *  * Limitations: ASCII decoding assumes file is UTF-8.  *  * Usage:  * const loader = new PLYLoader();  * loader.load('./models/ply/ascii/dolphins.ply', function (geometry) {  *  *  scene.add( new THREE.Mesh( geometry ) );  *  * } );  *  * If the PLY file uses non standard property names, they can be mapped while  * loading. For example, the following maps the properties  * ??diffuse_(red|green|blue)?? in the file to standard color names.  *  * loader.setPropertyNameMapping( {  * diffuse_red: 'red',  * diffuse_green: 'green',  * diffuse_blue: 'blue'  * } );  *  * Custom properties outside of the defaults for position, uv, normal  * and color attributes can be added using the setCustomPropertyNameMapping method.  * For example, the following maps the element properties ??custom_property_a??  * and ??custom_property_b?? to an attribute ??customAttribute?? with an item size of 2.  * Attribute item sizes are set from the number of element properties in the property array.  *  * loader.setCustomPropertyNameMapping( {  * customAttribute: ['custom_property_a', 'custom_property_b'],  * } );  *  */  const _color = new Color();  class PLYLoader extends Loader {   constructor( manager ) {    super( manager );    this.propertyNameMapping = {};   this.customPropertyMapping = {};   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( this.manager );   loader.setPath( this.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( this.requestHeader );   loader.setWithCredentials( this.withCredentials );   loader.load( url, function ( text ) {     try {      onLoad( scope.parse( text ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   setPropertyNameMapping( mapping ) {    this.propertyNameMapping = mapping;   }   setCustomPropertyNameMapping( mapping ) {    this.customPropertyMapping = mapping;   }   parse( data ) {    function parseHeader( data, headerLength = 0 ) {     const patternHeader = /^ply([|s|S]*)end_header(|r|n||r||n)/;    let headerText = '';    const result = patternHeader.exec( data );     if ( result !== null ) {      headerText = result[ 1 ];     }     const header = {     comments: [],     elements: [],     headerLength: headerLength,     objInfo: ''    };     const lines = headerText.split( /|r|n||r||n/ );    let currentElement;     function make_ply_element_property( propertValues, propertyNameMapping ) {      const property = { type: propertValues[ 0 ] };      if ( property.type === 'list' ) {       property.name = propertValues[ 3 ];      property.countType = propertValues[ 1 ];      property.itemType = propertValues[ 2 ];      } else {       property.name = propertValues[ 1 ];      }      if ( property.name in propertyNameMapping ) {       property.name = propertyNameMapping[ property.name ];      }      return property;     }     for ( let i = 0; i < lines.length; i ++ ) {      let line = lines[ i ];     line = line.trim();      if ( line === '' ) continue;      const lineValues = line.split( /|s+/ );     const lineType = lineValues.shift();     line = lineValues.join( ' ' );      switch ( lineType ) {       case 'format':        header.format = lineValues[ 0 ];       header.version = lineValues[ 1 ];        break;       case 'comment':        header.comments.push( line );        break;       case 'element':        if ( currentElement !== undefined ) {         header.elements.push( currentElement );        }        currentElement = {};       currentElement.name = lineValues[ 0 ];       currentElement.count = parseInt( lineValues[ 1 ] );       currentElement.properties = [];        break;       case 'property':        currentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) );        break;       case 'obj_info':        header.objInfo = line;        break;        default:        console.log( 'unhandled', lineType, lineValues );      }     }     if ( currentElement !== undefined ) {      header.elements.push( currentElement );     }     return header;    }    function parseASCIINumber( n, type ) {     switch ( type ) {      case 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':     case 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':       return parseInt( n );      case 'float': case 'double': case 'float32': case 'float64':       return parseFloat( n );     }    }    function parseASCIIElement( properties, tokens ) {     const element = {};     for ( let i = 0; i < properties.length; i ++ ) {      if ( tokens.empty() ) return null;      if ( properties[ i ].type === 'list' ) {       const list = [];      const n = parseASCIINumber( tokens.next(), properties[ i ].countType );       for ( let j = 0; j < n; j ++ ) {        if ( tokens.empty() ) return null;        list.push( parseASCIINumber( tokens.next(), properties[ i ].itemType ) );       }       element[ properties[ i ].name ] = list;      } else {       element[ properties[ i ].name ] = parseASCIINumber( tokens.next(), properties[ i ].type );      }     }     return element;    }    function createBuffer() {     const buffer = {      indices: [],      vertices: [],      normals: [],      uvs: [],      faceVertexUvs: [],      colors: [],      faceVertexColors: []    };     for ( const customProperty of Object.keys( scope.customPropertyMapping ) ) {       buffer[ customProperty ] = [];     }     return buffer;    }    function mapElementAttributes( properties ) {     const elementNames = properties.map( property => {      return property.name;     } );     function findAttrName( names ) {      for ( let i = 0, l = names.length; i < l; i ++ ) {       const name = names[ i ];       if ( elementNames.includes( name ) ) return name;      }      return null;     }     return {     attrX: findAttrName( [ 'x', 'px', 'posx' ] ) || 'x',     attrY: findAttrName( [ 'y', 'py', 'posy' ] ) || 'y',     attrZ: findAttrName( [ 'z', 'pz', 'posz' ] ) || 'z',     attrNX: findAttrName( [ 'nx', 'normalx' ] ),     attrNY: findAttrName( [ 'ny', 'normaly' ] ),     attrNZ: findAttrName( [ 'nz', 'normalz' ] ),     attrS: findAttrName( [ 's', 'u', 'texture_u', 'tx' ] ),     attrT: findAttrName( [ 't', 'v', 'texture_v', 'ty' ] ),     attrR: findAttrName( [ 'red', 'diffuse_red', 'r', 'diffuse_r' ] ),     attrG: findAttrName( [ 'green', 'diffuse_green', 'g', 'diffuse_g' ] ),     attrB: findAttrName( [ 'blue', 'diffuse_blue', 'b', 'diffuse_b' ] ),    };    }    function parseASCII( data, header ) {     // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)     const buffer = createBuffer();     const patternBody = /end_header|s+(|S[|s|S]*|S||S)|s*$/;    let body, matches;     if ( ( matches = patternBody.exec( data ) ) !== null ) {      body = matches[ 1 ].split( /|s+/ );     } else {      body = [ ];     }     const tokens = new ArrayStream( body );     loop: for ( let i = 0; i < header.elements.length; i ++ ) {      const elementDesc = header.elements[ i ];     const attributeMap = mapElementAttributes( elementDesc.properties );      for ( let j = 0; j < elementDesc.count; j ++ ) {       const element = parseASCIIElement( elementDesc.properties, tokens );       if ( ! element ) break loop;       handleElement( buffer, elementDesc.name, element, attributeMap );      }     }     return postProcess( buffer );    }    function postProcess( buffer ) {     let geometry = new BufferGeometry();     // mandatory buffer data     if ( buffer.indices.length > 0 ) {      geometry.setIndex( buffer.indices );     }     geometry.setAttribute( 'position', new Float32BufferAttribute( buffer.vertices, 3 ) );     // optional buffer data     if ( buffer.normals.length > 0 ) {      geometry.setAttribute( 'normal', new Float32BufferAttribute( buffer.normals, 3 ) );     }     if ( buffer.uvs.length > 0 ) {      geometry.setAttribute( 'uv', new Float32BufferAttribute( buffer.uvs, 2 ) );     }     if ( buffer.colors.length > 0 ) {      geometry.setAttribute( 'color', new Float32BufferAttribute( buffer.colors, 3 ) );     }     if ( buffer.faceVertexUvs.length > 0 || buffer.faceVertexColors.length > 0 ) {      geometry = geometry.toNonIndexed();      if ( buffer.faceVertexUvs.length > 0 ) geometry.setAttribute( 'uv', new Float32BufferAttribute( buffer.faceVertexUvs, 2 ) );     if ( buffer.faceVertexColors.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( buffer.faceVertexColors, 3 ) );     }     // custom buffer data     for ( const customProperty of Object.keys( scope.customPropertyMapping ) ) {      if ( buffer[ customProperty ].length > 0 ) {         geometry.setAttribute(       customProperty,       new Float32BufferAttribute(          buffer[ customProperty ],          scope.customPropertyMapping[ customProperty ].length       )        );      }     }     geometry.computeBoundingSphere();     return geometry;    }    function handleElement( buffer, elementName, element, cacheEntry ) {     if ( elementName === 'vertex' ) {      buffer.vertices.push( element[ cacheEntry.attrX ], element[ cacheEntry.attrY ], element[ cacheEntry.attrZ ] );      if ( cacheEntry.attrNX !== null && cacheEntry.attrNY !== null && cacheEntry.attrNZ !== null ) {       buffer.normals.push( element[ cacheEntry.attrNX ], element[ cacheEntry.attrNY ], element[ cacheEntry.attrNZ ] );      }      if ( cacheEntry.attrS !== null && cacheEntry.attrT !== null ) {       buffer.uvs.push( element[ cacheEntry.attrS ], element[ cacheEntry.attrT ] );      }      if ( cacheEntry.attrR !== null && cacheEntry.attrG !== null && cacheEntry.attrB !== null ) {       _color.setRGB(       element[ cacheEntry.attrR ] / 255.0,       element[ cacheEntry.attrG ] / 255.0,       element[ cacheEntry.attrB ] / 255.0,       SRGBColorSpace      );       buffer.colors.push( _color.r, _color.g, _color.b );      }      for ( const customProperty of Object.keys( scope.customPropertyMapping ) ) {       for ( const elementProperty of scope.customPropertyMapping[ customProperty ] ) {         buffer[ customProperty ].push( element[ elementProperty ] );       }      }     } else if ( elementName === 'face' ) {      const vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338     const texcoord = element.texcoord;      if ( vertex_indices.length === 3 ) {       buffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] );       if ( texcoord && texcoord.length === 6 ) {        buffer.faceVertexUvs.push( texcoord[ 0 ], texcoord[ 1 ] );       buffer.faceVertexUvs.push( texcoord[ 2 ], texcoord[ 3 ] );       buffer.faceVertexUvs.push( texcoord[ 4 ], texcoord[ 5 ] );       }      } else if ( vertex_indices.length === 4 ) {       buffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] );      buffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] );      }      // face colors      if ( cacheEntry.attrR !== null && cacheEntry.attrG !== null && cacheEntry.attrB !== null ) {       _color.setRGB(       element[ cacheEntry.attrR ] / 255.0,       element[ cacheEntry.attrG ] / 255.0,       element[ cacheEntry.attrB ] / 255.0,       SRGBColorSpace      );      buffer.faceVertexColors.push( _color.r, _color.g, _color.b );      buffer.faceVertexColors.push( _color.r, _color.g, _color.b );      buffer.faceVertexColors.push( _color.r, _color.g, _color.b );      }     }    }    function binaryReadElement( at, properties ) {     const element = {};    let read = 0;     for ( let i = 0; i < properties.length; i ++ ) {      const property = properties[ i ];     const valueReader = property.valueReader;      if ( property.type === 'list' ) {       const list = [];       const n = property.countReader.read( at + read );      read += property.countReader.size;       for ( let j = 0; j < n; j ++ ) {        list.push( valueReader.read( at + read ) );       read += valueReader.size;       }       element[ property.name ] = list;      } else {       element[ property.name ] = valueReader.read( at + read );      read += valueReader.size;      }     }     return [ element, read ];    }    function setPropertyBinaryReaders( properties, body, little_endian ) {     function getBinaryReader( dataview, type, little_endian ) {      switch ( type ) {       // corespondences for non-specific length types here match rply:      case 'int8': case 'char': return { read: ( at ) => {        return dataview.getInt8( at );       }, size: 1 };      case 'uint8': case 'uchar': return { read: ( at ) => {        return dataview.getUint8( at );       }, size: 1 };      case 'int16': case 'short': return { read: ( at ) => {        return dataview.getInt16( at, little_endian );       }, size: 2 };      case 'uint16': case 'ushort': return { read: ( at ) => {        return dataview.getUint16( at, little_endian );       }, size: 2 };      case 'int32': case 'int':  return { read: ( at ) => {        return dataview.getInt32( at, little_endian );       }, size: 4 };      case 'uint32': case 'uint': return { read: ( at ) => {        return dataview.getUint32( at, little_endian );       }, size: 4 };      case 'float32': case 'float': return { read: ( at ) => {        return dataview.getFloat32( at, little_endian );       }, size: 4 };      case 'float64': case 'double': return { read: ( at ) => {        return dataview.getFloat64( at, little_endian );       }, size: 8 };      }     }     for ( let i = 0, l = properties.length; i < l; i ++ ) {      const property = properties[ i ];      if ( property.type === 'list' ) {       property.countReader = getBinaryReader( body, property.countType, little_endian );      property.valueReader = getBinaryReader( body, property.itemType, little_endian );      } else {       property.valueReader = getBinaryReader( body, property.type, little_endian );      }     }    }    function parseBinary( data, header ) {     const buffer = createBuffer();     const little_endian = ( header.format === 'binary_little_endian' );    const body = new DataView( data, header.headerLength );    let result, loc = 0;     for ( let currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {      const elementDesc = header.elements[ currentElement ];     const properties = elementDesc.properties;     const attributeMap = mapElementAttributes( properties );      setPropertyBinaryReaders( properties, body, little_endian );      for ( let currentElementCount = 0; currentElementCount < elementDesc.count; currentElementCount ++ ) {       result = binaryReadElement( loc, properties );      loc += result[ 1 ];      const element = result[ 0 ];       handleElement( buffer, elementDesc.name, element, attributeMap );      }     }     return postProcess( buffer );    }    function extractHeaderText( bytes ) {     let i = 0;    let cont = true;     let line = '';    const lines = [];     const startLine = new TextDecoder().decode( bytes.subarray( 0, 5 ) );    const hasCRNL = /^ply|r|n/.test( startLine );     do {      const c = String.fromCharCode( bytes[ i ++ ] );      if ( c !== '|n' && c !== '|r' ) {       line += c;      } else {       if ( line === 'end_header' ) cont = false;      if ( line !== '' ) {        lines.push( line );       line = '';       }      }     } while ( cont && i < bytes.length );     // ascii section using |r|n as line endings    if ( hasCRNL === true ) i ++;     return { headerText: lines.join( '|r' ) + '|r', headerLength: i };    }    //    let geometry;   const scope = this;    if ( data instanceof ArrayBuffer ) {     const bytes = new Uint8Array( data );    const { headerText, headerLength } = extractHeaderText( bytes );    const header = parseHeader( headerText, headerLength );     if ( header.format === 'ascii' ) {      const text = new TextDecoder().decode( bytes );      geometry = parseASCII( text, header );     } else {      geometry = parseBinary( data, header );     }    } else {     geometry = parseASCII( data, parseHeader( data ) );    }    return geometry;   }  }  class ArrayStream {   constructor( arr ) {    this.arr = arr;   this.i = 0;   }   empty() {    return this.i >= this.arr.length;   }   next() {    return this.arr[ this.i ++ ];   }  }  export { PLYLoader }; 
^..^ FILENAME ^..^
addons|loaders|PVRLoader.js
^..^ CONTENTS ^..^
import {  CompressedTextureLoader,  RGBA_PVRTC_2BPPV1_Format,  RGBA_PVRTC_4BPPV1_Format,  RGB_PVRTC_2BPPV1_Format,  RGB_PVRTC_4BPPV1_Format } from 'three';  /*  *  PVR v2 (legacy) parser  *   TODO : Add Support for PVR v3 format  *   TODO : implement loadMipmaps option  */  class PVRLoader extends CompressedTextureLoader {   constructor( manager ) {    super( manager );   }   parse( buffer, loadMipmaps ) {    const headerLengthInt = 13;   const header = new Uint32Array( buffer, 0, headerLengthInt );    const pvrDatas = {    buffer: buffer,    header: header,    loadMipmaps: loadMipmaps   };    if ( header[ 0 ] === 0x03525650 ) {     // PVR v3     return _parseV3( pvrDatas );    } else if ( header[ 11 ] === 0x21525650 ) {     // PVR v2     return _parseV2( pvrDatas );    } else {     console.error( 'THREE.PVRLoader: Unknown PVR format.' );    }   }  }  function _parseV3( pvrDatas ) {   const header = pvrDatas.header;  let bpp, format;    const metaLen = header[ 12 ],   pixelFormat = header[ 2 ],   height = header[ 6 ],   width = header[ 7 ],   // numSurfs = header[ 9 ],   numFaces = header[ 10 ],   numMipmaps = header[ 11 ];   switch ( pixelFormat ) {    case 0 : // PVRTC 2bpp RGB    bpp = 2;    format = RGB_PVRTC_2BPPV1_Format;    break;    case 1 : // PVRTC 2bpp RGBA    bpp = 2;    format = RGBA_PVRTC_2BPPV1_Format;    break;    case 2 : // PVRTC 4bpp RGB    bpp = 4;    format = RGB_PVRTC_4BPPV1_Format;    break;    case 3 : // PVRTC 4bpp RGBA    bpp = 4;    format = RGBA_PVRTC_4BPPV1_Format;    break;    default :    console.error( 'THREE.PVRLoader: Unsupported PVR format:', pixelFormat );   }   pvrDatas.dataPtr = 52 + metaLen;  pvrDatas.bpp = bpp;  pvrDatas.format = format;  pvrDatas.width = width;  pvrDatas.height = height;  pvrDatas.numSurfaces = numFaces;  pvrDatas.numMipmaps = numMipmaps;  pvrDatas.isCubemap  = ( numFaces === 6 );   return _extract( pvrDatas );  }  function _parseV2( pvrDatas ) {   const header = pvrDatas.header;   const headerLength = header[ 0 ],   height = header[ 1 ],   width = header[ 2 ],   numMipmaps = header[ 3 ],   flags = header[ 4 ],   // dataLength = header[ 5 ],   // bpp =  header[ 6 ],   // bitmaskRed = header[ 7 ],   // bitmaskGreen = header[ 8 ],   // bitmaskBlue = header[ 9 ],   bitmaskAlpha = header[ 10 ],   // pvrTag = header[ 11 ],   numSurfs = header[ 12 ];    const TYPE_MASK = 0xff;  const PVRTC_2 = 24,   PVRTC_4 = 25;   const formatFlags = flags & TYPE_MASK;   let bpp, format;  const _hasAlpha = bitmaskAlpha > 0;   if ( formatFlags === PVRTC_4 ) {    format = _hasAlpha ? RGBA_PVRTC_4BPPV1_Format : RGB_PVRTC_4BPPV1_Format;   bpp = 4;   } else if ( formatFlags === PVRTC_2 ) {    format = _hasAlpha ? RGBA_PVRTC_2BPPV1_Format : RGB_PVRTC_2BPPV1_Format;   bpp = 2;   } else {    console.error( 'THREE.PVRLoader: Unknown PVR format:', formatFlags );   }   pvrDatas.dataPtr = headerLength;  pvrDatas.bpp = bpp;  pvrDatas.format = format;  pvrDatas.width = width;  pvrDatas.height = height;  pvrDatas.numSurfaces = numSurfs;  pvrDatas.numMipmaps = numMipmaps + 1;   // guess cubemap type seems tricky in v2  // it juste a pvr containing 6 surface (no explicit cubemap type)  pvrDatas.isCubemap  = ( numSurfs === 6 );   return _extract( pvrDatas );  }   function _extract( pvrDatas ) {   const pvr = {   mipmaps: [],   width: pvrDatas.width,   height: pvrDatas.height,   format: pvrDatas.format,   mipmapCount: pvrDatas.numMipmaps,   isCubemap: pvrDatas.isCubemap  };   const buffer = pvrDatas.buffer;   let dataOffset = pvrDatas.dataPtr,   dataSize = 0,   blockSize = 0,   blockWidth = 0,   blockHeight = 0,   widthBlocks = 0,   heightBlocks = 0;   const bpp = pvrDatas.bpp,   numSurfs = pvrDatas.numSurfaces;   if ( bpp === 2 ) {    blockWidth = 8;   blockHeight = 4;   } else {    blockWidth = 4;   blockHeight = 4;   }   blockSize = ( blockWidth * blockHeight ) * bpp / 8;   pvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;   let mipLevel = 0;   while ( mipLevel < pvrDatas.numMipmaps ) {    const sWidth = pvrDatas.width >> mipLevel,    sHeight = pvrDatas.height >> mipLevel;    widthBlocks = sWidth / blockWidth;   heightBlocks = sHeight / blockHeight;    // Clamp to minimum number of blocks   if ( widthBlocks < 2 ) widthBlocks = 2;   if ( heightBlocks < 2 ) heightBlocks = 2;    dataSize = widthBlocks * heightBlocks * blockSize;    for ( let surfIndex = 0; surfIndex < numSurfs; surfIndex ++ ) {     const byteArray = new Uint8Array( buffer, dataOffset, dataSize );     const mipmap = {     data: byteArray,     width: sWidth,     height: sHeight    };     pvr.mipmaps[ surfIndex * pvrDatas.numMipmaps + mipLevel ] = mipmap;     dataOffset += dataSize;    }    mipLevel ++;   }   return pvr;  }  export { PVRLoader }; 
^..^ FILENAME ^..^
addons|loaders|RGBELoader.js
^..^ CONTENTS ^..^
import {  DataTextureLoader,  DataUtils,  FloatType,  HalfFloatType,  LinearFilter,  LinearSRGBColorSpace } from 'three';  // https://github.com/mrdoob/three.js/issues/5552 // http://en.wikipedia.org/wiki/RGBE_image_format  class RGBELoader extends DataTextureLoader {   constructor( manager ) {    super( manager );    this.type = HalfFloatType;   }   // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html   parse( buffer ) {    const    /* default error routine.  change this to change error handling */    rgbe_read_error = 1,    rgbe_write_error = 2,    rgbe_format_error = 3,    rgbe_memory_error = 4,    rgbe_error = function ( rgbe_error_code, msg ) {      switch ( rgbe_error_code ) {       case rgbe_read_error: throw new Error( 'THREE.RGBELoader: Read Error: ' + ( msg || '' ) );      case rgbe_write_error: throw new Error( 'THREE.RGBELoader: Write Error: ' + ( msg || '' ) );      case rgbe_format_error: throw new Error( 'THREE.RGBELoader: Bad File Format: ' + ( msg || '' ) );      default:      case rgbe_memory_error: throw new Error( 'THREE.RGBELoader: Memory Error: ' + ( msg || '' ) );      }     },     /* offsets to red, green, and blue components in a data (float) pixel */    //RGBE_DATA_RED = 0,    //RGBE_DATA_GREEN = 1,    //RGBE_DATA_BLUE = 2,     /* number of floats per pixel, use 4 since stored in rgba image format */    //RGBE_DATA_SIZE = 4,     /* flags indicating which fields in an rgbe_header_info are valid */    RGBE_VALID_PROGRAMTYPE = 1,    RGBE_VALID_FORMAT = 2,    RGBE_VALID_DIMENSIONS = 4,     NEWLINE = '|n',     fgets = function ( buffer, lineLimit, consume ) {      const chunkSize = 128;      lineLimit = ! lineLimit ? 1024 : lineLimit;     let p = buffer.pos,      i = - 1, len = 0, s = '',      chunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );      while ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {       s += chunk; len += chunk.length;      p += chunkSize;      chunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );      }      if ( - 1 < i ) {       /*for (i=l-1; i>=0; i--) {       byteCode = m.charCodeAt(i);       if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;       else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;       if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate      }*/      if ( false !== consume ) buffer.pos += len + i + 1;      return s + chunk.slice( 0, i );      }      return false;     },     /* minimal header reading.  modify if you want to parse more information */    RGBE_ReadHeader = function ( buffer ) {       // regexes to parse header info fields     const magic_token_re = /^#|?(|S+)/,      gamma_re = /^|s*GAMMA|s*=|s*(|d+(|.|d+)?)|s*$/,      exposure_re = /^|s*EXPOSURE|s*=|s*(|d+(|.|d+)?)|s*$/,      format_re = /^|s*FORMAT=(|S+)|s*$/,      dimensions_re = /^|s*|-Y|s+(|d+)|s+|+X|s+(|d+)|s*$/,       // RGBE format header struct      header = {        valid: 0, /* indicate which fields are valid */        string: '', /* the actual header string */        comments: '', /* comments found in header */        programtype: 'RGBE', /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */        format: '', /* RGBE format, default 32-bit_rle_rgbe */        gamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */        exposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */        width: 0, height: 0 /* image dimensions, width/height */       };      let line, match;      if ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {       rgbe_error( rgbe_read_error, 'no header found' );      }      /* if you want to require the magic token then uncomment the next line */     if ( ! ( match = line.match( magic_token_re ) ) ) {       rgbe_error( rgbe_format_error, 'bad initial token' );      }      header.valid |= RGBE_VALID_PROGRAMTYPE;     header.programtype = match[ 1 ];     header.string += line + '|n';      while ( true ) {       line = fgets( buffer );      if ( false === line ) break;      header.string += line + '|n';       if ( '#' === line.charAt( 0 ) ) {        header.comments += line + '|n';       continue; // comment line       }       if ( match = line.match( gamma_re ) ) {        header.gamma = parseFloat( match[ 1 ] );       }       if ( match = line.match( exposure_re ) ) {        header.exposure = parseFloat( match[ 1 ] );       }       if ( match = line.match( format_re ) ) {        header.valid |= RGBE_VALID_FORMAT;       header.format = match[ 1 ];//'32-bit_rle_rgbe';       }       if ( match = line.match( dimensions_re ) ) {        header.valid |= RGBE_VALID_DIMENSIONS;       header.height = parseInt( match[ 1 ], 10 );       header.width = parseInt( match[ 2 ], 10 );       }       if ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;      }      if ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {       rgbe_error( rgbe_format_error, 'missing format specifier' );      }      if ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {       rgbe_error( rgbe_format_error, 'missing image size specifier' );      }      return header;     },     RGBE_ReadPixels_RLE = function ( buffer, w, h ) {      const scanline_width = w;      if (      // run length encoding is not allowed so read flat      ( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||      // this file is not run length encoded      ( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )     ) {       // return the flat buffer      return new Uint8Array( buffer );      }      if ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {       rgbe_error( rgbe_format_error, 'wrong scanline width' );      }      const data_rgba = new Uint8Array( 4 * w * h );      if ( ! data_rgba.length ) {       rgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );      }      let offset = 0, pos = 0;      const ptr_end = 4 * scanline_width;     const rgbeStart = new Uint8Array( 4 );     const scanline_buffer = new Uint8Array( ptr_end );     let num_scanlines = h;      // read in each successive scanline     while ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {       if ( pos + 4 > buffer.byteLength ) {        rgbe_error( rgbe_read_error );       }       rgbeStart[ 0 ] = buffer[ pos ++ ];      rgbeStart[ 1 ] = buffer[ pos ++ ];      rgbeStart[ 2 ] = buffer[ pos ++ ];      rgbeStart[ 3 ] = buffer[ pos ++ ];       if ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {        rgbe_error( rgbe_format_error, 'bad rgbe scanline format' );       }       // read each of the four channels for the scanline into the buffer      // first red, then green, then blue, then exponent      let ptr = 0, count;       while ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {        count = buffer[ pos ++ ];       const isEncodedRun = count > 128;       if ( isEncodedRun ) count -= 128;        if ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {         rgbe_error( rgbe_format_error, 'bad scanline data' );        }        if ( isEncodedRun ) {         // a (encoded) run of the same value        const byteValue = buffer[ pos ++ ];        for ( let i = 0; i < count; i ++ ) {          scanline_buffer[ ptr ++ ] = byteValue;         }        //ptr += count;        } else {         // a literal-run        scanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );        ptr += count; pos += count;        }       }        // now convert data from buffer into rgba      // first red, then green, then blue, then exponent (alpha)      const l = scanline_width; //scanline_buffer.byteLength;      for ( let i = 0; i < l; i ++ ) {        let off = 0;       data_rgba[ offset ] = scanline_buffer[ i + off ];       off += scanline_width; //1;       data_rgba[ offset + 1 ] = scanline_buffer[ i + off ];       off += scanline_width; //1;       data_rgba[ offset + 2 ] = scanline_buffer[ i + off ];       off += scanline_width; //1;       data_rgba[ offset + 3 ] = scanline_buffer[ i + off ];       offset += 4;       }       num_scanlines --;      }      return data_rgba;     };    const RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {     const e = sourceArray[ sourceOffset + 3 ];    const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;     destArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;    destArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;    destArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;    destArray[ destOffset + 3 ] = 1;    };    const RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {     const e = sourceArray[ sourceOffset + 3 ];    const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;     // clamping to 65504, the maximum representable value in float16    destArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );    destArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );    destArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );    destArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );    };    const byteArray = new Uint8Array( buffer );   byteArray.pos = 0;   const rgbe_header_info = RGBE_ReadHeader( byteArray );    const w = rgbe_header_info.width,    h = rgbe_header_info.height,    image_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );     let data, type;   let numElements;    switch ( this.type ) {     case FloatType:      numElements = image_rgba_data.length / 4;     const floatArray = new Float32Array( numElements * 4 );      for ( let j = 0; j < numElements; j ++ ) {       RGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );      }      data = floatArray;     type = FloatType;     break;     case HalfFloatType:      numElements = image_rgba_data.length / 4;     const halfArray = new Uint16Array( numElements * 4 );      for ( let j = 0; j < numElements; j ++ ) {       RGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );      }      data = halfArray;     type = HalfFloatType;     break;     default:      throw new Error( 'THREE.RGBELoader: Unsupported type: ' + this.type );     break;    }    return {    width: w, height: h,    data: data,    header: rgbe_header_info.string,    gamma: rgbe_header_info.gamma,    exposure: rgbe_header_info.exposure,    type: type   };   }   setDataType( value ) {    this.type = value;   return this;   }   load( url, onLoad, onProgress, onError ) {    function onLoadCallback( texture, texData ) {     switch ( texture.type ) {      case FloatType:     case HalfFloatType:       texture.colorSpace = LinearSRGBColorSpace;      texture.minFilter = LinearFilter;      texture.magFilter = LinearFilter;      texture.generateMipmaps = false;      texture.flipY = true;       break;     }     if ( onLoad ) onLoad( texture, texData );    }    return super.load( url, onLoadCallback, onProgress, onError );   }  }  export { RGBELoader }; 
^..^ FILENAME ^..^
addons|loaders|RGBMLoader.js
^..^ CONTENTS ^..^
import {  DataTextureLoader,  RGBAFormat,  LinearFilter,  CubeTexture,  HalfFloatType,  DataUtils } from 'three';  class RGBMLoader extends DataTextureLoader {   constructor( manager ) {    super( manager );    this.type = HalfFloatType;   this.maxRange = 7; // more information about this property at https://iwasbeingirony.blogspot.com/2010/06/difference-between-rgbm-and-rgbd.html   }   setDataType( value ) {    this.type = value;   return this;   }   setMaxRange( value ) {    this.maxRange = value;   return this;   }   loadCubemap( urls, onLoad, onProgress, onError ) {    const texture = new CubeTexture();    for ( let i = 0; i < 6; i ++ ) {     texture.images[ i ] = undefined;    }    let loaded = 0;    const scope = this;    function loadTexture( i ) {     scope.load( urls[ i ], function ( image ) {      texture.images[ i ] = image;      loaded ++;      if ( loaded === 6 ) {       texture.needsUpdate = true;       if ( onLoad ) onLoad( texture );      }     }, undefined, onError );    }    for ( let i = 0; i < urls.length; ++ i ) {     loadTexture( i );    }    texture.type = this.type;   texture.format = RGBAFormat;   texture.minFilter = LinearFilter;   texture.generateMipmaps = false;    return texture;   }   loadCubemapAsync( urls, onProgress ) {    return new Promise( ( resolve, reject ) => {     this.loadCubemap( urls, resolve, onProgress, reject );    } );   }   parse( buffer ) {    const img = UPNG.decode( buffer );   const rgba = UPNG.toRGBA8( img )[ 0 ];    const data = new Uint8Array( rgba );   const size = img.width * img.height * 4;    const output = ( this.type === HalfFloatType ) ? new Uint16Array( size ) : new Float32Array( size );    // decode RGBM    for ( let i = 0; i < data.length; i += 4 ) {     const r = data[ i + 0 ] / 255;    const g = data[ i + 1 ] / 255;    const b = data[ i + 2 ] / 255;    const a = data[ i + 3 ] / 255;     if ( this.type === HalfFloatType ) {      output[ i + 0 ] = DataUtils.toHalfFloat( Math.min( r * a * this.maxRange, 65504 ) );     output[ i + 1 ] = DataUtils.toHalfFloat( Math.min( g * a * this.maxRange, 65504 ) );     output[ i + 2 ] = DataUtils.toHalfFloat( Math.min( b * a * this.maxRange, 65504 ) );     output[ i + 3 ] = DataUtils.toHalfFloat( 1 );     } else {      output[ i + 0 ] = r * a * this.maxRange;     output[ i + 1 ] = g * a * this.maxRange;     output[ i + 2 ] = b * a * this.maxRange;     output[ i + 3 ] = 1;     }    }    return {    width: img.width,    height: img.height,    data: output,    format: RGBAFormat,    type: this.type,    flipY: true   };   }  }  // from https://github.com/photopea/UPNG.js (MIT License)  var UPNG = {};  UPNG.toRGBA8 = function ( out ) {   var w = out.width, h = out.height;  if ( out.tabs.acTL == null ) return [ UPNG.toRGBA8.decodeImage( out.data, w, h, out ).buffer ];   var frms = [];  if ( out.frames[ 0 ].data == null ) out.frames[ 0 ].data = out.data;   var len = w * h * 4, img = new Uint8Array( len ), empty = new Uint8Array( len ), prev = new Uint8Array( len );  for ( var i = 0; i < out.frames.length; i ++ ) {    var frm = out.frames[ i ];   var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;   var fdata = UPNG.toRGBA8.decodeImage( frm.data, fw, fh, out );    if ( i != 0 ) for ( var j = 0; j < len; j ++ ) prev[ j ] = img[ j ];    if ( frm.blend == 0 ) UPNG._copyTile( fdata, fw, fh, img, w, h, fx, fy, 0 );   else if ( frm.blend == 1 ) UPNG._copyTile( fdata, fw, fh, img, w, h, fx, fy, 1 );    frms.push( img.buffer.slice( 0 ) );    if ( frm.dispose == 1 ) UPNG._copyTile( empty, fw, fh, img, w, h, fx, fy, 0 );   else if ( frm.dispose == 2 ) for ( var j = 0; j < len; j ++ ) img[ j ] = prev[ j ];   }   return frms;  };  UPNG.toRGBA8.decodeImage = function ( data, w, h, out ) {   var area = w * h, bpp = UPNG.decode._getBPP( out );  var bpl = Math.ceil( w * bpp / 8 ); // bytes per line   var bf = new Uint8Array( area * 4 ), bf32 = new Uint32Array( bf.buffer );  var ctype = out.ctype, depth = out.depth;  var rs = UPNG._bin.readUshort;   if ( ctype == 6 ) { // RGB + alpha    var qarea = area << 2;   if ( depth == 8 ) for ( var i = 0; i < qarea; i += 4 ) {     bf[ i ] = data[ i ]; bf[ i + 1 ] = data[ i + 1 ]; bf[ i + 2 ] = data[ i + 2 ]; bf[ i + 3 ] = data[ i + 3 ];    }    if ( depth == 16 ) for ( var i = 0; i < qarea; i ++ ) {     bf[ i ] = data[ i << 1 ];    }   } else if ( ctype == 2 ) { // RGB    var ts = out.tabs[ 'tRNS' ];   if ( ts == null ) {     if ( depth == 8 ) for ( var i = 0; i < area; i ++ ) {      var ti = i * 3; bf32[ i ] = ( 255 << 24 ) | ( data[ ti + 2 ] << 16 ) | ( data[ ti + 1 ] << 8 ) | data[ ti ];     }     if ( depth == 16 ) for ( var i = 0; i < area; i ++ ) {      var ti = i * 6; bf32[ i ] = ( 255 << 24 ) | ( data[ ti + 4 ] << 16 ) | ( data[ ti + 2 ] << 8 ) | data[ ti ];     }    } else {     var tr = ts[ 0 ], tg = ts[ 1 ], tb = ts[ 2 ];    if ( depth == 8 ) for ( var i = 0; i < area; i ++ ) {      var qi = i << 2, ti = i * 3; bf32[ i ] = ( 255 << 24 ) | ( data[ ti + 2 ] << 16 ) | ( data[ ti + 1 ] << 8 ) | data[ ti ];     if ( data[ ti ] == tr && data[ ti + 1 ] == tg && data[ ti + 2 ] == tb ) bf[ qi + 3 ] = 0;     }     if ( depth == 16 ) for ( var i = 0; i < area; i ++ ) {      var qi = i << 2, ti = i * 6; bf32[ i ] = ( 255 << 24 ) | ( data[ ti + 4 ] << 16 ) | ( data[ ti + 2 ] << 8 ) | data[ ti ];     if ( rs( data, ti ) == tr && rs( data, ti + 2 ) == tg && rs( data, ti + 4 ) == tb ) bf[ qi + 3 ] = 0;     }    }   } else if ( ctype == 3 ) { // palette    var p = out.tabs[ 'PLTE' ], ap = out.tabs[ 'tRNS' ], tl = ap ? ap.length : 0;   //console.log(p, ap);   if ( depth == 1 ) for ( var y = 0; y < h; y ++ ) {     var s0 = y * bpl, t0 = y * w;    for ( var i = 0; i < w; i ++ ) {      var qi = ( t0 + i ) << 2, j = ( ( data[ s0 + ( i >> 3 ) ] >> ( 7 - ( ( i & 7 ) << 0 ) ) ) & 1 ), cj = 3 * j; bf[ qi ] = p[ cj ]; bf[ qi + 1 ] = p[ cj + 1 ]; bf[ qi + 2 ] = p[ cj + 2 ]; bf[ qi + 3 ] = ( j < tl ) ? ap[ j ] : 255;     }    }    if ( depth == 2 ) for ( var y = 0; y < h; y ++ ) {     var s0 = y * bpl, t0 = y * w;    for ( var i = 0; i < w; i ++ ) {      var qi = ( t0 + i ) << 2, j = ( ( data[ s0 + ( i >> 2 ) ] >> ( 6 - ( ( i & 3 ) << 1 ) ) ) & 3 ), cj = 3 * j; bf[ qi ] = p[ cj ]; bf[ qi + 1 ] = p[ cj + 1 ]; bf[ qi + 2 ] = p[ cj + 2 ]; bf[ qi + 3 ] = ( j < tl ) ? ap[ j ] : 255;     }    }    if ( depth == 4 ) for ( var y = 0; y < h; y ++ ) {     var s0 = y * bpl, t0 = y * w;    for ( var i = 0; i < w; i ++ ) {      var qi = ( t0 + i ) << 2, j = ( ( data[ s0 + ( i >> 1 ) ] >> ( 4 - ( ( i & 1 ) << 2 ) ) ) & 15 ), cj = 3 * j; bf[ qi ] = p[ cj ]; bf[ qi + 1 ] = p[ cj + 1 ]; bf[ qi + 2 ] = p[ cj + 2 ]; bf[ qi + 3 ] = ( j < tl ) ? ap[ j ] : 255;     }    }    if ( depth == 8 ) for ( var i = 0; i < area; i ++ ) {     var qi = i << 2, j = data[ i ], cj = 3 * j; bf[ qi ] = p[ cj ]; bf[ qi + 1 ] = p[ cj + 1 ]; bf[ qi + 2 ] = p[ cj + 2 ]; bf[ qi + 3 ] = ( j < tl ) ? ap[ j ] : 255;    }   } else if ( ctype == 4 ) { // gray + alpha    if ( depth == 8 ) for ( var i = 0; i < area; i ++ ) {     var qi = i << 2, di = i << 1, gr = data[ di ]; bf[ qi ] = gr; bf[ qi + 1 ] = gr; bf[ qi + 2 ] = gr; bf[ qi + 3 ] = data[ di + 1 ];    }    if ( depth == 16 ) for ( var i = 0; i < area; i ++ ) {     var qi = i << 2, di = i << 2, gr = data[ di ]; bf[ qi ] = gr; bf[ qi + 1 ] = gr; bf[ qi + 2 ] = gr; bf[ qi + 3 ] = data[ di + 2 ];    }   } else if ( ctype == 0 ) { // gray    var tr = out.tabs[ 'tRNS' ] ? out.tabs[ 'tRNS' ] : - 1;   for ( var y = 0; y < h; y ++ ) {     var off = y * bpl, to = y * w;    if ( depth == 1 ) for ( var x = 0; x < w; x ++ ) {      var gr = 255 * ( ( data[ off + ( x >>> 3 ) ] >>> ( 7 - ( x & 7 ) ) ) & 1 ), al = ( gr == tr * 255 ) ? 0 : 255; bf32[ to + x ] = ( al << 24 ) | ( gr << 16 ) | ( gr << 8 ) | gr;     }    else if ( depth == 2 ) for ( var x = 0; x < w; x ++ ) {      var gr = 85 * ( ( data[ off + ( x >>> 2 ) ] >>> ( 6 - ( ( x & 3 ) << 1 ) ) ) & 3 ), al = ( gr == tr * 85 ) ? 0 : 255; bf32[ to + x ] = ( al << 24 ) | ( gr << 16 ) | ( gr << 8 ) | gr;     }    else if ( depth == 4 ) for ( var x = 0; x < w; x ++ ) {      var gr = 17 * ( ( data[ off + ( x >>> 1 ) ] >>> ( 4 - ( ( x & 1 ) << 2 ) ) ) & 15 ), al = ( gr == tr * 17 ) ? 0 : 255; bf32[ to + x ] = ( al << 24 ) | ( gr << 16 ) | ( gr << 8 ) | gr;     }    else if ( depth == 8 ) for ( var x = 0; x < w; x ++ ) {      var gr = data[ off + x ], al = ( gr == tr ) ? 0 : 255; bf32[ to + x ] = ( al << 24 ) | ( gr << 16 ) | ( gr << 8 ) | gr;     }    else if ( depth == 16 ) for ( var x = 0; x < w; x ++ ) {      var gr = data[ off + ( x << 1 ) ], al = ( rs( data, off + ( x << 1 ) ) == tr ) ? 0 : 255; bf32[ to + x ] = ( al << 24 ) | ( gr << 16 ) | ( gr << 8 ) | gr;     }    }   }   //console.log(Date.now()-time);  return bf;  };    UPNG.decode = function ( buff ) {   var data = new Uint8Array( buff ), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;  var out = { tabs: {}, frames: [] };  var dd = new Uint8Array( data.length ), doff = 0;  // put all IDAT data into it  var fd, foff = 0; // frames  var text, keyw, bfr;   var mgck = [ 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a ];  for ( var i = 0; i < 8; i ++ ) if ( data[ i ] != mgck[ i ] ) throw new Error( 'The input is not a PNG file!' );   while ( offset < data.length ) {    var len = bin.readUint( data, offset ); offset += 4;   var type = bin.readASCII( data, offset, 4 ); offset += 4;   //console.log(type,len);    if ( type == 'IHDR' ) {     UPNG.decode._IHDR( data, offset, out );    } else if ( type == 'CgBI' ) {     out.tabs[ type ] = data.slice( offset, offset + 4 );    } else if ( type == 'IDAT' ) {     for ( var i = 0; i < len; i ++ ) dd[ doff + i ] = data[ offset + i ];    doff += len;    } else if ( type == 'acTL' ) {     out.tabs[ type ] = { num_frames: rUi( data, offset ), num_plays: rUi( data, offset + 4 ) };    fd = new Uint8Array( data.length );    } else if ( type == 'fcTL' ) {     if ( foff != 0 ) {      var fr = out.frames[ out.frames.length - 1 ];     fr.data = UPNG.decode._decompress( out, fd.slice( 0, foff ), fr.rect.width, fr.rect.height ); foff = 0;     }     var rct = { x: rUi( data, offset + 12 ), y: rUi( data, offset + 16 ), width: rUi( data, offset + 4 ), height: rUi( data, offset + 8 ) };    var del = rUs( data, offset + 22 ); del = rUs( data, offset + 20 ) / ( del == 0 ? 100 : del );    var frm = { rect: rct, delay: Math.round( del * 1000 ), dispose: data[ offset + 24 ], blend: data[ offset + 25 ] };    //console.log(frm);    out.frames.push( frm );    } else if ( type == 'fdAT' ) {     for ( var i = 0; i < len - 4; i ++ ) fd[ foff + i ] = data[ offset + i + 4 ];    foff += len - 4;    } else if ( type == 'pHYs' ) {     out.tabs[ type ] = [ bin.readUint( data, offset ), bin.readUint( data, offset + 4 ), data[ offset + 8 ] ];    } else if ( type == 'cHRM' ) {     out.tabs[ type ] = [];    for ( var i = 0; i < 8; i ++ ) out.tabs[ type ].push( bin.readUint( data, offset + i * 4 ) );    } else if ( type == 'tEXt' || type == 'zTXt' ) {     if ( out.tabs[ type ] == null ) out.tabs[ type ] = {};    var nz = bin.nextZero( data, offset );    keyw = bin.readASCII( data, offset, nz - offset );    var tl = offset + len - nz - 1;    if ( type == 'tEXt' ) text = bin.readASCII( data, nz + 1, tl );    else {      bfr = UPNG.decode._inflate( data.slice( nz + 2, nz + 2 + tl ) );     text = bin.readUTF8( bfr, 0, bfr.length );     }     out.tabs[ type ][ keyw ] = text;    } else if ( type == 'iTXt' ) {     if ( out.tabs[ type ] == null ) out.tabs[ type ] = {};    var nz = 0, off = offset;    nz = bin.nextZero( data, off );    keyw = bin.readASCII( data, off, nz - off ); off = nz + 1;    var cflag = data[ off ]; off += 2;    nz = bin.nextZero( data, off );    bin.readASCII( data, off, nz - off ); off = nz + 1;    nz = bin.nextZero( data, off );    bin.readUTF8( data, off, nz - off ); off = nz + 1;    var tl = len - ( off - offset );    if ( cflag == 0 ) text = bin.readUTF8( data, off, tl );    else {      bfr = UPNG.decode._inflate( data.slice( off, off + tl ) );     text = bin.readUTF8( bfr, 0, bfr.length );     }     out.tabs[ type ][ keyw ] = text;    } else if ( type == 'PLTE' ) {     out.tabs[ type ] = bin.readBytes( data, offset, len );    } else if ( type == 'hIST' ) {     var pl = out.tabs[ 'PLTE' ].length / 3;    out.tabs[ type ] = []; for ( var i = 0; i < pl; i ++ ) out.tabs[ type ].push( rUs( data, offset + i * 2 ) );    } else if ( type == 'tRNS' ) {     if ( out.ctype == 3 ) out.tabs[ type ] = bin.readBytes( data, offset, len );    else if ( out.ctype == 0 ) out.tabs[ type ] = rUs( data, offset );    else if ( out.ctype == 2 ) out.tabs[ type ] = [ rUs( data, offset ), rUs( data, offset + 2 ), rUs( data, offset + 4 ) ];    //else console.log("tRNS for unsupported color type",out.ctype, len);    } else if ( type == 'gAMA' ) out.tabs[ type ] = bin.readUint( data, offset ) / 100000;   else if ( type == 'sRGB' ) out.tabs[ type ] = data[ offset ];   else if ( type == 'bKGD' ) {     if ( out.ctype == 0 || out.ctype == 4 ) out.tabs[ type ] = [ rUs( data, offset ) ];    else if ( out.ctype == 2 || out.ctype == 6 ) out.tabs[ type ] = [ rUs( data, offset ), rUs( data, offset + 2 ), rUs( data, offset + 4 ) ];    else if ( out.ctype == 3 ) out.tabs[ type ] = data[ offset ];    } else if ( type == 'IEND' ) {     break;    }    //else {  console.log("unknown chunk type", type, len);  out.tabs[type]=data.slice(offset,offset+len);  }   offset += len;   bin.readUint( data, offset ); offset += 4;   }   if ( foff != 0 ) {    var fr = out.frames[ out.frames.length - 1 ];   fr.data = UPNG.decode._decompress( out, fd.slice( 0, foff ), fr.rect.width, fr.rect.height );   }   out.data = UPNG.decode._decompress( out, dd, out.width, out.height );   delete out.compress; delete out.interlace; delete out.filter;  return out;  };  UPNG.decode._decompress = function ( out, dd, w, h ) {   var bpp = UPNG.decode._getBPP( out ), bpl = Math.ceil( w * bpp / 8 ), buff = new Uint8Array( ( bpl + 1 + out.interlace ) * h );  if ( out.tabs[ 'CgBI' ] ) dd = UPNG.inflateRaw( dd, buff );  else dd = UPNG.decode._inflate( dd, buff );   if ( out.interlace == 0 ) dd = UPNG.decode._filterZero( dd, out, 0, w, h );  else if ( out.interlace == 1 ) dd = UPNG.decode._readInterlace( dd, out );   return dd;  };  UPNG.decode._inflate = function ( data, buff ) {   var out = UPNG[ 'inflateRaw' ]( new Uint8Array( data.buffer, 2, data.length - 6 ), buff ); return out;  };  UPNG.inflateRaw = function () {   var H = {}; H.H = {}; H.H.N = function ( N, W ) {    var R = Uint8Array, i = 0, m = 0, J = 0, h = 0, Q = 0, X = 0, u = 0, w = 0, d = 0, v, C;   if ( N[ 0 ] == 3 && N[ 1 ] == 0 ) return W ? W : new R( 0 ); var V = H.H, n = V.b, A = V.e, l = V.R, M = V.n, I = V.A, e = V.Z, b = V.m, Z = W == null;   if ( Z )W = new R( N.length >>> 2 << 5 ); while ( i == 0 ) {     i = n( N, d, 1 ); m = n( N, d + 1, 2 ); d += 3; if ( m == 0 ) {      if ( ( d & 7 ) != 0 )d += 8 - ( d & 7 );     var D = ( d >>> 3 ) + 4, q = N[ D - 4 ] | N[ D - 3 ] << 8; if ( Z )W = H.H.W( W, w + q ); W.set( new R( N.buffer, N.byteOffset + D, q ), w ); d = D + q << 3;     w += q; continue     ;     }     if ( Z )W = H.H.W( W, w + ( 1 << 17 ) ); if ( m == 1 ) {      v = b.J; C = b.h; X = ( 1 << 9 ) - 1; u = ( 1 << 5 ) - 1;     }     if ( m == 2 ) {      J = A( N, d, 5 ) + 257;     h = A( N, d + 5, 5 ) + 1; Q = A( N, d + 10, 4 ) + 4; d += 14; var j = 1; for ( var c = 0; c < 38; c += 2 ) {       b.Q[ c ] = 0; b.Q[ c + 1 ] = 0;      }      for ( var c = 0;      c < Q; c ++ ) {       var K = A( N, d + c * 3, 3 ); b.Q[ ( b.X[ c ] << 1 ) + 1 ] = K; if ( K > j )j = K      ;      }      d += 3 * Q; M( b.Q, j ); I( b.Q, j, b.u ); v = b.w; C = b.d;     d = l( b.u, ( 1 << j ) - 1, J + h, N, d, b.v ); var r = V.V( b.v, 0, J, b.C ); X = ( 1 << r ) - 1; var S = V.V( b.v, J, h, b.D ); u = ( 1 << S ) - 1; M( b.C, r );     I( b.C, r, v ); M( b.D, S ); I( b.D, S, C )     ;     }     while ( ! 0 ) {      var T = v[ e( N, d ) & X ]; d += T & 15; var p = T >>> 4; if ( p >>> 8 == 0 ) {       W[ w ++ ] = p;      } else if ( p == 256 ) {       break;      } else {       var z = w + p - 254;      if ( p > 264 ) {        var _ = b.q[ p - 257 ]; z = w + ( _ >>> 3 ) + A( N, d, _ & 7 ); d += _ & 7;       }       var $ = C[ e( N, d ) & u ]; d += $ & 15; var s = $ >>> 4, Y = b.c[ s ], a = ( Y >>> 4 ) + n( N, d, Y & 15 );      d += Y & 15; while ( w < z ) {        W[ w ] = W[ w ++ - a ]; W[ w ] = W[ w ++ - a ]; W[ w ] = W[ w ++ - a ]; W[ w ] = W[ w ++ - a ];       }       w = z      ;      }     }    }    return W.length == w ? W : W.slice( 0, w )   ;   };   H.H.W = function ( N, W ) {    var R = N.length; if ( W <= R ) return N; var V = new Uint8Array( R << 1 ); V.set( N, 0 ); return V;   };   H.H.R = function ( N, W, R, V, n, A ) {    var l = H.H.e, M = H.H.Z, I = 0; while ( I < R ) {     var e = N[ M( V, n ) & W ]; n += e & 15; var b = e >>> 4;    if ( b <= 15 ) {      A[ I ] = b; I ++;     } else {      var Z = 0, m = 0; if ( b == 16 ) {       m = 3 + l( V, n, 2 ); n += 2; Z = A[ I - 1 ];      } else if ( b == 17 ) {       m = 3 + l( V, n, 3 );      n += 3      ;      } else if ( b == 18 ) {       m = 11 + l( V, n, 7 ); n += 7;      }      var J = I + m; while ( I < J ) {       A[ I ] = Z; I ++;      }     }    }    return n   ;   };   H.H.V = function ( N, W, R, V ) {    var n = 0, A = 0, l = V.length >>> 1;   while ( A < R ) {     var M = N[ A + W ]; V[ A << 1 ] = 0; V[ ( A << 1 ) + 1 ] = M; if ( M > n )n = M; A ++;    }    while ( A < l ) {     V[ A << 1 ] = 0; V[ ( A << 1 ) + 1 ] = 0; A ++;    }    return n   ;   };   H.H.n = function ( N, W ) {    var R = H.H.m, V = N.length, n, A, l, M, I, e = R.j; for ( var M = 0; M <= W; M ++ )e[ M ] = 0; for ( M = 1; M < V; M += 2 )e[ N[ M ] ] ++;   var b = R.K; n = 0; e[ 0 ] = 0; for ( A = 1; A <= W; A ++ ) {     n = n + e[ A - 1 ] << 1; b[ A ] = n;    }    for ( l = 0; l < V; l += 2 ) {     I = N[ l + 1 ]; if ( I != 0 ) {      N[ l ] = b[ I ];     b[ I ] ++     ;     }    }   };   H.H.A = function ( N, W, R ) {    var V = N.length, n = H.H.m, A = n.r; for ( var l = 0; l < V; l += 2 ) if ( N[ l + 1 ] != 0 ) {     var M = l >> 1, I = N[ l + 1 ], e = M << 4 | I, b = W - I, Z = N[ l ] << b, m = Z + ( 1 << b );    while ( Z != m ) {      var J = A[ Z ] >>> 15 - W; R[ J ] = e; Z ++;     }    }   };   H.H.l = function ( N, W ) {    var R = H.H.m.r, V = 15 - W; for ( var n = 0; n < N.length;    n += 2 ) {     var A = N[ n ] << W - N[ n + 1 ]; N[ n ] = R[ A ] >>> V;    }   };   H.H.M = function ( N, W, R ) {    R = R << ( W & 7 ); var V = W >>> 3; N[ V ] |= R; N[ V + 1 ] |= R >>> 8;   };   H.H.I = function ( N, W, R ) {    R = R << ( W & 7 ); var V = W >>> 3; N[ V ] |= R; N[ V + 1 ] |= R >>> 8; N[ V + 2 ] |= R >>> 16;   };   H.H.e = function ( N, W, R ) {    return ( N[ W >>> 3 ] | N[ ( W >>> 3 ) + 1 ] << 8 ) >>> ( W & 7 ) & ( 1 << R ) - 1;   };   H.H.b = function ( N, W, R ) {    return ( N[ W >>> 3 ] | N[ ( W >>> 3 ) + 1 ] << 8 | N[ ( W >>> 3 ) + 2 ] << 16 ) >>> ( W & 7 ) & ( 1 << R ) - 1;   };   H.H.Z = function ( N, W ) {    return ( N[ W >>> 3 ] | N[ ( W >>> 3 ) + 1 ] << 8 | N[ ( W >>> 3 ) + 2 ] << 16 ) >>> ( W & 7 );   };   H.H.i = function ( N, W ) {    return ( N[ W >>> 3 ] | N[ ( W >>> 3 ) + 1 ] << 8 | N[ ( W >>> 3 ) + 2 ] << 16 | N[ ( W >>> 3 ) + 3 ] << 24 ) >>> ( W & 7 );   };   H.H.m = function () {    var N = Uint16Array, W = Uint32Array;   return { K: new N( 16 ), j: new N( 16 ), X: [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ], S: [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999 ], T: [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0 ], q: new N( 32 ), p: [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535 ], z: [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0 ], c: new W( 32 ), J: new N( 512 ), _: [], h: new N( 32 ), $: [], w: new N( 32768 ), C: [], v: [], d: new N( 32768 ), D: [], u: new N( 512 ), Q: [], r: new N( 1 << 15 ), s: new W( 286 ), Y: new W( 30 ), a: new W( 19 ), t: new W( 15e3 ), k: new N( 1 << 16 ), g: new N( 1 << 15 ) }   ;   }();  ( function () {    var N = H.H.m, W = 1 << 15; for ( var R = 0; R < W; R ++ ) {     var V = R; V = ( V & 2863311530 ) >>> 1 | ( V & 1431655765 ) << 1;    V = ( V & 3435973836 ) >>> 2 | ( V & 858993459 ) << 2; V = ( V & 4042322160 ) >>> 4 | ( V & 252645135 ) << 4; V = ( V & 4278255360 ) >>> 8 | ( V & 16711935 ) << 8;    N.r[ R ] = ( V >>> 16 | V << 16 ) >>> 17    ;    }    function n( A, l, M ) {     while ( l -- != 0 )A.push( 0, M )    ;    }    for ( var R = 0; R < 32; R ++ ) {     N.q[ R ] = N.S[ R ] << 3 | N.T[ R ];    N.c[ R ] = N.p[ R ] << 4 | N.z[ R ]    ;    }    n( N._, 144, 8 ); n( N._, 255 - 143, 9 ); n( N._, 279 - 255, 7 ); n( N._, 287 - 279, 8 ); H.H.n( N._, 9 );   H.H.A( N._, 9, N.J ); H.H.l( N._, 9 ); n( N.$, 32, 5 ); H.H.n( N.$, 5 ); H.H.A( N.$, 5, N.h ); H.H.l( N.$, 5 ); n( N.Q, 19, 0 ); n( N.C, 286, 0 );   n( N.D, 30, 0 ); n( N.v, 320, 0 )   ;   }() );   return H.H.N  ;  }();   UPNG.decode._readInterlace = function ( data, out ) {   var w = out.width, h = out.height;  var bpp = UPNG.decode._getBPP( out ), cbpp = bpp >> 3, bpl = Math.ceil( w * bpp / 8 );  var img = new Uint8Array( h * bpl );  var di = 0;   var starting_row = [ 0, 0, 4, 0, 2, 0, 1 ];  var starting_col = [ 0, 4, 0, 2, 0, 1, 0 ];  var row_increment = [ 8, 8, 8, 4, 4, 2, 2 ];  var col_increment = [ 8, 8, 4, 4, 2, 2, 1 ];   var pass = 0;  while ( pass < 7 ) {    var ri = row_increment[ pass ], ci = col_increment[ pass ];   var sw = 0, sh = 0;   var cr = starting_row[ pass ]; while ( cr < h ) {     cr += ri; sh ++;    }    var cc = starting_col[ pass ]; while ( cc < w ) {     cc += ci; sw ++;    }    var bpll = Math.ceil( sw * bpp / 8 );   UPNG.decode._filterZero( data, out, di, sw, sh );    var y = 0, row = starting_row[ pass ];   var val;    while ( row < h ) {     var col = starting_col[ pass ];    var cdi = ( di + y * bpll ) << 3;     while ( col < w ) {      if ( bpp == 1 ) {       val = data[ cdi >> 3 ]; val = ( val >> ( 7 - ( cdi & 7 ) ) ) & 1;      img[ row * bpl + ( col >> 3 ) ] |= ( val << ( 7 - ( ( col & 7 ) << 0 ) ) );      }      if ( bpp == 2 ) {       val = data[ cdi >> 3 ]; val = ( val >> ( 6 - ( cdi & 7 ) ) ) & 3;      img[ row * bpl + ( col >> 2 ) ] |= ( val << ( 6 - ( ( col & 3 ) << 1 ) ) );      }      if ( bpp == 4 ) {       val = data[ cdi >> 3 ]; val = ( val >> ( 4 - ( cdi & 7 ) ) ) & 15;      img[ row * bpl + ( col >> 1 ) ] |= ( val << ( 4 - ( ( col & 1 ) << 2 ) ) );      }      if ( bpp >= 8 ) {       var ii = row * bpl + col * cbpp;      for ( var j = 0; j < cbpp; j ++ ) img[ ii + j ] = data[ ( cdi >> 3 ) + j ];      }      cdi += bpp; col += ci;     }     y ++; row += ri;    }    if ( sw * sh != 0 ) di += sh * ( 1 + bpll );   pass = pass + 1;   }   return img;  };  UPNG.decode._getBPP = function ( out ) {   var noc = [ 1, null, 3, 1, 2, null, 4 ][ out.ctype ];  return noc * out.depth;  };  UPNG.decode._filterZero = function ( data, out, off, w, h ) {   var bpp = UPNG.decode._getBPP( out ), bpl = Math.ceil( w * bpp / 8 ), paeth = UPNG.decode._paeth;  bpp = Math.ceil( bpp / 8 );   var i, di, type = data[ off ], x = 0;   if ( type > 1 ) data[ off ] = [ 0, 0, 1 ][ type - 2 ];  if ( type == 3 ) for ( x = bpp; x < bpl; x ++ ) data[ x + 1 ] = ( data[ x + 1 ] + ( data[ x + 1 - bpp ] >>> 1 ) ) & 255;   for ( var y = 0; y < h; y ++ ) {    i = off + y * bpl; di = i + y + 1;   type = data[ di - 1 ]; x = 0;    if ( type == 0 ) for ( ; x < bpl; x ++ ) data[ i + x ] = data[ di + x ];   else if ( type == 1 ) {     for ( ; x < bpp; x ++ ) data[ i + x ] = data[ di + x ];          for ( ; x < bpl; x ++ ) data[ i + x ] = ( data[ di + x ] + data[ i + x - bpp ] );    } else if ( type == 2 ) {     for ( ; x < bpl; x ++ ) data[ i + x ] = ( data[ di + x ] + data[ i + x - bpl ] );    } else if ( type == 3 ) {     for ( ; x < bpp; x ++ ) data[ i + x ] = ( data[ di + x ] + ( data[ i + x - bpl ] >>> 1 ) );                   for ( ; x < bpl; x ++ ) data[ i + x ] = ( data[ di + x ] + ( ( data[ i + x - bpl ] + data[ i + x - bpp ] ) >>> 1 ) );    } else {     for ( ; x < bpp; x ++ ) data[ i + x ] = ( data[ di + x ] + paeth( 0, data[ i + x - bpl ], 0 ) );          for ( ; x < bpl; x ++ ) data[ i + x ] = ( data[ di + x ] + paeth( data[ i + x - bpp ], data[ i + x - bpl ], data[ i + x - bpp - bpl ] ) );    }   }   return data;  };  UPNG.decode._paeth = function ( a, b, c ) {   var p = a + b - c, pa = ( p - a ), pb = ( p - b ), pc = ( p - c );  if ( pa * pa <= pb * pb && pa * pa <= pc * pc ) return a;  else if ( pb * pb <= pc * pc ) return b;  return c;  };  UPNG.decode._IHDR = function ( data, offset, out ) {   var bin = UPNG._bin;  out.width = bin.readUint( data, offset ); offset += 4;  out.height = bin.readUint( data, offset ); offset += 4;  out.depth = data[ offset ]; offset ++;  out.ctype = data[ offset ]; offset ++;  out.compress = data[ offset ]; offset ++;  out.filter = data[ offset ]; offset ++;  out.interlace = data[ offset ]; offset ++;  };  UPNG._bin = {  nextZero: function ( data, p ) {    while ( data[ p ] != 0 ) p ++; return p;   },  readUshort: function ( buff, p ) {    return ( buff[ p ] << 8 ) | buff[ p + 1 ];   },  writeUshort: function ( buff, p, n ) {    buff[ p ] = ( n >> 8 ) & 255; buff[ p + 1 ] = n & 255;   },  readUint: function ( buff, p ) {    return ( buff[ p ] * ( 256 * 256 * 256 ) ) + ( ( buff[ p + 1 ] << 16 ) | ( buff[ p + 2 ] << 8 ) | buff[ p + 3 ] );   },  writeUint: function ( buff, p, n ) {    buff[ p ] = ( n >> 24 ) & 255; buff[ p + 1 ] = ( n >> 16 ) & 255; buff[ p + 2 ] = ( n >> 8 ) & 255; buff[ p + 3 ] = n & 255;   },  readASCII: function ( buff, p, l ) {    var s = ''; for ( var i = 0; i < l; i ++ ) s += String.fromCharCode( buff[ p + i ] ); return s;   },  writeASCII: function ( data, p, s ) {    for ( var i = 0; i < s.length; i ++ ) data[ p + i ] = s.charCodeAt( i );   },  readBytes: function ( buff, p, l ) {    var arr = []; for ( var i = 0; i < l; i ++ ) arr.push( buff[ p + i ] ); return arr;   },  pad: function ( n ) {    return n.length < 2 ? '0' + n : n;   },  readUTF8: function ( buff, p, l ) {    var s = '', ns;   for ( var i = 0; i < l; i ++ ) s += '%' + UPNG._bin.pad( buff[ p + i ].toString( 16 ) );   try {     ns = decodeURIComponent( s );    } catch ( e ) {     return UPNG._bin.readASCII( buff, p, l );    }    return ns;   } }; UPNG._copyTile = function ( sb, sw, sh, tb, tw, th, xoff, yoff, mode ) {   var w = Math.min( sw, tw ), h = Math.min( sh, th );  var si = 0, ti = 0;  for ( var y = 0; y < h; y ++ )   for ( var x = 0; x < w; x ++ ) {     if ( xoff >= 0 && yoff >= 0 ) {      si = ( y * sw + x ) << 2; ti = ( ( yoff + y ) * tw + xoff + x ) << 2;     } else {      si = ( ( - yoff + y ) * sw - xoff + x ) << 2; ti = ( y * tw + x ) << 2;     }     if ( mode == 0 ) {      tb[ ti ] = sb[ si ]; tb[ ti + 1 ] = sb[ si + 1 ]; tb[ ti + 2 ] = sb[ si + 2 ]; tb[ ti + 3 ] = sb[ si + 3 ];     } else if ( mode == 1 ) {      var fa = sb[ si + 3 ] * ( 1 / 255 ), fr = sb[ si ] * fa, fg = sb[ si + 1 ] * fa, fb = sb[ si + 2 ] * fa;     var ba = tb[ ti + 3 ] * ( 1 / 255 ), br = tb[ ti ] * ba, bg = tb[ ti + 1 ] * ba, bb = tb[ ti + 2 ] * ba;      var ifa = 1 - fa, oa = fa + ba * ifa, ioa = ( oa == 0 ? 0 : 1 / oa );     tb[ ti + 3 ] = 255 * oa;     tb[ ti + 0 ] = ( fr + br * ifa ) * ioa;     tb[ ti + 1 ] = ( fg + bg * ifa ) * ioa;     tb[ ti + 2 ] = ( fb + bb * ifa ) * ioa;     } else if ( mode == 2 ) { // copy only differences, otherwise zero      var fa = sb[ si + 3 ], fr = sb[ si ], fg = sb[ si + 1 ], fb = sb[ si + 2 ];     var ba = tb[ ti + 3 ], br = tb[ ti ], bg = tb[ ti + 1 ], bb = tb[ ti + 2 ];     if ( fa == ba && fr == br && fg == bg && fb == bb ) {       tb[ ti ] = 0; tb[ ti + 1 ] = 0; tb[ ti + 2 ] = 0; tb[ ti + 3 ] = 0;      } else {       tb[ ti ] = fr; tb[ ti + 1 ] = fg; tb[ ti + 2 ] = fb; tb[ ti + 3 ] = fa;      }     } else if ( mode == 3 ) { // check if can be blended      var fa = sb[ si + 3 ], fr = sb[ si ], fg = sb[ si + 1 ], fb = sb[ si + 2 ];     var ba = tb[ ti + 3 ], br = tb[ ti ], bg = tb[ ti + 1 ], bb = tb[ ti + 2 ];     if ( fa == ba && fr == br && fg == bg && fb == bb ) continue;     //if(fa!=255 && ba!=0) return false;     if ( fa < 220 && ba > 20 ) return false;     }    }   return true;  };  export { RGBMLoader }; 
^..^ FILENAME ^..^
addons|loaders|STLLoader.js
^..^ CONTENTS ^..^
import {  BufferAttribute,  BufferGeometry,  Color,  FileLoader,  Float32BufferAttribute,  Loader,  Vector3,  SRGBColorSpace } from 'three';  /**  * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.  *  * Supports both binary and ASCII encoded files, with automatic detection of type.  *  * The loader returns a non-indexed buffer geometry.  *  * Limitations:  *  Binary decoding supports "Magics" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).  *  There is perhaps some question as to how valid it is to always assume little-endian-ness.  *  ASCII decoding assumes file is UTF-8.  *  * Usage:  *  const loader = new STLLoader();  *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {  *    scene.add( new THREE.Mesh( geometry ) );  *  });  *  * For binary STLs geometry might contain colors for vertices. To use it:  *  // use the same code to load STL as above  *  if (geometry.hasColors) {  *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });  *  } else { .... }  *  const mesh = new THREE.Mesh( geometry, material );  *  * For ASCII STLs containing multiple solids, each solid is assigned to a different group.  * Groups can be used to assign a different color by defining an array of materials with the same length of  * geometry.groups and passing it to the Mesh constructor:  *  * const mesh = new THREE.Mesh( geometry, material );  *  * For example:  *  *  const materials = [];  *  const nGeometryGroups = geometry.groups.length;  *  *  const colorMap = ...; // Some logic to index colors.  *  *  for (let i = 0; i < nGeometryGroups; i++) {  *  *  const material = new THREE.MeshPhongMaterial({  *   color: colorMap[i],  *   wireframe: false  *  });  *  *  }  *  *  materials.push(material);  *  const mesh = new THREE.Mesh(geometry, materials);  */   class STLLoader extends Loader {   constructor( manager ) {    super( manager );   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( this.manager );   loader.setPath( this.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( this.requestHeader );   loader.setWithCredentials( this.withCredentials );    loader.load( url, function ( text ) {     try {      onLoad( scope.parse( text ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( data ) {    function isBinary( data ) {     const reader = new DataView( data );    const face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );    const n_faces = reader.getUint32( 80, true );    const expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );     if ( expect === reader.byteLength ) {      return true;     }     // An ASCII STL data must begin with 'solid ' as the first six bytes.    // However, ASCII STLs lacking the SPACE after the 'd' are known to be    // plentiful.  So, check the first 5 bytes for 'solid'.     // Several encodings, such as UTF-8, precede the text with up to 5 bytes:    // https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding    // Search for "solid" to start anywhere after those prefixes.     // US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'     const solid = [ 115, 111, 108, 105, 100 ];     for ( let off = 0; off < 5; off ++ ) {      // If "solid" text is matched to the current offset, declare it to be an ASCII STL.      if ( matchDataViewAt( solid, reader, off ) ) return false;     }     // Couldn't find "solid" text at the beginning; it is binary STL.     return true;    }    function matchDataViewAt( query, reader, offset ) {     // Check if each byte in query matches the corresponding byte from the current offset     for ( let i = 0, il = query.length; i < il; i ++ ) {      if ( query[ i ] !== reader.getUint8( offset + i ) ) return false;     }     return true;    }    function parseBinary( data ) {     const reader = new DataView( data );    const faces = reader.getUint32( 80, true );     let r, g, b, hasColors = false, colors;    let defaultR, defaultG, defaultB, alpha;     // process STL header    // check for default color in header ("COLOR=rgba" sequence).     for ( let index = 0; index < 80 - 10; index ++ ) {      if ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&      ( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&      ( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {       hasColors = true;      colors = new Float32Array( faces * 3 * 3 );       defaultR = reader.getUint8( index + 6 ) / 255;      defaultG = reader.getUint8( index + 7 ) / 255;      defaultB = reader.getUint8( index + 8 ) / 255;      alpha = reader.getUint8( index + 9 ) / 255;      }     }     const dataOffset = 84;    const faceLength = 12 * 4 + 2;     const geometry = new BufferGeometry();     const vertices = new Float32Array( faces * 3 * 3 );    const normals = new Float32Array( faces * 3 * 3 );     const color = new Color();     for ( let face = 0; face < faces; face ++ ) {      const start = dataOffset + face * faceLength;     const normalX = reader.getFloat32( start, true );     const normalY = reader.getFloat32( start + 4, true );     const normalZ = reader.getFloat32( start + 8, true );      if ( hasColors ) {       const packedColor = reader.getUint16( start + 48, true );       if ( ( packedColor & 0x8000 ) === 0 ) {        // facet has its own unique color        r = ( packedColor & 0x1F ) / 31;       g = ( ( packedColor >> 5 ) & 0x1F ) / 31;       b = ( ( packedColor >> 10 ) & 0x1F ) / 31;       } else {        r = defaultR;       g = defaultG;       b = defaultB;       }      }      for ( let i = 1; i <= 3; i ++ ) {       const vertexstart = start + i * 12;      const componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );       vertices[ componentIdx ] = reader.getFloat32( vertexstart, true );      vertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );      vertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );       normals[ componentIdx ] = normalX;      normals[ componentIdx + 1 ] = normalY;      normals[ componentIdx + 2 ] = normalZ;       if ( hasColors ) {        color.setRGB( r, g, b, SRGBColorSpace );        colors[ componentIdx ] = color.r;       colors[ componentIdx + 1 ] = color.g;       colors[ componentIdx + 2 ] = color.b;       }      }     }     geometry.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );    geometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );     if ( hasColors ) {      geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );     geometry.hasColors = true;     geometry.alpha = alpha;     }     return geometry;    }    function parseASCII( data ) {     const geometry = new BufferGeometry();    const patternSolid = /solid([|s|S]*?)endsolid/g;    const patternFace = /facet([|s|S]*?)endfacet/g;    const patternName = /solid|s(.+)/;    let faceCounter = 0;     const patternFloat = /[|s]+([+-]?(?:|d*)(?:|.|d*)?(?:[eE][+-]?|d+)?)/.source;    const patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );    const patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );     const vertices = [];    const normals = [];    const groupNames = [];     const normal = new Vector3();     let result;     let groupCount = 0;    let startVertex = 0;    let endVertex = 0;     while ( ( result = patternSolid.exec( data ) ) !== null ) {      startVertex = endVertex;      const solid = result[ 0 ];      const name = ( result = patternName.exec( solid ) ) !== null ? result[ 1 ] : '';     groupNames.push( name );      while ( ( result = patternFace.exec( solid ) ) !== null ) {       let vertexCountPerFace = 0;      let normalCountPerFace = 0;       const text = result[ 0 ];       while ( ( result = patternNormal.exec( text ) ) !== null ) {        normal.x = parseFloat( result[ 1 ] );       normal.y = parseFloat( result[ 2 ] );       normal.z = parseFloat( result[ 3 ] );       normalCountPerFace ++;       }       while ( ( result = patternVertex.exec( text ) ) !== null ) {        vertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );       normals.push( normal.x, normal.y, normal.z );       vertexCountPerFace ++;       endVertex ++;       }       // every face have to own ONE valid normal       if ( normalCountPerFace !== 1 ) {        console.error( 'THREE.STLLoader: Something isn|'t right with the normal of face number ' + faceCounter );       }       // each face have to own THREE valid vertices       if ( vertexCountPerFace !== 3 ) {        console.error( 'THREE.STLLoader: Something isn|'t right with the vertices of face number ' + faceCounter );       }       faceCounter ++;      }      const start = startVertex;     const count = endVertex - startVertex;      geometry.userData.groupNames = groupNames;      geometry.addGroup( start, count, groupCount );     groupCount ++;     }     geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );    geometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );     return geometry;    }    function ensureString( buffer ) {     if ( typeof buffer !== 'string' ) {      return new TextDecoder().decode( buffer );     }     return buffer;    }    function ensureBinary( buffer ) {     if ( typeof buffer === 'string' ) {      const array_buffer = new Uint8Array( buffer.length );     for ( let i = 0; i < buffer.length; i ++ ) {       array_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian      }      return array_buffer.buffer || array_buffer;     } else {      return buffer;     }    }    // start    const binData = ensureBinary( data );    return isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );   }  }  export { STLLoader }; 
^..^ FILENAME ^..^
addons|loaders|SVGLoader.js
^..^ CONTENTS ^..^
import {  Box2,  BufferGeometry,  FileLoader,  Float32BufferAttribute,  Loader,  Matrix3,  Path,  Shape,  ShapePath,  ShapeUtils,  SRGBColorSpace,  Vector2,  Vector3 } from 'three';  const COLOR_SPACE_SVG = SRGBColorSpace;  class SVGLoader extends Loader {   constructor( manager ) {    super( manager );    // Default dots per inch   this.defaultDPI = 90;    // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'   this.defaultUnit = 'px';   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( scope.manager );   loader.setPath( scope.path );   loader.setRequestHeader( scope.requestHeader );   loader.setWithCredentials( scope.withCredentials );   loader.load( url, function ( text ) {     try {      onLoad( scope.parse( text ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( text ) {    const scope = this;    function parseNode( node, style ) {     if ( node.nodeType !== 1 ) return;     const transform = getNodeTransform( node );     let isDefsNode = false;     let path = null;     switch ( node.nodeName ) {      case 'svg':      style = parseStyle( node, style );      break;      case 'style':      parseCSSStylesheet( node );      break;      case 'g':      style = parseStyle( node, style );      break;      case 'path':      style = parseStyle( node, style );      if ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );      break;      case 'rect':      style = parseStyle( node, style );      path = parseRectNode( node );      break;      case 'polygon':      style = parseStyle( node, style );      path = parsePolygonNode( node );      break;      case 'polyline':      style = parseStyle( node, style );      path = parsePolylineNode( node );      break;      case 'circle':      style = parseStyle( node, style );      path = parseCircleNode( node );      break;      case 'ellipse':      style = parseStyle( node, style );      path = parseEllipseNode( node );      break;      case 'line':      style = parseStyle( node, style );      path = parseLineNode( node );      break;      case 'defs':      isDefsNode = true;      break;      case 'use':      style = parseStyle( node, style );       const href = node.getAttributeNS( 'http://www.w3.org/1999/xlink', 'href' ) || '';      const usedNodeId = href.substring( 1 );      const usedNode = node.viewportElement.getElementById( usedNodeId );      if ( usedNode ) {        parseNode( usedNode, style );       } else {        console.warn( 'SVGLoader: |'use node|' references non-existent node id: ' + usedNodeId );       }       break;      default:      // console.log( node );     }     if ( path ) {      if ( style.fill !== undefined && style.fill !== 'none' ) {       path.color.setStyle( style.fill, COLOR_SPACE_SVG );      }      transformPath( path, currentTransform );      paths.push( path );      path.userData = { node: node, style: style };     }     const childNodes = node.childNodes;     for ( let i = 0; i < childNodes.length; i ++ ) {      const node = childNodes[ i ];      if ( isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs' ) {       // Ignore everything in defs except CSS style definitions      // and nested defs, because it is OK by the standard to have      // <style/> there.      continue;      }      parseNode( node, style );     }      if ( transform ) {      transformStack.pop();      if ( transformStack.length > 0 ) {       currentTransform.copy( transformStack[ transformStack.length - 1 ] );      } else {       currentTransform.identity();      }     }    }    function parsePathNode( node ) {     const path = new ShapePath();     const point = new Vector2();    const control = new Vector2();     const firstPoint = new Vector2();    let isFirstPoint = true;    let doSetFirstPoint = false;     const d = node.getAttribute( 'd' );     if ( d === '' || d === 'none' ) return null;     // console.log( d );     const commands = d.match( /[a-df-z][^a-df-z]*/ig );     for ( let i = 0, l = commands.length; i < l; i ++ ) {      const command = commands[ i ];      const type = command.charAt( 0 );     const data = command.slice( 1 ).trim();      if ( isFirstPoint === true ) {       doSetFirstPoint = true;      isFirstPoint = false;      }      let numbers;      switch ( type ) {       case 'M':       numbers = parseFloats( data );       for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {         point.x = numbers[ j + 0 ];        point.y = numbers[ j + 1 ];        control.x = point.x;        control.y = point.y;         if ( j === 0 ) {          path.moveTo( point.x, point.y );         } else {          path.lineTo( point.x, point.y );         }         if ( j === 0 ) firstPoint.copy( point );        }        break;       case 'H':       numbers = parseFloats( data );        for ( let j = 0, jl = numbers.length; j < jl; j ++ ) {         point.x = numbers[ j ];        control.x = point.x;        control.y = point.y;        path.lineTo( point.x, point.y );         if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );        }        break;       case 'V':       numbers = parseFloats( data );        for ( let j = 0, jl = numbers.length; j < jl; j ++ ) {         point.y = numbers[ j ];        control.x = point.x;        control.y = point.y;        path.lineTo( point.x, point.y );         if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );        }        break;       case 'L':       numbers = parseFloats( data );        for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {         point.x = numbers[ j + 0 ];        point.y = numbers[ j + 1 ];        control.x = point.x;        control.y = point.y;        path.lineTo( point.x, point.y );         if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );        }        break;       case 'C':       numbers = parseFloats( data );        for ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {         path.bezierCurveTo(         numbers[ j + 0 ],         numbers[ j + 1 ],         numbers[ j + 2 ],         numbers[ j + 3 ],         numbers[ j + 4 ],         numbers[ j + 5 ]        );        control.x = numbers[ j + 2 ];        control.y = numbers[ j + 3 ];        point.x = numbers[ j + 4 ];        point.y = numbers[ j + 5 ];         if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );        }        break;       case 'S':       numbers = parseFloats( data );        for ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {         path.bezierCurveTo(         getReflection( point.x, control.x ),         getReflection( point.y, control.y ),         numbers[ j + 0 ],         numbers[ j + 1 ],         numbers[ j + 2 ],         numbers[ j + 3 ]        );        control.x = numbers[ j + 0 ];        control.y = numbers[ j + 1 ];        point.x = numbers[ j + 2 ];        point.y = numbers[ j + 3 ];         if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );        }        break;       case 'Q':       numbers = parseFloats( data );        for ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {         path.quadraticCurveTo(         numbers[ j + 0 ],         numbers[ j + 1 ],         numbers[ j + 2 ],         numbers[ j + 3 ]        );        control.x = numbers[ j + 0 ];        control.y = numbers[ j + 1 ];        point.x = numbers[ j + 2 ];        point.y = numbers[ j + 3 ];         if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );        }        break;       case 'T':       numbers = parseFloats( data );        for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {         const rx = getReflection( point.x, control.x );        const ry = getReflection( point.y, control.y );        path.quadraticCurveTo(         rx,         ry,         numbers[ j + 0 ],         numbers[ j + 1 ]        );        control.x = rx;        control.y = ry;        point.x = numbers[ j + 0 ];        point.y = numbers[ j + 1 ];         if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );        }        break;       case 'A':       numbers = parseFloats( data, [ 3, 4 ], 7 );        for ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {         // skip command if start point == end point        if ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;         const start = point.clone();        point.x = numbers[ j + 5 ];        point.y = numbers[ j + 6 ];        control.x = point.x;        control.y = point.y;        parseArcCommand(         path, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point        );         if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );        }        break;       case 'm':       numbers = parseFloats( data );        for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {         point.x += numbers[ j + 0 ];        point.y += numbers[ j + 1 ];        control.x = point.x;        control.y = point.y;         if ( j === 0 ) {          path.moveTo( point.x, point.y );         } else {          path.lineTo( point.x, point.y );         }         if ( j === 0 ) firstPoint.copy( point );        }        break;       case 'h':       numbers = parseFloats( data );        for ( let j = 0, jl = numbers.length; j < jl; j ++ ) {         point.x += numbers[ j ];        control.x = point.x;        control.y = point.y;        path.lineTo( point.x, point.y );         if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );        }        break;       case 'v':       numbers = parseFloats( data );        for ( let j = 0, jl = numbers.length; j < jl; j ++ ) {         point.y += numbers[ j ];        control.x = point.x;        control.y = point.y;        path.lineTo( point.x, point.y );         if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );        }        break;       case 'l':       numbers = parseFloats( data );        for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {         point.x += numbers[ j + 0 ];        point.y += numbers[ j + 1 ];        control.x = point.x;        control.y = point.y;        path.lineTo( point.x, point.y );         if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );        }        break;       case 'c':       numbers = parseFloats( data );        for ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {         path.bezierCurveTo(         point.x + numbers[ j + 0 ],         point.y + numbers[ j + 1 ],         point.x + numbers[ j + 2 ],         point.y + numbers[ j + 3 ],         point.x + numbers[ j + 4 ],         point.y + numbers[ j + 5 ]        );        control.x = point.x + numbers[ j + 2 ];        control.y = point.y + numbers[ j + 3 ];        point.x += numbers[ j + 4 ];        point.y += numbers[ j + 5 ];         if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );        }        break;       case 's':       numbers = parseFloats( data );        for ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {         path.bezierCurveTo(         getReflection( point.x, control.x ),         getReflection( point.y, control.y ),         point.x + numbers[ j + 0 ],         point.y + numbers[ j + 1 ],         point.x + numbers[ j + 2 ],         point.y + numbers[ j + 3 ]        );        control.x = point.x + numbers[ j + 0 ];        control.y = point.y + numbers[ j + 1 ];        point.x += numbers[ j + 2 ];        point.y += numbers[ j + 3 ];         if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );        }        break;       case 'q':       numbers = parseFloats( data );        for ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {         path.quadraticCurveTo(         point.x + numbers[ j + 0 ],         point.y + numbers[ j + 1 ],         point.x + numbers[ j + 2 ],         point.y + numbers[ j + 3 ]        );        control.x = point.x + numbers[ j + 0 ];        control.y = point.y + numbers[ j + 1 ];        point.x += numbers[ j + 2 ];        point.y += numbers[ j + 3 ];         if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );        }        break;       case 't':       numbers = parseFloats( data );        for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {         const rx = getReflection( point.x, control.x );        const ry = getReflection( point.y, control.y );        path.quadraticCurveTo(         rx,         ry,         point.x + numbers[ j + 0 ],         point.y + numbers[ j + 1 ]        );        control.x = rx;        control.y = ry;        point.x = point.x + numbers[ j + 0 ];        point.y = point.y + numbers[ j + 1 ];         if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );        }        break;       case 'a':       numbers = parseFloats( data, [ 3, 4 ], 7 );        for ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {         // skip command if no displacement        if ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;         const start = point.clone();        point.x += numbers[ j + 5 ];        point.y += numbers[ j + 6 ];        control.x = point.x;        control.y = point.y;        parseArcCommand(         path, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point        );         if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );        }        break;       case 'Z':      case 'z':       path.currentPath.autoClose = true;        if ( path.currentPath.curves.length > 0 ) {         // Reset point to beginning of Path        point.copy( firstPoint );        path.currentPath.currentPoint.copy( point );        isFirstPoint = true;        }        break;       default:       console.warn( command );      }      // console.log( type, parseFloats( data ), parseFloats( data ).length  )      doSetFirstPoint = false;     }     return path;    }    function parseCSSStylesheet( node ) {     if ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;     for ( let i = 0; i < node.sheet.cssRules.length; i ++ ) {      const stylesheet = node.sheet.cssRules[ i ];      if ( stylesheet.type !== 1 ) continue;      const selectorList = stylesheet.selectorText      .split( /,/gm )      .filter( Boolean )      .map( i => i.trim() );      for ( let j = 0; j < selectorList.length; j ++ ) {       // Remove empty rules      const definitions = Object.fromEntries(       Object.entries( stylesheet.style ).filter( ( [ , v ] ) => v !== '' )      );       stylesheets[ selectorList[ j ] ] = Object.assign(       stylesheets[ selectorList[ j ] ] || {},       definitions      );      }     }    }    /**    * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes    * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion    * From    * rx ry x-axis-rotation large-arc-flag sweep-flag x y    * To    * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation    */    function parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {     if ( rx == 0 || ry == 0 ) {      // draw a line if either of the radii == 0     path.lineTo( end.x, end.y );     return;     }     x_axis_rotation = x_axis_rotation * Math.PI / 180;     // Ensure radii are positive    rx = Math.abs( rx );    ry = Math.abs( ry );     // Compute (x1', y1')    const dx2 = ( start.x - end.x ) / 2.0;    const dy2 = ( start.y - end.y ) / 2.0;    const x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;    const y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;     // Compute (cx', cy')    let rxs = rx * rx;    let rys = ry * ry;    const x1ps = x1p * x1p;    const y1ps = y1p * y1p;     // Ensure radii are large enough    const cr = x1ps / rxs + y1ps / rys;     if ( cr > 1 ) {      // scale up rx,ry equally so cr == 1     const s = Math.sqrt( cr );     rx = s * rx;     ry = s * ry;     rxs = rx * rx;     rys = ry * ry;     }     const dq = ( rxs * y1ps + rys * x1ps );    const pq = ( rxs * rys - dq ) / dq;    let q = Math.sqrt( Math.max( 0, pq ) );    if ( large_arc_flag === sweep_flag ) q = - q;    const cxp = q * rx * y1p / ry;    const cyp = - q * ry * x1p / rx;     // Step 3: Compute (cx, cy) from (cx', cy')    const cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;    const cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;     // Step 4: Compute 1 and "    const theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );    const delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );     path.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );    }    function svgAngle( ux, uy, vx, vy ) {     const dot = ux * vx + uy * vy;    const len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );    let ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear    if ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;    return ang;    }    /*   * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute   * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough   */   function parseRectNode( node ) {     const x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );    const y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );    const rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || node.getAttribute( 'ry' ) || 0 );    const ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || node.getAttribute( 'rx' ) || 0 );    const w = parseFloatWithUnits( node.getAttribute( 'width' ) );    const h = parseFloatWithUnits( node.getAttribute( 'height' ) );     // Ellipse arc to Bezier approximation Coefficient (Inversed). See:    // https://spencermortensen.com/articles/bezier-circle/    const bci = 1 - 0.551915024494;     const path = new ShapePath();     // top left    path.moveTo( x + rx, y );     // top right    path.lineTo( x + w - rx, y );    if ( rx !== 0 || ry !== 0 ) {      path.bezierCurveTo(      x + w - rx * bci,      y,      x + w,      y + ry * bci,      x + w,      y + ry     );     }     // bottom right    path.lineTo( x + w, y + h - ry );    if ( rx !== 0 || ry !== 0 ) {      path.bezierCurveTo(      x + w,      y + h - ry * bci,      x + w - rx * bci,      y + h,      x + w - rx,      y + h     );     }     // bottom left    path.lineTo( x + rx, y + h );    if ( rx !== 0 || ry !== 0 ) {      path.bezierCurveTo(      x + rx * bci,      y + h,      x,      y + h - ry * bci,      x,      y + h - ry     );     }     // back to top left    path.lineTo( x, y + ry );    if ( rx !== 0 || ry !== 0 ) {      path.bezierCurveTo( x, y + ry * bci, x + rx * bci, y, x + rx, y );     }     return path;    }    function parsePolygonNode( node ) {     function iterator( match, a, b ) {      const x = parseFloatWithUnits( a );     const y = parseFloatWithUnits( b );      if ( index === 0 ) {       path.moveTo( x, y );      } else {       path.lineTo( x, y );      }      index ++;     }     const regex = /([+-]?|d*|.?|d+(?:e[+-]?|d+)?)(?:,||s)([+-]?|d*|.?|d+(?:e[+-]?|d+)?)/g;     const path = new ShapePath();     let index = 0;     node.getAttribute( 'points' ).replace( regex, iterator );     path.currentPath.autoClose = true;     return path;    }    function parsePolylineNode( node ) {     function iterator( match, a, b ) {      const x = parseFloatWithUnits( a );     const y = parseFloatWithUnits( b );      if ( index === 0 ) {       path.moveTo( x, y );      } else {       path.lineTo( x, y );      }      index ++;     }     const regex = /([+-]?|d*|.?|d+(?:e[+-]?|d+)?)(?:,||s)([+-]?|d*|.?|d+(?:e[+-]?|d+)?)/g;     const path = new ShapePath();     let index = 0;     node.getAttribute( 'points' ).replace( regex, iterator );     path.currentPath.autoClose = false;     return path;    }    function parseCircleNode( node ) {     const x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );    const y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );    const r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 );     const subpath = new Path();    subpath.absarc( x, y, r, 0, Math.PI * 2 );     const path = new ShapePath();    path.subPaths.push( subpath );     return path;    }    function parseEllipseNode( node ) {     const x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );    const y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );    const rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );    const ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );     const subpath = new Path();    subpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );     const path = new ShapePath();    path.subPaths.push( subpath );     return path;    }    function parseLineNode( node ) {     const x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 );    const y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 );    const x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 );    const y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 );     const path = new ShapePath();    path.moveTo( x1, y1 );    path.lineTo( x2, y2 );    path.currentPath.autoClose = false;     return path;    }    //    function parseStyle( node, style ) {     style = Object.assign( {}, style ); // clone style     let stylesheetStyles = {};     if ( node.hasAttribute( 'class' ) ) {      const classSelectors = node.getAttribute( 'class' )      .split( /|s/ )      .filter( Boolean )      .map( i => i.trim() );      for ( let i = 0; i < classSelectors.length; i ++ ) {       stylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );      }     }     if ( node.hasAttribute( 'id' ) ) {      stylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );     }     function addStyle( svgName, jsName, adjustFunction ) {      if ( adjustFunction === undefined ) adjustFunction = function copy( v ) {       if ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );       return v;      };      if ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );     if ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );     if ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );     }     function clamp( v ) {      return Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );     }     function positive( v ) {      return Math.max( 0, parseFloatWithUnits( v ) );     }     addStyle( 'fill', 'fill' );    addStyle( 'fill-opacity', 'fillOpacity', clamp );    addStyle( 'fill-rule', 'fillRule' );    addStyle( 'opacity', 'opacity', clamp );    addStyle( 'stroke', 'stroke' );    addStyle( 'stroke-opacity', 'strokeOpacity', clamp );    addStyle( 'stroke-width', 'strokeWidth', positive );    addStyle( 'stroke-linejoin', 'strokeLineJoin' );    addStyle( 'stroke-linecap', 'strokeLineCap' );    addStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );    addStyle( 'visibility', 'visibility' );     return style;    }    // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes    function getReflection( a, b ) {     return a - ( b - a );    }    // from https://github.com/ppvg/svg-numbers (MIT License)    function parseFloats( input, flags, stride ) {     if ( typeof input !== 'string' ) {      throw new TypeError( 'Invalid input: ' + typeof input );     }     // Character groups    const RE = {     SEPARATOR: /[ |t|r|n|,.|-+]/,     WHITESPACE: /[ |t|r|n]/,     DIGIT: /[|d]/,     SIGN: /[-+]/,     POINT: /|./,     COMMA: /,/,     EXP: /e/i,     FLAGS: /[01]/    };     // States    const SEP = 0;    const INT = 1;    const FLOAT = 2;    const EXP = 3;     let state = SEP;    let seenComma = true;    let number = '', exponent = '';    const result = [];     function throwSyntaxError( current, i, partial ) {      const error = new SyntaxError( 'Unexpected character "' + current + '" at index ' + i + '.' );     error.partial = partial;     throw error;     }     function newNumber() {      if ( number !== '' ) {       if ( exponent === '' ) result.push( Number( number ) );      else result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );      }      number = '';     exponent = '';     }     let current;    const length = input.length;     for ( let i = 0; i < length; i ++ ) {      current = input[ i ];      // check for flags     if ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) {       state = INT;      number = current;      newNumber();      continue;      }      // parse until next number     if ( state === SEP ) {       // eat whitespace      if ( RE.WHITESPACE.test( current ) ) {        continue;       }       // start new number      if ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {        state = INT;       number = current;       continue;       }       if ( RE.POINT.test( current ) ) {        state = FLOAT;       number = current;       continue;       }       // throw on double commas (e.g. "1, , 2")      if ( RE.COMMA.test( current ) ) {        if ( seenComma ) {         throwSyntaxError( current, i, result );        }        seenComma = true;       }      }      // parse integer part     if ( state === INT ) {       if ( RE.DIGIT.test( current ) ) {        number += current;       continue;       }       if ( RE.POINT.test( current ) ) {        number += current;       state = FLOAT;       continue;       }       if ( RE.EXP.test( current ) ) {        state = EXP;       continue;       }       // throw on double signs ("-+1"), but not on sign as separator ("-1-2")      if ( RE.SIGN.test( current )        && number.length === 1        && RE.SIGN.test( number[ 0 ] ) ) {        throwSyntaxError( current, i, result );       }      }      // parse decimal part     if ( state === FLOAT ) {       if ( RE.DIGIT.test( current ) ) {        number += current;       continue;       }       if ( RE.EXP.test( current ) ) {        state = EXP;       continue;       }       // throw on double decimal points (e.g. "1..2")      if ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {        throwSyntaxError( current, i, result );       }      }      // parse exponent part     if ( state === EXP ) {       if ( RE.DIGIT.test( current ) ) {        exponent += current;       continue;       }       if ( RE.SIGN.test( current ) ) {        if ( exponent === '' ) {         exponent += current;        continue;        }        if ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {         throwSyntaxError( current, i, result );        }       }      }       // end of number     if ( RE.WHITESPACE.test( current ) ) {       newNumber();      state = SEP;      seenComma = false;      } else if ( RE.COMMA.test( current ) ) {       newNumber();      state = SEP;      seenComma = true;      } else if ( RE.SIGN.test( current ) ) {       newNumber();      state = INT;      number = current;      } else if ( RE.POINT.test( current ) ) {       newNumber();      state = FLOAT;      number = current;      } else {       throwSyntaxError( current, i, result );      }     }     // add the last number found (if any)    newNumber();     return result;    }    // Units    const units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];    // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)   const unitConversion = {     'mm': {     'mm': 1,     'cm': 0.1,     'in': 1 / 25.4,     'pt': 72 / 25.4,     'pc': 6 / 25.4,     'px': - 1    },    'cm': {     'mm': 10,     'cm': 1,     'in': 1 / 2.54,     'pt': 72 / 2.54,     'pc': 6 / 2.54,     'px': - 1    },    'in': {     'mm': 25.4,     'cm': 2.54,     'in': 1,     'pt': 72,     'pc': 6,     'px': - 1    },    'pt': {     'mm': 25.4 / 72,     'cm': 2.54 / 72,     'in': 1 / 72,     'pt': 1,     'pc': 6 / 72,     'px': - 1    },    'pc': {     'mm': 25.4 / 6,     'cm': 2.54 / 6,     'in': 1 / 6,     'pt': 72 / 6,     'pc': 1,     'px': - 1    },    'px': {     'px': 1    }    };    function parseFloatWithUnits( string ) {     let theUnit = 'px';     if ( typeof string === 'string' || string instanceof String ) {      for ( let i = 0, n = units.length; i < n; i ++ ) {       const u = units[ i ];       if ( string.endsWith( u ) ) {        theUnit = u;       string = string.substring( 0, string.length - u.length );       break;       }      }     }     let scale = undefined;     if ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {      // Conversion scale from  pixels to inches, then to default units      scale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;     } else {      scale = unitConversion[ theUnit ][ scope.defaultUnit ];      if ( scale < 0 ) {       // Conversion scale to pixels       scale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;      }     }     return scale * parseFloat( string );    }    // Transforms    function getNodeTransform( node ) {     if ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {      return null;     }     const transform = parseNodeTransform( node );     if ( transformStack.length > 0 ) {      transform.premultiply( transformStack[ transformStack.length - 1 ] );     }     currentTransform.copy( transform );    transformStack.push( transform );     return transform;    }    function parseNodeTransform( node ) {     const transform = new Matrix3();    const currentTransform = tempTransform0;     if ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {      const tx = parseFloatWithUnits( node.getAttribute( 'x' ) );     const ty = parseFloatWithUnits( node.getAttribute( 'y' ) );      transform.translate( tx, ty );     }     if ( node.hasAttribute( 'transform' ) ) {      const transformsTexts = node.getAttribute( 'transform' ).split( ')' );      for ( let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {       const transformText = transformsTexts[ tIndex ].trim();       if ( transformText === '' ) continue;       const openParPos = transformText.indexOf( '(' );      const closeParPos = transformText.length;       if ( openParPos > 0 && openParPos < closeParPos ) {        const transformType = transformText.slice( 0, openParPos );        const array = parseFloats( transformText.slice( openParPos + 1 ) );        currentTransform.identity();        switch ( transformType ) {         case 'translate':          if ( array.length >= 1 ) {           const tx = array[ 0 ];          let ty = 0;           if ( array.length >= 2 ) {            ty = array[ 1 ];           }           currentTransform.translate( tx, ty );          }          break;         case 'rotate':          if ( array.length >= 1 ) {           let angle = 0;          let cx = 0;          let cy = 0;           // Angle          angle = array[ 0 ] * Math.PI / 180;           if ( array.length >= 3 ) {            // Center x, y           cx = array[ 1 ];           cy = array[ 2 ];           }           // Rotate around center (cx, cy)          tempTransform1.makeTranslation( - cx, - cy );          tempTransform2.makeRotation( angle );          tempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );          tempTransform1.makeTranslation( cx, cy );          currentTransform.multiplyMatrices( tempTransform1, tempTransform3 );          }          break;         case 'scale':          if ( array.length >= 1 ) {           const scaleX = array[ 0 ];          let scaleY = scaleX;           if ( array.length >= 2 ) {            scaleY = array[ 1 ];           }           currentTransform.scale( scaleX, scaleY );          }          break;         case 'skewX':          if ( array.length === 1 ) {           currentTransform.set(           1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,           0, 1, 0,           0, 0, 1          );          }          break;         case 'skewY':          if ( array.length === 1 ) {           currentTransform.set(           1, 0, 0,           Math.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,           0, 0, 1          );          }          break;         case 'matrix':          if ( array.length === 6 ) {           currentTransform.set(           array[ 0 ], array[ 2 ], array[ 4 ],           array[ 1 ], array[ 3 ], array[ 5 ],           0, 0, 1          );          }          break;        }       }       transform.premultiply( currentTransform );      }     }     return transform;    }    function transformPath( path, m ) {     function transfVec2( v2 ) {      tempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );      v2.set( tempV3.x, tempV3.y );     }     function transfEllipseGeneric( curve ) {      // For math description see:     // https://math.stackexchange.com/questions/4544164      const a = curve.xRadius;     const b = curve.yRadius;      const cosTheta = Math.cos( curve.aRotation );     const sinTheta = Math.sin( curve.aRotation );      const v1 = new Vector3( a * cosTheta, a * sinTheta, 0 );     const v2 = new Vector3( - b * sinTheta, b * cosTheta, 0 );      const f1 = v1.applyMatrix3( m );     const f2 = v2.applyMatrix3( m );      const mF = tempTransform0.set(      f1.x, f2.x, 0,      f1.y, f2.y, 0,      0, 0, 1,     );      const mFInv = tempTransform1.copy( mF ).invert();     const mFInvT = tempTransform2.copy( mFInv ).transpose();     const mQ = mFInvT.multiply( mFInv );     const mQe = mQ.elements;      const ed = eigenDecomposition( mQe[ 0 ], mQe[ 1 ], mQe[ 4 ] );     const rt1sqrt = Math.sqrt( ed.rt1 );     const rt2sqrt = Math.sqrt( ed.rt2 );      curve.xRadius = 1 / rt1sqrt;     curve.yRadius = 1 / rt2sqrt;     curve.aRotation = Math.atan2( ed.sn, ed.cs );      const isFullEllipse =      ( curve.aEndAngle - curve.aStartAngle ) % ( 2 * Math.PI ) < Number.EPSILON;      // Do not touch angles of a full ellipse because after transformation they     // would converge to a sinle value effectively removing the whole curve      if ( ! isFullEllipse ) {       const mDsqrt = tempTransform1.set(       rt1sqrt, 0, 0,       0, rt2sqrt, 0,       0, 0, 1,      );       const mRT = tempTransform2.set(       ed.cs, ed.sn, 0,       - ed.sn, ed.cs, 0,       0, 0, 1,      );       const mDRF = mDsqrt.multiply( mRT ).multiply( mF );       const transformAngle = phi => {        const { x: cosR, y: sinR } =        new Vector3( Math.cos( phi ), Math.sin( phi ), 0 ).applyMatrix3( mDRF );        return Math.atan2( sinR, cosR );       };       curve.aStartAngle = transformAngle( curve.aStartAngle );      curve.aEndAngle = transformAngle( curve.aEndAngle );       if ( isTransformFlipped( m ) ) {        curve.aClockwise = ! curve.aClockwise;       }      }     }     function transfEllipseNoSkew( curve ) {      // Faster shortcut if no skew is applied     // (e.g, a euclidean transform of a group containing the ellipse)      const sx = getTransformScaleX( m );     const sy = getTransformScaleY( m );      curve.xRadius *= sx;     curve.yRadius *= sy;      // Extract rotation angle from the matrix of form:     //     //  | cos sx   -sin sy |     //  | sin sx    cos sy |     //     // Remembering that tan = sin / cos; and that     // |sx|, |sy|, or both might be zero.     const theta =      sx > Number.EPSILON       ? Math.atan2( m.elements[ 1 ], m.elements[ 0 ] )       : Math.atan2( - m.elements[ 3 ], m.elements[ 4 ] );      curve.aRotation += theta;      if ( isTransformFlipped( m ) ) {       curve.aStartAngle *= - 1;      curve.aEndAngle *= - 1;      curve.aClockwise = ! curve.aClockwise;      }     }     const subPaths = path.subPaths;     for ( let i = 0, n = subPaths.length; i < n; i ++ ) {      const subPath = subPaths[ i ];     const curves = subPath.curves;      for ( let j = 0; j < curves.length; j ++ ) {       const curve = curves[ j ];       if ( curve.isLineCurve ) {        transfVec2( curve.v1 );       transfVec2( curve.v2 );       } else if ( curve.isCubicBezierCurve ) {        transfVec2( curve.v0 );       transfVec2( curve.v1 );       transfVec2( curve.v2 );       transfVec2( curve.v3 );       } else if ( curve.isQuadraticBezierCurve ) {        transfVec2( curve.v0 );       transfVec2( curve.v1 );       transfVec2( curve.v2 );       } else if ( curve.isEllipseCurve ) {        // Transform ellipse center point        tempV2.set( curve.aX, curve.aY );       transfVec2( tempV2 );       curve.aX = tempV2.x;       curve.aY = tempV2.y;        // Transform ellipse shape parameters        if ( isTransformSkewed( m ) ) {         transfEllipseGeneric( curve );        } else {         transfEllipseNoSkew( curve );        }       }      }     }    }    function isTransformFlipped( m ) {     const te = m.elements;    return te[ 0 ] * te[ 4 ] - te[ 1 ] * te[ 3 ] < 0;    }    function isTransformSkewed( m ) {     const te = m.elements;    const basisDot = te[ 0 ] * te[ 3 ] + te[ 1 ] * te[ 4 ];     // Shortcut for trivial rotations and transformations    if ( basisDot === 0 ) return false;     const sx = getTransformScaleX( m );    const sy = getTransformScaleY( m );     return Math.abs( basisDot / ( sx * sy ) ) > Number.EPSILON;    }    function getTransformScaleX( m ) {     const te = m.elements;    return Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );    }    function getTransformScaleY( m ) {     const te = m.elements;    return Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );    }    // Calculates the eigensystem of a real symmetric 2x2 matrix   //    [ A  B ]   //    [ B  C ]   // in the form   //    [ A  B ]  =  [ cs  -sn ] [ rt1   0  ] [  cs  sn ]   //    [ B  C ]     [ sn   cs ] [  0   rt2 ] [ -sn  cs ]   // where rt1 >= rt2.   //   // Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html   // -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric)   function eigenDecomposition( A, B, C ) {     let rt1, rt2, cs, sn, t;    const sm = A + C;    const df = A - C;    const rt = Math.sqrt( df * df + 4 * B * B );     if ( sm > 0 ) {      rt1 = 0.5 * ( sm + rt );     t = 1 / rt1;     rt2 = A * t * C - B * t * B;     } else if ( sm < 0 ) {      rt2 = 0.5 * ( sm - rt );     } else {      // This case needs to be treated separately to avoid div by 0      rt1 = 0.5 * rt;     rt2 = - 0.5 * rt;     }     // Calculate eigenvectors     if ( df > 0 ) {      cs = df + rt;     } else {      cs = df - rt;     }     if ( Math.abs( cs ) > 2 * Math.abs( B ) ) {      t = - 2 * B / cs;     sn = 1 / Math.sqrt( 1 + t * t );     cs = t * sn;     } else if ( Math.abs( B ) === 0 ) {      cs = 1;     sn = 0;     } else {      t = - 0.5 * cs / B;     cs = 1 / Math.sqrt( 1 + t * t );     sn = t * cs;     }     if ( df > 0 ) {      t = cs;     cs = - sn;     sn = t;     }     return { rt1, rt2, cs, sn };    }    //    const paths = [];   const stylesheets = {};    const transformStack = [];    const tempTransform0 = new Matrix3();   const tempTransform1 = new Matrix3();   const tempTransform2 = new Matrix3();   const tempTransform3 = new Matrix3();   const tempV2 = new Vector2();   const tempV3 = new Vector3();    const currentTransform = new Matrix3();    const xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml    parseNode( xml.documentElement, {    fill: '#000',    fillOpacity: 1,    strokeOpacity: 1,    strokeWidth: 1,    strokeLineJoin: 'miter',    strokeLineCap: 'butt',    strokeMiterLimit: 4   } );    const data = { paths: paths, xml: xml.documentElement };    // console.log( paths );   return data;   }   static createShapes( shapePath ) {    // Param shapePath: a shapepath as returned by the parse function of this class   // Returns Shape object    const BIGNUMBER = 999999999;    const IntersectionLocationType = {    ORIGIN: 0,    DESTINATION: 1,    BETWEEN: 2,    LEFT: 3,    RIGHT: 4,    BEHIND: 5,    BEYOND: 6   };    const classifyResult = {    loc: IntersectionLocationType.ORIGIN,    t: 0   };    function findEdgeIntersection( a0, a1, b0, b1 ) {     const x1 = a0.x;    const x2 = a1.x;    const x3 = b0.x;    const x4 = b1.x;    const y1 = a0.y;    const y2 = a1.y;    const y3 = b0.y;    const y4 = b1.y;    const nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );    const nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );    const denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );    const t1 = nom1 / denom;    const t2 = nom2 / denom;     if ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 <= 0 ) || ( t1 >= 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) {      //1. lines are parallel or edges don't intersect      return null;     } else if ( ( nom1 === 0 ) && ( denom === 0 ) ) {      //2. lines are colinear      //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)     for ( let i = 0; i < 2; i ++ ) {       classifyPoint( i === 0 ? b0 : b1, a0, a1 );      //find position of this endpoints relatively to edge1      if ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {        const point = ( i === 0 ? b0 : b1 );       return { x: point.x, y: point.y, t: classifyResult.t };       } else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) {        const x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) );       const y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) );       return { x: x, y: y, t: classifyResult.t, };       }      }      return null;     } else {      //3. edges intersect      for ( let i = 0; i < 2; i ++ ) {       classifyPoint( i === 0 ? b0 : b1, a0, a1 );       if ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {        const point = ( i === 0 ? b0 : b1 );       return { x: point.x, y: point.y, t: classifyResult.t };       }      }      const x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) );     const y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) );     return { x: x, y: y, t: t1 };     }    }    function classifyPoint( p, edgeStart, edgeEnd ) {     const ax = edgeEnd.x - edgeStart.x;    const ay = edgeEnd.y - edgeStart.y;    const bx = p.x - edgeStart.x;    const by = p.y - edgeStart.y;    const sa = ax * by - bx * ay;     if ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) {      classifyResult.loc = IntersectionLocationType.ORIGIN;     classifyResult.t = 0;     return;     }     if ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) {      classifyResult.loc = IntersectionLocationType.DESTINATION;     classifyResult.t = 1;     return;     }     if ( sa < - Number.EPSILON ) {      classifyResult.loc = IntersectionLocationType.LEFT;     return;     }     if ( sa > Number.EPSILON ) {      classifyResult.loc = IntersectionLocationType.RIGHT;     return;      }     if ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) {      classifyResult.loc = IntersectionLocationType.BEHIND;     return;     }     if ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) {      classifyResult.loc = IntersectionLocationType.BEYOND;     return;     }     let t;     if ( ax !== 0 ) {      t = bx / ax;     } else {      t = by / ay;     }     classifyResult.loc = IntersectionLocationType.BETWEEN;    classifyResult.t = t;    }    function getIntersections( path1, path2 ) {     const intersectionsRaw = [];    const intersections = [];     for ( let index = 1; index < path1.length; index ++ ) {      const path1EdgeStart = path1[ index - 1 ];     const path1EdgeEnd = path1[ index ];      for ( let index2 = 1; index2 < path2.length; index2 ++ ) {       const path2EdgeStart = path2[ index2 - 1 ];      const path2EdgeEnd = path2[ index2 ];       const intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd );       if ( intersection !== null && intersectionsRaw.find( i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON ) === undefined ) {        intersectionsRaw.push( intersection );       intersections.push( new Vector2( intersection.x, intersection.y ) );       }      }     }     return intersections;    }    function getScanlineIntersections( scanline, boundingBox, paths ) {     const center = new Vector2();    boundingBox.getCenter( center );     const allIntersections = [];     paths.forEach( path => {      // check if the center of the bounding box is in the bounding box of the paths.     // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.     // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.     if ( path.boundingBox.containsPoint( center ) ) {       const intersections = getIntersections( scanline, path.points );       intersections.forEach( p => {        allIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } );       } );      }     } );     allIntersections.sort( ( i1, i2 ) => {      return i1.point.x - i2.point.x;     } );     return allIntersections;    }    function isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) {     if ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) {      _fillRule = 'nonzero';     }     const centerBoundingBox = new Vector2();    simplePath.boundingBox.getCenter( centerBoundingBox );     const scanline = [ new Vector2( scanlineMinX, centerBoundingBox.y ), new Vector2( scanlineMaxX, centerBoundingBox.y ) ];     const scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths );     scanlineIntersections.sort( ( i1, i2 ) => {      return i1.point.x - i2.point.x;     } );     const baseIntersections = [];    const otherIntersections = [];     scanlineIntersections.forEach( i => {      if ( i.identifier === simplePath.identifier ) {       baseIntersections.push( i );      } else {       otherIntersections.push( i );      }     } );     const firstXOfPath = baseIntersections[ 0 ].point.x;     // build up the path hierarchy    const stack = [];    let i = 0;     while ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) {      if ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) {       stack.pop();      } else {       stack.push( otherIntersections[ i ].identifier );      }      i ++;     }     stack.push( simplePath.identifier );     if ( _fillRule === 'evenodd' ) {      const isHole = stack.length % 2 === 0 ? true : false;     const isHoleFor = stack[ stack.length - 2 ];      return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };     } else if ( _fillRule === 'nonzero' ) {      // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.     let isHole = true;     let isHoleFor = null;     let lastCWValue = null;      for ( let i = 0; i < stack.length; i ++ ) {       const identifier = stack[ i ];      if ( isHole ) {        lastCWValue = allPaths[ identifier ].isCW;       isHole = false;       isHoleFor = identifier;       } else if ( lastCWValue !== allPaths[ identifier ].isCW ) {        lastCWValue = allPaths[ identifier ].isCW;       isHole = true;       }      }      return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };     } else {      console.warn( 'fill-rule: "' + _fillRule + '" is currently not implemented.' );     }    }    // check for self intersecting paths   // TODO    // check intersecting paths   // TODO    // prepare paths for hole detection   let scanlineMinX = BIGNUMBER;   let scanlineMaxX = - BIGNUMBER;    let simplePaths = shapePath.subPaths.map( p => {     const points = p.getPoints();    let maxY = - BIGNUMBER;    let minY = BIGNUMBER;    let maxX = - BIGNUMBER;    let minX = BIGNUMBER;          //points.forEach(p => p.y *= -1);     for ( let i = 0; i < points.length; i ++ ) {      const p = points[ i ];      if ( p.y > maxY ) {       maxY = p.y;      }      if ( p.y < minY ) {       minY = p.y;      }      if ( p.x > maxX ) {       maxX = p.x;      }      if ( p.x < minX ) {       minX = p.x;      }     }     //    if ( scanlineMaxX <= maxX ) {      scanlineMaxX = maxX + 1;     }     if ( scanlineMinX >= minX ) {      scanlineMinX = minX - 1;     }     return { curves: p.curves, points: points, isCW: ShapeUtils.isClockWise( points ), identifier: - 1, boundingBox: new Box2( new Vector2( minX, minY ), new Vector2( maxX, maxY ) ) };    } );    simplePaths = simplePaths.filter( sp => sp.points.length > 1 );    for ( let identifier = 0; identifier < simplePaths.length; identifier ++ ) {     simplePaths[ identifier ].identifier = identifier;    }    // check if path is solid or a hole   const isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, ( shapePath.userData ? shapePath.userData.style.fillRule : undefined ) ) );     const shapesToReturn = [];   simplePaths.forEach( p => {     const amIAHole = isAHole[ p.identifier ];     if ( ! amIAHole.isHole ) {      const shape = new Shape();     shape.curves = p.curves;     const holes = isAHole.filter( h => h.isHole && h.for === p.identifier );     holes.forEach( h => {       const hole = simplePaths[ h.identifier ];      const path = new Path();      path.curves = hole.curves;      shape.holes.push( path );      } );     shapesToReturn.push( shape );     }    } );    return shapesToReturn;   }   static getStrokeStyle( width, color, lineJoin, lineCap, miterLimit ) {    // Param width: Stroke width   // Param color: As returned by THREE.Color.getStyle()   // Param lineJoin: One of "round", "bevel", "miter" or "miter-limit"   // Param lineCap: One of "round", "square" or "butt"   // Param miterLimit: Maximum join length, in multiples of the "width" parameter (join is truncated if it exceeds that distance)   // Returns style object    width = width !== undefined ? width : 1;   color = color !== undefined ? color : '#000';   lineJoin = lineJoin !== undefined ? lineJoin : 'miter';   lineCap = lineCap !== undefined ? lineCap : 'butt';   miterLimit = miterLimit !== undefined ? miterLimit : 4;    return {    strokeColor: color,    strokeWidth: width,    strokeLineJoin: lineJoin,    strokeLineCap: lineCap,    strokeMiterLimit: miterLimit   };   }   static pointsToStroke( points, style, arcDivisions, minDistance ) {    // Generates a stroke with some width around the given path.   // The path can be open or closed (last point equals to first point)   // Param points: Array of Vector2D (the path). Minimum 2 points.   // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object   // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)   // Param minDistance: Points closer to this distance will be merged. (Optional)   // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)    const vertices = [];   const normals = [];   const uvs = [];    if ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {     return null;    }    const geometry = new BufferGeometry();   geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );   geometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );   geometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );    return geometry;   }   static pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {    // This function can be called to update existing arrays or buffers.   // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.   // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)   // Returns number of written vertices / normals / uvs pairs   // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)   // 'normals' and 'uvs' buffers are optional    const tempV2_1 = new Vector2();   const tempV2_2 = new Vector2();   const tempV2_3 = new Vector2();   const tempV2_4 = new Vector2();   const tempV2_5 = new Vector2();   const tempV2_6 = new Vector2();   const tempV2_7 = new Vector2();   const lastPointL = new Vector2();   const lastPointR = new Vector2();   const point0L = new Vector2();   const point0R = new Vector2();   const currentPointL = new Vector2();   const currentPointR = new Vector2();   const nextPointL = new Vector2();   const nextPointR = new Vector2();   const innerPoint = new Vector2();   const outerPoint = new Vector2();    arcDivisions = arcDivisions !== undefined ? arcDivisions : 12;   minDistance = minDistance !== undefined ? minDistance : 0.001;   vertexOffset = vertexOffset !== undefined ? vertexOffset : 0;    // First ensure there are no duplicated points   points = removeDuplicatedPoints( points );    const numPoints = points.length;    if ( numPoints < 2 ) return 0;    const isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );    let currentPoint;   let previousPoint = points[ 0 ];   let nextPoint;    const strokeWidth2 = style.strokeWidth / 2;    const deltaU = 1 / ( numPoints - 1 );   let u0 = 0, u1;    let innerSideModified;   let joinIsOnLeftSide;   let isMiter;   let initialJoinIsOnLeftSide = false;    let numVertices = 0;   let currentCoordinate = vertexOffset * 3;   let currentCoordinateUV = vertexOffset * 2;    // Get initial left and right stroke points   getNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );   lastPointL.copy( points[ 0 ] ).sub( tempV2_1 );   lastPointR.copy( points[ 0 ] ).add( tempV2_1 );   point0L.copy( lastPointL );   point0R.copy( lastPointR );    for ( let iPoint = 1; iPoint < numPoints; iPoint ++ ) {     currentPoint = points[ iPoint ];     // Get next point    if ( iPoint === numPoints - 1 ) {      if ( isClosed ) {       // Skip duplicated initial point      nextPoint = points[ 1 ];      } else nextPoint = undefined;     } else {      nextPoint = points[ iPoint + 1 ];     }     // Normal of previous segment in tempV2_1    const normal1 = tempV2_1;    getNormal( previousPoint, currentPoint, normal1 );     tempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );    currentPointL.copy( currentPoint ).sub( tempV2_3 );    currentPointR.copy( currentPoint ).add( tempV2_3 );     u1 = u0 + deltaU;     innerSideModified = false;     if ( nextPoint !== undefined ) {      // Normal of next segment in tempV2_2     getNormal( currentPoint, nextPoint, tempV2_2 );      tempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );     nextPointL.copy( currentPoint ).sub( tempV2_3 );     nextPointR.copy( currentPoint ).add( tempV2_3 );      joinIsOnLeftSide = true;     tempV2_3.subVectors( nextPoint, previousPoint );     if ( normal1.dot( tempV2_3 ) < 0 ) {       joinIsOnLeftSide = false;      }      if ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;      tempV2_3.subVectors( nextPoint, currentPoint );     tempV2_3.normalize();     const dot = Math.abs( normal1.dot( tempV2_3 ) );      // If path is straight, don't create join     if ( dot > Number.EPSILON ) {       // Compute inner and outer segment intersections      const miterSide = strokeWidth2 / dot;      tempV2_3.multiplyScalar( - miterSide );      tempV2_4.subVectors( currentPoint, previousPoint );      tempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );      innerPoint.copy( tempV2_5 ).negate();      const miterLength2 = tempV2_5.length();      const segmentLengthPrev = tempV2_4.length();      tempV2_4.divideScalar( segmentLengthPrev );      tempV2_6.subVectors( nextPoint, currentPoint );      const segmentLengthNext = tempV2_6.length();      tempV2_6.divideScalar( segmentLengthNext );      // Check that previous and next segments doesn't overlap with the innerPoint of intersection      if ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {        innerSideModified = true;       }       outerPoint.copy( tempV2_5 ).add( currentPoint );      innerPoint.add( currentPoint );       isMiter = false;       if ( innerSideModified ) {        if ( joinIsOnLeftSide ) {         nextPointR.copy( innerPoint );        currentPointR.copy( innerPoint );        } else {         nextPointL.copy( innerPoint );        currentPointL.copy( innerPoint );        }       } else {        // The segment triangles are generated here if there was overlapping        makeSegmentTriangles();       }       switch ( style.strokeLineJoin ) {        case 'bevel':         makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );         break;        case 'round':         // Segment triangles         createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );         // Join triangles         if ( joinIsOnLeftSide ) {          makeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );         } else {          makeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );         }         break;        case 'miter':       case 'miter-clip':       default:         const miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;         if ( miterFraction < 1 ) {          // The join miter length exceeds the miter limit          if ( style.strokeLineJoin !== 'miter-clip' ) {           makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );          break;          } else {           // Segment triangles           createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );           // Miter-clip join triangles           if ( joinIsOnLeftSide ) {            tempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );           tempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );            addVertex( currentPointL, u1, 0 );           addVertex( tempV2_6, u1, 0 );           addVertex( currentPoint, u1, 0.5 );            addVertex( currentPoint, u1, 0.5 );           addVertex( tempV2_6, u1, 0 );           addVertex( tempV2_7, u1, 0 );            addVertex( currentPoint, u1, 0.5 );           addVertex( tempV2_7, u1, 0 );           addVertex( nextPointL, u1, 0 );           } else {            tempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );           tempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );            addVertex( currentPointR, u1, 1 );           addVertex( tempV2_6, u1, 1 );           addVertex( currentPoint, u1, 0.5 );            addVertex( currentPoint, u1, 0.5 );           addVertex( tempV2_6, u1, 1 );           addVertex( tempV2_7, u1, 1 );            addVertex( currentPoint, u1, 0.5 );           addVertex( tempV2_7, u1, 1 );           addVertex( nextPointR, u1, 1 );           }          }         } else {          // Miter join segment triangles          if ( innerSideModified ) {           // Optimized segment + join triangles           if ( joinIsOnLeftSide ) {            addVertex( lastPointR, u0, 1 );           addVertex( lastPointL, u0, 0 );           addVertex( outerPoint, u1, 0 );            addVertex( lastPointR, u0, 1 );           addVertex( outerPoint, u1, 0 );           addVertex( innerPoint, u1, 1 );           } else {            addVertex( lastPointR, u0, 1 );           addVertex( lastPointL, u0, 0 );           addVertex( outerPoint, u1, 1 );            addVertex( lastPointL, u0, 0 );           addVertex( innerPoint, u1, 0 );           addVertex( outerPoint, u1, 1 );           }            if ( joinIsOnLeftSide ) {            nextPointL.copy( outerPoint );           } else {            nextPointR.copy( outerPoint );           }           } else {           // Add extra miter join triangles           if ( joinIsOnLeftSide ) {            addVertex( currentPointL, u1, 0 );           addVertex( outerPoint, u1, 0 );           addVertex( currentPoint, u1, 0.5 );            addVertex( currentPoint, u1, 0.5 );           addVertex( outerPoint, u1, 0 );           addVertex( nextPointL, u1, 0 );           } else {            addVertex( currentPointR, u1, 1 );           addVertex( outerPoint, u1, 1 );           addVertex( currentPoint, u1, 0.5 );            addVertex( currentPoint, u1, 0.5 );           addVertex( outerPoint, u1, 1 );           addVertex( nextPointR, u1, 1 );           }          }          isMiter = true;         }         break;       }      } else {       // The segment triangles are generated here when two consecutive points are collinear       makeSegmentTriangles();      }     } else {      // The segment triangles are generated here if it is the ending segment      makeSegmentTriangles();     }     if ( ! isClosed && iPoint === numPoints - 1 ) {      // Start line endcap     addCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );     }     // Increment loop variables     u0 = u1;     previousPoint = currentPoint;     lastPointL.copy( nextPointL );    lastPointR.copy( nextPointR );    }    if ( ! isClosed ) {     // Ending line endcap    addCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );    } else if ( innerSideModified && vertices ) {     // Modify path first segment vertices to adjust to the segments inner and outer intersections     let lastOuter = outerPoint;    let lastInner = innerPoint;     if ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {      lastOuter = innerPoint;     lastInner = outerPoint;     }     if ( joinIsOnLeftSide ) {      if ( isMiter || initialJoinIsOnLeftSide ) {       lastInner.toArray( vertices, 0 * 3 );      lastInner.toArray( vertices, 3 * 3 );       if ( isMiter ) {        lastOuter.toArray( vertices, 1 * 3 );       }      }     } else {      if ( isMiter || ! initialJoinIsOnLeftSide ) {       lastInner.toArray( vertices, 1 * 3 );      lastInner.toArray( vertices, 3 * 3 );       if ( isMiter ) {        lastOuter.toArray( vertices, 0 * 3 );       }      }     }    }    return numVertices;    // -- End of algorithm    // -- Functions    function getNormal( p1, p2, result ) {     result.subVectors( p2, p1 );    return result.set( - result.y, result.x ).normalize();    }    function addVertex( position, u, v ) {     if ( vertices ) {      vertices[ currentCoordinate ] = position.x;     vertices[ currentCoordinate + 1 ] = position.y;     vertices[ currentCoordinate + 2 ] = 0;      if ( normals ) {       normals[ currentCoordinate ] = 0;      normals[ currentCoordinate + 1 ] = 0;      normals[ currentCoordinate + 2 ] = 1;      }      currentCoordinate += 3;      if ( uvs ) {       uvs[ currentCoordinateUV ] = u;      uvs[ currentCoordinateUV + 1 ] = v;       currentCoordinateUV += 2;      }     }     numVertices += 3;    }    function makeCircularSector( center, p1, p2, u, v ) {     // param p1, p2: Points in the circle arc.    // p1 and p2 are in clockwise direction.     tempV2_1.copy( p1 ).sub( center ).normalize();    tempV2_2.copy( p2 ).sub( center ).normalize();     let angle = Math.PI;    const dot = tempV2_1.dot( tempV2_2 );    if ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );     angle /= arcDivisions;     tempV2_3.copy( p1 );     for ( let i = 0, il = arcDivisions - 1; i < il; i ++ ) {      tempV2_4.copy( tempV2_3 ).rotateAround( center, angle );      addVertex( tempV2_3, u, v );     addVertex( tempV2_4, u, v );     addVertex( center, u, 0.5 );      tempV2_3.copy( tempV2_4 );     }     addVertex( tempV2_4, u, v );    addVertex( p2, u, v );    addVertex( center, u, 0.5 );    }    function makeSegmentTriangles() {     addVertex( lastPointR, u0, 1 );    addVertex( lastPointL, u0, 0 );    addVertex( currentPointL, u1, 0 );     addVertex( lastPointR, u0, 1 );    addVertex( currentPointL, u1, 0 );    addVertex( currentPointR, u1, 1 );    }    function makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {     if ( innerSideModified ) {      // Optimized segment + bevel triangles      if ( joinIsOnLeftSide ) {       // Path segments triangles       addVertex( lastPointR, u0, 1 );      addVertex( lastPointL, u0, 0 );      addVertex( currentPointL, u1, 0 );       addVertex( lastPointR, u0, 1 );      addVertex( currentPointL, u1, 0 );      addVertex( innerPoint, u1, 1 );       // Bevel join triangle       addVertex( currentPointL, u, 0 );      addVertex( nextPointL, u, 0 );      addVertex( innerPoint, u, 0.5 );      } else {       // Path segments triangles       addVertex( lastPointR, u0, 1 );      addVertex( lastPointL, u0, 0 );      addVertex( currentPointR, u1, 1 );       addVertex( lastPointL, u0, 0 );      addVertex( innerPoint, u1, 0 );      addVertex( currentPointR, u1, 1 );       // Bevel join triangle       addVertex( currentPointR, u, 1 );      addVertex( innerPoint, u, 0 );      addVertex( nextPointR, u, 1 );      }     } else {      // Bevel join triangle. The segment triangles are done in the main loop      if ( joinIsOnLeftSide ) {       addVertex( currentPointL, u, 0 );      addVertex( nextPointL, u, 0 );      addVertex( currentPoint, u, 0.5 );      } else {       addVertex( currentPointR, u, 1 );      addVertex( nextPointR, u, 0 );      addVertex( currentPoint, u, 0.5 );      }     }    }    function createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {     if ( innerSideModified ) {      if ( joinIsOnLeftSide ) {       addVertex( lastPointR, u0, 1 );      addVertex( lastPointL, u0, 0 );      addVertex( currentPointL, u1, 0 );       addVertex( lastPointR, u0, 1 );      addVertex( currentPointL, u1, 0 );      addVertex( innerPoint, u1, 1 );       addVertex( currentPointL, u0, 0 );      addVertex( currentPoint, u1, 0.5 );      addVertex( innerPoint, u1, 1 );       addVertex( currentPoint, u1, 0.5 );      addVertex( nextPointL, u0, 0 );      addVertex( innerPoint, u1, 1 );      } else {       addVertex( lastPointR, u0, 1 );      addVertex( lastPointL, u0, 0 );      addVertex( currentPointR, u1, 1 );       addVertex( lastPointL, u0, 0 );      addVertex( innerPoint, u1, 0 );      addVertex( currentPointR, u1, 1 );       addVertex( currentPointR, u0, 1 );      addVertex( innerPoint, u1, 0 );      addVertex( currentPoint, u1, 0.5 );       addVertex( currentPoint, u1, 0.5 );      addVertex( innerPoint, u1, 0 );      addVertex( nextPointR, u0, 1 );      }     }    }    function addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {     // param center: End point of the path    // param p1, p2: Left and right cap points     switch ( style.strokeLineCap ) {      case 'round':       if ( start ) {        makeCircularSector( center, p2, p1, u, 0.5 );       } else {        makeCircularSector( center, p1, p2, u, 0.5 );       }       break;      case 'square':       if ( start ) {        tempV2_1.subVectors( p1, center );       tempV2_2.set( tempV2_1.y, - tempV2_1.x );        tempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );       tempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );        // Modify already existing vertices       if ( joinIsOnLeftSide ) {         tempV2_3.toArray( vertices, 1 * 3 );        tempV2_4.toArray( vertices, 0 * 3 );        tempV2_4.toArray( vertices, 3 * 3 );        } else {         tempV2_3.toArray( vertices, 1 * 3 );        // using tempV2_4 to update 3rd vertex if the uv.y of 3rd vertex is 1        uvs[ 3 * 2 + 1 ] === 1 ? tempV2_4.toArray( vertices, 3 * 3 ) : tempV2_3.toArray( vertices, 3 * 3 );        tempV2_4.toArray( vertices, 0 * 3 );        }       } else {        tempV2_1.subVectors( p2, center );       tempV2_2.set( tempV2_1.y, - tempV2_1.x );        tempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );       tempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );        const vl = vertices.length;        // Modify already existing vertices       if ( joinIsOnLeftSide ) {         tempV2_3.toArray( vertices, vl - 1 * 3 );        tempV2_4.toArray( vertices, vl - 2 * 3 );        tempV2_4.toArray( vertices, vl - 4 * 3 );        } else {         tempV2_4.toArray( vertices, vl - 2 * 3 );        tempV2_3.toArray( vertices, vl - 1 * 3 );        tempV2_4.toArray( vertices, vl - 4 * 3 );        }       }       break;      case 'butt':     default:       // Nothing to do here      break;     }    }    function removeDuplicatedPoints( points ) {     // Creates a new array if necessary with duplicated points removed.    // This does not remove duplicated initial and ending points of a closed path.     let dupPoints = false;    for ( let i = 1, n = points.length - 1; i < n; i ++ ) {      if ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {       dupPoints = true;      break;      }     }     if ( ! dupPoints ) return points;     const newPoints = [];    newPoints.push( points[ 0 ] );     for ( let i = 1, n = points.length - 1; i < n; i ++ ) {      if ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {       newPoints.push( points[ i ] );      }     }     newPoints.push( points[ points.length - 1 ] );     return newPoints;    }   }   }  export { SVGLoader }; 
^..^ FILENAME ^..^
addons|loaders|TDSLoader.js
^..^ CONTENTS ^..^
import {  AdditiveBlending,  BufferGeometry,  Color,  DoubleSide,  FileLoader,  Float32BufferAttribute,  Group,  Loader,  LoaderUtils,  Matrix4,  Mesh,  MeshPhongMaterial,  TextureLoader } from 'three';  /**  * Autodesk 3DS three.js file loader, based on lib3ds.  *  * Loads geometry with uv and materials basic properties with texture support.  *  * @class TDSLoader  * @constructor  */  class TDSLoader extends Loader {   constructor( manager ) {    super( manager );    this.debug = false;    this.group = null;    this.materials = [];   this.meshes = [];   }   /**   * Load 3ds file from url.   *   * @method load   * @param {[type]} url URL for the file.   * @param {Function} onLoad onLoad callback, receives group Object3D as argument.   * @param {Function} onProgress onProgress callback.   * @param {Function} onError onError callback.   */  load( url, onLoad, onProgress, onError ) {    const scope = this;    const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;    const loader = new FileLoader( this.manager );   loader.setPath( this.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( this.requestHeader );   loader.setWithCredentials( this.withCredentials );    loader.load( url, function ( data ) {     try {      onLoad( scope.parse( data, path ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   /**   * Parse arraybuffer data and load 3ds file.   *   * @method parse   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.   * @param {String} path Path for external resources.   * @return {Group} Group loaded from 3ds file.   */  parse( arraybuffer, path ) {    this.group = new Group();   this.materials = [];   this.meshes = [];    this.readFile( arraybuffer, path );    for ( let i = 0; i < this.meshes.length; i ++ ) {     this.group.add( this.meshes[ i ] );    }    return this.group;   }   /**   * Decode file content to read 3ds data.   *   * @method readFile   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.   * @param {String} path Path for external resources.   */  readFile( arraybuffer, path ) {    const data = new DataView( arraybuffer );   const chunk = new Chunk( data, 0, this.debugMessage );    if ( chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC ) {     let next = chunk.readChunk();     while ( next ) {      if ( next.id === M3D_VERSION ) {       const version = next.readDWord();      this.debugMessage( '3DS file version: ' + version );      } else if ( next.id === MDATA ) {       this.readMeshData( next, path );      } else {       this.debugMessage( 'Unknown main chunk: ' + next.hexId );      }      next = chunk.readChunk();     }    }    this.debugMessage( 'Parsed ' + this.meshes.length + ' meshes' );   }   /**   * Read mesh data chunk.   *   * @method readMeshData   * @param {Chunk} chunk to read mesh from   * @param {String} path Path for external resources.   */  readMeshData( chunk, path ) {    let next = chunk.readChunk();    while ( next ) {     if ( next.id === MESH_VERSION ) {      const version = + next.readDWord();     this.debugMessage( 'Mesh Version: ' + version );     } else if ( next.id === MASTER_SCALE ) {      const scale = next.readFloat();     this.debugMessage( 'Master scale: ' + scale );     this.group.scale.set( scale, scale, scale );     } else if ( next.id === NAMED_OBJECT ) {      this.debugMessage( 'Named Object' );     this.readNamedObject( next );     } else if ( next.id === MAT_ENTRY ) {      this.debugMessage( 'Material' );     this.readMaterialEntry( next, path );     } else {      this.debugMessage( 'Unknown MDATA chunk: ' + next.hexId );     }     next = chunk.readChunk();    }   }   /**   * Read named object chunk.   *   * @method readNamedObject   * @param {Chunk} chunk Chunk in use.   */  readNamedObject( chunk ) {    const name = chunk.readString();    let next = chunk.readChunk();   while ( next ) {     if ( next.id === N_TRI_OBJECT ) {      const mesh = this.readMesh( next );     mesh.name = name;     this.meshes.push( mesh );     } else {      this.debugMessage( 'Unknown named object chunk: ' + next.hexId );     }     next = chunk.readChunk( );    }   }   /**   * Read material data chunk and add it to the material list.   *   * @method readMaterialEntry   * @param {Chunk} chunk Chunk in use.   * @param {String} path Path for external resources.   */  readMaterialEntry( chunk, path ) {    let next = chunk.readChunk();   const material = new MeshPhongMaterial();    while ( next ) {     if ( next.id === MAT_NAME ) {      material.name = next.readString();     this.debugMessage( '   Name: ' + material.name );     } else if ( next.id === MAT_WIRE ) {      this.debugMessage( '   Wireframe' );     material.wireframe = true;     } else if ( next.id === MAT_WIRE_SIZE ) {      const value = next.readByte();     material.wireframeLinewidth = value;     this.debugMessage( '   Wireframe Thickness: ' + value );     } else if ( next.id === MAT_TWO_SIDE ) {      material.side = DoubleSide;     this.debugMessage( '   DoubleSided' );     } else if ( next.id === MAT_ADDITIVE ) {      this.debugMessage( '   Additive Blending' );     material.blending = AdditiveBlending;     } else if ( next.id === MAT_DIFFUSE ) {      this.debugMessage( '   Diffuse Color' );     material.color = this.readColor( next );     } else if ( next.id === MAT_SPECULAR ) {      this.debugMessage( '   Specular Color' );     material.specular = this.readColor( next );     } else if ( next.id === MAT_AMBIENT ) {      this.debugMessage( '   Ambient color' );     material.color = this.readColor( next );     } else if ( next.id === MAT_SHININESS ) {      const shininess = this.readPercentage( next );     material.shininess = shininess * 100;     this.debugMessage( '   Shininess : ' + shininess );     } else if ( next.id === MAT_TRANSPARENCY ) {      const transparency = this.readPercentage( next );     material.opacity = 1 - transparency;     this.debugMessage( '  Transparency : ' + transparency );     material.transparent = material.opacity < 1 ? true : false;     } else if ( next.id === MAT_TEXMAP ) {      this.debugMessage( '   ColorMap' );     material.map = this.readMap( next, path );     } else if ( next.id === MAT_BUMPMAP ) {      this.debugMessage( '   BumpMap' );     material.bumpMap = this.readMap( next, path );     } else if ( next.id === MAT_OPACMAP ) {      this.debugMessage( '   OpacityMap' );     material.alphaMap = this.readMap( next, path );     } else if ( next.id === MAT_SPECMAP ) {      this.debugMessage( '   SpecularMap' );     material.specularMap = this.readMap( next, path );     } else {      this.debugMessage( '   Unknown material chunk: ' + next.hexId );     }     next = chunk.readChunk();    }    this.materials[ material.name ] = material;   }   /**   * Read mesh data chunk.   *   * @method readMesh   * @param {Chunk} chunk Chunk in use.   * @return {Mesh} The parsed mesh.   */  readMesh( chunk ) {    let next = chunk.readChunk( );    const geometry = new BufferGeometry();    const material = new MeshPhongMaterial();   const mesh = new Mesh( geometry, material );   mesh.name = 'mesh';    while ( next ) {     if ( next.id === POINT_ARRAY ) {      const points = next.readWord( );      this.debugMessage( '   Vertex: ' + points );      //BufferGeometry      const vertices = [];      for ( let i = 0; i < points; i ++ )  {       vertices.push( next.readFloat( ) );      vertices.push( next.readFloat( ) );      vertices.push( next.readFloat( ) );      }      geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );     } else if ( next.id === FACE_ARRAY ) {      this.readFaceArray( next, mesh );     } else if ( next.id === TEX_VERTS ) {      const texels = next.readWord( );      this.debugMessage( '   UV: ' + texels );      //BufferGeometry      const uvs = [];      for ( let i = 0; i < texels; i ++ ) {       uvs.push( next.readFloat( ) );      uvs.push( next.readFloat( ) );      }      geometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );      } else if ( next.id === MESH_MATRIX ) {      this.debugMessage( '   Tranformation Matrix (TODO)' );      const values = [];     for ( let i = 0; i < 12; i ++ ) {       values[ i ] = next.readFloat( );      }      const matrix = new Matrix4();      //X Line     matrix.elements[ 0 ] = values[ 0 ];     matrix.elements[ 1 ] = values[ 6 ];     matrix.elements[ 2 ] = values[ 3 ];     matrix.elements[ 3 ] = values[ 9 ];      //Y Line     matrix.elements[ 4 ] = values[ 2 ];     matrix.elements[ 5 ] = values[ 8 ];     matrix.elements[ 6 ] = values[ 5 ];     matrix.elements[ 7 ] = values[ 11 ];      //Z Line     matrix.elements[ 8 ] = values[ 1 ];     matrix.elements[ 9 ] = values[ 7 ];     matrix.elements[ 10 ] = values[ 4 ];     matrix.elements[ 11 ] = values[ 10 ];      //W Line     matrix.elements[ 12 ] = 0;     matrix.elements[ 13 ] = 0;     matrix.elements[ 14 ] = 0;     matrix.elements[ 15 ] = 1;      matrix.transpose();      const inverse = new Matrix4();     inverse.copy( matrix ).invert();     geometry.applyMatrix4( inverse );      matrix.decompose( mesh.position, mesh.quaternion, mesh.scale );     } else {      this.debugMessage( '   Unknown mesh chunk: ' + next.hexId );     }     next = chunk.readChunk( );    }    geometry.computeVertexNormals();    return mesh;   }   /**   * Read face array data chunk.   *   * @method readFaceArray   * @param {Chunk} chunk Chunk in use.   * @param {Mesh} mesh Mesh to be filled with the data read.   */  readFaceArray( chunk, mesh ) {    const faces = chunk.readWord( );    this.debugMessage( '   Faces: ' + faces );    const index = [];    for ( let i = 0; i < faces; ++ i ) {     index.push( chunk.readWord( ), chunk.readWord( ), chunk.readWord( ) );     chunk.readWord( ); // visibility    }    mesh.geometry.setIndex( index );    //The rest of the FACE_ARRAY chunk is subchunks    let materialIndex = 0;   let start = 0;    while ( ! chunk.endOfChunk ) {     const subchunk = chunk.readChunk( );     if ( subchunk.id === MSH_MAT_GROUP ) {      this.debugMessage( '      Material Group' );      const group = this.readMaterialGroup( subchunk );     const count = group.index.length * 3; // assuming successive indices      mesh.geometry.addGroup( start, count, materialIndex );      start += count;     materialIndex ++;      const material = this.materials[ group.name ];      if ( Array.isArray( mesh.material ) === false ) mesh.material = [];      if ( material !== undefined ) {       mesh.material.push( material );      }     } else {      this.debugMessage( '      Unknown face array chunk: ' + subchunk.hexId );     }    }    if ( mesh.material.length === 1 ) mesh.material = mesh.material[ 0 ]; // for backwards compatibility   }   /**   * Read texture map data chunk.   *   * @method readMap   * @param {Chunk} chunk Chunk in use.   * @param {String} path Path for external resources.   * @return {Texture} Texture read from this data chunk.   */  readMap( chunk, path ) {    let next = chunk.readChunk( );   let texture = {};    const loader = new TextureLoader( this.manager );   loader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );    while ( next ) {     if ( next.id === MAT_MAPNAME ) {      const name = next.readString();     texture = loader.load( name );      this.debugMessage( '      File: ' + path + name );     } else if ( next.id === MAT_MAP_UOFFSET ) {      texture.offset.x = next.readFloat( );     this.debugMessage( '      OffsetX: ' + texture.offset.x );     } else if ( next.id === MAT_MAP_VOFFSET ) {      texture.offset.y = next.readFloat( );     this.debugMessage( '      OffsetY: ' + texture.offset.y );     } else if ( next.id === MAT_MAP_USCALE ) {      texture.repeat.x = next.readFloat( );     this.debugMessage( '      RepeatX: ' + texture.repeat.x );     } else if ( next.id === MAT_MAP_VSCALE ) {      texture.repeat.y = next.readFloat( );     this.debugMessage( '      RepeatY: ' + texture.repeat.y );     } else {      this.debugMessage( '      Unknown map chunk: ' + next.hexId );     }     next = chunk.readChunk( );    }    return texture;   }   /**   * Read material group data chunk.   *   * @method readMaterialGroup   * @param {Chunk} chunk Chunk in use.   * @return {Object} Object with name and index of the object.   */  readMaterialGroup( chunk ) {    const name = chunk.readString();   const numFaces = chunk.readWord();    this.debugMessage( '         Name: ' + name );   this.debugMessage( '         Faces: ' + numFaces );    const index = [];   for ( let i = 0; i < numFaces; ++ i ) {     index.push( chunk.readWord( ) );    }    return { name: name, index: index };   }   /**   * Read a color value.   *   * @method readColor   * @param {Chunk} chunk Chunk.   * @return {Color} Color value read..   */  readColor( chunk ) {    const subChunk = chunk.readChunk( );   const color = new Color();    if ( subChunk.id === COLOR_24 || subChunk.id === LIN_COLOR_24 ) {     const r = subChunk.readByte( );    const g = subChunk.readByte( );    const b = subChunk.readByte( );     color.setRGB( r / 255, g / 255, b / 255 );     this.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );    } else if ( subChunk.id === COLOR_F || subChunk.id === LIN_COLOR_F ) {     const r = subChunk.readFloat( );    const g = subChunk.readFloat( );    const b = subChunk.readFloat( );     color.setRGB( r, g, b );     this.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );    } else {     this.debugMessage( '      Unknown color chunk: ' + subChunk.hexId );    }    return color;   }   /**   * Read percentage value.   *   * @method readPercentage   * @param {Chunk} chunk Chunk to read data from.   * @return {Number} Data read from the dataview.   */  readPercentage( chunk ) {    const subChunk = chunk.readChunk( );    switch ( subChunk.id ) {     case INT_PERCENTAGE:     return ( subChunk.readShort( ) / 100 );     break;     case FLOAT_PERCENTAGE:     return subChunk.readFloat( );     break;     default:     this.debugMessage( '      Unknown percentage chunk: ' + subChunk.hexId );     return 0;    }   }   /**   * Print debug message to the console.   *   * Is controlled by a flag to show or hide debug messages.   *   * @method debugMessage   * @param {Object} message Debug message to print to the console.   */  debugMessage( message ) {    if ( this.debug ) {     console.log( message );    }   }  }   /** Read data/sub-chunks from chunk */ class Chunk {   /**   * Create a new chunk   *   * @class Chunk   * @param {DataView} data DataView to read from.   * @param {Number} position in data.   * @param {Function} debugMessage logging callback.   */  constructor( data, position, debugMessage ) {    this.data = data;   // the offset to the begin of this chunk   this.offset = position;   // the current reading position   this.position = position;   this.debugMessage = debugMessage;    if ( this.debugMessage instanceof Function ) {     this.debugMessage = function () {};    }    this.id = this.readWord();   this.size = this.readDWord();   this.end = this.offset + this.size;    if ( this.end > data.byteLength ) {     this.debugMessage( 'Bad chunk size for chunk at ' + position );    }   }   /**   * read a sub cchunk.   *   * @method readChunk   * @return {Chunk | null} next sub chunk   */  readChunk() {    if ( this.endOfChunk ) {     return null;    }    try {     const next = new Chunk( this.data, this.position, this.debugMessage );    this.position += next.size;    return next;    } catch ( e ) {     this.debugMessage( 'Unable to read chunk at ' + this.position );    return null;    }   }   /**   * return the ID of this chunk as Hex   *   * @method idToString   * @return {String} hex-string of id   */  get hexId() {    return this.id.toString( 16 );   }   get endOfChunk() {    return this.position >= this.end;   }   /**   * Read byte value.   *   * @method readByte   * @return {Number} Data read from the dataview.   */  readByte() {    const v = this.data.getUint8( this.position, true );   this.position += 1;   return v;   }   /**   * Read 32 bit float value.   *   * @method readFloat   * @return {Number} Data read from the dataview.   */  readFloat() {    try {     const v = this.data.getFloat32( this.position, true );    this.position += 4;    return v;    } catch ( e ) {     this.debugMessage( e + ' ' + this.position + ' ' + this.data.byteLength );    return 0;    }   }   /**   * Read 32 bit signed integer value.   *   * @method readInt   * @return {Number} Data read from the dataview.   */  readInt() {    const v = this.data.getInt32( this.position, true );   this.position += 4;   return v;   }   /**   * Read 16 bit signed integer value.   *   * @method readShort   * @return {Number} Data read from the dataview.   */  readShort() {    const v = this.data.getInt16( this.position, true );   this.position += 2;   return v;   }   /**   * Read 64 bit unsigned integer value.   *   * @method readDWord   * @return {Number} Data read from the dataview.   */  readDWord() {    const v = this.data.getUint32( this.position, true );   this.position += 4;   return v;   }   /**   * Read 32 bit unsigned integer value.   *   * @method readWord   * @return {Number} Data read from the dataview.   */  readWord() {    const v = this.data.getUint16( this.position, true );   this.position += 2;   return v;   }   /**   * Read NULL terminated ASCII string value from chunk-pos.   *   * @method readString   * @return {String} Data read from the dataview.   */  readString() {    let s = '';   let c = this.readByte();   while ( c ) {     s += String.fromCharCode( c );    c = this.readByte();    }    return s;   }  }  // const NULL_CHUNK = 0x0000; const M3DMAGIC = 0x4D4D; // const SMAGIC = 0x2D2D; // const LMAGIC = 0x2D3D; const MLIBMAGIC = 0x3DAA; // const MATMAGIC = 0x3DFF; const CMAGIC = 0xC23D; const M3D_VERSION = 0x0002; // const M3D_KFVERSION = 0x0005; const COLOR_F = 0x0010; const COLOR_24 = 0x0011; const LIN_COLOR_24 = 0x0012; const LIN_COLOR_F = 0x0013; const INT_PERCENTAGE = 0x0030; const FLOAT_PERCENTAGE = 0x0031; const MDATA = 0x3D3D; const MESH_VERSION = 0x3D3E; const MASTER_SCALE = 0x0100; // const LO_SHADOW_BIAS = 0x1400; // const HI_SHADOW_BIAS = 0x1410; // const SHADOW_MAP_SIZE = 0x1420; // const SHADOW_SAMPLES = 0x1430; // const SHADOW_RANGE = 0x1440; // const SHADOW_FILTER = 0x1450; // const RAY_BIAS = 0x1460; // const O_CONSTS = 0x1500; // const AMBIENT_LIGHT = 0x2100; // const BIT_MAP = 0x1100; // const SOLID_BGND = 0x1200; // const V_GRADIENT = 0x1300; // const USE_BIT_MAP = 0x1101; // const USE_SOLID_BGND = 0x1201; // const USE_V_GRADIENT = 0x1301; // const FOG = 0x2200; // const FOG_BGND = 0x2210; // const LAYER_FOG = 0x2302; // const DISTANCE_CUE = 0x2300; // const DCUE_BGND = 0x2310; // const USE_FOG = 0x2201; // const USE_LAYER_FOG = 0x2303; // const USE_DISTANCE_CUE = 0x2301; const MAT_ENTRY = 0xAFFF; const MAT_NAME = 0xA000; const MAT_AMBIENT = 0xA010; const MAT_DIFFUSE = 0xA020; const MAT_SPECULAR = 0xA030; const MAT_SHININESS = 0xA040; // const MAT_SHIN2PCT = 0xA041; const MAT_TRANSPARENCY = 0xA050; // const MAT_XPFALL = 0xA052; // const MAT_USE_XPFALL = 0xA240; // const MAT_REFBLUR = 0xA053; // const MAT_SHADING = 0xA100; // const MAT_USE_REFBLUR = 0xA250; // const MAT_SELF_ILLUM = 0xA084; const MAT_TWO_SIDE = 0xA081; // const MAT_DECAL = 0xA082; const MAT_ADDITIVE = 0xA083; const MAT_WIRE = 0xA085; // const MAT_FACEMAP = 0xA088; // const MAT_TRANSFALLOFF_IN = 0xA08A; // const MAT_PHONGSOFT = 0xA08C; // const MAT_WIREABS = 0xA08E; const MAT_WIRE_SIZE = 0xA087; const MAT_TEXMAP = 0xA200; // const MAT_SXP_TEXT_DATA = 0xA320; // const MAT_TEXMASK = 0xA33E; // const MAT_SXP_TEXTMASK_DATA = 0xA32A; // const MAT_TEX2MAP = 0xA33A; // const MAT_SXP_TEXT2_DATA = 0xA321; // const MAT_TEX2MASK = 0xA340; // const MAT_SXP_TEXT2MASK_DATA = 0xA32C; const MAT_OPACMAP = 0xA210; // const MAT_SXP_OPAC_DATA = 0xA322; // const MAT_OPACMASK = 0xA342; // const MAT_SXP_OPACMASK_DATA = 0xA32E; const MAT_BUMPMAP = 0xA230; // const MAT_SXP_BUMP_DATA = 0xA324; // const MAT_BUMPMASK = 0xA344; // const MAT_SXP_BUMPMASK_DATA = 0xA330; const MAT_SPECMAP = 0xA204; // const MAT_SXP_SPEC_DATA = 0xA325; // const MAT_SPECMASK = 0xA348; // const MAT_SXP_SPECMASK_DATA = 0xA332; // const MAT_SHINMAP = 0xA33C; // const MAT_SXP_SHIN_DATA = 0xA326; // const MAT_SHINMASK = 0xA346; // const MAT_SXP_SHINMASK_DATA = 0xA334; // const MAT_SELFIMAP = 0xA33D; // const MAT_SXP_SELFI_DATA = 0xA328; // const MAT_SELFIMASK = 0xA34A; // const MAT_SXP_SELFIMASK_DATA = 0xA336; // const MAT_REFLMAP = 0xA220; // const MAT_REFLMASK = 0xA34C; // const MAT_SXP_REFLMASK_DATA = 0xA338; // const MAT_ACUBIC = 0xA310; const MAT_MAPNAME = 0xA300; // const MAT_MAP_TILING = 0xA351; // const MAT_MAP_TEXBLUR = 0xA353; const MAT_MAP_USCALE = 0xA354; const MAT_MAP_VSCALE = 0xA356; const MAT_MAP_UOFFSET = 0xA358; const MAT_MAP_VOFFSET = 0xA35A; // const MAT_MAP_ANG = 0xA35C; // const MAT_MAP_COL1 = 0xA360; // const MAT_MAP_COL2 = 0xA362; // const MAT_MAP_RCOL = 0xA364; // const MAT_MAP_GCOL = 0xA366; // const MAT_MAP_BCOL = 0xA368; const NAMED_OBJECT = 0x4000; // const N_DIRECT_LIGHT = 0x4600; // const DL_OFF = 0x4620; // const DL_OUTER_RANGE = 0x465A; // const DL_INNER_RANGE = 0x4659; // const DL_MULTIPLIER = 0x465B; // const DL_EXCLUDE = 0x4654; // const DL_ATTENUATE = 0x4625; // const DL_SPOTLIGHT = 0x4610; // const DL_SPOT_ROLL = 0x4656; // const DL_SHADOWED = 0x4630; // const DL_LOCAL_SHADOW2 = 0x4641; // const DL_SEE_CONE = 0x4650; // const DL_SPOT_RECTANGULAR = 0x4651; // const DL_SPOT_ASPECT = 0x4657; // const DL_SPOT_PROJECTOR = 0x4653; // const DL_SPOT_OVERSHOOT = 0x4652; // const DL_RAY_BIAS = 0x4658; // const DL_RAYSHAD = 0x4627; // const N_CAMERA = 0x4700; // const CAM_SEE_CONE = 0x4710; // const CAM_RANGES = 0x4720; // const OBJ_HIDDEN = 0x4010; // const OBJ_VIS_LOFTER = 0x4011; // const OBJ_DOESNT_CAST = 0x4012; // const OBJ_DONT_RECVSHADOW = 0x4017; // const OBJ_MATTE = 0x4013; // const OBJ_FAST = 0x4014; // const OBJ_PROCEDURAL = 0x4015; // const OBJ_FROZEN = 0x4016; const N_TRI_OBJECT = 0x4100; const POINT_ARRAY = 0x4110; // const POINT_FLAG_ARRAY = 0x4111; const FACE_ARRAY = 0x4120; const MSH_MAT_GROUP = 0x4130; // const SMOOTH_GROUP = 0x4150; // const MSH_BOXMAP = 0x4190; const TEX_VERTS = 0x4140; const MESH_MATRIX = 0x4160; // const MESH_COLOR = 0x4165; // const MESH_TEXTURE_INFO = 0x4170; // const KFDATA = 0xB000; // const KFHDR = 0xB00A; // const KFSEG = 0xB008; // const KFCURTIME = 0xB009; // const AMBIENT_NODE_TAG = 0xB001; // const OBJECT_NODE_TAG = 0xB002; // const CAMERA_NODE_TAG = 0xB003; // const TARGET_NODE_TAG = 0xB004; // const LIGHT_NODE_TAG = 0xB005; // const L_TARGET_NODE_TAG = 0xB006; // const SPOTLIGHT_NODE_TAG = 0xB007; // const NODE_ID = 0xB030; // const NODE_HDR = 0xB010; // const PIVOT = 0xB013; // const INSTANCE_NAME = 0xB011; // const MORPH_SMOOTH = 0xB015; // const BOUNDBOX = 0xB014; // const POS_TRACK_TAG = 0xB020; // const COL_TRACK_TAG = 0xB025; // const ROT_TRACK_TAG = 0xB021; // const SCL_TRACK_TAG = 0xB022; // const MORPH_TRACK_TAG = 0xB026; // const FOV_TRACK_TAG = 0xB023; // const ROLL_TRACK_TAG = 0xB024; // const HOT_TRACK_TAG = 0xB027; // const FALL_TRACK_TAG = 0xB028; // const HIDE_TRACK_TAG = 0xB029; // const POLY_2D = 0x5000; // const SHAPE_OK = 0x5010; // const SHAPE_NOT_OK = 0x5011; // const SHAPE_HOOK = 0x5020; // const PATH_3D = 0x6000; // const PATH_MATRIX = 0x6005; // const SHAPE_2D = 0x6010; // const M_SCALE = 0x6020; // const M_TWIST = 0x6030; // const M_TEETER = 0x6040; // const M_FIT = 0x6050; // const M_BEVEL = 0x6060; // const XZ_CURVE = 0x6070; // const YZ_CURVE = 0x6080; // const INTERPCT = 0x6090; // const DEFORM_LIMIT = 0x60A0; // const USE_CONTOUR = 0x6100; // const USE_TWEEN = 0x6110; // const USE_SCALE = 0x6120; // const USE_TWIST = 0x6130; // const USE_TEETER = 0x6140; // const USE_FIT = 0x6150; // const USE_BEVEL = 0x6160; // const DEFAULT_VIEW = 0x3000; // const VIEW_TOP = 0x3010; // const VIEW_BOTTOM = 0x3020; // const VIEW_LEFT = 0x3030; // const VIEW_RIGHT = 0x3040; // const VIEW_FRONT = 0x3050; // const VIEW_BACK = 0x3060; // const VIEW_USER = 0x3070; // const VIEW_CAMERA = 0x3080; // const VIEW_WINDOW = 0x3090; // const VIEWPORT_LAYOUT_OLD = 0x7000; // const VIEWPORT_DATA_OLD = 0x7010; // const VIEWPORT_LAYOUT = 0x7001; // const VIEWPORT_DATA = 0x7011; // const VIEWPORT_DATA_3 = 0x7012; // const VIEWPORT_SIZE = 0x7020; // const NETWORK_VIEW = 0x7030;  export { TDSLoader }; 
^..^ FILENAME ^..^
addons|loaders|TGALoader.js
^..^ CONTENTS ^..^
import {  DataTextureLoader,  LinearMipmapLinearFilter } from 'three';  class TGALoader extends DataTextureLoader {   constructor( manager ) {    super( manager );   }   parse( buffer ) {    // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js    function tgaCheckHeader( header ) {     switch ( header.image_type ) {      // check indexed type      case TGA_TYPE_INDEXED:     case TGA_TYPE_RLE_INDEXED:      if ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {        throw new Error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );       }       break;       // check colormap type      case TGA_TYPE_RGB:     case TGA_TYPE_GREY:     case TGA_TYPE_RLE_RGB:     case TGA_TYPE_RLE_GREY:      if ( header.colormap_type ) {        throw new Error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );       }       break;       // What the need of a file without data ?      case TGA_TYPE_NO_DATA:      throw new Error( 'THREE.TGALoader: No data.' );       // Invalid type ?      default:      throw new Error( 'THREE.TGALoader: Invalid type ' + header.image_type );     }     // check image width and height     if ( header.width <= 0 || header.height <= 0 ) {      throw new Error( 'THREE.TGALoader: Invalid image size.' );     }     // check image pixel size     if ( header.pixel_size !== 8 && header.pixel_size !== 16 &&     header.pixel_size !== 24 && header.pixel_size !== 32 ) {      throw new Error( 'THREE.TGALoader: Invalid pixel size ' + header.pixel_size );     }    }    // parse tga image buffer    function tgaParse( use_rle, use_pal, header, offset, data ) {     let pixel_data,     palettes;     const pixel_size = header.pixel_size >> 3;    const pixel_total = header.width * header.height * pixel_size;      // read palettes      if ( use_pal ) {       palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );      }      // read RLE      if ( use_rle ) {       pixel_data = new Uint8Array( pixel_total );      let c, count, i;     let shift = 0;     const pixels = new Uint8Array( pixel_size );      while ( shift < pixel_total ) {       c = data[ offset ++ ];      count = ( c & 0x7f ) + 1;       // RLE pixels       if ( c & 0x80 ) {        // bind pixel tmp array        for ( i = 0; i < pixel_size; ++ i ) {         pixels[ i ] = data[ offset ++ ];        }        // copy pixel array        for ( i = 0; i < count; ++ i ) {         pixel_data.set( pixels, shift + i * pixel_size );        }        shift += pixel_size * count;       } else {        // raw pixels        count *= pixel_size;        for ( i = 0; i < count; ++ i ) {         pixel_data[ shift + i ] = data[ offset ++ ];        }        shift += count;       }      }      } else {      // raw pixels      pixel_data = data.subarray(       offset, offset += ( use_pal ? header.width * header.height : pixel_total )     );      }      return {     pixel_data: pixel_data,     palettes: palettes     };    }    function tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {     const colormap = palettes;    let color, i = 0, x, y;    const width = header.width;     for ( y = y_start; y !== y_end; y += y_step ) {      for ( x = x_start; x !== x_end; x += x_step, i ++ ) {       color = image[ i ];      imageData[ ( x + width * y ) * 4 + 3 ] = 255;      imageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];      imageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];      imageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];      }     }     return imageData;    }    function tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {     let color, i = 0, x, y;    const width = header.width;     for ( y = y_start; y !== y_end; y += y_step ) {      for ( x = x_start; x !== x_end; x += x_step, i += 2 ) {       color = image[ i + 0 ] + ( image[ i + 1 ] << 8 );      imageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;      imageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;      imageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) << 3;      imageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;      }     }     return imageData;    }    function tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {     let i = 0, x, y;    const width = header.width;     for ( y = y_start; y !== y_end; y += y_step ) {      for ( x = x_start; x !== x_end; x += x_step, i += 3 ) {       imageData[ ( x + width * y ) * 4 + 3 ] = 255;      imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];      imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];      imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];      }     }     return imageData;    }    function tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {     let i = 0, x, y;    const width = header.width;     for ( y = y_start; y !== y_end; y += y_step ) {      for ( x = x_start; x !== x_end; x += x_step, i += 4 ) {       imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];      imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];      imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];      imageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];      }     }     return imageData;    }    function tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {     let color, i = 0, x, y;    const width = header.width;     for ( y = y_start; y !== y_end; y += y_step ) {      for ( x = x_start; x !== x_end; x += x_step, i ++ ) {       color = image[ i ];      imageData[ ( x + width * y ) * 4 + 0 ] = color;      imageData[ ( x + width * y ) * 4 + 1 ] = color;      imageData[ ( x + width * y ) * 4 + 2 ] = color;      imageData[ ( x + width * y ) * 4 + 3 ] = 255;      }     }     return imageData;    }    function tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {     let i = 0, x, y;    const width = header.width;     for ( y = y_start; y !== y_end; y += y_step ) {      for ( x = x_start; x !== x_end; x += x_step, i += 2 ) {       imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];      imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];      imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];      imageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];      }     }     return imageData;    }    function getTgaRGBA( data, width, height, image, palette ) {     let x_start,     y_start,     x_step,     y_step,     x_end,     y_end;     switch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {      default:     case TGA_ORIGIN_UL:      x_start = 0;      x_step = 1;      x_end = width;      y_start = 0;      y_step = 1;      y_end = height;      break;      case TGA_ORIGIN_BL:      x_start = 0;      x_step = 1;      x_end = width;      y_start = height - 1;      y_step = - 1;      y_end = - 1;      break;      case TGA_ORIGIN_UR:      x_start = width - 1;      x_step = - 1;      x_end = - 1;      y_start = 0;      y_step = 1;      y_end = height;      break;      case TGA_ORIGIN_BR:      x_start = width - 1;      x_step = - 1;      x_end = - 1;      y_start = height - 1;      y_step = - 1;      y_end = - 1;      break;     }     if ( use_grey ) {      switch ( header.pixel_size ) {       case 8:       tgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );       break;       case 16:       tgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );       break;       default:       throw new Error( 'THREE.TGALoader: Format not supported.' );       break;      }     } else {      switch ( header.pixel_size ) {       case 8:       tgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );       break;       case 16:       tgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );       break;       case 24:       tgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );       break;       case 32:       tgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );       break;       default:       throw new Error( 'THREE.TGALoader: Format not supported.' );       break;      }     }     // Load image data according to specific method    // let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';    // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );    return data;    }    // TGA constants    const TGA_TYPE_NO_DATA = 0,    TGA_TYPE_INDEXED = 1,    TGA_TYPE_RGB = 2,    TGA_TYPE_GREY = 3,    TGA_TYPE_RLE_INDEXED = 9,    TGA_TYPE_RLE_RGB = 10,    TGA_TYPE_RLE_GREY = 11,     TGA_ORIGIN_MASK = 0x30,    TGA_ORIGIN_SHIFT = 0x04,    TGA_ORIGIN_BL = 0x00,    TGA_ORIGIN_BR = 0x01,    TGA_ORIGIN_UL = 0x02,    TGA_ORIGIN_UR = 0x03;    if ( buffer.length < 19 ) throw new Error( 'THREE.TGALoader: Not enough data to contain header.' );    let offset = 0;    const content = new Uint8Array( buffer ),    header = {     id_length: content[ offset ++ ],     colormap_type: content[ offset ++ ],     image_type: content[ offset ++ ],     colormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,     colormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,     colormap_size: content[ offset ++ ],     origin: [      content[ offset ++ ] | content[ offset ++ ] << 8,      content[ offset ++ ] | content[ offset ++ ] << 8     ],     width: content[ offset ++ ] | content[ offset ++ ] << 8,     height: content[ offset ++ ] | content[ offset ++ ] << 8,     pixel_size: content[ offset ++ ],     flags: content[ offset ++ ]    };    // check tga if it is valid format    tgaCheckHeader( header );    if ( header.id_length + offset > buffer.length ) {     throw new Error( 'THREE.TGALoader: No data.' );    }    // skip the needn't data    offset += header.id_length;    // get targa information about RLE compression and palette    let use_rle = false,    use_pal = false,    use_grey = false;    switch ( header.image_type ) {     case TGA_TYPE_RLE_INDEXED:     use_rle = true;     use_pal = true;     break;     case TGA_TYPE_INDEXED:     use_pal = true;     break;     case TGA_TYPE_RLE_RGB:     use_rle = true;     break;     case TGA_TYPE_RGB:     break;     case TGA_TYPE_RLE_GREY:     use_rle = true;     use_grey = true;     break;     case TGA_TYPE_GREY:     use_grey = true;     break;    }    //    const imageData = new Uint8Array( header.width * header.height * 4 );   const result = tgaParse( use_rle, use_pal, header, offset, content );   getTgaRGBA( imageData, header.width, header.height, result.pixel_data, result.palettes );    return {     data: imageData,    width: header.width,    height: header.height,    flipY: true,    generateMipmaps: true,    minFilter: LinearMipmapLinearFilter,    };   }  }  export { TGALoader }; 
^..^ FILENAME ^..^
addons|loaders|TIFFLoader.js
^..^ CONTENTS ^..^
import {  DataTextureLoader,  LinearFilter,  LinearMipmapLinearFilter } from 'three';  import UTIF from '../libs/utif.module.js';  class TIFFLoader extends DataTextureLoader {   constructor( manager ) {    super( manager );   }   parse( buffer ) {    const ifds = UTIF.decode( buffer );   UTIF.decodeImage( buffer, ifds[ 0 ] );   const rgba = UTIF.toRGBA8( ifds[ 0 ] );    return {    width: ifds[ 0 ].width,    height: ifds[ 0 ].height,    data: rgba,    flipY: true,    magFilter: LinearFilter,    minFilter: LinearMipmapLinearFilter   };   }  }  export { TIFFLoader }; 
^..^ FILENAME ^..^
addons|loaders|TTFLoader.js
^..^ CONTENTS ^..^
import {  FileLoader,  Loader } from 'three'; import opentype from '../libs/opentype.module.js';  /**  * Requires opentype.js to be included in the project.  * Loads TTF files and converts them into typeface JSON that can be used directly  * to create THREE.Font objects.  */  class TTFLoader extends Loader {   constructor( manager ) {    super( manager );    this.reversed = false;   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( this.manager );   loader.setPath( this.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( this.requestHeader );   loader.setWithCredentials( this.withCredentials );   loader.load( url, function ( buffer ) {     try {      onLoad( scope.parse( buffer ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( arraybuffer ) {    function convert( font, reversed ) {     const round = Math.round;     const glyphs = {};    const scale = ( 100000 ) / ( ( font.unitsPerEm || 2048 ) * 72 );     const glyphIndexMap = font.encoding.cmap.glyphIndexMap;    const unicodes = Object.keys( glyphIndexMap );     for ( let i = 0; i < unicodes.length; i ++ ) {      const unicode = unicodes[ i ];     const glyph = font.glyphs.glyphs[ glyphIndexMap[ unicode ] ];      if ( unicode !== undefined ) {       const token = {       ha: round( glyph.advanceWidth * scale ),       x_min: round( glyph.xMin * scale ),       x_max: round( glyph.xMax * scale ),       o: ''      };       if ( reversed ) {        glyph.path.commands = reverseCommands( glyph.path.commands );       }       glyph.path.commands.forEach( function ( command ) {        if ( command.type.toLowerCase() === 'c' ) {         command.type = 'b';        }        token.o += command.type.toLowerCase() + ' ';        if ( command.x !== undefined && command.y !== undefined ) {         token.o += round( command.x * scale ) + ' ' + round( command.y * scale ) + ' ';        }        if ( command.x1 !== undefined && command.y1 !== undefined ) {         token.o += round( command.x1 * scale ) + ' ' + round( command.y1 * scale ) + ' ';        }        if ( command.x2 !== undefined && command.y2 !== undefined ) {         token.o += round( command.x2 * scale ) + ' ' + round( command.y2 * scale ) + ' ';        }       } );       glyphs[ String.fromCodePoint( glyph.unicode ) ] = token;      }     }     return {     glyphs: glyphs,     familyName: font.getEnglishName( 'fullName' ),     ascender: round( font.ascender * scale ),     descender: round( font.descender * scale ),     underlinePosition: font.tables.post.underlinePosition,     underlineThickness: font.tables.post.underlineThickness,     boundingBox: {      xMin: font.tables.head.xMin,      xMax: font.tables.head.xMax,      yMin: font.tables.head.yMin,      yMax: font.tables.head.yMax     },     resolution: 1000,     original_font_information: font.tables.name    };    }    function reverseCommands( commands ) {     const paths = [];    let path;     commands.forEach( function ( c ) {      if ( c.type.toLowerCase() === 'm' ) {       path = [ c ];      paths.push( path );      } else if ( c.type.toLowerCase() !== 'z' ) {       path.push( c );      }     } );     const reversed = [];     paths.forEach( function ( p ) {      const result = {      type: 'm',      x: p[ p.length - 1 ].x,      y: p[ p.length - 1 ].y     };      reversed.push( result );      for ( let i = p.length - 1; i > 0; i -- ) {       const command = p[ i ];      const result = { type: command.type };       if ( command.x2 !== undefined && command.y2 !== undefined ) {        result.x1 = command.x2;       result.y1 = command.y2;       result.x2 = command.x1;       result.y2 = command.y1;       } else if ( command.x1 !== undefined && command.y1 !== undefined ) {        result.x1 = command.x1;       result.y1 = command.y1;       }       result.x = p[ i - 1 ].x;      result.y = p[ i - 1 ].y;      reversed.push( result );      }     } );     return reversed;    }    return convert( opentype.parse( arraybuffer ), this.reversed );   }  }  export { TTFLoader }; 
^..^ FILENAME ^..^
addons|loaders|UltraHDRLoader.js
^..^ CONTENTS ^..^
import {  ClampToEdgeWrapping,  DataTexture,  DataUtils,  FileLoader,  HalfFloatType,  LinearFilter,  LinearMipMapLinearFilter,  LinearSRGBColorSpace,  Loader,  RGBAFormat,  UVMapping, } from 'three';  // UltraHDR Image Format - https://developer.android.com/media/platform/hdr-image-format // HDR/EXR to UltraHDR Converter - https://gainmap-creator.monogrid.com/  /**  *  * Short format brief:  *  *  [JPEG headers]  *  [XMP metadata describing the MPF container and *both* SDR and gainmap images]  *  [Optional metadata] [EXIF] [ICC Profile]  *  [SDR image]  *  [XMP metadata describing only the gainmap image]  *  [Gainmap image]  *  * Each section is separated by a 0xFFXX byte followed by a descriptor byte (0xFFE0, 0xFFE1, 0xFFE2.)  * Binary image storages are prefixed with a unique 0xFFD8 16-bit descriptor.  */  /**  * Current feature set:  * - JPEG headers (required)  * - XMP metadata (required)  *  - XMP validation (not implemented)  * - EXIF profile (not implemented)  * - ICC profile (not implemented)  * - Binary storage for SDR & HDR images (required)  * - Gainmap metadata (required)  * - Non-JPEG image formats (not implemented)  * - Primary image as an HDR image (not implemented)  */  /* Calculating this SRGB powers is extremely slow for 4K images and can be sufficiently precalculated for a 3-4x speed boost */ const SRGB_TO_LINEAR = Array( 1024 )  .fill( 0 )  .map( ( _, value ) =>   Math.pow( ( value / 255 ) * 0.9478672986 + 0.0521327014, 2.4 )  );  class UltraHDRLoader extends Loader {   constructor( manager ) {    super( manager );    this.type = HalfFloatType;   }   setDataType( value ) {    this.type = value;    return this;   }   parse( buffer, onLoad ) {    const xmpMetadata = {    version: null,    baseRenditionIsHDR: null,    gainMapMin: null,    gainMapMax: null,    gamma: null,    offsetSDR: null,    offsetHDR: null,    hdrCapacityMin: null,    hdrCapacityMax: null,   };   const textDecoder = new TextDecoder();    const data = new DataView( buffer );    let byteOffset = 0;   const sections = [];    while ( byteOffset < data.byteLength ) {     const byte = data.getUint8( byteOffset );     if ( byte === 0xff ) {      const leadingByte = data.getUint8( byteOffset + 1 );      if (      [       /* Valid section headers */       0xd8, // SOI       0xe0, // APP0       0xe1, // APP1       0xe2, // APP2      ].includes( leadingByte )     ) {       sections.push( {       sectionType: leadingByte,       section: [ byte, leadingByte ],       sectionOffset: byteOffset + 2,      } );       byteOffset += 2;      } else {       sections[ sections.length - 1 ].section.push( byte, leadingByte );       byteOffset += 2;      }     } else {      sections[ sections.length - 1 ].section.push( byte );      byteOffset ++;     }    }    let primaryImage, gainmapImage;    for ( let i = 0; i < sections.length; i ++ ) {     const { sectionType, section, sectionOffset } = sections[ i ];     if ( sectionType === 0xe0 ) {     /* JPEG Header - no useful information */    } else if ( sectionType === 0xe1 ) {      /* XMP Metadata */      this._parseXMPMetadata(      textDecoder.decode( new Uint8Array( section ) ),      xmpMetadata     );     } else if ( sectionType === 0xe2 ) {      /* Data Sections - MPF / EXIF / ICC Profile */      const sectionData = new DataView(      new Uint8Array( section.slice( 2 ) ).buffer     );     const sectionHeader = sectionData.getUint32( 2, false );      if ( sectionHeader === 0x4d504600 ) {       /* MPF Section */       /* Section contains a list of static bytes and ends with offsets indicating location of SDR and gainmap images */      /* First bytes after header indicate little / big endian ordering (0x49492A00 - LE / 0x4D4D002A - BE) */      /*      ... 60 bytes indicating tags, versions, etc. ...       bytes | bits | description       4       32     primary image size      4       32     primary image offset      2       16     0x0000      2       16     0x0000       4       32     0x00000000      4       32     gainmap image size      4       32     gainmap image offset      2       16     0x0000      2       16     0x0000      */       const mpfLittleEndian = sectionData.getUint32( 6 ) === 0x49492a00;      const mpfBytesOffset = 60;       /* SDR size includes the metadata length, SDR offset is always 0 */       const primaryImageSize = sectionData.getUint32(       mpfBytesOffset,       mpfLittleEndian      );      const primaryImageOffset = sectionData.getUint32(       mpfBytesOffset + 4,       mpfLittleEndian      );       /* Gainmap size is an absolute value starting from its offset, gainmap offset needs 6 bytes padding to take into account 0x00 bytes at the end of XMP */      const gainmapImageSize = sectionData.getUint32(       mpfBytesOffset + 16,       mpfLittleEndian      );      const gainmapImageOffset =       sectionData.getUint32( mpfBytesOffset + 20, mpfLittleEndian ) +       sectionOffset +       6;       primaryImage = new Uint8Array(       data.buffer,       primaryImageOffset,       primaryImageSize      );       gainmapImage = new Uint8Array(       data.buffer,       gainmapImageOffset,       gainmapImageSize      );      }     }    }    /* Minimal sufficient validation - https://developer.android.com/media/platform/hdr-image-format#signal_of_the_format */   if ( ! xmpMetadata.version ) {     throw new Error( 'THREE.UltraHDRLoader: Not a valid UltraHDR image' );    }    if ( primaryImage && gainmapImage ) {     this._applyGainmapToSDR(     xmpMetadata,     primaryImage,     gainmapImage,     ( hdrBuffer, width, height ) => {       onLoad( {       width,       height,       data: hdrBuffer,       format: RGBAFormat,       type: this.type,      } );      },     ( error ) => {       throw new Error( error );      }    );    } else {     throw new Error( 'THREE.UltraHDRLoader: Could not parse UltraHDR images' );    }   }   load( url, onLoad, onProgress, onError ) {    const texture = new DataTexture(    this.type === HalfFloatType ? new Uint16Array() : new Float32Array(),    0,    0,    RGBAFormat,    this.type,    UVMapping,    ClampToEdgeWrapping,    ClampToEdgeWrapping,    LinearFilter,    LinearMipMapLinearFilter,    1,    LinearSRGBColorSpace   );   texture.generateMipmaps = true;   texture.flipY = true;    const loader = new FileLoader( this.manager );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( this.requestHeader );   loader.setPath( this.path );   loader.setWithCredentials( this.withCredentials );   loader.load( url, ( buffer ) => {     try {      this.parse(      buffer,      ( texData ) => {        texture.image = {        data: texData.data,        width: texData.width,        height: texData.height,       };       texture.needsUpdate = true;        if ( onLoad ) onLoad( texture, texData );       }     );     } catch ( error ) {      if ( onError ) onError( error );      console.error( error );     }    }, onProgress, onError );    return texture;   }   _parseXMPMetadata( xmpDataString, xmpMetadata ) {    const domParser = new DOMParser();    const xmpXml = domParser.parseFromString(    xmpDataString.substring(     xmpDataString.indexOf( '<' ),     xmpDataString.lastIndexOf( '>' ) + 1    ),    'text/xml'   );    /* Determine if given XMP metadata is the primary GContainer descriptor or a gainmap descriptor */   const [ hasHDRContainerDescriptor ] = xmpXml.getElementsByTagName(    'Container:Directory'   );    if ( hasHDRContainerDescriptor ) {    /* There's not much useful information in the container descriptor besides memory-validation */   } else {     /* Gainmap descriptor - defaults from https://developer.android.com/media/platform/hdr-image-format#HDR_gain_map_metadata */     const [ gainmapNode ] = xmpXml.getElementsByTagName( 'rdf:Description' );     xmpMetadata.version = gainmapNode.getAttribute( 'hdrgm:Version' );    xmpMetadata.baseRenditionIsHDR =     gainmapNode.getAttribute( 'hdrgm:BaseRenditionIsHDR' ) === 'True';    xmpMetadata.gainMapMin = parseFloat(     gainmapNode.getAttribute( 'hdrgm:GainMapMin' ) || 0.0    );    xmpMetadata.gainMapMax = parseFloat(     gainmapNode.getAttribute( 'hdrgm:GainMapMax' ) || 1.0    );    xmpMetadata.gamma = parseFloat(     gainmapNode.getAttribute( 'hdrgm:Gamma' ) || 1.0    );    xmpMetadata.offsetSDR = parseFloat(     gainmapNode.getAttribute( 'hdrgm:OffsetSDR' ) / ( 1 / 64 )    );    xmpMetadata.offsetHDR = parseFloat(     gainmapNode.getAttribute( 'hdrgm:OffsetHDR' ) / ( 1 / 64 )    );    xmpMetadata.hdrCapacityMin = parseFloat(     gainmapNode.getAttribute( 'hdrgm:HDRCapacityMin' ) || 0.0    );    xmpMetadata.hdrCapacityMax = parseFloat(     gainmapNode.getAttribute( 'hdrgm:HDRCapacityMax' ) || 1.0    );    }   }   _srgbToLinear( value ) {    if ( value / 255 < 0.04045 ) {     return ( value / 255 ) * 0.0773993808;    }    if ( value < 1024 ) {     return SRGB_TO_LINEAR[ ~ ~ value ];    }    return Math.pow( ( value / 255 ) * 0.9478672986 + 0.0521327014, 2.4 );   }   _applyGainmapToSDR(   xmpMetadata,   sdrBuffer,   gainmapBuffer,   onSuccess,   onError  ) {    const getImageDataFromBuffer = ( buffer ) =>    new Promise( ( resolve, reject ) => {      const imageLoader = document.createElement( 'img' );      imageLoader.onload = () => {       const image = {       width: imageLoader.naturalWidth,       height: imageLoader.naturalHeight,       source: imageLoader,      };       URL.revokeObjectURL( imageLoader.src );       resolve( image );      };      imageLoader.onerror = () => {       URL.revokeObjectURL( imageLoader.src );       reject();      };      imageLoader.src = URL.createObjectURL(      new Blob( [ buffer ], { type: 'image/jpeg' } )     );     } );    Promise.all( [    getImageDataFromBuffer( sdrBuffer ),    getImageDataFromBuffer( gainmapBuffer ),   ] )    .then( ( [ sdrImage, gainmapImage ] ) => {      const sdrImageAspect = sdrImage.width / sdrImage.height;     const gainmapImageAspect = gainmapImage.width / gainmapImage.height;      if ( sdrImageAspect !== gainmapImageAspect ) {       onError(       'THREE.UltraHDRLoader Error: Aspect ratio mismatch between SDR and Gainmap images'      );       return;      }      const canvas = document.createElement( 'canvas' );     const ctx = canvas.getContext( '2d', {      willReadFrequently: true,      colorSpace: 'srgb',     } );      canvas.width = sdrImage.width;     canvas.height = sdrImage.height;      /* Use out-of-the-box interpolation of Canvas API to scale gainmap to fit the SDR resolution */     ctx.drawImage(      gainmapImage.source,      0,      0,      gainmapImage.width,      gainmapImage.height,      0,      0,      sdrImage.width,      sdrImage.height     );     const gainmapImageData = ctx.getImageData(      0,      0,      sdrImage.width,      sdrImage.height,      { colorSpace: 'srgb' }     );      ctx.drawImage( sdrImage.source, 0, 0 );     const sdrImageData = ctx.getImageData(      0,      0,      sdrImage.width,      sdrImage.height,      { colorSpace: 'srgb' }     );      /* HDR Recovery formula - https://developer.android.com/media/platform/hdr-image-format#use_the_gain_map_to_create_adapted_HDR_rendition */     let hdrBuffer;      if ( this.type === HalfFloatType ) {       hdrBuffer = new Uint16Array( sdrImageData.data.length ).fill( 23544 );      } else {       hdrBuffer = new Float32Array( sdrImageData.data.length ).fill( 255 );      }      const maxDisplayBoost = Math.sqrt(      Math.pow(       /* 1.8 instead of 2 near-perfectly rectifies approximations introduced by precalculated SRGB_TO_LINEAR values */       1.8,       xmpMetadata.hdrCapacityMax      )     );     const unclampedWeightFactor =      ( Math.log2( maxDisplayBoost ) - xmpMetadata.hdrCapacityMin ) /      ( xmpMetadata.hdrCapacityMax - xmpMetadata.hdrCapacityMin );     const weightFactor = Math.min(      Math.max( unclampedWeightFactor, 0.0 ),      1.0     );     const useGammaOne = xmpMetadata.gamma === 1.0;      for (      let pixelIndex = 0;      pixelIndex < sdrImageData.data.length;      pixelIndex += 4     ) {       const x = ( pixelIndex / 4 ) % sdrImage.width;      const y = Math.floor( pixelIndex / 4 / sdrImage.width );       for ( let channelIndex = 0; channelIndex < 3; channelIndex ++ ) {        const sdrValue = sdrImageData.data[ pixelIndex + channelIndex ];        const gainmapIndex = ( y * sdrImage.width + x ) * 4 + channelIndex;       const gainmapValue = gainmapImageData.data[ gainmapIndex ] / 255.0;        /* Gamma is 1.0 by default */       const logRecovery = useGammaOne        ? gainmapValue        : Math.pow( gainmapValue, 1.0 / xmpMetadata.gamma );        const logBoost =        xmpMetadata.gainMapMin * ( 1.0 - logRecovery ) +        xmpMetadata.gainMapMax * logRecovery;        const hdrValue =        ( sdrValue + xmpMetadata.offsetSDR ) *         ( logBoost * weightFactor === 0.0          ? 1.0          : Math.pow( 2, logBoost * weightFactor ) ) -        xmpMetadata.offsetHDR;        const linearHDRValue = Math.min(        Math.max( this._srgbToLinear( hdrValue ), 0 ),        65504       );        hdrBuffer[ pixelIndex + channelIndex ] =        this.type === HalfFloatType         ? DataUtils.toHalfFloat( linearHDRValue )         : linearHDRValue;       }      }      onSuccess( hdrBuffer, sdrImage.width, sdrImage.height );     } )    .catch( () => {      throw new Error(      'THREE.UltraHDRLoader Error: Could not parse UltraHDR images'     );     } );   }  }  export { UltraHDRLoader }; 
^..^ FILENAME ^..^
addons|loaders|USDZLoader.js
^..^ CONTENTS ^..^
import {  BufferAttribute,  BufferGeometry,  ClampToEdgeWrapping,  FileLoader,  Group,  NoColorSpace,  Loader,  Mesh,  MeshPhysicalMaterial,  MirroredRepeatWrapping,  RepeatWrapping,  SRGBColorSpace,  TextureLoader,  Object3D,  Vector2 } from 'three';  import * as fflate from '../libs/fflate.module.js';  class USDAParser {   parse( text ) {    const data = {};    const lines = text.split( '|n' );    let string = null;   let target = data;    const stack = [ data ];    // debugger;    for ( const line of lines ) {     // console.log( line );     if ( line.includes( '=' ) ) {      const assignment = line.split( '=' );      const lhs = assignment[ 0 ].trim();     const rhs = assignment[ 1 ].trim();      if ( rhs.endsWith( '{' ) ) {       const group = {};      stack.push( group );       target[ lhs ] = group;      target = group;      } else if ( rhs.endsWith( '(' ) ) {       // see #28631       const values = rhs.slice( 0, - 1 );      target[ lhs ] = values;       const meta = {};      stack.push( meta );       target = meta;      } else {       target[ lhs ] = rhs;      }     } else if ( line.endsWith( '{' ) ) {      const group = target[ string ] || {};     stack.push( group );      target[ string ] = group;     target = group;     } else if ( line.endsWith( '}' ) ) {      stack.pop();      if ( stack.length === 0 ) continue;      target = stack[ stack.length - 1 ];     } else if ( line.endsWith( '(' ) ) {      const meta = {};     stack.push( meta );      string = line.split( '(' )[ 0 ].trim() || string;      target[ string ] = meta;     target = meta;     } else if ( line.endsWith( ')' ) ) {      stack.pop();      target = stack[ stack.length - 1 ];     } else {      string = line.trim();     }    }    return data;   }  }  class USDZLoader extends Loader {   constructor( manager ) {    super( manager );   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( scope.manager );   loader.setPath( scope.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( scope.requestHeader );   loader.setWithCredentials( scope.withCredentials );   loader.load( url, function ( text ) {     try {      onLoad( scope.parse( text ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( buffer ) {    const parser = new USDAParser();    function parseAssets( zip ) {     const data = {};    const loader = new FileLoader();    loader.setResponseType( 'arraybuffer' );     for ( const filename in zip ) {      if ( filename.endsWith( 'png' ) ) {       const blob = new Blob( [ zip[ filename ] ], { type: { type: 'image/png' } } );      data[ filename ] = URL.createObjectURL( blob );      }      if ( filename.endsWith( 'usd' ) || filename.endsWith( 'usda' ) ) {       if ( isCrateFile( zip[ filename ] ) ) {        throw Error( 'THREE.USDZLoader: Crate files (.usdc or binary .usd) are not supported.' );       }       const text = fflate.strFromU8( zip[ filename ] );      data[ filename ] = parser.parse( text );      }     }     return data;    }    function isCrateFile( buffer ) {     // Check if this a crate file. First 7 bytes of a crate file are "PXR-USDC".    const fileHeader = buffer.slice( 0, 7 );    const crateHeader = new Uint8Array( [ 0x50, 0x58, 0x52, 0x2D, 0x55, 0x53, 0x44, 0x43 ] );     // If this is not a crate file, we assume it is a plain USDA file.    return fileHeader.every( ( value, index ) => value === crateHeader[ index ] );    }    function findUSD( zip ) {     if ( zip.length < 1 ) return undefined;     const firstFileName = Object.keys( zip )[ 0 ];    let isCrate = false;     // As per the USD specification, the first entry in the zip archive is used as the main file ("UsdStage").    // ASCII files can end in either .usda or .usd.    // See https://openusd.org/release/spec_usdz.html#layout    if ( firstFileName.endsWith( 'usda' ) ) return zip[ firstFileName ];     if ( firstFileName.endsWith( 'usdc' ) ) {      isCrate = true;     } else if ( firstFileName.endsWith( 'usd' ) ) {      // If this is not a crate file, we assume it is a plain USDA file.     if ( ! isCrateFile( zip[ firstFileName ] ) ) {       return zip[ firstFileName ];      } else {       isCrate = true;      }     }     if ( isCrate ) {      throw Error( 'THREE.USDZLoader: Crate files (.usdc or binary .usd) are not supported.' );     }    }    const zip = fflate.unzipSync( new Uint8Array( buffer ) );    // console.log( zip );    const assets = parseAssets( zip );    // console.log( assets )    const file = findUSD( zip );    // Parse file    const text = fflate.strFromU8( file );   const root = parser.parse( text );    // Build scene    function findMeshGeometry( data ) {     if ( ! data ) return undefined;     if ( 'prepend references' in data ) {      const reference = data[ 'prepend references' ];     const parts = reference.split( '@' );     const path = parts[ 1 ].replace( /^.|//, '' );     const id = parts[ 2 ].replace( /^<|//, '' ).replace( />$/, '' );      return findGeometry( assets[ path ], id );     }     return findGeometry( data );    }    function findGeometry( data, id ) {     if ( ! data ) return undefined;     if ( id !== undefined ) {      const def = |def Mesh "|id}"|;      if ( def in data ) {       return data[ def ];      }     }     for ( const name in data ) {      const object = data[ name ];      if ( name.startsWith( 'def Mesh' ) ) {       return object;      }       if ( typeof object === 'object' ) {       const geometry = findGeometry( object );       if ( geometry ) return geometry;      }     }    }    function buildGeometry( data ) {     if ( ! data ) return undefined;     const geometry = new BufferGeometry();    let indices = null;    let counts = null;    let uvs = null;     let positionsLength = - 1;     // index     if ( 'int[] faceVertexIndices' in data ) {      indices = JSON.parse( data[ 'int[] faceVertexIndices' ] );     }     // face count     if ( 'int[] faceVertexCounts' in data ) {      counts = JSON.parse( data[ 'int[] faceVertexCounts' ] );     indices = toTriangleIndices( indices, counts );     }     // position     if ( 'point3f[] points' in data ) {      const positions = JSON.parse( data[ 'point3f[] points' ].replace( /[()]*/g, '' ) );     positionsLength = positions.length;     let attribute = new BufferAttribute( new Float32Array( positions ), 3 );      if ( indices !== null ) attribute = toFlatBufferAttribute( attribute, indices );      geometry.setAttribute( 'position', attribute );     }     // uv     if ( 'float2[] primvars:st' in data ) {      data[ 'texCoord2f[] primvars:st' ] = data[ 'float2[] primvars:st' ];     }     if ( 'texCoord2f[] primvars:st' in data ) {      uvs = JSON.parse( data[ 'texCoord2f[] primvars:st' ].replace( /[()]*/g, '' ) );     let attribute = new BufferAttribute( new Float32Array( uvs ), 2 );      if ( indices !== null ) attribute = toFlatBufferAttribute( attribute, indices );      geometry.setAttribute( 'uv', attribute );     }     if ( 'int[] primvars:st:indices' in data && uvs !== null ) {      // custom uv index, overwrite uvs with new data      const attribute = new BufferAttribute( new Float32Array( uvs ), 2 );     let indices = JSON.parse( data[ 'int[] primvars:st:indices' ] );     indices = toTriangleIndices( indices, counts );     geometry.setAttribute( 'uv', toFlatBufferAttribute( attribute, indices ) );     }     // normal     if ( 'normal3f[] normals' in data ) {      const normals = JSON.parse( data[ 'normal3f[] normals' ].replace( /[()]*/g, '' ) );     let attribute = new BufferAttribute( new Float32Array( normals ), 3 );      // normals require a special treatment in USD      if ( normals.length === positionsLength ) {       // raw normal and position data have equal length (like produced by USDZExporter)       if ( indices !== null ) attribute = toFlatBufferAttribute( attribute, indices );      } else {       // unequal length, normals are independent of faceVertexIndices       let indices = Array.from( Array( normals.length / 3 ).keys() ); // [ 0, 1, 2, 3 ... ]      indices = toTriangleIndices( indices, counts );      attribute = toFlatBufferAttribute( attribute, indices );      }      geometry.setAttribute( 'normal', attribute );     } else {      // compute flat vertex normals      geometry.computeVertexNormals();     }     return geometry;    }    function toTriangleIndices( rawIndices, counts ) {     const indices = [];     for ( let i = 0; i < counts.length; i ++ ) {      const count = counts[ i ];      const stride = i * count;      if ( count === 3 ) {       const a = rawIndices[ stride + 0 ];      const b = rawIndices[ stride + 1 ];      const c = rawIndices[ stride + 2 ];       indices.push( a, b, c );      } else if ( count === 4 ) {       const a = rawIndices[ stride + 0 ];      const b = rawIndices[ stride + 1 ];      const c = rawIndices[ stride + 2 ];      const d = rawIndices[ stride + 3 ];       indices.push( a, b, c );      indices.push( a, c, d );      } else {       console.warn( 'THREE.USDZLoader: Face vertex count of %s unsupported.', count );      }     }     return indices;    }    function toFlatBufferAttribute( attribute, indices ) {     const array = attribute.array;    const itemSize = attribute.itemSize;     const array2 = new array.constructor( indices.length * itemSize );     let index = 0, index2 = 0;     for ( let i = 0, l = indices.length; i < l; i ++ ) {      index = indices[ i ] * itemSize;      for ( let j = 0; j < itemSize; j ++ ) {       array2[ index2 ++ ] = array[ index ++ ];      }     }     return new BufferAttribute( array2, itemSize );    }    function findMeshMaterial( data ) {     if ( ! data ) return undefined;     if ( 'rel material:binding' in data ) {      const reference = data[ 'rel material:binding' ];     const id = reference.replace( /^<|//, '' ).replace( />$/, '' );     const parts = id.split( '/' );      return findMaterial( root, | "| parts[ 1 ] }"| );     }     return findMaterial( data );    }    function findMaterial( data, id = '' ) {     for ( const name in data ) {      const object = data[ name ];      if ( name.startsWith( 'def Material' + id ) ) {       return object;      }      if ( typeof object === 'object' ) {       const material = findMaterial( object, id );       if ( material ) return material;      }     }    }    function setTextureParams( map, data_value ) {     // rotation, scale and translation     if ( data_value[ 'float inputs:rotation' ] ) {      map.rotation = parseFloat( data_value[ 'float inputs:rotation' ] );     }     if ( data_value[ 'float2 inputs:scale' ] ) {      map.repeat = new Vector2().fromArray( JSON.parse( '[' + data_value[ 'float2 inputs:scale' ].replace( /[()]*/g, '' ) + ']' ) );     }     if ( data_value[ 'float2 inputs:translation' ] ) {      map.offset = new Vector2().fromArray( JSON.parse( '[' + data_value[ 'float2 inputs:translation' ].replace( /[()]*/g, '' ) + ']' ) );     }    }    function buildMaterial( data ) {     const material = new MeshPhysicalMaterial();     if ( data !== undefined ) {      const surfaceConnection = data[ 'token outputs:surface.connect' ];     const surfaceName = /(|w+).output/.exec( surfaceConnection )[ 1 ];     const surface = data[ |def Shader "|surfaceName}"| ];      if ( surface !== undefined ) {       if ( 'color3f inputs:diffuseColor.connect' in surface ) {        const path = surface[ 'color3f inputs:diffuseColor.connect' ];       const sampler = findTexture( root, /(|w+).output/.exec( path )[ 1 ] );        material.map = buildTexture( sampler );       material.map.colorSpace = SRGBColorSpace;        if ( 'def Shader "Transform2d_diffuse"' in data ) {         setTextureParams( material.map, data[ 'def Shader "Transform2d_diffuse"' ] );        }       } else if ( 'color3f inputs:diffuseColor' in surface ) {        const color = surface[ 'color3f inputs:diffuseColor' ].replace( /[()]*/g, '' );       material.color.fromArray( JSON.parse( '[' + color + ']' ) );       }       if ( 'color3f inputs:emissiveColor.connect' in surface ) {        const path = surface[ 'color3f inputs:emissiveColor.connect' ];       const sampler = findTexture( root, /(|w+).output/.exec( path )[ 1 ] );        material.emissiveMap = buildTexture( sampler );       material.emissiveMap.colorSpace = SRGBColorSpace;       material.emissive.set( 0xffffff );        if ( 'def Shader "Transform2d_emissive"' in data ) {         setTextureParams( material.emissiveMap, data[ 'def Shader "Transform2d_emissive"' ] );        }       } else if ( 'color3f inputs:emissiveColor' in surface ) {        const color = surface[ 'color3f inputs:emissiveColor' ].replace( /[()]*/g, '' );       material.emissive.fromArray( JSON.parse( '[' + color + ']' ) );       }       if ( 'normal3f inputs:normal.connect' in surface ) {        const path = surface[ 'normal3f inputs:normal.connect' ];       const sampler = findTexture( root, /(|w+).output/.exec( path )[ 1 ] );        material.normalMap = buildTexture( sampler );       material.normalMap.colorSpace = NoColorSpace;        if ( 'def Shader "Transform2d_normal"' in data ) {         setTextureParams( material.normalMap, data[ 'def Shader "Transform2d_normal"' ] );        }       }       if ( 'float inputs:roughness.connect' in surface ) {        const path = surface[ 'float inputs:roughness.connect' ];       const sampler = findTexture( root, /(|w+).output/.exec( path )[ 1 ] );        material.roughness = 1.0;       material.roughnessMap = buildTexture( sampler );       material.roughnessMap.colorSpace = NoColorSpace;        if ( 'def Shader "Transform2d_roughness"' in data ) {         setTextureParams( material.roughnessMap, data[ 'def Shader "Transform2d_roughness"' ] );        }       } else if ( 'float inputs:roughness' in surface ) {        material.roughness = parseFloat( surface[ 'float inputs:roughness' ] );       }       if ( 'float inputs:metallic.connect' in surface ) {        const path = surface[ 'float inputs:metallic.connect' ];       const sampler = findTexture( root, /(|w+).output/.exec( path )[ 1 ] );        material.metalness = 1.0;       material.metalnessMap = buildTexture( sampler );       material.metalnessMap.colorSpace = NoColorSpace;        if ( 'def Shader "Transform2d_metallic"' in data ) {         setTextureParams( material.metalnessMap, data[ 'def Shader "Transform2d_metallic"' ] );        }       } else if ( 'float inputs:metallic' in surface ) {        material.metalness = parseFloat( surface[ 'float inputs:metallic' ] );       }       if ( 'float inputs:clearcoat.connect' in surface ) {        const path = surface[ 'float inputs:clearcoat.connect' ];       const sampler = findTexture( root, /(|w+).output/.exec( path )[ 1 ] );        material.clearcoat = 1.0;       material.clearcoatMap = buildTexture( sampler );       material.clearcoatMap.colorSpace = NoColorSpace;        if ( 'def Shader "Transform2d_clearcoat"' in data ) {         setTextureParams( material.clearcoatMap, data[ 'def Shader "Transform2d_clearcoat"' ] );        }       } else if ( 'float inputs:clearcoat' in surface ) {        material.clearcoat = parseFloat( surface[ 'float inputs:clearcoat' ] );       }       if ( 'float inputs:clearcoatRoughness.connect' in surface ) {        const path = surface[ 'float inputs:clearcoatRoughness.connect' ];       const sampler = findTexture( root, /(|w+).output/.exec( path )[ 1 ] );        material.clearcoatRoughness = 1.0;       material.clearcoatRoughnessMap = buildTexture( sampler );       material.clearcoatRoughnessMap.colorSpace = NoColorSpace;        if ( 'def Shader "Transform2d_clearcoatRoughness"' in data ) {         setTextureParams( material.clearcoatRoughnessMap, data[ 'def Shader "Transform2d_clearcoatRoughness"' ] );        }       } else if ( 'float inputs:clearcoatRoughness' in surface ) {        material.clearcoatRoughness = parseFloat( surface[ 'float inputs:clearcoatRoughness' ] );       }       if ( 'float inputs:ior' in surface ) {        material.ior = parseFloat( surface[ 'float inputs:ior' ] );       }       if ( 'float inputs:occlusion.connect' in surface ) {        const path = surface[ 'float inputs:occlusion.connect' ];       const sampler = findTexture( root, /(|w+).output/.exec( path )[ 1 ] );        material.aoMap = buildTexture( sampler );       material.aoMap.colorSpace = NoColorSpace;        if ( 'def Shader "Transform2d_occlusion"' in data ) {         setTextureParams( material.aoMap, data[ 'def Shader "Transform2d_occlusion"' ] );        }       }      }     }     return material;    }    function findTexture( data, id ) {     for ( const name in data ) {      const object = data[ name ];      if ( name.startsWith( |def Shader "| id }"| ) ) {       return object;      }      if ( typeof object === 'object' ) {       const texture = findTexture( object, id );       if ( texture ) return texture;      }     }    }    function buildTexture( data ) {     if ( 'asset inputs:file' in data ) {      const path = data[ 'asset inputs:file' ].replace( /@*/g, '' ).trim();      const loader = new TextureLoader();      const texture = loader.load( assets[ path ] );      const map = {      '"clamp"': ClampToEdgeWrapping,      '"mirror"': MirroredRepeatWrapping,      '"repeat"': RepeatWrapping     };      if ( 'token inputs:wrapS' in data ) {       texture.wrapS = map[ data[ 'token inputs:wrapS' ] ];      }      if ( 'token inputs:wrapT' in data ) {       texture.wrapT = map[ data[ 'token inputs:wrapT' ] ];      }      return texture;     }     return null;    }    function buildObject( data ) {     const geometry = buildGeometry( findMeshGeometry( data ) );    const material = buildMaterial( findMeshMaterial( data ) );     const mesh = geometry ? new Mesh( geometry, material ) : new Object3D();     if ( 'matrix4d xformOp:transform' in data ) {      const array = JSON.parse( '[' + data[ 'matrix4d xformOp:transform' ].replace( /[()]*/g, '' ) + ']' );      mesh.matrix.fromArray( array );     mesh.matrix.decompose( mesh.position, mesh.quaternion, mesh.scale );     }     return mesh;    }    function buildHierarchy( data, group ) {     for ( const name in data ) {      if ( name.startsWith( 'def Scope' ) ) {       buildHierarchy( data[ name ], group );      } else if ( name.startsWith( 'def Xform' ) ) {       const mesh = buildObject( data[ name ] );       if ( /def Xform "(|w+)"/.test( name ) ) {        mesh.name = /def Xform "(|w+)"/.exec( name )[ 1 ];       }       group.add( mesh );       buildHierarchy( data[ name ], mesh );      }     }    }    const group = new Group();    buildHierarchy( root, group );    return group;   }  }  export { USDZLoader }; 
^..^ FILENAME ^..^
addons|loaders|VOXLoader.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  Color,  Data3DTexture,  FileLoader,  Float32BufferAttribute,  Loader,  LinearFilter,  Mesh,  MeshStandardMaterial,  NearestFilter,  RedFormat,  SRGBColorSpace } from 'three';  class VOXLoader extends Loader {   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( scope.manager );   loader.setPath( scope.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( scope.requestHeader );   loader.load( url, function ( buffer ) {     try {      onLoad( scope.parse( buffer ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( buffer ) {    const data = new DataView( buffer );    const id = data.getUint32( 0, true );   const version = data.getUint32( 4, true );    if ( id !== 542658390 ) {     console.error( 'THREE.VOXLoader: Invalid VOX file.' );    return;    }    if ( version !== 150 ) {     console.error( 'THREE.VOXLoader: Invalid VOX file. Unsupported version:', version );    return;    }    const DEFAULT_PALETTE = [    0x00000000, 0xffffffff, 0xffccffff, 0xff99ffff, 0xff66ffff, 0xff33ffff, 0xff00ffff, 0xffffccff,    0xffccccff, 0xff99ccff, 0xff66ccff, 0xff33ccff, 0xff00ccff, 0xffff99ff, 0xffcc99ff, 0xff9999ff,    0xff6699ff, 0xff3399ff, 0xff0099ff, 0xffff66ff, 0xffcc66ff, 0xff9966ff, 0xff6666ff, 0xff3366ff,    0xff0066ff, 0xffff33ff, 0xffcc33ff, 0xff9933ff, 0xff6633ff, 0xff3333ff, 0xff0033ff, 0xffff00ff,    0xffcc00ff, 0xff9900ff, 0xff6600ff, 0xff3300ff, 0xff0000ff, 0xffffffcc, 0xffccffcc, 0xff99ffcc,    0xff66ffcc, 0xff33ffcc, 0xff00ffcc, 0xffffcccc, 0xffcccccc, 0xff99cccc, 0xff66cccc, 0xff33cccc,    0xff00cccc, 0xffff99cc, 0xffcc99cc, 0xff9999cc, 0xff6699cc, 0xff3399cc, 0xff0099cc, 0xffff66cc,    0xffcc66cc, 0xff9966cc, 0xff6666cc, 0xff3366cc, 0xff0066cc, 0xffff33cc, 0xffcc33cc, 0xff9933cc,    0xff6633cc, 0xff3333cc, 0xff0033cc, 0xffff00cc, 0xffcc00cc, 0xff9900cc, 0xff6600cc, 0xff3300cc,    0xff0000cc, 0xffffff99, 0xffccff99, 0xff99ff99, 0xff66ff99, 0xff33ff99, 0xff00ff99, 0xffffcc99,    0xffcccc99, 0xff99cc99, 0xff66cc99, 0xff33cc99, 0xff00cc99, 0xffff9999, 0xffcc9999, 0xff999999,    0xff669999, 0xff339999, 0xff009999, 0xffff6699, 0xffcc6699, 0xff996699, 0xff666699, 0xff336699,    0xff006699, 0xffff3399, 0xffcc3399, 0xff993399, 0xff663399, 0xff333399, 0xff003399, 0xffff0099,    0xffcc0099, 0xff990099, 0xff660099, 0xff330099, 0xff000099, 0xffffff66, 0xffccff66, 0xff99ff66,    0xff66ff66, 0xff33ff66, 0xff00ff66, 0xffffcc66, 0xffcccc66, 0xff99cc66, 0xff66cc66, 0xff33cc66,    0xff00cc66, 0xffff9966, 0xffcc9966, 0xff999966, 0xff669966, 0xff339966, 0xff009966, 0xffff6666,    0xffcc6666, 0xff996666, 0xff666666, 0xff336666, 0xff006666, 0xffff3366, 0xffcc3366, 0xff993366,    0xff663366, 0xff333366, 0xff003366, 0xffff0066, 0xffcc0066, 0xff990066, 0xff660066, 0xff330066,    0xff000066, 0xffffff33, 0xffccff33, 0xff99ff33, 0xff66ff33, 0xff33ff33, 0xff00ff33, 0xffffcc33,    0xffcccc33, 0xff99cc33, 0xff66cc33, 0xff33cc33, 0xff00cc33, 0xffff9933, 0xffcc9933, 0xff999933,    0xff669933, 0xff339933, 0xff009933, 0xffff6633, 0xffcc6633, 0xff996633, 0xff666633, 0xff336633,    0xff006633, 0xffff3333, 0xffcc3333, 0xff993333, 0xff663333, 0xff333333, 0xff003333, 0xffff0033,    0xffcc0033, 0xff990033, 0xff660033, 0xff330033, 0xff000033, 0xffffff00, 0xffccff00, 0xff99ff00,    0xff66ff00, 0xff33ff00, 0xff00ff00, 0xffffcc00, 0xffcccc00, 0xff99cc00, 0xff66cc00, 0xff33cc00,    0xff00cc00, 0xffff9900, 0xffcc9900, 0xff999900, 0xff669900, 0xff339900, 0xff009900, 0xffff6600,    0xffcc6600, 0xff996600, 0xff666600, 0xff336600, 0xff006600, 0xffff3300, 0xffcc3300, 0xff993300,    0xff663300, 0xff333300, 0xff003300, 0xffff0000, 0xffcc0000, 0xff990000, 0xff660000, 0xff330000,    0xff0000ee, 0xff0000dd, 0xff0000bb, 0xff0000aa, 0xff000088, 0xff000077, 0xff000055, 0xff000044,    0xff000022, 0xff000011, 0xff00ee00, 0xff00dd00, 0xff00bb00, 0xff00aa00, 0xff008800, 0xff007700,    0xff005500, 0xff004400, 0xff002200, 0xff001100, 0xffee0000, 0xffdd0000, 0xffbb0000, 0xffaa0000,    0xff880000, 0xff770000, 0xff550000, 0xff440000, 0xff220000, 0xff110000, 0xffeeeeee, 0xffdddddd,    0xffbbbbbb, 0xffaaaaaa, 0xff888888, 0xff777777, 0xff555555, 0xff444444, 0xff222222, 0xff111111   ];    let i = 8;    let chunk;   const chunks = [];    while ( i < data.byteLength ) {     let id = '';     for ( let j = 0; j < 4; j ++ ) {      id += String.fromCharCode( data.getUint8( i ++ ) );     }     const chunkSize = data.getUint32( i, true ); i += 4;    i += 4; // childChunks     if ( id === 'SIZE' ) {      const x = data.getUint32( i, true ); i += 4;     const y = data.getUint32( i, true ); i += 4;     const z = data.getUint32( i, true ); i += 4;      chunk = {      palette: DEFAULT_PALETTE,      size: { x: x, y: y, z: z },     };      chunks.push( chunk );      i += chunkSize - ( 3 * 4 );     } else if ( id === 'XYZI' ) {      const numVoxels = data.getUint32( i, true ); i += 4;     chunk.data = new Uint8Array( buffer, i, numVoxels * 4 );      i += numVoxels * 4;     } else if ( id === 'RGBA' ) {      const palette = [ 0 ];      for ( let j = 0; j < 256; j ++ ) {       palette[ j + 1 ] = data.getUint32( i, true ); i += 4;      }      chunk.palette = palette;     } else {      // console.log( id, chunkSize, childChunks );      i += chunkSize;     }    }    return chunks;   }  }  class VOXMesh extends Mesh {   constructor( chunk ) {    const data = chunk.data;   const size = chunk.size;   const palette = chunk.palette;    //    const vertices = [];   const colors = [];    const nx = [ 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1 ];   const px = [ 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0 ];   const py = [ 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1 ];   const ny = [ 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0 ];   const nz = [ 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0 ];   const pz = [ 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1 ];    const _color = new Color();    function add( tile, x, y, z, r, g, b ) {     x -= size.x / 2;    y -= size.z / 2;    z += size.y / 2;     for ( let i = 0; i < 18; i += 3 ) {      _color.setRGB( r, g, b, SRGBColorSpace );      vertices.push( tile[ i + 0 ] + x, tile[ i + 1 ] + y, tile[ i + 2 ] + z );     colors.push( _color.r, _color.g, _color.b );     }    }    // Store data in a volume for sampling    const offsety = size.x;   const offsetz = size.x * size.y;    const array = new Uint8Array( size.x * size.y * size.z );    for ( let j = 0; j < data.length; j += 4 ) {     const x = data[ j + 0 ];    const y = data[ j + 1 ];    const z = data[ j + 2 ];     const index = x + ( y * offsety ) + ( z * offsetz );     array[ index ] = 255;    }    // Construct geometry    let hasColors = false;    for ( let j = 0; j < data.length; j += 4 ) {     const x = data[ j + 0 ];    const y = data[ j + 1 ];    const z = data[ j + 2 ];    const c = data[ j + 3 ];     const hex = palette[ c ];    const r = ( hex >> 0 & 0xff ) / 0xff;    const g = ( hex >> 8 & 0xff ) / 0xff;    const b = ( hex >> 16 & 0xff ) / 0xff;     if ( r > 0 || g > 0 || b > 0 ) hasColors = true;     const index = x + ( y * offsety ) + ( z * offsetz );     if ( array[ index + 1 ] === 0 || x === size.x - 1 ) add( px, x, z, - y, r, g, b );    if ( array[ index - 1 ] === 0 || x === 0 ) add( nx, x, z, - y, r, g, b );    if ( array[ index + offsety ] === 0 || y === size.y - 1 ) add( ny, x, z, - y, r, g, b );    if ( array[ index - offsety ] === 0 || y === 0 ) add( py, x, z, - y, r, g, b );    if ( array[ index + offsetz ] === 0 || z === size.z - 1 ) add( pz, x, z, - y, r, g, b );    if ( array[ index - offsetz ] === 0 || z === 0 ) add( nz, x, z, - y, r, g, b );    }    const geometry = new BufferGeometry();   geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );   geometry.computeVertexNormals();    const material = new MeshStandardMaterial();    if ( hasColors ) {     geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );    material.vertexColors = true;    }    super( geometry, material );   }  }  class VOXData3DTexture extends Data3DTexture {   constructor( chunk ) {    const data = chunk.data;   const size = chunk.size;    const offsety = size.x;   const offsetz = size.x * size.y;    const array = new Uint8Array( size.x * size.y * size.z );    for ( let j = 0; j < data.length; j += 4 ) {     const x = data[ j + 0 ];    const y = data[ j + 1 ];    const z = data[ j + 2 ];     const index = x + ( y * offsety ) + ( z * offsetz );     array[ index ] = 255;    }    super( array, size.x, size.y, size.z );    this.format = RedFormat;   this.minFilter = NearestFilter;   this.magFilter = LinearFilter;   this.unpackAlignment = 1;   this.needsUpdate = true;   }  }  export { VOXLoader, VOXMesh, VOXData3DTexture }; 
^..^ FILENAME ^..^
addons|loaders|VRMLLoader.js
^..^ CONTENTS ^..^
import {  BackSide,  BoxGeometry,  BufferAttribute,  BufferGeometry,  ClampToEdgeWrapping,  Color,  ColorManagement,  ConeGeometry,  CylinderGeometry,  DataTexture,  DoubleSide,  FileLoader,  Float32BufferAttribute,  FrontSide,  Group,  LineBasicMaterial,  LineSegments,  Loader,  LoaderUtils,  Mesh,  MeshBasicMaterial,  MeshPhongMaterial,  Object3D,  Points,  PointsMaterial,  Quaternion,  RepeatWrapping,  Scene,  ShapeUtils,  SphereGeometry,  SRGBColorSpace,  TextureLoader,  Vector2,  Vector3 } from 'three'; import chevrotain from '../libs/chevrotain.module.min.js';   class VRMLLoader extends Loader {   constructor( manager ) {    super( manager );   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;    const loader = new FileLoader( scope.manager );   loader.setPath( scope.path );   loader.setRequestHeader( scope.requestHeader );   loader.setWithCredentials( scope.withCredentials );   loader.load( url, function ( text ) {     try {      onLoad( scope.parse( text, path ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( data, path ) {    const nodeMap = {};    function generateVRMLTree( data ) {     // create lexer, parser and visitor     const tokenData = createTokens();     const lexer = new VRMLLexer( tokenData.tokens );    const parser = new VRMLParser( tokenData.tokenVocabulary );    const visitor = createVisitor( parser.getBaseCstVisitorConstructor() );     // lexing     const lexingResult = lexer.lex( data );    parser.input = lexingResult.tokens;     // parsing     const cstOutput = parser.vrml();     if ( parser.errors.length > 0 ) {      console.error( parser.errors );      throw Error( 'THREE.VRMLLoader: Parsing errors detected.' );     }     // actions     const ast = visitor.visit( cstOutput );     return ast;    }    function createTokens() {     const createToken = chevrotain.createToken;     // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics     const RouteIdentifier = createToken( { name: 'RouteIdentifier', pattern: /[^|x30-|x39|0-|x20|x22|x27|x23|x2b|x2c|x2d|x2e|x5b|x5d|x5c|x7b|x7d][^|0-|x20|x22|x27|x23|x2b|x2c|x2d|x2e|x5b|x5d|x5c|x7b|x7d]*[|.][^|x30-|x39|0-|x20|x22|x27|x23|x2b|x2c|x2d|x2e|x5b|x5d|x5c|x7b|x7d][^|0-|x20|x22|x27|x23|x2b|x2c|x2d|x2e|x5b|x5d|x5c|x7b|x7d]*/ } );    const Identifier = createToken( { name: 'Identifier', pattern: /[^|x30-|x39|0-|x20|x22|x27|x23|x2b|x2c|x2d|x2e|x5b|x5d|x5c|x7b|x7d]([^|0-|x20|x22|x27|x23|x2b|x2c|x2e|x5b|x5d|x5c|x7b|x7d])*/, longer_alt: RouteIdentifier } );     // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html     const nodeTypes = [     'Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes     'Inline', 'LOD', 'Switch', // special groups     'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes     'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors     'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries     'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties     'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance     'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators     'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes     'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate    ];     //     const Version = createToken( {     name: 'Version',     pattern: /#VRML.*/,     longer_alt: Identifier    } );     const NodeName = createToken( {     name: 'NodeName',     pattern: new RegExp( nodeTypes.join( '|' ) ),     longer_alt: Identifier    } );     const DEF = createToken( {     name: 'DEF',     pattern: /DEF/,     longer_alt: Identifier    } );     const USE = createToken( {     name: 'USE',     pattern: /USE/,     longer_alt: Identifier    } );     const ROUTE = createToken( {     name: 'ROUTE',     pattern: /ROUTE/,     longer_alt: Identifier    } );     const TO = createToken( {     name: 'TO',     pattern: /TO/,     longer_alt: Identifier    } );     //     const StringLiteral = createToken( { name: 'StringLiteral', pattern: /"(?:[^||"|n|r]|||[bfnrtv"||/]|||u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*"/ } );    const HexLiteral = createToken( { name: 'HexLiteral', pattern: /0[xX][0-9a-fA-F]+/ } );    const NumberLiteral = createToken( { name: 'NumberLiteral', pattern: /[-+]?[0-9]*|.?[0-9]+([eE][-+]?[0-9]+)?/ } );    const TrueLiteral = createToken( { name: 'TrueLiteral', pattern: /TRUE/ } );    const FalseLiteral = createToken( { name: 'FalseLiteral', pattern: /FALSE/ } );    const NullLiteral = createToken( { name: 'NullLiteral', pattern: /NULL/ } );    const LSquare = createToken( { name: 'LSquare', pattern: /|[/ } );    const RSquare = createToken( { name: 'RSquare', pattern: /]/ } );    const LCurly = createToken( { name: 'LCurly', pattern: /{/ } );    const RCurly = createToken( { name: 'RCurly', pattern: /}/ } );    const Comment = createToken( {     name: 'Comment',     pattern: /#.*/,     group: chevrotain.Lexer.SKIPPED    } );     // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields     const WhiteSpace = createToken( {     name: 'WhiteSpace',     pattern: /[ ,|s]/,     group: chevrotain.Lexer.SKIPPED    } );     const tokens = [     WhiteSpace,     // keywords appear before the Identifier     NodeName,     DEF,     USE,     ROUTE,     TO,     TrueLiteral,     FalseLiteral,     NullLiteral,     // the Identifier must appear after the keywords because all keywords are valid identifiers     Version,     Identifier,     RouteIdentifier,     StringLiteral,     HexLiteral,     NumberLiteral,     LSquare,     RSquare,     LCurly,     RCurly,     Comment    ];     const tokenVocabulary = {};     for ( let i = 0, l = tokens.length; i < l; i ++ ) {      const token = tokens[ i ];      tokenVocabulary[ token.name ] = token;     }     return { tokens: tokens, tokenVocabulary: tokenVocabulary };    }     function createVisitor( BaseVRMLVisitor ) {     // the visitor is created dynmaically based on the given base class     class VRMLToASTVisitor extends BaseVRMLVisitor {      constructor() {       super();       this.validateVisitor();      }      vrml( ctx ) {       const data = {       version: this.visit( ctx.version ),       nodes: [],       routes: []      };       for ( let i = 0, l = ctx.node.length; i < l; i ++ ) {        const node = ctx.node[ i ];        data.nodes.push( this.visit( node ) );       }       if ( ctx.route ) {        for ( let i = 0, l = ctx.route.length; i < l; i ++ ) {         const route = ctx.route[ i ];         data.routes.push( this.visit( route ) );        }       }       return data;      }      version( ctx ) {       return ctx.Version[ 0 ].image;      }      node( ctx ) {       const data = {       name: ctx.NodeName[ 0 ].image,       fields: []      };       if ( ctx.field ) {        for ( let i = 0, l = ctx.field.length; i < l; i ++ ) {         const field = ctx.field[ i ];         data.fields.push( this.visit( field ) );        }       }       // DEF       if ( ctx.def ) {        data.DEF = this.visit( ctx.def[ 0 ] );       }       return data;      }      field( ctx ) {       const data = {       name: ctx.Identifier[ 0 ].image,       type: null,       values: null      };       let result;       // SFValue       if ( ctx.singleFieldValue ) {        result = this.visit( ctx.singleFieldValue[ 0 ] );       }       // MFValue       if ( ctx.multiFieldValue ) {        result = this.visit( ctx.multiFieldValue[ 0 ] );       }       data.type = result.type;      data.values = result.values;       return data;      }      def( ctx ) {       return ( ctx.Identifier || ctx.NodeName )[ 0 ].image;      }      use( ctx ) {       return { USE: ( ctx.Identifier || ctx.NodeName )[ 0 ].image };      }      singleFieldValue( ctx ) {       return processField( this, ctx );      }      multiFieldValue( ctx ) {       return processField( this, ctx );      }      route( ctx ) {       const data = {       FROM: ctx.RouteIdentifier[ 0 ].image,       TO: ctx.RouteIdentifier[ 1 ].image      };       return data;      }     }     function processField( scope, ctx ) {      const field = {      type: null,      values: []     };      if ( ctx.node ) {       field.type = 'node';       for ( let i = 0, l = ctx.node.length; i < l; i ++ ) {        const node = ctx.node[ i ];        field.values.push( scope.visit( node ) );       }      }      if ( ctx.use ) {       field.type = 'use';       for ( let i = 0, l = ctx.use.length; i < l; i ++ ) {        const use = ctx.use[ i ];        field.values.push( scope.visit( use ) );       }      }      if ( ctx.StringLiteral ) {       field.type = 'string';       for ( let i = 0, l = ctx.StringLiteral.length; i < l; i ++ ) {        const stringLiteral = ctx.StringLiteral[ i ];        field.values.push( stringLiteral.image.replace( /'|"/g, '' ) );       }      }      if ( ctx.NumberLiteral ) {       field.type = 'number';       for ( let i = 0, l = ctx.NumberLiteral.length; i < l; i ++ ) {        const numberLiteral = ctx.NumberLiteral[ i ];        field.values.push( parseFloat( numberLiteral.image ) );       }      }      if ( ctx.HexLiteral ) {       field.type = 'hex';       for ( let i = 0, l = ctx.HexLiteral.length; i < l; i ++ ) {        const hexLiteral = ctx.HexLiteral[ i ];        field.values.push( hexLiteral.image );       }      }      if ( ctx.TrueLiteral ) {       field.type = 'boolean';       for ( let i = 0, l = ctx.TrueLiteral.length; i < l; i ++ ) {        const trueLiteral = ctx.TrueLiteral[ i ];        if ( trueLiteral.image === 'TRUE' ) field.values.push( true );       }      }      if ( ctx.FalseLiteral ) {       field.type = 'boolean';       for ( let i = 0, l = ctx.FalseLiteral.length; i < l; i ++ ) {        const falseLiteral = ctx.FalseLiteral[ i ];        if ( falseLiteral.image === 'FALSE' ) field.values.push( false );       }      }      if ( ctx.NullLiteral ) {       field.type = 'null';       ctx.NullLiteral.forEach( function () {        field.values.push( null );       } );      }      return field;     }     return new VRMLToASTVisitor();    }    function parseTree( tree ) {     // console.log( JSON.stringify( tree, null, 2 ) );     const nodes = tree.nodes;    const scene = new Scene();     // first iteration: build nodemap based on DEF statements     for ( let i = 0, l = nodes.length; i < l; i ++ ) {      const node = nodes[ i ];      buildNodeMap( node );     }     // second iteration: build nodes     for ( let i = 0, l = nodes.length; i < l; i ++ ) {      const node = nodes[ i ];     const object = getNode( node );      if ( object instanceof Object3D ) scene.add( object );      if ( node.name === 'WorldInfo' ) scene.userData.worldInfo = object;     }     return scene;    }    function buildNodeMap( node ) {     if ( node.DEF ) {      nodeMap[ node.DEF ] = node;     }     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];      if ( field.type === 'node' ) {       const fieldValues = field.values;       for ( let j = 0, jl = fieldValues.length; j < jl; j ++ ) {        buildNodeMap( fieldValues[ j ] );       }      }      }    }     function getNode( node ) {     // handle case where a node refers to a different one     if ( node.USE ) {      return resolveUSE( node.USE );     }     if ( node.build !== undefined ) return node.build;     node.build = buildNode( node );     return node.build;    }    // node builder    function buildNode( node ) {     const nodeName = node.name;    let build;     switch ( nodeName ) {      case 'Anchor':     case 'Group':     case 'Transform':     case 'Collision':      build = buildGroupingNode( node );      break;      case 'Background':      build = buildBackgroundNode( node );      break;      case 'Shape':      build = buildShapeNode( node );      break;      case 'Appearance':      build = buildAppearanceNode( node );      break;      case 'Material':      build = buildMaterialNode( node );      break;      case 'ImageTexture':      build = buildImageTextureNode( node );      break;      case 'PixelTexture':      build = buildPixelTextureNode( node );      break;      case 'TextureTransform':      build = buildTextureTransformNode( node );      break;      case 'IndexedFaceSet':      build = buildIndexedFaceSetNode( node );      break;      case 'IndexedLineSet':      build = buildIndexedLineSetNode( node );      break;      case 'PointSet':      build = buildPointSetNode( node );      break;      case 'Box':      build = buildBoxNode( node );      break;      case 'Cone':      build = buildConeNode( node );      break;      case 'Cylinder':      build = buildCylinderNode( node );      break;      case 'Sphere':      build = buildSphereNode( node );      break;      case 'ElevationGrid':      build = buildElevationGridNode( node );      break;      case 'Extrusion':      build = buildExtrusionNode( node );      break;      case 'Color':     case 'Coordinate':     case 'Normal':     case 'TextureCoordinate':      build = buildGeometricNode( node );      break;      case 'WorldInfo':      build = buildWorldInfoNode( node );      break;      case 'Billboard':      case 'Inline':     case 'LOD':     case 'Switch':      case 'AudioClip':     case 'DirectionalLight':     case 'PointLight':     case 'Script':     case 'Sound':     case 'SpotLight':      case 'CylinderSensor':     case 'PlaneSensor':     case 'ProximitySensor':     case 'SphereSensor':     case 'TimeSensor':     case 'TouchSensor':     case 'VisibilitySensor':      case 'Text':      case 'FontStyle':     case 'MovieTexture':      case 'ColorInterpolator':     case 'CoordinateInterpolator':     case 'NormalInterpolator':     case 'OrientationInterpolator':     case 'PositionInterpolator':     case 'ScalarInterpolator':      case 'Fog':     case 'NavigationInfo':     case 'Viewpoint':      // node not supported yet      break;      default:      console.warn( 'THREE.VRMLLoader: Unknown node:', nodeName );      break;     }     if ( build !== undefined && node.DEF !== undefined && build.hasOwnProperty( 'name' ) === true ) {      build.name = node.DEF;     }     return build;    }    function buildGroupingNode( node ) {     const object = new Group();     //     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'bboxCenter':       // field not supported       break;       case 'bboxSize':       // field not supported       break;       case 'center':       // field not supported       break;       case 'children':       parseFieldChildren( fieldValues, object );       break;       case 'description':       // field not supported       break;       case 'collide':       // field not supported       break;       case 'parameter':       // field not supported       break;       case 'rotation':       const axis = new Vector3( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] ).normalize();       const angle = fieldValues[ 3 ];       object.quaternion.setFromAxisAngle( axis, angle );       break;       case 'scale':       object.scale.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );       break;       case 'scaleOrientation':       // field not supported       break;       case 'translation':       object.position.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );       break;       case 'proxy':       // field not supported       break;       case 'url':       // field not supported       break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     return object;    }    function buildBackgroundNode( node ) {     const group = new Group();     let groundAngle, groundColor;    let skyAngle, skyColor;     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'groundAngle':       groundAngle = fieldValues;       break;       case 'groundColor':       groundColor = fieldValues;       break;       case 'backUrl':       // field not supported       break;       case 'bottomUrl':       // field not supported       break;       case 'frontUrl':       // field not supported       break;       case 'leftUrl':       // field not supported       break;       case 'rightUrl':       // field not supported       break;       case 'topUrl':       // field not supported       break;       case 'skyAngle':       skyAngle = fieldValues;       break;       case 'skyColor':       skyColor = fieldValues;       break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     const radius = 10000;     // sky     if ( skyColor ) {      const skyGeometry = new SphereGeometry( radius, 32, 16 );     const skyMaterial = new MeshBasicMaterial( { fog: false, side: BackSide, depthWrite: false, depthTest: false } );      if ( skyColor.length > 3 ) {       paintFaces( skyGeometry, radius, skyAngle, toColorArray( skyColor ), true );      skyMaterial.vertexColors = true;      } else {       skyMaterial.color.setRGB( skyColor[ 0 ], skyColor[ 1 ], skyColor[ 2 ], SRGBColorSpace );      }      const sky = new Mesh( skyGeometry, skyMaterial );     group.add( sky );     }     // ground     if ( groundColor ) {      if ( groundColor.length > 0 ) {       const groundGeometry = new SphereGeometry( radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI );      const groundMaterial = new MeshBasicMaterial( { fog: false, side: BackSide, vertexColors: true, depthWrite: false, depthTest: false } );       paintFaces( groundGeometry, radius, groundAngle, toColorArray( groundColor ), false );       const ground = new Mesh( groundGeometry, groundMaterial );      group.add( ground );      }     }     // render background group first     group.renderOrder = - Infinity;     return group;    }    function buildShapeNode( node ) {     const fields = node.fields;     // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)     let material = new MeshBasicMaterial( {     name: Loader.DEFAULT_MATERIAL_NAME,     color: 0x000000    } );    let geometry;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'appearance':       if ( fieldValues[ 0 ] !== null ) {         material = getNode( fieldValues[ 0 ] );        }        break;       case 'geometry':       if ( fieldValues[ 0 ] !== null ) {         geometry = getNode( fieldValues[ 0 ] );        }        break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     // build 3D object     let object;     if ( geometry && geometry.attributes.position ) {      const type = geometry._type;      if ( type === 'points' ) { // points       const pointsMaterial = new PointsMaterial( {       name: Loader.DEFAULT_MATERIAL_NAME,       color: 0xffffff,       opacity: material.opacity,       transparent: material.transparent      } );       if ( geometry.attributes.color !== undefined ) {        pointsMaterial.vertexColors = true;       } else {        // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points        if ( material.isMeshPhongMaterial ) {         pointsMaterial.color.copy( material.emissive );        }       }       object = new Points( geometry, pointsMaterial );      } else if ( type === 'line' ) { // lines       const lineMaterial = new LineBasicMaterial( {       name: Loader.DEFAULT_MATERIAL_NAME,       color: 0xffffff,       opacity: material.opacity,       transparent: material.transparent      } );       if ( geometry.attributes.color !== undefined ) {        lineMaterial.vertexColors = true;       } else {        // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines        if ( material.isMeshPhongMaterial ) {         lineMaterial.color.copy( material.emissive );        }       }       object = new LineSegments( geometry, lineMaterial );      } else { // consider meshes       // check "solid" hint (it's placed in the geometry but affects the material)       if ( geometry._solid !== undefined ) {        material.side = ( geometry._solid ) ? FrontSide : DoubleSide;       }       // check for vertex colors       if ( geometry.attributes.color !== undefined ) {        material.vertexColors = true;       }       object = new Mesh( geometry, material );      }     } else {      object = new Object3D();      // if the geometry field is NULL or no vertices are defined the object is not drawn      object.visible = false;     }     return object;    }    function buildAppearanceNode( node ) {     let material = new MeshPhongMaterial();    let transformData;     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'material':       if ( fieldValues[ 0 ] !== null ) {         const materialData = getNode( fieldValues[ 0 ] );         if ( materialData.diffuseColor ) material.color.copy( materialData.diffuseColor );        if ( materialData.emissiveColor ) material.emissive.copy( materialData.emissiveColor );        if ( materialData.shininess ) material.shininess = materialData.shininess;        if ( materialData.specularColor ) material.specular.copy( materialData.specularColor );        if ( materialData.transparency ) material.opacity = 1 - materialData.transparency;        if ( materialData.transparency > 0 ) material.transparent = true;        } else {         // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)         material = new MeshBasicMaterial( {         name: Loader.DEFAULT_MATERIAL_NAME,         color: 0x000000        } );        }        break;       case 'texture':       const textureNode = fieldValues[ 0 ];       if ( textureNode !== null ) {         if ( textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture' ) {          material.map = getNode( textureNode );         } else {          // MovieTexture not supported yet         }        }        break;       case 'textureTransform':       if ( fieldValues[ 0 ] !== null ) {         transformData = getNode( fieldValues[ 0 ] );        }        break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     // only apply texture transform data if a texture was defined     if ( material.map ) {      // respect VRML lighting model      if ( material.map.__type ) {       switch ( material.map.__type ) {        case TEXTURE_TYPE.INTENSITY_ALPHA:        material.opacity = 1; // ignore transparency        break;        case TEXTURE_TYPE.RGB:        material.color.set( 0xffffff ); // ignore material color        break;        case TEXTURE_TYPE.RGBA:        material.color.set( 0xffffff ); // ignore material color        material.opacity = 1; // ignore transparency        break;        default:       }       delete material.map.__type;      }      // apply texture transform      if ( transformData ) {       material.map.center.copy( transformData.center );      material.map.rotation = transformData.rotation;      material.map.repeat.copy( transformData.scale );      material.map.offset.copy( transformData.translation );      }     }     return material;    }    function buildMaterialNode( node ) {     const materialData = {};     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'ambientIntensity':       // field not supported       break;       case 'diffuseColor':       materialData.diffuseColor = new Color().setRGB( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ], SRGBColorSpace );       break;       case 'emissiveColor':       materialData.emissiveColor = new Color().setRGB( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ], SRGBColorSpace );       break;       case 'shininess':       materialData.shininess = fieldValues[ 0 ];       break;       case 'specularColor':       materialData.specularColor = new Color().setRGB( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ], SRGBColorSpace );       break;       case 'transparency':       materialData.transparency = fieldValues[ 0 ];       break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     return materialData;    }    function parseHexColor( hex, textureType, color ) {     let value;     switch ( textureType ) {      case TEXTURE_TYPE.INTENSITY:      // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image      value = parseInt( hex );      color.r = value;      color.g = value;      color.b = value;      color.a = 1;      break;      case TEXTURE_TYPE.INTENSITY_ALPHA:      // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.      value = parseInt( '0x' + hex.substring( 2, 4 ) );      color.r = value;      color.g = value;      color.b = value;      color.a = parseInt( '0x' + hex.substring( 4, 6 ) );      break;      case TEXTURE_TYPE.RGB:      // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components      color.r = parseInt( '0x' + hex.substring( 2, 4 ) );      color.g = parseInt( '0x' + hex.substring( 4, 6 ) );      color.b = parseInt( '0x' + hex.substring( 6, 8 ) );      color.a = 1;      break;      case TEXTURE_TYPE.RGBA:      // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue      color.r = parseInt( '0x' + hex.substring( 2, 4 ) );      color.g = parseInt( '0x' + hex.substring( 4, 6 ) );      color.b = parseInt( '0x' + hex.substring( 6, 8 ) );      color.a = parseInt( '0x' + hex.substring( 8, 10 ) );      break;      default:     }    }    function getTextureType( num_components ) {     let type;     switch ( num_components ) {      case 1:      type = TEXTURE_TYPE.INTENSITY;      break;      case 2:      type = TEXTURE_TYPE.INTENSITY_ALPHA;      break;      case 3:      type = TEXTURE_TYPE.RGB;      break;      case 4:      type = TEXTURE_TYPE.RGBA;      break;      default:     }     return type;    }    function buildPixelTextureNode( node ) {     let texture;    let wrapS = RepeatWrapping;    let wrapT = RepeatWrapping;     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'image':       const width = fieldValues[ 0 ];       const height = fieldValues[ 1 ];       const num_components = fieldValues[ 2 ];        const textureType = getTextureType( num_components );        const data = new Uint8Array( 4 * width * height );        const color = { r: 0, g: 0, b: 0, a: 0 };        for ( let j = 3, k = 0, jl = fieldValues.length; j < jl; j ++, k ++ ) {         parseHexColor( fieldValues[ j ], textureType, color );         const stride = k * 4;         data[ stride + 0 ] = color.r;        data[ stride + 1 ] = color.g;        data[ stride + 2 ] = color.b;        data[ stride + 3 ] = color.a;        }        texture = new DataTexture( data, width, height );       texture.colorSpace = SRGBColorSpace;       texture.needsUpdate = true;       texture.__type = textureType; // needed for material modifications       break;       case 'repeatS':       if ( fieldValues[ 0 ] === false ) wrapS = ClampToEdgeWrapping;       break;       case 'repeatT':       if ( fieldValues[ 0 ] === false ) wrapT = ClampToEdgeWrapping;       break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     if ( texture ) {      texture.wrapS = wrapS;     texture.wrapT = wrapT;     }     return texture;    }    function buildImageTextureNode( node ) {     let texture;    let wrapS = RepeatWrapping;    let wrapT = RepeatWrapping;     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'url':       const url = fieldValues[ 0 ];       if ( url ) texture = textureLoader.load( url );       break;       case 'repeatS':       if ( fieldValues[ 0 ] === false ) wrapS = ClampToEdgeWrapping;       break;       case 'repeatT':       if ( fieldValues[ 0 ] === false ) wrapT = ClampToEdgeWrapping;       break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     if ( texture ) {      texture.wrapS = wrapS;     texture.wrapT = wrapT;     texture.colorSpace = SRGBColorSpace;     }     return texture;    }    function buildTextureTransformNode( node ) {     const transformData = {     center: new Vector2(),     rotation: new Vector2(),     scale: new Vector2(),     translation: new Vector2()    };     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'center':       transformData.center.set( fieldValues[ 0 ], fieldValues[ 1 ] );       break;       case 'rotation':       transformData.rotation = fieldValues[ 0 ];       break;       case 'scale':       transformData.scale.set( fieldValues[ 0 ], fieldValues[ 1 ] );       break;       case 'translation':       transformData.translation.set( fieldValues[ 0 ], fieldValues[ 1 ] );       break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     return transformData;    }    function buildGeometricNode( node ) {     return node.fields[ 0 ].values;    }    function buildWorldInfoNode( node ) {     const worldInfo = {};     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'title':       worldInfo.title = fieldValues[ 0 ];       break;       case 'info':       worldInfo.info = fieldValues;       break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     return worldInfo;    }    function buildIndexedFaceSetNode( node ) {     let color, coord, normal, texCoord;    let ccw = true, solid = true, creaseAngle = 0;    let colorIndex, coordIndex, normalIndex, texCoordIndex;    let colorPerVertex = true, normalPerVertex = true;     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'color':       const colorNode = fieldValues[ 0 ];        if ( colorNode !== null ) {         color = getNode( colorNode );        }        break;       case 'coord':       const coordNode = fieldValues[ 0 ];        if ( coordNode !== null ) {         coord = getNode( coordNode );        }        break;       case 'normal':       const normalNode = fieldValues[ 0 ];        if ( normalNode !== null ) {         normal = getNode( normalNode );        }        break;       case 'texCoord':       const texCoordNode = fieldValues[ 0 ];        if ( texCoordNode !== null ) {         texCoord = getNode( texCoordNode );        }        break;       case 'ccw':       ccw = fieldValues[ 0 ];       break;       case 'colorIndex':       colorIndex = fieldValues;       break;       case 'colorPerVertex':       colorPerVertex = fieldValues[ 0 ];       break;       case 'convex':       // field not supported       break;       case 'coordIndex':       coordIndex = fieldValues;       break;       case 'creaseAngle':       creaseAngle = fieldValues[ 0 ];       break;       case 'normalIndex':       normalIndex = fieldValues;       break;       case 'normalPerVertex':       normalPerVertex = fieldValues[ 0 ];       break;       case 'solid':       solid = fieldValues[ 0 ];       break;       case 'texCoordIndex':       texCoordIndex = fieldValues;       break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     if ( coordIndex === undefined ) {      console.warn( 'THREE.VRMLLoader: Missing coordIndex.' );      return new BufferGeometry(); // handle VRML files with incomplete geometry definition     }     const triangulatedCoordIndex = triangulateFaceIndex( coordIndex, ccw );     let colorAttribute;    let normalAttribute;    let uvAttribute;     if ( color ) {      if ( colorPerVertex === true ) {       if ( colorIndex && colorIndex.length > 0 ) {        // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.        const triangulatedColorIndex = triangulateFaceIndex( colorIndex, ccw );       colorAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedColorIndex, color, 3 );       } else {        // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node        colorAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new Float32BufferAttribute( color, 3 ) );       }      } else {       if ( colorIndex && colorIndex.length > 0 ) {        // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet        const flattenFaceColors = flattenData( color, colorIndex );       const triangulatedFaceColors = triangulateFaceData( flattenFaceColors, coordIndex );       colorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors );       } else {        // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order        const triangulatedFaceColors = triangulateFaceData( color, coordIndex );       colorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors );        }      }      convertColorsToLinearSRGB( colorAttribute );     }     if ( normal ) {      if ( normalPerVertex === true ) {       // consider vertex normals       if ( normalIndex && normalIndex.length > 0 ) {        // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.        const triangulatedNormalIndex = triangulateFaceIndex( normalIndex, ccw );       normalAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedNormalIndex, normal, 3 );       } else {        // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node        normalAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new Float32BufferAttribute( normal, 3 ) );       }      } else {       // consider face normals       if ( normalIndex && normalIndex.length > 0 ) {        // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet        const flattenFaceNormals = flattenData( normal, normalIndex );       const triangulatedFaceNormals = triangulateFaceData( flattenFaceNormals, coordIndex );       normalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals );       } else {        // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order        const triangulatedFaceNormals = triangulateFaceData( normal, coordIndex );       normalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals );       }      }     } else {      // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices      normalAttribute = computeNormalAttribute( triangulatedCoordIndex, coord, creaseAngle );     }     if ( texCoord ) {      // texture coordinates are always defined on vertex level      if ( texCoordIndex && texCoordIndex.length > 0 ) {       // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.       const triangulatedTexCoordIndex = triangulateFaceIndex( texCoordIndex, ccw );      uvAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2 );       } else {       // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node       uvAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new Float32BufferAttribute( texCoord, 2 ) );      }     }     const geometry = new BufferGeometry();    const positionAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new Float32BufferAttribute( coord, 3 ) );     geometry.setAttribute( 'position', positionAttribute );    geometry.setAttribute( 'normal', normalAttribute );     // optional attributes     if ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );    if ( uvAttribute ) geometry.setAttribute( 'uv', uvAttribute );     // "solid" influences the material so let's store it for later use     geometry._solid = solid;    geometry._type = 'mesh';     return geometry;    }    function buildIndexedLineSetNode( node ) {     let color, coord;    let colorIndex, coordIndex;    let colorPerVertex = true;     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'color':       const colorNode = fieldValues[ 0 ];        if ( colorNode !== null ) {         color = getNode( colorNode );        }        break;       case 'coord':       const coordNode = fieldValues[ 0 ];        if ( coordNode !== null ) {         coord = getNode( coordNode );        }        break;       case 'colorIndex':       colorIndex = fieldValues;       break;       case 'colorPerVertex':       colorPerVertex = fieldValues[ 0 ];       break;       case 'coordIndex':       coordIndex = fieldValues;       break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     // build lines     let colorAttribute;     const expandedLineIndex = expandLineIndex( coordIndex ); // create an index for three.js's linesegment primitive     if ( color ) {      if ( colorPerVertex === true ) {       if ( colorIndex.length > 0 ) {        // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.        const expandedColorIndex = expandLineIndex( colorIndex ); // compute colors for each line segment (rendering primitve)       colorAttribute = computeAttributeFromIndexedData( expandedLineIndex, expandedColorIndex, color, 3 ); // compute data on vertex level       } else {        // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.        colorAttribute = toNonIndexedAttribute( expandedLineIndex, new Float32BufferAttribute( color, 3 ) );       }      } else {       if ( colorIndex.length > 0 ) {        // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet        const flattenLineColors = flattenData( color, colorIndex ); // compute colors for each VRML primitve       const expandedLineColors = expandLineData( flattenLineColors, coordIndex ); // compute colors for each line segment (rendering primitve)       colorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level        } else {        // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node        const expandedLineColors = expandLineData( color, coordIndex ); // compute colors for each line segment (rendering primitve)       colorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level       }      }      convertColorsToLinearSRGB( colorAttribute );     }     //     const geometry = new BufferGeometry();     const positionAttribute = toNonIndexedAttribute( expandedLineIndex, new Float32BufferAttribute( coord, 3 ) );    geometry.setAttribute( 'position', positionAttribute );     if ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );     geometry._type = 'line';     return geometry;    }    function buildPointSetNode( node ) {     let color, coord;     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'color':       const colorNode = fieldValues[ 0 ];        if ( colorNode !== null ) {         color = getNode( colorNode );        }        break;       case 'coord':       const coordNode = fieldValues[ 0 ];        if ( coordNode !== null ) {         coord = getNode( coordNode );        }        break;        default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     const geometry = new BufferGeometry();     geometry.setAttribute( 'position', new Float32BufferAttribute( coord, 3 ) );     if ( color ) {      const colorAttribute = new Float32BufferAttribute( color, 3 );     convertColorsToLinearSRGB( colorAttribute );      geometry.setAttribute( 'color', colorAttribute );     }     geometry._type = 'points';     return geometry;    }    function buildBoxNode( node ) {     const size = new Vector3( 2, 2, 2 );     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'size':       size.x = fieldValues[ 0 ];       size.y = fieldValues[ 1 ];       size.z = fieldValues[ 2 ];       break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     const geometry = new BoxGeometry( size.x, size.y, size.z );     return geometry;    }    function buildConeNode( node ) {     let radius = 1, height = 2, openEnded = false;     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'bottom':       openEnded = ! fieldValues[ 0 ];       break;       case 'bottomRadius':       radius = fieldValues[ 0 ];       break;       case 'height':       height = fieldValues[ 0 ];       break;       case 'side':       // field not supported       break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     const geometry = new ConeGeometry( radius, height, 16, 1, openEnded );     return geometry;    }    function buildCylinderNode( node ) {     let radius = 1, height = 2;     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'bottom':       // field not supported       break;       case 'radius':       radius = fieldValues[ 0 ];       break;       case 'height':       height = fieldValues[ 0 ];       break;       case 'side':       // field not supported       break;       case 'top':       // field not supported       break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     const geometry = new CylinderGeometry( radius, radius, height, 16, 1 );     return geometry;    }    function buildSphereNode( node ) {     let radius = 1;     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'radius':       radius = fieldValues[ 0 ];       break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     const geometry = new SphereGeometry( radius, 16, 16 );     return geometry;    }    function buildElevationGridNode( node ) {     let color;    let normal;    let texCoord;    let height;     let colorPerVertex = true;    let normalPerVertex = true;    let solid = true;    let ccw = true;    let creaseAngle = 0;    let xDimension = 2;    let zDimension = 2;    let xSpacing = 1;    let zSpacing = 1;     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'color':       const colorNode = fieldValues[ 0 ];        if ( colorNode !== null ) {         color = getNode( colorNode );        }        break;       case 'normal':       const normalNode = fieldValues[ 0 ];        if ( normalNode !== null ) {         normal = getNode( normalNode );        }        break;       case 'texCoord':       const texCoordNode = fieldValues[ 0 ];        if ( texCoordNode !== null ) {         texCoord = getNode( texCoordNode );        }        break;       case 'height':       height = fieldValues;       break;       case 'ccw':       ccw = fieldValues[ 0 ];       break;       case 'colorPerVertex':       colorPerVertex = fieldValues[ 0 ];       break;       case 'creaseAngle':       creaseAngle = fieldValues[ 0 ];       break;       case 'normalPerVertex':       normalPerVertex = fieldValues[ 0 ];       break;       case 'solid':       solid = fieldValues[ 0 ];       break;       case 'xDimension':       xDimension = fieldValues[ 0 ];       break;       case 'xSpacing':       xSpacing = fieldValues[ 0 ];       break;       case 'zDimension':       zDimension = fieldValues[ 0 ];       break;       case 'zSpacing':       zSpacing = fieldValues[ 0 ];       break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     // vertex data     const vertices = [];    const normals = [];    const colors = [];    const uvs = [];     for ( let i = 0; i < zDimension; i ++ ) {      for ( let j = 0; j < xDimension; j ++ ) {       // compute a row major index       const index = ( i * xDimension ) + j;       // vertices       const x = xSpacing * i;      const y = height[ index ];      const z = zSpacing * j;       vertices.push( x, y, z );       // colors       if ( color && colorPerVertex === true ) {        const r = color[ index * 3 + 0 ];       const g = color[ index * 3 + 1 ];       const b = color[ index * 3 + 2 ];        colors.push( r, g, b );       }       // normals       if ( normal && normalPerVertex === true ) {        const xn = normal[ index * 3 + 0 ];       const yn = normal[ index * 3 + 1 ];       const zn = normal[ index * 3 + 2 ];        normals.push( xn, yn, zn );       }       // uvs       if ( texCoord ) {        const s = texCoord[ index * 2 + 0 ];       const t = texCoord[ index * 2 + 1 ];        uvs.push( s, t );        } else {        uvs.push( i / ( xDimension - 1 ), j / ( zDimension - 1 ) );       }      }     }     // indices     const indices = [];     for ( let i = 0; i < xDimension - 1; i ++ ) {      for ( let j = 0; j < zDimension - 1; j ++ ) {       // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid       const a = i + j * xDimension;      const b = i + ( j + 1 ) * xDimension;      const c = ( i + 1 ) + ( j + 1 ) * xDimension;      const d = ( i + 1 ) + j * xDimension;       // faces       if ( ccw === true ) {        indices.push( a, c, b );       indices.push( c, a, d );       } else {        indices.push( a, b, c );       indices.push( c, d, a );       }      }     }     //     const positionAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( vertices, 3 ) );    const uvAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( uvs, 2 ) );    let colorAttribute;    let normalAttribute;     // color attribute     if ( color ) {      if ( colorPerVertex === false ) {       for ( let i = 0; i < xDimension - 1; i ++ ) {        for ( let j = 0; j < zDimension - 1; j ++ ) {         const index = i + j * ( xDimension - 1 );         const r = color[ index * 3 + 0 ];        const g = color[ index * 3 + 1 ];        const b = color[ index * 3 + 2 ];         // one color per quad         colors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b );        colors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b );        }       }       colorAttribute = new Float32BufferAttribute( colors, 3 );      } else {       colorAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( colors, 3 ) );      }      convertColorsToLinearSRGB( colorAttribute );     }     // normal attribute     if ( normal ) {      if ( normalPerVertex === false ) {       for ( let i = 0; i < xDimension - 1; i ++ ) {        for ( let j = 0; j < zDimension - 1; j ++ ) {         const index = i + j * ( xDimension - 1 );         const xn = normal[ index * 3 + 0 ];        const yn = normal[ index * 3 + 1 ];        const zn = normal[ index * 3 + 2 ];         // one normal per quad         normals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn );        normals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn );        }       }       normalAttribute = new Float32BufferAttribute( normals, 3 );      } else {       normalAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( normals, 3 ) );      }     } else {      normalAttribute = computeNormalAttribute( indices, vertices, creaseAngle );     }     // build geometry     const geometry = new BufferGeometry();    geometry.setAttribute( 'position', positionAttribute );    geometry.setAttribute( 'normal', normalAttribute );    geometry.setAttribute( 'uv', uvAttribute );     if ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );     // "solid" influences the material so let's store it for later use     geometry._solid = solid;    geometry._type = 'mesh';     return geometry;    }    function buildExtrusionNode( node ) {     let crossSection = [ 1, 1, 1, - 1, - 1, - 1, - 1, 1, 1, 1 ];    let spine = [ 0, 0, 0, 0, 1, 0 ];    let scale;    let orientation;     let beginCap = true;    let ccw = true;    let creaseAngle = 0;    let endCap = true;    let solid = true;     const fields = node.fields;     for ( let i = 0, l = fields.length; i < l; i ++ ) {      const field = fields[ i ];     const fieldName = field.name;     const fieldValues = field.values;      switch ( fieldName ) {       case 'beginCap':       beginCap = fieldValues[ 0 ];       break;       case 'ccw':       ccw = fieldValues[ 0 ];       break;       case 'convex':       // field not supported       break;       case 'creaseAngle':       creaseAngle = fieldValues[ 0 ];       break;       case 'crossSection':       crossSection = fieldValues;       break;       case 'endCap':       endCap = fieldValues[ 0 ];       break;       case 'orientation':       orientation = fieldValues;       break;       case 'scale':       scale = fieldValues;       break;       case 'solid':       solid = fieldValues[ 0 ];       break;       case 'spine':       spine = fieldValues; // only extrusion along the Y-axis are supported so far       break;       default:       console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );       break;      }     }     const crossSectionClosed = ( crossSection[ 0 ] === crossSection[ crossSection.length - 2 ] && crossSection[ 1 ] === crossSection[ crossSection.length - 1 ] );     // vertices     const vertices = [];    const spineVector = new Vector3();    const scaling = new Vector3();     const axis = new Vector3();    const vertex = new Vector3();    const quaternion = new Quaternion();     for ( let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4 ) {      spineVector.fromArray( spine, i );      scaling.x = scale ? scale[ j + 0 ] : 1;     scaling.y = 1;     scaling.z = scale ? scale[ j + 1 ] : 1;      axis.x = orientation ? orientation[ o + 0 ] : 0;     axis.y = orientation ? orientation[ o + 1 ] : 0;     axis.z = orientation ? orientation[ o + 2 ] : 1;     const angle = orientation ? orientation[ o + 3 ] : 0;      for ( let k = 0, kl = crossSection.length; k < kl; k += 2 ) {       vertex.x = crossSection[ k + 0 ];      vertex.y = 0;      vertex.z = crossSection[ k + 1 ];       // scale       vertex.multiply( scaling );       // rotate       quaternion.setFromAxisAngle( axis, angle );      vertex.applyQuaternion( quaternion );       // translate       vertex.add( spineVector );       vertices.push( vertex.x, vertex.y, vertex.z );      }     }     // indices     const indices = [];     const spineCount = spine.length / 3;    const crossSectionCount = crossSection.length / 2;     for ( let i = 0; i < spineCount - 1; i ++ ) {      for ( let j = 0; j < crossSectionCount - 1; j ++ ) {       const a = j + i * crossSectionCount;      let b = ( j + 1 ) + i * crossSectionCount;      const c = j + ( i + 1 ) * crossSectionCount;      let d = ( j + 1 ) + ( i + 1 ) * crossSectionCount;       if ( ( j === crossSectionCount - 2 ) && ( crossSectionClosed === true ) ) {        b = i * crossSectionCount;       d = ( i + 1 ) * crossSectionCount;       }       if ( ccw === true ) {        indices.push( a, b, c );       indices.push( c, b, d );       } else {        indices.push( a, c, b );       indices.push( c, d, b );       }      }     }     // triangulate cap     if ( beginCap === true || endCap === true ) {      const contour = [];      for ( let i = 0, l = crossSection.length; i < l; i += 2 ) {       contour.push( new Vector2( crossSection[ i ], crossSection[ i + 1 ] ) );      }      const faces = ShapeUtils.triangulateShape( contour, [] );     const capIndices = [];      for ( let i = 0, l = faces.length; i < l; i ++ ) {       const face = faces[ i ];       capIndices.push( face[ 0 ], face[ 1 ], face[ 2 ] );      }      // begin cap      if ( beginCap === true ) {       for ( let i = 0, l = capIndices.length; i < l; i += 3 ) {        if ( ccw === true ) {         indices.push( capIndices[ i + 0 ], capIndices[ i + 1 ], capIndices[ i + 2 ] );        } else {         indices.push( capIndices[ i + 0 ], capIndices[ i + 2 ], capIndices[ i + 1 ] );        }       }      }      // end cap      if ( endCap === true ) {       const indexOffset = crossSectionCount * ( spineCount - 1 ); // references to the first vertex of the last cross section       for ( let i = 0, l = capIndices.length; i < l; i += 3 ) {        if ( ccw === true ) {         indices.push( indexOffset + capIndices[ i + 0 ], indexOffset + capIndices[ i + 2 ], indexOffset + capIndices[ i + 1 ] );        } else {         indices.push( indexOffset + capIndices[ i + 0 ], indexOffset + capIndices[ i + 1 ], indexOffset + capIndices[ i + 2 ] );        }       }      }     }     const positionAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( vertices, 3 ) );    const normalAttribute = computeNormalAttribute( indices, vertices, creaseAngle );     const geometry = new BufferGeometry();    geometry.setAttribute( 'position', positionAttribute );    geometry.setAttribute( 'normal', normalAttribute );    // no uvs yet     // "solid" influences the material so let's store it for later use     geometry._solid = solid;    geometry._type = 'mesh';     return geometry;    }    // helper functions    function resolveUSE( identifier ) {     const node = nodeMap[ identifier ];    const build = getNode( node );     // because the same 3D objects can have different transformations, it's necessary to clone them.    // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid    // any side effects     return ( build.isObject3D || build.isMaterial ) ? build.clone() : build;    }    function parseFieldChildren( children, owner ) {     for ( let i = 0, l = children.length; i < l; i ++ ) {      const object = getNode( children[ i ] );      if ( object instanceof Object3D ) owner.add( object );     }    }    function triangulateFaceIndex( index, ccw ) {     const indices = [];     // since face defintions can have more than three vertices, it's necessary to    // perform a simple triangulation     let start = 0;     for ( let i = 0, l = index.length; i < l; i ++ ) {      const i1 = index[ start ];     const i2 = index[ i + ( ccw ? 1 : 2 ) ];     const i3 = index[ i + ( ccw ? 2 : 1 ) ];      indices.push( i1, i2, i3 );      // an index of -1 indicates that the current face has ended and the next one begins      if ( index[ i + 3 ] === - 1 || i + 3 >= l ) {       i += 3;      start = i + 1;      }     }     return indices;    }    function triangulateFaceData( data, index ) {     const triangulatedData = [];     let start = 0;     for ( let i = 0, l = index.length; i < l; i ++ ) {      const stride = start * 3;      const x = data[ stride ];     const y = data[ stride + 1 ];     const z = data[ stride + 2 ];      triangulatedData.push( x, y, z );      // an index of -1 indicates that the current face has ended and the next one begins      if ( index[ i + 3 ] === - 1 || i + 3 >= l ) {       i += 3;      start ++;      }     }     return triangulatedData;    }    function flattenData( data, index ) {     const flattenData = [];     for ( let i = 0, l = index.length; i < l; i ++ ) {      const i1 = index[ i ];      const stride = i1 * 3;      const x = data[ stride ];     const y = data[ stride + 1 ];     const z = data[ stride + 2 ];      flattenData.push( x, y, z );     }     return flattenData;    }    function expandLineIndex( index ) {     const indices = [];     for ( let i = 0, l = index.length; i < l; i ++ ) {      const i1 = index[ i ];     const i2 = index[ i + 1 ];      indices.push( i1, i2 );      // an index of -1 indicates that the current line has ended and the next one begins      if ( index[ i + 2 ] === - 1 || i + 2 >= l ) {       i += 2;      }     }     return indices;    }    function expandLineData( data, index ) {     const triangulatedData = [];     let start = 0;     for ( let i = 0, l = index.length; i < l; i ++ ) {      const stride = start * 3;      const x = data[ stride ];     const y = data[ stride + 1 ];     const z = data[ stride + 2 ];      triangulatedData.push( x, y, z );      // an index of -1 indicates that the current line has ended and the next one begins      if ( index[ i + 2 ] === - 1 || i + 2 >= l ) {       i += 2;      start ++;      }     }     return triangulatedData;    }    const vA = new Vector3();   const vB = new Vector3();   const vC = new Vector3();    const uvA = new Vector2();   const uvB = new Vector2();   const uvC = new Vector2();    function computeAttributeFromIndexedData( coordIndex, index, data, itemSize ) {     const array = [];     // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices     for ( let i = 0, l = coordIndex.length; i < l; i += 3 ) {      const a = index[ i ];     const b = index[ i + 1 ];     const c = index[ i + 2 ];      if ( itemSize === 2 ) {       uvA.fromArray( data, a * itemSize );      uvB.fromArray( data, b * itemSize );      uvC.fromArray( data, c * itemSize );       array.push( uvA.x, uvA.y );      array.push( uvB.x, uvB.y );      array.push( uvC.x, uvC.y );      } else {       vA.fromArray( data, a * itemSize );      vB.fromArray( data, b * itemSize );      vC.fromArray( data, c * itemSize );       array.push( vA.x, vA.y, vA.z );      array.push( vB.x, vB.y, vB.z );      array.push( vC.x, vC.y, vC.z );      }     }     return new Float32BufferAttribute( array, itemSize );    }    function computeAttributeFromFaceData( index, faceData ) {     const array = [];     for ( let i = 0, j = 0, l = index.length; i < l; i += 3, j ++ ) {      vA.fromArray( faceData, j * 3 );      array.push( vA.x, vA.y, vA.z );     array.push( vA.x, vA.y, vA.z );     array.push( vA.x, vA.y, vA.z );     }     return new Float32BufferAttribute( array, 3 );    }    function computeAttributeFromLineData( index, lineData ) {     const array = [];     for ( let i = 0, j = 0, l = index.length; i < l; i += 2, j ++ ) {      vA.fromArray( lineData, j * 3 );      array.push( vA.x, vA.y, vA.z );     array.push( vA.x, vA.y, vA.z );     }     return new Float32BufferAttribute( array, 3 );    }    function toNonIndexedAttribute( indices, attribute ) {     const array = attribute.array;    const itemSize = attribute.itemSize;     const array2 = new array.constructor( indices.length * itemSize );     let index = 0, index2 = 0;     for ( let i = 0, l = indices.length; i < l; i ++ ) {      index = indices[ i ] * itemSize;      for ( let j = 0; j < itemSize; j ++ ) {       array2[ index2 ++ ] = array[ index ++ ];      }     }     return new Float32BufferAttribute( array2, itemSize );    }    const ab = new Vector3();   const cb = new Vector3();    function computeNormalAttribute( index, coord, creaseAngle ) {     const faces = [];    const vertexNormals = {};     // prepare face and raw vertex normals     for ( let i = 0, l = index.length; i < l; i += 3 ) {      const a = index[ i ];     const b = index[ i + 1 ];     const c = index[ i + 2 ];      const face = new Face( a, b, c );      vA.fromArray( coord, a * 3 );     vB.fromArray( coord, b * 3 );     vC.fromArray( coord, c * 3 );      cb.subVectors( vC, vB );     ab.subVectors( vA, vB );     cb.cross( ab );      cb.normalize();      face.normal.copy( cb );      if ( vertexNormals[ a ] === undefined ) vertexNormals[ a ] = [];     if ( vertexNormals[ b ] === undefined ) vertexNormals[ b ] = [];     if ( vertexNormals[ c ] === undefined ) vertexNormals[ c ] = [];      vertexNormals[ a ].push( face.normal );     vertexNormals[ b ].push( face.normal );     vertexNormals[ c ].push( face.normal );      faces.push( face );     }     // compute vertex normals and build final geometry     const normals = [];     for ( let i = 0, l = faces.length; i < l; i ++ ) {      const face = faces[ i ];      const nA = weightedNormal( vertexNormals[ face.a ], face.normal, creaseAngle );     const nB = weightedNormal( vertexNormals[ face.b ], face.normal, creaseAngle );     const nC = weightedNormal( vertexNormals[ face.c ], face.normal, creaseAngle );      vA.fromArray( coord, face.a * 3 );     vB.fromArray( coord, face.b * 3 );     vC.fromArray( coord, face.c * 3 );      normals.push( nA.x, nA.y, nA.z );     normals.push( nB.x, nB.y, nB.z );     normals.push( nC.x, nC.y, nC.z );     }     return new Float32BufferAttribute( normals, 3 );    }    function weightedNormal( normals, vector, creaseAngle ) {     const normal = new Vector3();     if ( creaseAngle === 0 ) {      normal.copy( vector );     } else {      for ( let i = 0, l = normals.length; i < l; i ++ ) {       if ( normals[ i ].angleTo( vector ) < creaseAngle ) {        normal.add( normals[ i ] );       }      }     }     return normal.normalize();    }    function toColorArray( colors ) {     const array = [];     for ( let i = 0, l = colors.length; i < l; i += 3 ) {      array.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );     }     return array;    }    function convertColorsToLinearSRGB( attribute ) {     const color = new Color();     for ( let i = 0; i < attribute.count; i ++ ) {      color.fromBufferAttribute( attribute, i );      ColorManagement.toWorkingColorSpace( color, SRGBColorSpace );      attribute.setXYZ( i, color.r, color.g, color.b );     }    }    /**    * Vertically paints the faces interpolating between the    * specified colors at the specified angels. This is used for the Background    * node, but could be applied to other nodes with multiple faces as well.    *    * When used with the Background node, default is directionIsDown is true if    * interpolating the skyColor down from the Zenith. When interpolationg up from    * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.    *    * The first angle is never specified, it is the Zenith (0 rad). Angles are specified    * in radians. The geometry is thought a sphere, but could be anything. The color interpolation    * is linear along the Y axis in any case.    *    * You must specify one more color than you have angles at the beginning of the colors array.    * This is the color of the Zenith (the top of the shape).    *    * @param {BufferGeometry} geometry    * @param {number} radius    * @param {array} angles    * @param {array} colors    * @param {boolean} topDown - Whether to work top down or bottom up.    */   function paintFaces( geometry, radius, angles, colors, topDown ) {     // compute threshold values     const thresholds = [];    const startAngle = ( topDown === true ) ? 0 : Math.PI;     for ( let i = 0, l = colors.length; i < l; i ++ ) {      let angle = ( i === 0 ) ? 0 : angles[ i - 1 ];     angle = ( topDown === true ) ? angle : ( startAngle - angle );      const point = new Vector3();     point.setFromSphericalCoords( radius, angle, 0 );      thresholds.push( point );     }     // generate vertex colors     const indices = geometry.index;    const positionAttribute = geometry.attributes.position;    const colorAttribute = new BufferAttribute( new Float32Array( geometry.attributes.position.count * 3 ), 3 );     const position = new Vector3();    const color = new Color();     for ( let i = 0; i < indices.count; i ++ ) {      const index = indices.getX( i );     position.fromBufferAttribute( positionAttribute, index );      let thresholdIndexA, thresholdIndexB;     let t = 1;      for ( let j = 1; j < thresholds.length; j ++ ) {       thresholdIndexA = j - 1;      thresholdIndexB = j;       const thresholdA = thresholds[ thresholdIndexA ];      const thresholdB = thresholds[ thresholdIndexB ];       if ( topDown === true ) {        // interpolation for sky color        if ( position.y <= thresholdA.y && position.y > thresholdB.y ) {         t = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y );         break;        }       } else {        // interpolation for ground color        if ( position.y >= thresholdA.y && position.y < thresholdB.y ) {         t = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y );         break;        }       }      }      const colorA = colors[ thresholdIndexA ];     const colorB = colors[ thresholdIndexB ];      color.copy( colorA ).lerp( colorB, t );      ColorManagement.toWorkingColorSpace( color, SRGBColorSpace );      colorAttribute.setXYZ( index, color.r, color.g, color.b );     }     geometry.setAttribute( 'color', colorAttribute );    }    //    const textureLoader = new TextureLoader( this.manager );   textureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );    // check version (only 2.0 is supported)    if ( data.indexOf( '#VRML V2.0' ) === - 1 ) {     throw Error( 'THREE.VRMLLexer: Version of VRML asset not supported.' );    }    // create JSON representing the tree structure of the VRML asset    const tree = generateVRMLTree( data );    // parse the tree structure to a three.js scene    const scene = parseTree( tree );    return scene;   }  }  class VRMLLexer {   constructor( tokens ) {    this.lexer = new chevrotain.Lexer( tokens );   }   lex( inputText ) {    const lexingResult = this.lexer.tokenize( inputText );    if ( lexingResult.errors.length > 0 ) {     console.error( lexingResult.errors );     throw Error( 'THREE.VRMLLexer: Lexing errors detected.' );    }    return lexingResult;   }  }  const CstParser = chevrotain.CstParser;  class VRMLParser extends CstParser {   constructor( tokenVocabulary ) {    super( tokenVocabulary );    const $ = this;    const Version = tokenVocabulary[ 'Version' ];   const LCurly = tokenVocabulary[ 'LCurly' ];   const RCurly = tokenVocabulary[ 'RCurly' ];   const LSquare = tokenVocabulary[ 'LSquare' ];   const RSquare = tokenVocabulary[ 'RSquare' ];   const Identifier = tokenVocabulary[ 'Identifier' ];   const RouteIdentifier = tokenVocabulary[ 'RouteIdentifier' ];   const StringLiteral = tokenVocabulary[ 'StringLiteral' ];   const HexLiteral = tokenVocabulary[ 'HexLiteral' ];   const NumberLiteral = tokenVocabulary[ 'NumberLiteral' ];   const TrueLiteral = tokenVocabulary[ 'TrueLiteral' ];   const FalseLiteral = tokenVocabulary[ 'FalseLiteral' ];   const NullLiteral = tokenVocabulary[ 'NullLiteral' ];   const DEF = tokenVocabulary[ 'DEF' ];   const USE = tokenVocabulary[ 'USE' ];   const ROUTE = tokenVocabulary[ 'ROUTE' ];   const TO = tokenVocabulary[ 'TO' ];   const NodeName = tokenVocabulary[ 'NodeName' ];    $.RULE( 'vrml', function () {     $.SUBRULE( $.version );    $.AT_LEAST_ONE( function () {      $.SUBRULE( $.node );     } );    $.MANY( function () {      $.SUBRULE( $.route );     } );    } );    $.RULE( 'version', function () {     $.CONSUME( Version );    } );    $.RULE( 'node', function () {     $.OPTION( function () {      $.SUBRULE( $.def );     } );     $.CONSUME( NodeName );    $.CONSUME( LCurly );    $.MANY( function () {      $.SUBRULE( $.field );     } );    $.CONSUME( RCurly );    } );    $.RULE( 'field', function () {     $.CONSUME( Identifier );     $.OR2( [     { ALT: function () {       $.SUBRULE( $.singleFieldValue );      } },     { ALT: function () {       $.SUBRULE( $.multiFieldValue );      } }    ] );    } );    $.RULE( 'def', function () {     $.CONSUME( DEF );    $.OR( [     { ALT: function () {       $.CONSUME( Identifier );      } },     { ALT: function () {       $.CONSUME( NodeName );      } }    ] );    } );    $.RULE( 'use', function () {     $.CONSUME( USE );    $.OR( [     { ALT: function () {       $.CONSUME( Identifier );      } },     { ALT: function () {       $.CONSUME( NodeName );      } }    ] );    } );    $.RULE( 'singleFieldValue', function () {     $.AT_LEAST_ONE( function () {      $.OR( [      { ALT: function () {        $.SUBRULE( $.node );       } },      { ALT: function () {        $.SUBRULE( $.use );       } },      { ALT: function () {        $.CONSUME( StringLiteral );       } },      { ALT: function () {        $.CONSUME( HexLiteral );       } },      { ALT: function () {        $.CONSUME( NumberLiteral );       } },      { ALT: function () {        $.CONSUME( TrueLiteral );       } },      { ALT: function () {        $.CONSUME( FalseLiteral );       } },      { ALT: function () {        $.CONSUME( NullLiteral );       } }     ] );      } );    } );    $.RULE( 'multiFieldValue', function () {     $.CONSUME( LSquare );    $.MANY( function () {      $.OR( [      { ALT: function () {        $.SUBRULE( $.node );       } },      { ALT: function () {        $.SUBRULE( $.use );       } },      { ALT: function () {        $.CONSUME( StringLiteral );       } },      { ALT: function () {        $.CONSUME( HexLiteral );       } },      { ALT: function () {        $.CONSUME( NumberLiteral );       } },      { ALT: function () {        $.CONSUME( NullLiteral );       } }     ] );     } );    $.CONSUME( RSquare );    } );    $.RULE( 'route', function () {     $.CONSUME( ROUTE );    $.CONSUME( RouteIdentifier );    $.CONSUME( TO );    $.CONSUME2( RouteIdentifier );    } );    this.performSelfAnalysis();   }  }  class Face {   constructor( a, b, c ) {    this.a = a;   this.b = b;   this.c = c;   this.normal = new Vector3();   }  }  const TEXTURE_TYPE = {  INTENSITY: 1,  INTENSITY_ALPHA: 2,  RGB: 3,  RGBA: 4 };  export { VRMLLoader }; 
^..^ FILENAME ^..^
addons|loaders|VTKLoader.js
^..^ CONTENTS ^..^
import {  BufferAttribute,  BufferGeometry,  Color,  FileLoader,  Float32BufferAttribute,  Loader,  SRGBColorSpace } from 'three'; import * as fflate from '../libs/fflate.module.js';  class VTKLoader extends Loader {   constructor( manager ) {    super( manager );   }   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( scope.manager );   loader.setPath( scope.path );   loader.setResponseType( 'arraybuffer' );   loader.setRequestHeader( scope.requestHeader );   loader.setWithCredentials( scope.withCredentials );   loader.load( url, function ( text ) {     try {      onLoad( scope.parse( text ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( data ) {    function parseASCII( data ) {     // connectivity of the triangles    const indices = [];     // triangles vertices    const positions = [];     // red, green, blue colors in the range 0 to 1    const colors = [];     // normal vector, one per vertex    const normals = [];     let result;     // pattern for detecting the end of a number sequence    const patWord = /^[^|d.|s-]+/;     // pattern for reading vertices, 3 floats or integers    const pat3Floats = /(|-?|d+|.?[|d|-|+e]*)|s+(|-?|d+|.?[|d|-|+e]*)|s+(|-?|d+|.?[|d|-|+e]*)/g;     // pattern for connectivity, an integer followed by any number of ints    // the first integer is the number of polygon nodes    const patConnectivity = /^(|d+)|s+([|s|d]*)/;     // indicates start of vertex data section    const patPOINTS = /^POINTS /;     // indicates start of polygon connectivity section    const patPOLYGONS = /^POLYGONS /;     // indicates start of triangle strips section    const patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;     // POINT_DATA number_of_values    const patPOINT_DATA = /^POINT_DATA[ ]+(|d+)/;     // CELL_DATA number_of_polys    const patCELL_DATA = /^CELL_DATA[ ]+(|d+)/;     // Start of color section    const patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(|w+)[ ]+3/;     // NORMALS Normals float    const patNORMALS = /^NORMALS[ ]+(|w+)[ ]+(|w+)/;     let inPointsSection = false;    let inPolygonsSection = false;    let inTriangleStripSection = false;    let inPointDataSection = false;    let inCellDataSection = false;    let inColorSection = false;    let inNormalsSection = false;     const color = new Color();     const lines = data.split( '|n' );     for ( const i in lines ) {      const line = lines[ i ].trim();      if ( line.indexOf( 'DATASET' ) === 0 ) {       const dataset = line.split( ' ' )[ 1 ];       if ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset );      } else if ( inPointsSection ) {       // get the vertices      while ( ( result = pat3Floats.exec( line ) ) !== null ) {        if ( patWord.exec( line ) !== null ) break;        const x = parseFloat( result[ 1 ] );       const y = parseFloat( result[ 2 ] );       const z = parseFloat( result[ 3 ] );       positions.push( x, y, z );       }      } else if ( inPolygonsSection ) {       if ( ( result = patConnectivity.exec( line ) ) !== null ) {        // numVertices i0 i1 i2 ...       const numVertices = parseInt( result[ 1 ] );       const inds = result[ 2 ].split( /|s+/ );        if ( numVertices >= 3 ) {         const i0 = parseInt( inds[ 0 ] );        let k = 1;        // split the polygon in numVertices - 2 triangles        for ( let j = 0; j < numVertices - 2; ++ j ) {          const i1 = parseInt( inds[ k ] );         const i2 = parseInt( inds[ k + 1 ] );         indices.push( i0, i1, i2 );         k ++;         }        }       }      } else if ( inTriangleStripSection ) {       if ( ( result = patConnectivity.exec( line ) ) !== null ) {        // numVertices i0 i1 i2 ...       const numVertices = parseInt( result[ 1 ] );       const inds = result[ 2 ].split( /|s+/ );        if ( numVertices >= 3 ) {         // split the polygon in numVertices - 2 triangles        for ( let j = 0; j < numVertices - 2; j ++ ) {          if ( j % 2 === 1 ) {           const i0 = parseInt( inds[ j ] );          const i1 = parseInt( inds[ j + 2 ] );          const i2 = parseInt( inds[ j + 1 ] );          indices.push( i0, i1, i2 );          } else {           const i0 = parseInt( inds[ j ] );          const i1 = parseInt( inds[ j + 1 ] );          const i2 = parseInt( inds[ j + 2 ] );          indices.push( i0, i1, i2 );          }         }        }       }      } else if ( inPointDataSection || inCellDataSection ) {       if ( inColorSection ) {        // Get the colors        while ( ( result = pat3Floats.exec( line ) ) !== null ) {         if ( patWord.exec( line ) !== null ) break;         const r = parseFloat( result[ 1 ] );        const g = parseFloat( result[ 2 ] );        const b = parseFloat( result[ 3 ] );         color.setRGB( r, g, b, SRGBColorSpace );         colors.push( color.r, color.g, color.b );        }       } else if ( inNormalsSection ) {        // Get the normal vectors        while ( ( result = pat3Floats.exec( line ) ) !== null ) {         if ( patWord.exec( line ) !== null ) break;         const nx = parseFloat( result[ 1 ] );        const ny = parseFloat( result[ 2 ] );        const nz = parseFloat( result[ 3 ] );        normals.push( nx, ny, nz );        }       }      }      if ( patPOLYGONS.exec( line ) !== null ) {       inPolygonsSection = true;      inPointsSection = false;      inTriangleStripSection = false;      } else if ( patPOINTS.exec( line ) !== null ) {       inPolygonsSection = false;      inPointsSection = true;      inTriangleStripSection = false;      } else if ( patTRIANGLE_STRIPS.exec( line ) !== null ) {       inPolygonsSection = false;      inPointsSection = false;      inTriangleStripSection = true;      } else if ( patPOINT_DATA.exec( line ) !== null ) {       inPointDataSection = true;      inPointsSection = false;      inPolygonsSection = false;      inTriangleStripSection = false;      } else if ( patCELL_DATA.exec( line ) !== null ) {       inCellDataSection = true;      inPointsSection = false;      inPolygonsSection = false;      inTriangleStripSection = false;      } else if ( patCOLOR_SCALARS.exec( line ) !== null ) {       inColorSection = true;      inNormalsSection = false;      inPointsSection = false;      inPolygonsSection = false;      inTriangleStripSection = false;      } else if ( patNORMALS.exec( line ) !== null ) {       inNormalsSection = true;      inColorSection = false;      inPointsSection = false;      inPolygonsSection = false;      inTriangleStripSection = false;      }     }     let geometry = new BufferGeometry();    geometry.setIndex( indices );    geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );     if ( normals.length === positions.length ) {      geometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );     }     if ( colors.length !== indices.length ) {      // stagger      if ( colors.length === positions.length ) {       geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );      }     } else {      // cell      geometry = geometry.toNonIndexed();     const numTriangles = geometry.attributes.position.count / 3;      if ( colors.length === ( numTriangles * 3 ) ) {       const newColors = [];       for ( let i = 0; i < numTriangles; i ++ ) {        const r = colors[ 3 * i + 0 ];       const g = colors[ 3 * i + 1 ];       const b = colors[ 3 * i + 2 ];        color.setRGB( r, g, b, SRGBColorSpace );        newColors.push( color.r, color.g, color.b );       newColors.push( color.r, color.g, color.b );       newColors.push( color.r, color.g, color.b );       }       geometry.setAttribute( 'color', new Float32BufferAttribute( newColors, 3 ) );      }     }     return geometry;    }    function parseBinary( data ) {     const buffer = new Uint8Array( data );    const dataView = new DataView( data );     // Points and normals, by default, are empty    let points = [];    let normals = [];    let indices = [];     let index = 0;     function findString( buffer, start ) {      let index = start;     let c = buffer[ index ];     const s = [];     while ( c !== 10 ) {       s.push( String.fromCharCode( c ) );      index ++;      c = buffer[ index ];      }      return { start: start,      end: index,      next: index + 1,      parsedString: s.join( '' ) };     }     let state, line;     while ( true ) {      // Get a string     state = findString( buffer, index );     line = state.parsedString;      if ( line.indexOf( 'DATASET' ) === 0 ) {       const dataset = line.split( ' ' )[ 1 ];       if ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset );      } else if ( line.indexOf( 'POINTS' ) === 0 ) {       // Add the points      const numberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );       // Each point is 3 4-byte floats      const count = numberOfPoints * 4 * 3;       points = new Float32Array( numberOfPoints * 3 );       let pointIndex = state.next;      for ( let i = 0; i < numberOfPoints; i ++ ) {        points[ 3 * i ] = dataView.getFloat32( pointIndex, false );       points[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );       points[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );       pointIndex = pointIndex + 12;       }       // increment our next pointer      state.next = state.next + count + 1;      } else if ( line.indexOf( 'TRIANGLE_STRIPS' ) === 0 ) {       const numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );      const size = parseInt( line.split( ' ' )[ 2 ], 10 );      // 4 byte integers      const count = size * 4;       indices = new Uint32Array( 3 * size - 9 * numberOfStrips );      let indicesIndex = 0;       let pointIndex = state.next;      for ( let i = 0; i < numberOfStrips; i ++ ) {        // For each strip, read the first value, then record that many more points       const indexCount = dataView.getInt32( pointIndex, false );       const strip = [];       pointIndex += 4;       for ( let s = 0; s < indexCount; s ++ ) {         strip.push( dataView.getInt32( pointIndex, false ) );        pointIndex += 4;        }        // retrieves the n-2 triangles from the triangle strip       for ( let j = 0; j < indexCount - 2; j ++ ) {         if ( j % 2 ) {          indices[ indicesIndex ++ ] = strip[ j ];         indices[ indicesIndex ++ ] = strip[ j + 2 ];         indices[ indicesIndex ++ ] = strip[ j + 1 ];         } else {          indices[ indicesIndex ++ ] = strip[ j ];         indices[ indicesIndex ++ ] = strip[ j + 1 ];         indices[ indicesIndex ++ ] = strip[ j + 2 ];         }        }       }       // increment our next pointer      state.next = state.next + count + 1;      } else if ( line.indexOf( 'POLYGONS' ) === 0 ) {       const numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );      const size = parseInt( line.split( ' ' )[ 2 ], 10 );      // 4 byte integers      const count = size * 4;       indices = new Uint32Array( 3 * size - 9 * numberOfStrips );      let indicesIndex = 0;       let pointIndex = state.next;      for ( let i = 0; i < numberOfStrips; i ++ ) {        // For each strip, read the first value, then record that many more points       const indexCount = dataView.getInt32( pointIndex, false );       const strip = [];       pointIndex += 4;       for ( let s = 0; s < indexCount; s ++ ) {         strip.push( dataView.getInt32( pointIndex, false ) );        pointIndex += 4;        }        // divide the polygon in n-2 triangle       for ( let j = 1; j < indexCount - 1; j ++ ) {         indices[ indicesIndex ++ ] = strip[ 0 ];        indices[ indicesIndex ++ ] = strip[ j ];        indices[ indicesIndex ++ ] = strip[ j + 1 ];        }       }       // increment our next pointer      state.next = state.next + count + 1;      } else if ( line.indexOf( 'POINT_DATA' ) === 0 ) {       const numberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );       // Grab the next line      state = findString( buffer, state.next );       // Now grab the binary data      const count = numberOfPoints * 4 * 3;       normals = new Float32Array( numberOfPoints * 3 );      let pointIndex = state.next;      for ( let i = 0; i < numberOfPoints; i ++ ) {        normals[ 3 * i ] = dataView.getFloat32( pointIndex, false );       normals[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );       normals[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );       pointIndex += 12;       }       // Increment past our data      state.next = state.next + count;      }      // Increment index     index = state.next;      if ( index >= buffer.byteLength ) {       break;      }     }     const geometry = new BufferGeometry();    geometry.setIndex( new BufferAttribute( indices, 1 ) );    geometry.setAttribute( 'position', new BufferAttribute( points, 3 ) );     if ( normals.length === points.length ) {      geometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );     }     return geometry;    }    function Float32Concat( first, second ) {     const firstLength = first.length, result = new Float32Array( firstLength + second.length );     result.set( first );    result.set( second, firstLength );     return result;    }    function Int32Concat( first, second ) {     const firstLength = first.length, result = new Int32Array( firstLength + second.length );     result.set( first );    result.set( second, firstLength );     return result;    }    function parseXML( stringFile ) {     // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json     function xmlToJson( xml ) {      // Create the return object     let obj = {};      if ( xml.nodeType === 1 ) { // element       // do attributes       if ( xml.attributes ) {        if ( xml.attributes.length > 0 ) {         obj[ 'attributes' ] = {};         for ( let j = 0; j < xml.attributes.length; j ++ ) {          const attribute = xml.attributes.item( j );         obj[ 'attributes' ][ attribute.nodeName ] = attribute.nodeValue.trim();         }        }       }      } else if ( xml.nodeType === 3 ) { // text       obj = xml.nodeValue.trim();      }      // do children     if ( xml.hasChildNodes() ) {       for ( let i = 0; i < xml.childNodes.length; i ++ ) {        const item = xml.childNodes.item( i );       const nodeName = item.nodeName;        if ( typeof obj[ nodeName ] === 'undefined' ) {         const tmp = xmlToJson( item );         if ( tmp !== '' ) {          if ( Array.isArray( tmp[ '#text' ] ) ) {           tmp[ '#text' ] = tmp[ '#text' ][ 0 ];          }          obj[ nodeName ] = tmp;         }        } else {         if ( typeof obj[ nodeName ].push === 'undefined' ) {          const old = obj[ nodeName ];         obj[ nodeName ] = [ old ];         }         const tmp = xmlToJson( item );         if ( tmp !== '' ) {          if ( Array.isArray( tmp[ '#text' ] ) ) {           tmp[ '#text' ] = tmp[ '#text' ][ 0 ];          }          obj[ nodeName ].push( tmp );         }        }       }      }      return obj;     }     // Taken from Base64-js    function Base64toByteArray( b64 ) {      const Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;     const revLookup = [];     const code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';      for ( let i = 0, l = code.length; i < l; ++ i ) {       revLookup[ code.charCodeAt( i ) ] = i;      }      revLookup[ '-'.charCodeAt( 0 ) ] = 62;     revLookup[ '_'.charCodeAt( 0 ) ] = 63;      const len = b64.length;      if ( len % 4 > 0 ) {       throw new Error( 'Invalid string. Length must be a multiple of 4' );      }      const placeHolders = b64[ len - 2 ] === '=' ? 2 : b64[ len - 1 ] === '=' ? 1 : 0;     const arr = new Arr( len * 3 / 4 - placeHolders );     const l = placeHolders > 0 ? len - 4 : len;      let L = 0;     let i, j;      for ( i = 0, j = 0; i < l; i += 4, j += 3 ) {       const tmp = ( revLookup[ b64.charCodeAt( i ) ] << 18 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 12 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] << 6 ) | revLookup[ b64.charCodeAt( i + 3 ) ];      arr[ L ++ ] = ( tmp & 0xFF0000 ) >> 16;      arr[ L ++ ] = ( tmp & 0xFF00 ) >> 8;      arr[ L ++ ] = tmp & 0xFF;      }      if ( placeHolders === 2 ) {       const tmp = ( revLookup[ b64.charCodeAt( i ) ] << 2 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] >> 4 );      arr[ L ++ ] = tmp & 0xFF;      } else if ( placeHolders === 1 ) {       const tmp = ( revLookup[ b64.charCodeAt( i ) ] << 10 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 4 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] >> 2 );      arr[ L ++ ] = ( tmp >> 8 ) & 0xFF;      arr[ L ++ ] = tmp & 0xFF;      }      return arr;     }     function parseDataArray( ele, compressed ) {      let numBytes = 0;      if ( json.attributes.header_type === 'UInt64' ) {       numBytes = 8;      } else if ( json.attributes.header_type === 'UInt32' ) {       numBytes = 4;      }      let txt, content;      // Check the format     if ( ele.attributes.format === 'binary' && compressed ) {       if ( ele.attributes.type === 'Float32' ) {        txt = new Float32Array( );       } else if ( ele.attributes.type === 'Int32' || ele.attributes.type === 'Int64' ) {        txt = new Int32Array( );       }       // VTP data with the header has the following structure:      // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]      //      // Each token is an integer value whose type is specified by "header_type" at the top of the file (UInt32 if no type specified). The token meanings are:      // [#blocks] = Number of blocks      // [#u-size] = Block size before compression      // [#p-size] = Size of last partial block (zero if it not needed)      // [#c-size-i] = Size in bytes of block i after compression      //      // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is      // computed by summing the compressed block sizes from preceding blocks according to the header.       const textNode = ele[ '#text' ];      const rawData = Array.isArray( textNode ) ? textNode[ 0 ] : textNode;       const byteData = Base64toByteArray( rawData );       // Each data point consists of 8 bits regardless of the header type      const dataPointSize = 8;       let blocks = byteData[ 0 ];      for ( let i = 1; i < numBytes - 1; i ++ ) {        blocks = blocks | ( byteData[ i ] << ( i * dataPointSize ) );       }       let headerSize = ( blocks + 3 ) * numBytes;      const padding = ( ( headerSize % 3 ) > 0 ) ? 3 - ( headerSize % 3 ) : 0;      headerSize = headerSize + padding;       const dataOffsets = [];      let currentOffset = headerSize;      dataOffsets.push( currentOffset );       // Get the blocks sizes after the compression.      // There are three blocks before c-size-i, so we skip 3*numBytes      const cSizeStart = 3 * numBytes;       for ( let i = 0; i < blocks; i ++ ) {        let currentBlockSize = byteData[ i * numBytes + cSizeStart ];        for ( let j = 1; j < numBytes - 1; j ++ ) {         currentBlockSize = currentBlockSize | ( byteData[ i * numBytes + cSizeStart + j ] << ( j * dataPointSize ) );        }        currentOffset = currentOffset + currentBlockSize;       dataOffsets.push( currentOffset );       }       for ( let i = 0; i < dataOffsets.length - 1; i ++ ) {        const data = fflate.unzlibSync( byteData.slice( dataOffsets[ i ], dataOffsets[ i + 1 ] ) );       content = data.buffer;        if ( ele.attributes.type === 'Float32' ) {         content = new Float32Array( content );        txt = Float32Concat( txt, content );        } else if ( ele.attributes.type === 'Int32' || ele.attributes.type === 'Int64' ) {         content = new Int32Array( content );        txt = Int32Concat( txt, content );        }       }       delete ele[ '#text' ];       if ( ele.attributes.type === 'Int64' ) {        if ( ele.attributes.format === 'binary' ) {         txt = txt.filter( function ( el, idx ) {          if ( idx % 2 !== 1 ) return true;         } );        }       }      } else {       if ( ele.attributes.format === 'binary' && ! compressed ) {        content = Base64toByteArray( ele[ '#text' ] );        //  VTP data for the uncompressed case has the following structure:       // [#bytes][DATA]       // where "[#bytes]" is an integer value specifying the number of bytes in the block of data following it.       content = content.slice( numBytes ).buffer;       } else {        if ( ele[ '#text' ] ) {         content = ele[ '#text' ].split( /|s+/ ).filter( function ( el ) {          if ( el !== '' ) return el;         } );        } else {         content = new Int32Array( 0 ).buffer;        }       }       delete ele[ '#text' ];       // Get the content and optimize it      if ( ele.attributes.type === 'Float32' ) {        txt = new Float32Array( content );       } else if ( ele.attributes.type === 'Int32' ) {        txt = new Int32Array( content );       } else if ( ele.attributes.type === 'Int64' ) {        txt = new Int32Array( content );        if ( ele.attributes.format === 'binary' ) {         txt = txt.filter( function ( el, idx ) {          if ( idx % 2 !== 1 ) return true;         } );        }       }      } // endif ( ele.attributes.format === 'binary' && compressed )      return txt;     }     // Main part    // Get Dom    const dom = new DOMParser().parseFromString( stringFile, 'application/xml' );     // Get the doc    const doc = dom.documentElement;    // Convert to json    const json = xmlToJson( doc );    let points = [];    let normals = [];    let indices = [];     if ( json.AppendedData ) {      const appendedData = json.AppendedData[ '#text' ].slice( 1 );     const piece = json.PolyData.Piece;      const sections = [ 'PointData', 'CellData', 'Points', 'Verts', 'Lines', 'Strips', 'Polys' ];     let sectionIndex = 0;      const offsets = sections.map( s => {       const sect = piece[ s ];       if ( sect && sect.DataArray ) {        const arr = Array.isArray( sect.DataArray ) ? sect.DataArray : [ sect.DataArray ];        return arr.map( a => a.attributes.offset );       }       return [];      } ).flat();      for ( const sect of sections ) {       const section = piece[ sect ];       if ( section && section.DataArray ) {        if ( Array.isArray( section.DataArray ) ) {         for ( const sectionEle of section.DataArray ) {          sectionEle[ '#text' ] = appendedData.slice( offsets[ sectionIndex ], offsets[ sectionIndex + 1 ] );         sectionEle.attributes.format = 'binary';         sectionIndex ++;         }        } else {         section.DataArray[ '#text' ] = appendedData.slice( offsets[ sectionIndex ], offsets[ sectionIndex + 1 ] );        section.DataArray.attributes.format = 'binary';        sectionIndex ++;        }       }      }     }     if ( json.PolyData ) {      const piece = json.PolyData.Piece;     const compressed = json.attributes.hasOwnProperty( 'compressor' );      // Can be optimized     // Loop through the sections     const sections = [ 'PointData', 'Points', 'Strips', 'Polys' ];// +['CellData', 'Verts', 'Lines'];     let sectionIndex = 0;     const numberOfSections = sections.length;      while ( sectionIndex < numberOfSections ) {       const section = piece[ sections[ sectionIndex ] ];       // If it has a DataArray in it       if ( section && section.DataArray ) {        // Depending on the number of DataArrays        let arr;        if ( Array.isArray( section.DataArray ) ) {         arr = section.DataArray;        } else {         arr = [ section.DataArray ];        }        let dataArrayIndex = 0;       const numberOfDataArrays = arr.length;        while ( dataArrayIndex < numberOfDataArrays ) {         // Parse the DataArray        if ( ( '#text' in arr[ dataArrayIndex ] ) && ( arr[ dataArrayIndex ][ '#text' ].length > 0 ) ) {          arr[ dataArrayIndex ].text = parseDataArray( arr[ dataArrayIndex ], compressed );         }         dataArrayIndex ++;        }        switch ( sections[ sectionIndex ] ) {         // if iti is point data        case 'PointData':          {           const numberOfPoints = parseInt( piece.attributes.NumberOfPoints );          const normalsName = section.attributes.Normals;           if ( numberOfPoints > 0 ) {            for ( let i = 0, len = arr.length; i < len; i ++ ) {             if ( normalsName === arr[ i ].attributes.Name ) {              const components = arr[ i ].attributes.NumberOfComponents;             normals = new Float32Array( numberOfPoints * components );             normals.set( arr[ i ].text, 0 );             }            }           }          }          break;         // if it is points        case 'Points':          {           const numberOfPoints = parseInt( piece.attributes.NumberOfPoints );           if ( numberOfPoints > 0 ) {            const components = section.DataArray.attributes.NumberOfComponents;           points = new Float32Array( numberOfPoints * components );           points.set( section.DataArray.text, 0 );           }          }          break;         // if it is strips        case 'Strips':          {           const numberOfStrips = parseInt( piece.attributes.NumberOfStrips );           if ( numberOfStrips > 0 ) {            const connectivity = new Int32Array( section.DataArray[ 0 ].text.length );           const offset = new Int32Array( section.DataArray[ 1 ].text.length );           connectivity.set( section.DataArray[ 0 ].text, 0 );           offset.set( section.DataArray[ 1 ].text, 0 );            const size = numberOfStrips + connectivity.length;           indices = new Uint32Array( 3 * size - 9 * numberOfStrips );            let indicesIndex = 0;            for ( let i = 0, len = numberOfStrips; i < len; i ++ ) {             const strip = [];             for ( let s = 0, len1 = offset[ i ], len0 = 0; s < len1 - len0; s ++ ) {              strip.push( connectivity[ s ] );              if ( i > 0 ) len0 = offset[ i - 1 ];             }             for ( let j = 0, len1 = offset[ i ], len0 = 0; j < len1 - len0 - 2; j ++ ) {              if ( j % 2 ) {               indices[ indicesIndex ++ ] = strip[ j ];              indices[ indicesIndex ++ ] = strip[ j + 2 ];              indices[ indicesIndex ++ ] = strip[ j + 1 ];              } else {               indices[ indicesIndex ++ ] = strip[ j ];              indices[ indicesIndex ++ ] = strip[ j + 1 ];              indices[ indicesIndex ++ ] = strip[ j + 2 ];              }              if ( i > 0 ) len0 = offset[ i - 1 ];             }            }           }          }          break;         // if it is polys        case 'Polys':          {           const numberOfPolys = parseInt( piece.attributes.NumberOfPolys );           if ( numberOfPolys > 0 ) {            const connectivity = new Int32Array( section.DataArray[ 0 ].text.length );           const offset = new Int32Array( section.DataArray[ 1 ].text.length );           connectivity.set( section.DataArray[ 0 ].text, 0 );           offset.set( section.DataArray[ 1 ].text, 0 );            const size = numberOfPolys + connectivity.length;           indices = new Uint32Array( 3 * size - 9 * numberOfPolys );           let indicesIndex = 0, connectivityIndex = 0;           let i = 0, len0 = 0;           const len = numberOfPolys;            while ( i < len ) {             const poly = [];            let s = 0;            const len1 = offset[ i ];             while ( s < len1 - len0 ) {              poly.push( connectivity[ connectivityIndex ++ ] );             s ++;             }             let j = 1;             while ( j < len1 - len0 - 1 ) {              indices[ indicesIndex ++ ] = poly[ 0 ];             indices[ indicesIndex ++ ] = poly[ j ];             indices[ indicesIndex ++ ] = poly[ j + 1 ];             j ++;             }             i ++;            len0 = offset[ i - 1 ];            }           }          }          break;         default:         break;        }       }       sectionIndex ++;      }      const geometry = new BufferGeometry();     geometry.setIndex( new BufferAttribute( indices, 1 ) );     geometry.setAttribute( 'position', new BufferAttribute( points, 3 ) );      if ( normals.length === points.length ) {       geometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );      }      return geometry;     } else {      throw new Error( 'Unsupported DATASET type' );     }    }    const textDecoder = new TextDecoder();    // get the 5 first lines of the files to check if there is the key word binary   const meta = textDecoder.decode( new Uint8Array( data, 0, 250 ) ).split( '|n' );    if ( meta[ 0 ].indexOf( 'xml' ) !== - 1 ) {     return parseXML( textDecoder.decode( data ) );    } else if ( meta[ 2 ].includes( 'ASCII' ) ) {     return parseASCII( textDecoder.decode( data ) );    } else {     return parseBinary( data );    }   }  }  export { VTKLoader }; 
^..^ FILENAME ^..^
addons|loaders|XYZLoader.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  Color,  FileLoader,  Float32BufferAttribute,  Loader,  SRGBColorSpace } from 'three';  class XYZLoader extends Loader {   load( url, onLoad, onProgress, onError ) {    const scope = this;    const loader = new FileLoader( this.manager );   loader.setPath( this.path );   loader.setRequestHeader( this.requestHeader );   loader.setWithCredentials( this.withCredentials );   loader.load( url, function ( text ) {     try {      onLoad( scope.parse( text ) );     } catch ( e ) {      if ( onError ) {       onError( e );      } else {       console.error( e );      }      scope.manager.itemError( url );     }    }, onProgress, onError );   }   parse( text ) {    const lines = text.split( '|n' );    const vertices = [];   const colors = [];   const color = new Color();    for ( let line of lines ) {     line = line.trim();     if ( line.charAt( 0 ) === '#' ) continue; // skip comments     const lineValues = line.split( /|s+/ );     if ( lineValues.length === 3 ) {      // XYZ      vertices.push( parseFloat( lineValues[ 0 ] ) );     vertices.push( parseFloat( lineValues[ 1 ] ) );     vertices.push( parseFloat( lineValues[ 2 ] ) );     }     if ( lineValues.length === 6 ) {      // XYZRGB      vertices.push( parseFloat( lineValues[ 0 ] ) );     vertices.push( parseFloat( lineValues[ 1 ] ) );     vertices.push( parseFloat( lineValues[ 2 ] ) );      const r = parseFloat( lineValues[ 3 ] ) / 255;     const g = parseFloat( lineValues[ 4 ] ) / 255;     const b = parseFloat( lineValues[ 5 ] ) / 255;      color.setRGB( r, g, b, SRGBColorSpace );      colors.push( color.r, color.g, color.b );     }    }    const geometry = new BufferGeometry();   geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );    if ( colors.length > 0 ) {     geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );    }    return geometry;   }  }  export { XYZLoader }; 
^..^ FILENAME ^..^
addons|loaders|lwo|IFFParser.js
^..^ CONTENTS ^..^
/**  * === IFFParser ===  * - Parses data from the IFF buffer.  * - LWO3 files are in IFF format and can contain the following data types, referred to by shorthand codes  *  * ATOMIC DATA TYPES  *  ID Tag - 4x 7 bit uppercase ASCII chars: ID4  *  signed integer, 1, 2, or 4 byte length: I1, I2, I4  *  unsigned integer, 1, 2, or 4 byte length: U1, U2, U4  *  float, 4 byte length: F4  *  string, series of ASCII chars followed by null byte (If the length of the string including the null terminating byte is odd, an extra null is added so that the data that follows will begin on an even byte boundary): S0  *  * COMPOUND DATA TYPES  *  Variable-length Index (index into an array or collection): U2 or U4 : VX  *  Color (RGB): F4 + F4 + F4: COL12  *  Coordinate (x, y, z): F4 + F4 + F4: VEC12  *  Percentage F4 data type from 0->1 with 1 = 100%: FP4  *  Angle in radian F4: ANG4  *  Filename (string) S0: FNAM0  *  XValue F4 + index (VX) + optional envelope( ENVL ): XVAL  *  XValue vector VEC12 + index (VX) + optional envelope( ENVL ): XVAL3  *  *  The IFF file is arranged in chunks:  *  CHUNK = ID4 + length (U4) + length X bytes of data + optional 0 pad byte  *  optional 0 pad byte is there to ensure chunk ends on even boundary, not counted in size  *  * COMPOUND DATA TYPES  * - Chunks are combined in Forms (collections of chunks)  * - FORM = string 'FORM' (ID4) + length (U4) + type (ID4) + optional ( CHUNK | FORM )  * - CHUNKS and FORMS are collectively referred to as blocks  * - The entire file is contained in one top level FORM  *  **/  import { LWO2Parser } from './LWO2Parser.js'; import { LWO3Parser } from './LWO3Parser.js';  class IFFParser {   constructor() {    this.debugger = new Debugger();   // this.debugger.enable(); // un-comment to log IFF hierarchy.   }   parse( buffer ) {    this.reader = new DataViewReader( buffer );    this.tree = {    materials: {},    layers: [],    tags: [],    textures: [],   };    // start out at the top level to add any data before first layer is encountered   this.currentLayer = this.tree;   this.currentForm = this.tree;    this.parseTopForm();    if ( this.tree.format === undefined ) return;    if ( this.tree.format === 'LWO2' ) {     this.parser = new LWO2Parser( this );    while ( ! this.reader.endOfFile() ) this.parser.parseBlock();    } else if ( this.tree.format === 'LWO3' ) {     this.parser = new LWO3Parser( this );    while ( ! this.reader.endOfFile() ) this.parser.parseBlock();    }    this.debugger.offset = this.reader.offset;   this.debugger.closeForms();    return this.tree;   }   parseTopForm() {    this.debugger.offset = this.reader.offset;    var topForm = this.reader.getIDTag();    if ( topForm !== 'FORM' ) {     console.warn( 'LWOLoader: Top-level FORM missing.' );    return;    }    var length = this.reader.getUint32();    this.debugger.dataOffset = this.reader.offset;   this.debugger.length = length;    var type = this.reader.getIDTag();    if ( type === 'LWO2' ) {     this.tree.format = type;    } else if ( type === 'LWO3' ) {     this.tree.format = type;    }    this.debugger.node = 0;   this.debugger.nodeID = type;   this.debugger.log();    return;   }    ///  // FORM PARSING METHODS  ///   // Forms are organisational and can contain any number of sub chunks and sub forms  // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }  parseForm( length ) {    var type = this.reader.getIDTag();    switch ( type ) {     // SKIPPED FORMS    // if skipForm( length ) is called, the entire form and any sub forms and chunks are skipped     case 'ISEQ': // Image sequence    case 'ANIM': // plug in animation    case 'STCC': // Color-cycling Still    case 'VPVL':    case 'VPRM':    case 'NROT':    case 'WRPW': // image wrap w ( for cylindrical and spherical projections)    case 'WRPH': // image wrap h    case 'FUNC':    case 'FALL':    case 'OPAC':    case 'GRAD': // gradient texture    case 'ENVS':    case 'VMOP':    case 'VMBG':     // Car Material FORMS    case 'OMAX':    case 'STEX':    case 'CKBG':    case 'CKEY':    case 'VMLA':    case 'VMLB':     this.debugger.skipped = true;     this.skipForm( length ); // not currently supported     break;     // if break; is called directly, the position in the lwoTree is not created    // any sub chunks and forms are added to the parent form instead    case 'META':    case 'NNDS':    case 'NODS':    case 'NDTA':    case 'ADAT':    case 'AOVS':    case 'BLOK':     // used by texture nodes    case 'IBGC': // imageBackgroundColor    case 'IOPC': // imageOpacity    case 'IIMG': // hold reference to image path    case 'TXTR':     // this.setupForm( type, length );     this.debugger.length = 4;     this.debugger.skipped = true;     break;     case 'IFAL': // imageFallof    case 'ISCL': // imageScale    case 'IPOS': // imagePosition    case 'IROT': // imageRotation    case 'IBMP':    case 'IUTD':    case 'IVTD':     this.parseTextureNodeAttribute( type );     break;     case 'ENVL':     this.parseEnvelope( length );     break;      // CLIP FORM AND SUB FORMS     case 'CLIP':     if ( this.tree.format === 'LWO2' ) {       this.parseForm( length );      } else {       this.parseClip( length );      }      break;     case 'STIL':     this.parseImage();     break;     case 'XREF': // clone of another STIL     this.reader.skip( 8 ); // unknown     this.currentForm.referenceTexture = {      index: this.reader.getUint32(),      refName: this.reader.getString() // internal unique ref     };     break;      // Not in spec, used by texture nodes     case 'IMST':     this.parseImageStateForm( length );     break;      // SURF FORM AND SUB FORMS     case 'SURF':     this.parseSurfaceForm( length );     break;     case 'VALU': // Not in spec     this.parseValueForm( length );     break;     case 'NTAG':     this.parseSubNode( length );     break;     case 'ATTR': // BSDF Node Attributes    case 'SATR': // Standard Node Attributes     this.setupForm( 'attributes', length );     break;     case 'NCON':     this.parseConnections( length );     break;     case 'SSHA':     this.parentForm = this.currentForm;     this.currentForm = this.currentSurface;     this.setupForm( 'surfaceShader', length );     break;     case 'SSHD':     this.setupForm( 'surfaceShaderData', length );     break;     case 'ENTR': // Not in spec     this.parseEntryForm( length );     break;      // Image Map Layer     case 'IMAP':     this.parseImageMap( length );     break;     case 'TAMP':     this.parseXVAL( 'amplitude', length );     break;      //Texture Mapping Form     case 'TMAP':     this.setupForm( 'textureMap', length );     break;     case 'CNTR':     this.parseXVAL3( 'center', length );     break;     case 'SIZE':     this.parseXVAL3( 'scale', length );     break;     case 'ROTA':     this.parseXVAL3( 'rotation', length );     break;     default:     this.parseUnknownForm( type, length );    }    this.debugger.node = 0;   this.debugger.nodeID = type;   this.debugger.log();   }   setupForm( type, length ) {    if ( ! this.currentForm ) this.currentForm = this.currentNode;    this.currentFormEnd = this.reader.offset + length;   this.parentForm = this.currentForm;    if ( ! this.currentForm[ type ] ) {     this.currentForm[ type ] = {};    this.currentForm = this.currentForm[ type ];     } else {     // should never see this unless there's a bug in the reader    console.warn( 'LWOLoader: form already exists on parent: ', type, this.currentForm );     this.currentForm = this.currentForm[ type ];    }    }   skipForm( length ) {    this.reader.skip( length - 4 );   }   parseUnknownForm( type, length ) {    console.warn( 'LWOLoader: unknown FORM encountered: ' + type, length );    printBuffer( this.reader.dv.buffer, this.reader.offset, length - 4 );   this.reader.skip( length - 4 );   }   parseSurfaceForm( length ) {    this.reader.skip( 8 ); // unknown Uint32 x2    var name = this.reader.getString();    var surface = {    attributes: {}, // LWO2 style non-node attributes will go here    connections: {},    name: name,    inputName: name,    nodes: {},    source: this.reader.getString(),   };    this.tree.materials[ name ] = surface;   this.currentSurface = surface;    this.parentForm = this.tree.materials;   this.currentForm = surface;   this.currentFormEnd = this.reader.offset + length;   }   parseSurfaceLwo2( length ) {    var name = this.reader.getString();    var surface = {    attributes: {}, // LWO2 style non-node attributes will go here    connections: {},    name: name,    nodes: {},    source: this.reader.getString(),   };    this.tree.materials[ name ] = surface;   this.currentSurface = surface;    this.parentForm = this.tree.materials;   this.currentForm = surface;   this.currentFormEnd = this.reader.offset + length;   }   parseSubNode( length ) {    // parse the NRNM CHUNK of the subnode FORM to get   // a meaningful name for the subNode   // some subnodes can be renamed, but Input and Surface cannot    this.reader.skip( 8 ); // NRNM + length   var name = this.reader.getString();    var node = {    name: name   };   this.currentForm = node;   this.currentNode = node;    this.currentFormEnd = this.reader.offset + length;    }   // collect attributes from all nodes at the top level of a surface  parseConnections( length ) {    this.currentFormEnd = this.reader.offset + length;   this.parentForm = this.currentForm;    this.currentForm = this.currentSurface.connections;   }   // surface node attribute data, e.g. specular, roughness etc  parseEntryForm( length ) {    this.reader.skip( 8 ); // NAME + length   var name = this.reader.getString();   this.currentForm = this.currentNode.attributes;    this.setupForm( name, length );   }   // parse values from material - doesn't match up to other LWO3 data types  // sub form of entry form  parseValueForm() {    this.reader.skip( 8 ); // unknown + length    var valueType = this.reader.getString();    if ( valueType === 'double' ) {     this.currentForm.value = this.reader.getUint64();    } else if ( valueType === 'int' ) {     this.currentForm.value = this.reader.getUint32();    } else if ( valueType === 'vparam' ) {     this.reader.skip( 24 );    this.currentForm.value = this.reader.getFloat64();    } else if ( valueType === 'vparam3' ) {     this.reader.skip( 24 );    this.currentForm.value = this.reader.getFloat64Array( 3 );    }   }   // holds various data about texture node image state  // Data other thanmipMapLevel unknown  parseImageStateForm() {    this.reader.skip( 8 ); // unknown    this.currentForm.mipMapLevel = this.reader.getFloat32();   }   // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)  parseImageMap( length ) {    this.currentFormEnd = this.reader.offset + length;   this.parentForm = this.currentForm;    if ( ! this.currentForm.maps ) this.currentForm.maps = [];    var map = {};   this.currentForm.maps.push( map );   this.currentForm = map;    this.reader.skip( 10 ); // unknown, could be an issue if it contains a VX   }   parseTextureNodeAttribute( type ) {    this.reader.skip( 28 ); // FORM + length + VPRM + unknown + Uint32 x2 + float32    this.reader.skip( 20 ); // FORM + length + VPVL + float32 + Uint32    switch ( type ) {     case 'ISCL':     this.currentNode.scale = this.reader.getFloat32Array( 3 );     break;    case 'IPOS':     this.currentNode.position = this.reader.getFloat32Array( 3 );     break;    case 'IROT':     this.currentNode.rotation = this.reader.getFloat32Array( 3 );     break;    case 'IFAL':     this.currentNode.falloff = this.reader.getFloat32Array( 3 );     break;     case 'IBMP':     this.currentNode.amplitude = this.reader.getFloat32();     break;    case 'IUTD':     this.currentNode.uTiles = this.reader.getFloat32();     break;    case 'IVTD':     this.currentNode.vTiles = this.reader.getFloat32();     break;    }    this.reader.skip( 2 ); // unknown    }   // ENVL forms are currently ignored  parseEnvelope( length ) {    this.reader.skip( length - 4 ); // skipping  entirely for now   }   ///  // CHUNK PARSING METHODS  ///   // clips can either be defined inside a surface node, or at the top  // level and they have a different format in each case  parseClip( length ) {    var tag = this.reader.getIDTag();    // inside surface node   if ( tag === 'FORM' ) {     this.reader.skip( 16 );     this.currentNode.fileName = this.reader.getString();     return;    }    // otherwise top level   this.reader.setOffset( this.reader.offset - 4 );    this.currentFormEnd = this.reader.offset + length;   this.parentForm = this.currentForm;    this.reader.skip( 8 ); // unknown    var texture = {    index: this.reader.getUint32()   };   this.tree.textures.push( texture );   this.currentForm = texture;   }   parseClipLwo2( length ) {    var texture = {    index: this.reader.getUint32(),    fileName: ''   };    // seach STIL block   while ( true ) {     var tag = this.reader.getIDTag();    var n_length = this.reader.getUint16();    if ( tag === 'STIL' ) {      texture.fileName = this.reader.getString();     break;     }     if ( n_length >= length ) {      break;     }    }    this.tree.textures.push( texture );   this.currentForm = texture;   }   parseImage() {    this.reader.skip( 8 ); // unknown   this.currentForm.fileName = this.reader.getString();   }   parseXVAL( type, length ) {    var endOffset = this.reader.offset + length - 4;   this.reader.skip( 8 );    this.currentForm[ type ] = this.reader.getFloat32();    this.reader.setOffset( endOffset ); // set end offset directly to skip optional envelope   }   parseXVAL3( type, length ) {    var endOffset = this.reader.offset + length - 4;   this.reader.skip( 8 );    this.currentForm[ type ] = {    x: this.reader.getFloat32(),    y: this.reader.getFloat32(),    z: this.reader.getFloat32(),   };    this.reader.setOffset( endOffset );   }   // Tags associated with an object  // OTAG { type[ID4], tag-string[S0] }  parseObjectTag() {    if ( ! this.tree.objectTags ) this.tree.objectTags = {};    this.tree.objectTags[ this.reader.getIDTag() ] = {    tagString: this.reader.getString()   };   }   // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.  // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]  parseLayer( length ) {    var number = this.reader.getUint16();   var flags = this.reader.getUint16(); // If the least significant bit of flags is set, the layer is hidden.   var pivot = this.reader.getFloat32Array( 3 ); // Note: this seems to be superflous, as the geometry is translated when pivot is present   var layer = {    number: number,    flags: flags, // If the least significant bit of flags is set, the layer is hidden.    pivot: [ - pivot[ 0 ], pivot[ 1 ], pivot[ 2 ] ], // Note: this seems to be superflous, as the geometry is translated when pivot is present    name: this.reader.getString(),   };    this.tree.layers.push( layer );   this.currentLayer = layer;    var parsedLength = 16 + stringOffset( this.currentLayer.name ); // index ( 2 ) + flags( 2 ) + pivot( 12 ) + stringlength    // if we have not reached then end of the layer block, there must be a parent defined   this.currentLayer.parent = ( parsedLength < length ) ? this.reader.getUint16() : - 1; // omitted or -1 for no parent   }   // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors  // Converting from left to right handed coordinate system:  // x -> -x and switch material FrontSide -> BackSide  parsePoints( length ) {    this.currentPoints = [];   for ( var i = 0; i < length / 4; i += 3 ) {     // x -> -x to match three.js right handed coords    this.currentPoints.push( - this.reader.getFloat32(), this.reader.getFloat32(), this.reader.getFloat32() );    }   }   // parse VMAP or VMAD  // Associates a set of floating-point vectors with a set of points.  // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }   // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.  // Similar to VMAP UVs, but associates with polygon vertices rather than points  // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,  // if they exist. The vector values in the VMAD will then replace those in the  // corresponding VMAP, but only for calculations involving the specified polygons.  // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }  parseVertexMapping( length, discontinuous ) {    var finalOffset = this.reader.offset + length;    var channelName = this.reader.getString();    if ( this.reader.offset === finalOffset ) {     // then we are in a texture node and the VMAP chunk is just a reference to a UV channel name    this.currentForm.UVChannel = channelName;    return;    }    // otherwise reset to initial length and parse normal VMAP CHUNK   this.reader.setOffset( this.reader.offset - stringOffset( channelName ) );    var type = this.reader.getIDTag();    this.reader.getUint16(); // dimension   var name = this.reader.getString();    var remainingLength = length - 6 - stringOffset( name );    switch ( type ) {     case 'TXUV':     this.parseUVMapping( name, finalOffset, discontinuous );     break;    case 'MORF':    case 'SPOT':     this.parseMorphTargets( name, finalOffset, type ); // can't be discontinuous     break;    // unsupported VMAPs    case 'APSL':    case 'NORM':    case 'WGHT':    case 'MNVW':    case 'PICK':    case 'RGB ':    case 'RGBA':     this.reader.skip( remainingLength );     break;    default:     console.warn( 'LWOLoader: unknown vertex map type: ' + type );     this.reader.skip( remainingLength );    }   }   parseUVMapping( name, finalOffset, discontinuous ) {    var uvIndices = [];   var polyIndices = [];   var uvs = [];    while ( this.reader.offset < finalOffset ) {     uvIndices.push( this.reader.getVariableLengthIndex() );     if ( discontinuous ) polyIndices.push( this.reader.getVariableLengthIndex() );     uvs.push( this.reader.getFloat32(), this.reader.getFloat32() );    }    if ( discontinuous ) {     if ( ! this.currentLayer.discontinuousUVs ) this.currentLayer.discontinuousUVs = {};     this.currentLayer.discontinuousUVs[ name ] = {     uvIndices: uvIndices,     polyIndices: polyIndices,     uvs: uvs,    };    } else {     if ( ! this.currentLayer.uvs ) this.currentLayer.uvs = {};     this.currentLayer.uvs[ name ] = {     uvIndices: uvIndices,     uvs: uvs,    };    }   }   parseMorphTargets( name, finalOffset, type ) {    var indices = [];   var points = [];    type = ( type === 'MORF' ) ? 'relative' : 'absolute';    while ( this.reader.offset < finalOffset ) {     indices.push( this.reader.getVariableLengthIndex() );    // z -> -z to match three.js right handed coords    points.push( this.reader.getFloat32(), this.reader.getFloat32(), - this.reader.getFloat32() );    }    if ( ! this.currentLayer.morphTargets ) this.currentLayer.morphTargets = {};    this.currentLayer.morphTargets[ name ] = {    indices: indices,    points: points,    type: type,   };   }   // A list of polygons for the current layer.  // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }  parsePolygonList( length ) {    var finalOffset = this.reader.offset + length;   var type = this.reader.getIDTag();    var indices = [];    // hold a list of polygon sizes, to be split up later   var polygonDimensions = [];    while ( this.reader.offset < finalOffset ) {     var numverts = this.reader.getUint16();     //var flags = numverts & 64512; // 6 high order bits are flags - ignoring for now    numverts = numverts & 1023; // remaining ten low order bits are vertex num    polygonDimensions.push( numverts );     for ( var j = 0; j < numverts; j ++ ) indices.push( this.reader.getVariableLengthIndex() );    }    var geometryData = {    type: type,    vertexIndices: indices,    polygonDimensions: polygonDimensions,    points: this.currentPoints   };    // Note: assuming that all polys will be lines or points if the first is   if ( polygonDimensions[ 0 ] === 1 ) geometryData.type = 'points';   else if ( polygonDimensions[ 0 ] === 2 ) geometryData.type = 'lines';    this.currentLayer.geometry = geometryData;   }   // Lists the tag strings that can be associated with polygons by the PTAG chunk.  // TAGS { tag-string[S0] * }  parseTagStrings( length ) {    this.tree.tags = this.reader.getStringArray( length );   }   // Associates tags of a given type with polygons in the most recent POLS chunk.  // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }  parsePolygonTagMapping( length ) {    var finalOffset = this.reader.offset + length;   var type = this.reader.getIDTag();   if ( type === 'SURF' ) this.parseMaterialIndices( finalOffset );   else { //PART, SMGP, COLR not supported     this.reader.skip( length - 4 );    }   }   parseMaterialIndices( finalOffset ) {    // array holds polygon index followed by material index   this.currentLayer.geometry.materialIndices = [];    while ( this.reader.offset < finalOffset ) {     var polygonIndex = this.reader.getVariableLengthIndex();    var materialIndex = this.reader.getUint16();     this.currentLayer.geometry.materialIndices.push( polygonIndex, materialIndex );    }   }   parseUnknownCHUNK( blockID, length ) {    console.warn( 'LWOLoader: unknown chunk type: ' + blockID + ' length: ' + length );    // print the chunk plus some bytes padding either side   // printBuffer( this.reader.dv.buffer, this.reader.offset - 20, length + 40 );    var data = this.reader.getString( length );    this.currentForm[ blockID ] = data;   }  }   class DataViewReader {   constructor( buffer ) {    this.dv = new DataView( buffer );   this.offset = 0;   this._textDecoder = new TextDecoder();   this._bytes = new Uint8Array( buffer );   }   size() {    return this.dv.buffer.byteLength;   }   setOffset( offset ) {    if ( offset > 0 && offset < this.dv.buffer.byteLength ) {     this.offset = offset;    } else {     console.error( 'LWOLoader: invalid buffer offset' );    }   }   endOfFile() {    if ( this.offset >= this.size() ) return true;   return false;   }   skip( length ) {    this.offset += length;   }   getUint8() {    var value = this.dv.getUint8( this.offset );   this.offset += 1;   return value;   }   getUint16() {    var value = this.dv.getUint16( this.offset );   this.offset += 2;   return value;   }   getInt32() {    var value = this.dv.getInt32( this.offset, false );   this.offset += 4;   return value;   }   getUint32() {    var value = this.dv.getUint32( this.offset, false );   this.offset += 4;   return value;   }   getUint64() {    var low, high;    high = this.getUint32();   low = this.getUint32();   return high * 0x100000000 + low;   }   getFloat32() {    var value = this.dv.getFloat32( this.offset, false );   this.offset += 4;   return value;   }   getFloat32Array( size ) {    var a = [];    for ( var i = 0; i < size; i ++ ) {     a.push( this.getFloat32() );    }    return a;   }   getFloat64() {    var value = this.dv.getFloat64( this.offset, this.littleEndian );   this.offset += 8;   return value;   }   getFloat64Array( size ) {    var a = [];    for ( var i = 0; i < size; i ++ ) {     a.push( this.getFloat64() );    }    return a;   }   // get variable-length index data type  // VX ::= index[U2] | (index + 0xFF000000)[U4]  // If the index value is less than 65,280 (0xFF00),then VX === U2  // otherwise VX === U4 with bits 24-31 set  // When reading an index, if the first byte encountered is 255 (0xFF), then  // the four-byte form is being used and the first byte should be discarded or masked out.  getVariableLengthIndex() {    var firstByte = this.getUint8();    if ( firstByte === 255 ) {     return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();    }    return firstByte * 256 + this.getUint8();   }   // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values  getIDTag() {    return this.getString( 4 );   }   getString( size ) {    if ( size === 0 ) return;    const start = this.offset;    let result;   let length;    if ( size ) {     length = size;    result = this._textDecoder.decode( new Uint8Array( this.dv.buffer, start, size ) );    } else {     // use 1:1 mapping of buffer to avoid redundant new array creation.    length = this._bytes.indexOf( 0, start ) - start;     result = this._textDecoder.decode( new Uint8Array( this.dv.buffer, start, length ) );     // account for null byte in length    length ++;     // if string with terminating nullbyte is uneven, extra nullbyte is added, skip that too    length += length % 2;    }    this.skip( length );    return result;   }   getStringArray( size ) {    var a = this.getString( size );   a = a.split( '|0' );    return a.filter( Boolean ); // return array with any empty strings removed   }  }   // ************** DEBUGGER  **************  class Debugger {   constructor() {    this.active = false;   this.depth = 0;   this.formList = [];   }   enable() {    this.active = true;   }   log() {    if ( ! this.active ) return;    var nodeType;    switch ( this.node ) {     case 0:     nodeType = 'FORM';     break;     case 1:     nodeType = 'CHK';     break;     case 2:     nodeType = 'S-CHK';     break;    }    console.log(    '| '.repeat( this.depth ) +    nodeType,    this.nodeID,    |( |this.offset} ) -> ( |this.dataOffset + this.length} )|,    ( ( this.node == 0 ) ? ' {' : '' ),    ( ( this.skipped ) ? 'SKIPPED' : '' ),    ( ( this.node == 0 && this.skipped ) ? '}' : '' )   );    if ( this.node == 0 && ! this.skipped ) {     this.depth += 1;    this.formList.push( this.dataOffset + this.length );    }    this.skipped = false;   }   closeForms() {    if ( ! this.active ) return;    for ( var i = this.formList.length - 1; i >= 0; i -- ) {     if ( this.offset >= this.formList[ i ] ) {      this.depth -= 1;     console.log( '| '.repeat( this.depth ) + '}' );     this.formList.splice( - 1, 1 );     }    }   }  }  // ************** UTILITY FUNCTIONS **************  function isEven( num ) {   return num % 2;  }  // calculate the length of the string in the buffer // this will be string.length + nullbyte + optional padbyte to make the length even function stringOffset( string ) {   return string.length + 1 + ( isEven( string.length + 1 ) ? 1 : 0 );  }  // for testing purposes, dump buffer to console // printBuffer( this.reader.dv.buffer, this.reader.offset, length ); function printBuffer( buffer, from, to ) {   console.log( new TextDecoder().decode( new Uint8Array( buffer, from, to ) ) );  }  export { IFFParser }; 
^..^ FILENAME ^..^
addons|loaders|lwo|LWO2Parser.js
^..^ CONTENTS ^..^
class LWO2Parser {   constructor( IFFParser ) {    this.IFF = IFFParser;   }   parseBlock() {    this.IFF.debugger.offset = this.IFF.reader.offset;   this.IFF.debugger.closeForms();    const blockID = this.IFF.reader.getIDTag();   let length = this.IFF.reader.getUint32(); // size of data in bytes   if ( length > this.IFF.reader.dv.byteLength - this.IFF.reader.offset ) {     this.IFF.reader.offset -= 4;    length = this.IFF.reader.getUint16();    }    this.IFF.debugger.dataOffset = this.IFF.reader.offset;   this.IFF.debugger.length = length;    // Data types may be found in either LWO2 OR LWO3 spec   switch ( blockID ) {     case 'FORM': // form blocks may consist of sub -chunks or sub-forms     this.IFF.parseForm( length );     break;     // SKIPPED CHUNKS    // if break; is called directly, the position in the lwoTree is not created    // any sub chunks and forms are added to the parent form instead    // MISC skipped    case 'ICON': // Thumbnail Icon Image    case 'VMPA': // Vertex Map Parameter    case 'BBOX': // bounding box    // case 'VMMD':    // case 'VTYP':     // normal maps can be specified, normally on models imported from other applications. Currently ignored    case 'NORM':     // ENVL FORM skipped    case 'PRE ':    case 'POST':    case 'KEY ':    case 'SPAN':     // CLIP FORM skipped    case 'TIME':    case 'CLRS':    case 'CLRA':    case 'FILT':    case 'DITH':    case 'CONT':    case 'BRIT':    case 'SATR':    case 'HUE ':    case 'GAMM':    case 'NEGA':    case 'IFLT':    case 'PFLT':     // Image Map Layer skipped    case 'PROJ':    case 'AXIS':    case 'AAST':    case 'PIXB':    case 'AUVO':    case 'STCK':     // Procedural Textures skipped    case 'PROC':    case 'VALU':    case 'FUNC':     // Gradient Textures skipped    case 'PNAM':    case 'INAM':    case 'GRST':    case 'GREN':    case 'GRPT':    case 'FKEY':    case 'IKEY':     // Texture Mapping Form skipped    case 'CSYS':     // Surface CHUNKs skipped    case 'OPAQ': // top level 'opacity' checkbox    case 'CMAP': // clip map     // Surface node CHUNKS skipped    // These mainly specify the node editor setup in LW    case 'NLOC':    case 'NZOM':    case 'NVER':    case 'NSRV':    case 'NVSK': // unknown    case 'NCRD':    case 'WRPW': // image wrap w ( for cylindrical and spherical projections)    case 'WRPH': // image wrap h    case 'NMOD':    case 'NSEL':    case 'NPRW':    case 'NPLA':    case 'NODS':    case 'VERS':    case 'ENUM':    case 'TAG ':    case 'OPAC':     // Car Material CHUNKS    case 'CGMD':    case 'CGTY':    case 'CGST':    case 'CGEN':    case 'CGTS':    case 'CGTE':    case 'OSMP':    case 'OMDE':    case 'OUTR':    case 'FLAG':     case 'TRNL':    case 'GLOW':    case 'GVAL': // glow intensity    case 'SHRP':    case 'RFOP':    case 'RSAN':    case 'TROP':    case 'RBLR':    case 'TBLR':    case 'CLRH':    case 'CLRF':    case 'ADTR':    case 'LINE':    case 'ALPH':    case 'VCOL':    case 'ENAB':     this.IFF.debugger.skipped = true;     this.IFF.reader.skip( length );     break;     case 'SURF':     this.IFF.parseSurfaceLwo2( length );     break;     case 'CLIP':     this.IFF.parseClipLwo2( length );     break;     // Texture node chunks (not in spec)    case 'IPIX': // usePixelBlending    case 'IMIP': // useMipMaps    case 'IMOD': // imageBlendingMode    case 'AMOD': // unknown    case 'IINV': // imageInvertAlpha    case 'INCR': // imageInvertColor    case 'IAXS': // imageAxis ( for non-UV maps)    case 'IFOT': // imageFallofType    case 'ITIM': // timing for animated textures    case 'IWRL':    case 'IUTI':    case 'IINX':    case 'IINY':    case 'IINZ':    case 'IREF': // possibly a VX for reused texture nodes     if ( length === 4 ) this.IFF.currentNode[ blockID ] = this.IFF.reader.getInt32();     else this.IFF.reader.skip( length );     break;     case 'OTAG':     this.IFF.parseObjectTag();     break;     case 'LAYR':     this.IFF.parseLayer( length );     break;     case 'PNTS':     this.IFF.parsePoints( length );     break;     case 'VMAP':     this.IFF.parseVertexMapping( length );     break;     case 'AUVU':    case 'AUVN':     this.IFF.reader.skip( length - 1 );     this.IFF.reader.getVariableLengthIndex(); // VX     break;     case 'POLS':     this.IFF.parsePolygonList( length );     break;     case 'TAGS':     this.IFF.parseTagStrings( length );     break;     case 'PTAG':     this.IFF.parsePolygonTagMapping( length );     break;     case 'VMAD':     this.IFF.parseVertexMapping( length, true );     break;     // Misc CHUNKS    case 'DESC': // Description Line     this.IFF.currentForm.description = this.IFF.reader.getString();     break;     case 'TEXT':    case 'CMNT':    case 'NCOM':     this.IFF.currentForm.comment = this.IFF.reader.getString();     break;     // Envelope Form    case 'NAME':     this.IFF.currentForm.channelName = this.IFF.reader.getString();     break;     // Image Map Layer    case 'WRAP':     this.IFF.currentForm.wrap = { w: this.IFF.reader.getUint16(), h: this.IFF.reader.getUint16() };     break;     case 'IMAG':     const index = this.IFF.reader.getVariableLengthIndex();     this.IFF.currentForm.imageIndex = index;     break;     // Texture Mapping Form    case 'OREF':     this.IFF.currentForm.referenceObject = this.IFF.reader.getString();     break;     case 'ROID':     this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32();     break;     // Surface Blocks    case 'SSHN':     this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString();     break;     case 'AOVN':     this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString();     break;     // Nodal Blocks    case 'NSTA':     this.IFF.currentForm.disabled = this.IFF.reader.getUint16();     break;     case 'NRNM':     this.IFF.currentForm.realName = this.IFF.reader.getString();     break;     case 'NNME':     this.IFF.currentForm.refName = this.IFF.reader.getString();     this.IFF.currentSurface.nodes[ this.IFF.currentForm.refName ] = this.IFF.currentForm;     break;     // Nodal Blocks : connections    case 'INME':     if ( ! this.IFF.currentForm.nodeName ) this.IFF.currentForm.nodeName = [];     this.IFF.currentForm.nodeName.push( this.IFF.reader.getString() );     break;     case 'IINN':     if ( ! this.IFF.currentForm.inputNodeName ) this.IFF.currentForm.inputNodeName = [];     this.IFF.currentForm.inputNodeName.push( this.IFF.reader.getString() );     break;     case 'IINM':     if ( ! this.IFF.currentForm.inputName ) this.IFF.currentForm.inputName = [];     this.IFF.currentForm.inputName.push( this.IFF.reader.getString() );     break;     case 'IONM':     if ( ! this.IFF.currentForm.inputOutputName ) this.IFF.currentForm.inputOutputName = [];     this.IFF.currentForm.inputOutputName.push( this.IFF.reader.getString() );     break;     case 'FNAM':     this.IFF.currentForm.fileName = this.IFF.reader.getString();     break;     case 'CHAN': // NOTE: ENVL Forms may also have CHAN chunk, however ENVL is currently ignored     if ( length === 4 ) this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag();     else this.IFF.reader.skip( length );     break;     // LWO2 Spec chunks: these are needed since the SURF FORMs are often in LWO2 format    case 'SMAN':     const maxSmoothingAngle = this.IFF.reader.getFloat32();     this.IFF.currentSurface.attributes.smooth = ( maxSmoothingAngle < 0 ) ? false : true;     break;     // LWO2: Basic Surface Parameters    case 'COLR':     this.IFF.currentSurface.attributes.Color = { value: this.IFF.reader.getFloat32Array( 3 ) };     this.IFF.reader.skip( 2 ); // VX: envelope     break;     case 'LUMI':     this.IFF.currentSurface.attributes.Luminosity = { value: this.IFF.reader.getFloat32() };     this.IFF.reader.skip( 2 );     break;     case 'SPEC':     this.IFF.currentSurface.attributes.Specular = { value: this.IFF.reader.getFloat32() };     this.IFF.reader.skip( 2 );     break;     case 'DIFF':     this.IFF.currentSurface.attributes.Diffuse = { value: this.IFF.reader.getFloat32() };     this.IFF.reader.skip( 2 );     break;     case 'REFL':     this.IFF.currentSurface.attributes.Reflection = { value: this.IFF.reader.getFloat32() };     this.IFF.reader.skip( 2 );     break;     case 'GLOS':     this.IFF.currentSurface.attributes.Glossiness = { value: this.IFF.reader.getFloat32() };     this.IFF.reader.skip( 2 );     break;     case 'TRAN':     this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32();     this.IFF.reader.skip( 2 );     break;     case 'BUMP':     this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32();     this.IFF.reader.skip( 2 );     break;     case 'SIDE':     this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16();     break;     case 'RIMG':     this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex();     break;     case 'RIND':     this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32();     this.IFF.reader.skip( 2 );     break;     case 'TIMG':     this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex();     break;     case 'IMAP':     this.IFF.reader.skip( 2 );     break;     case 'TMAP':     this.IFF.debugger.skipped = true;     this.IFF.reader.skip( length ); // needs implementing     break;     case 'IUVI': // uv channel name     this.IFF.currentNode.UVChannel = this.IFF.reader.getString( length );     break;     case 'IUTL': // widthWrappingMode: 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge     this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32();     break;    case 'IVTL': // heightWrappingMode     this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32();     break;     // LWO2 USE    case 'BLOK':     // skip     break;     default:     this.IFF.parseUnknownCHUNK( blockID, length );    }    if ( blockID != 'FORM' ) {     this.IFF.debugger.node = 1;    this.IFF.debugger.nodeID = blockID;    this.IFF.debugger.log();    }    if ( this.IFF.reader.offset >= this.IFF.currentFormEnd ) {     this.IFF.currentForm = this.IFF.parentForm;    }   }  }  export { LWO2Parser }; 
^..^ FILENAME ^..^
addons|loaders|lwo|LWO3Parser.js
^..^ CONTENTS ^..^
class LWO3Parser {   constructor( IFFParser ) {    this.IFF = IFFParser;   }   parseBlock() {    this.IFF.debugger.offset = this.IFF.reader.offset;   this.IFF.debugger.closeForms();    const blockID = this.IFF.reader.getIDTag();   const length = this.IFF.reader.getUint32(); // size of data in bytes    this.IFF.debugger.dataOffset = this.IFF.reader.offset;   this.IFF.debugger.length = length;    // Data types may be found in either LWO2 OR LWO3 spec   switch ( blockID ) {     case 'FORM': // form blocks may consist of sub -chunks or sub-forms     this.IFF.parseForm( length );     break;     // SKIPPED CHUNKS    // MISC skipped    case 'ICON': // Thumbnail Icon Image    case 'VMPA': // Vertex Map Parameter    case 'BBOX': // bounding box    // case 'VMMD':    // case 'VTYP':     // normal maps can be specified, normally on models imported from other applications. Currently ignored    case 'NORM':     // ENVL FORM skipped    case 'PRE ': // Pre-loop behavior for the keyframe    case 'POST': // Post-loop behavior for the keyframe    case 'KEY ':    case 'SPAN':     // CLIP FORM skipped    case 'TIME':    case 'CLRS':    case 'CLRA':    case 'FILT':    case 'DITH':    case 'CONT':    case 'BRIT':    case 'SATR':    case 'HUE ':    case 'GAMM':    case 'NEGA':    case 'IFLT':    case 'PFLT':     // Image Map Layer skipped    case 'PROJ':    case 'AXIS':    case 'AAST':    case 'PIXB':    case 'STCK':     // Procedural Textures skipped    case 'VALU':     // Gradient Textures skipped    case 'PNAM':    case 'INAM':    case 'GRST':    case 'GREN':    case 'GRPT':    case 'FKEY':    case 'IKEY':     // Texture Mapping Form skipped    case 'CSYS':      // Surface CHUNKs skipped    case 'OPAQ': // top level 'opacity' checkbox    case 'CMAP': // clip map     // Surface node CHUNKS skipped    // These mainly specify the node editor setup in LW    case 'NLOC':    case 'NZOM':    case 'NVER':    case 'NSRV':    case 'NCRD':    case 'NMOD':    case 'NSEL':    case 'NPRW':    case 'NPLA':    case 'VERS':    case 'ENUM':    case 'TAG ':     // Car Material CHUNKS    case 'CGMD':    case 'CGTY':    case 'CGST':    case 'CGEN':    case 'CGTS':    case 'CGTE':    case 'OSMP':    case 'OMDE':    case 'OUTR':    case 'FLAG':     case 'TRNL':    case 'SHRP':    case 'RFOP':    case 'RSAN':    case 'TROP':    case 'RBLR':    case 'TBLR':    case 'CLRH':    case 'CLRF':    case 'ADTR':    case 'GLOW':    case 'LINE':    case 'ALPH':    case 'VCOL':    case 'ENAB':     this.IFF.debugger.skipped = true;     this.IFF.reader.skip( length );     break;     // Texture node chunks (not in spec)    case 'IPIX': // usePixelBlending    case 'IMIP': // useMipMaps    case 'IMOD': // imageBlendingMode    case 'AMOD': // unknown    case 'IINV': // imageInvertAlpha    case 'INCR': // imageInvertColor    case 'IAXS': // imageAxis ( for non-UV maps)    case 'IFOT': // imageFallofType    case 'ITIM': // timing for animated textures    case 'IWRL':    case 'IUTI':    case 'IINX':    case 'IINY':    case 'IINZ':    case 'IREF': // possibly a VX for reused texture nodes     if ( length === 4 ) this.IFF.currentNode[ blockID ] = this.IFF.reader.getInt32();     else this.IFF.reader.skip( length );     break;     case 'OTAG':     this.IFF.parseObjectTag();     break;     case 'LAYR':     this.IFF.parseLayer( length );     break;     case 'PNTS':     this.IFF.parsePoints( length );     break;     case 'VMAP':     this.IFF.parseVertexMapping( length );     break;     case 'POLS':     this.IFF.parsePolygonList( length );     break;     case 'TAGS':     this.IFF.parseTagStrings( length );     break;     case 'PTAG':     this.IFF.parsePolygonTagMapping( length );     break;     case 'VMAD':     this.IFF.parseVertexMapping( length, true );     break;     // Misc CHUNKS    case 'DESC': // Description Line     this.IFF.currentForm.description = this.IFF.reader.getString();     break;     case 'TEXT':    case 'CMNT':    case 'NCOM':     this.IFF.currentForm.comment = this.IFF.reader.getString();     break;     // Envelope Form    case 'NAME':     this.IFF.currentForm.channelName = this.IFF.reader.getString();     break;     // Image Map Layer    case 'WRAP':     this.IFF.currentForm.wrap = { w: this.IFF.reader.getUint16(), h: this.IFF.reader.getUint16() };     break;     case 'IMAG':     const index = this.IFF.reader.getVariableLengthIndex();     this.IFF.currentForm.imageIndex = index;     break;     // Texture Mapping Form    case 'OREF':     this.IFF.currentForm.referenceObject = this.IFF.reader.getString();     break;     case 'ROID':     this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32();     break;     // Surface Blocks    case 'SSHN':     this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString();     break;     case 'AOVN':     this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString();     break;     // Nodal Blocks    case 'NSTA':     this.IFF.currentForm.disabled = this.IFF.reader.getUint16();     break;     case 'NRNM':     this.IFF.currentForm.realName = this.IFF.reader.getString();     break;     case 'NNME':     this.IFF.currentForm.refName = this.IFF.reader.getString();     this.IFF.currentSurface.nodes[ this.IFF.currentForm.refName ] = this.IFF.currentForm;     break;     // Nodal Blocks : connections    case 'INME':     if ( ! this.IFF.currentForm.nodeName ) this.IFF.currentForm.nodeName = [];     this.IFF.currentForm.nodeName.push( this.IFF.reader.getString() );     break;     case 'IINN':     if ( ! this.IFF.currentForm.inputNodeName ) this.IFF.currentForm.inputNodeName = [];     this.IFF.currentForm.inputNodeName.push( this.IFF.reader.getString() );     break;     case 'IINM':     if ( ! this.IFF.currentForm.inputName ) this.IFF.currentForm.inputName = [];     this.IFF.currentForm.inputName.push( this.IFF.reader.getString() );     break;     case 'IONM':     if ( ! this.IFF.currentForm.inputOutputName ) this.IFF.currentForm.inputOutputName = [];     this.IFF.currentForm.inputOutputName.push( this.IFF.reader.getString() );     break;     case 'FNAM':     this.IFF.currentForm.fileName = this.IFF.reader.getString();     break;     case 'CHAN': // NOTE: ENVL Forms may also have CHAN chunk, however ENVL is currently ignored     if ( length === 4 ) this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag();     else this.IFF.reader.skip( length );     break;     // LWO2 Spec chunks: these are needed since the SURF FORMs are often in LWO2 format    case 'SMAN':     const maxSmoothingAngle = this.IFF.reader.getFloat32();     this.IFF.currentSurface.attributes.smooth = ( maxSmoothingAngle < 0 ) ? false : true;     break;     // LWO2: Basic Surface Parameters    case 'COLR':     this.IFF.currentSurface.attributes.Color = { value: this.IFF.reader.getFloat32Array( 3 ) };     this.IFF.reader.skip( 2 ); // VX: envelope     break;     case 'LUMI':     this.IFF.currentSurface.attributes.Luminosity = { value: this.IFF.reader.getFloat32() };     this.IFF.reader.skip( 2 );     break;     case 'SPEC':     this.IFF.currentSurface.attributes.Specular = { value: this.IFF.reader.getFloat32() };     this.IFF.reader.skip( 2 );     break;     case 'DIFF':     this.IFF.currentSurface.attributes.Diffuse = { value: this.IFF.reader.getFloat32() };     this.IFF.reader.skip( 2 );     break;     case 'REFL':     this.IFF.currentSurface.attributes.Reflection = { value: this.IFF.reader.getFloat32() };     this.IFF.reader.skip( 2 );     break;     case 'GLOS':     this.IFF.currentSurface.attributes.Glossiness = { value: this.IFF.reader.getFloat32() };     this.IFF.reader.skip( 2 );     break;     case 'TRAN':     this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32();     this.IFF.reader.skip( 2 );     break;     case 'BUMP':     this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32();     this.IFF.reader.skip( 2 );     break;     case 'SIDE':     this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16();     break;     case 'RIMG':     this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex();     break;     case 'RIND':     this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32();     this.IFF.reader.skip( 2 );     break;     case 'TIMG':     this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex();     break;     case 'IMAP':     this.IFF.currentSurface.attributes.imageMapIndex = this.IFF.reader.getUint32();     break;     case 'IUVI': // uv channel name     this.IFF.currentNode.UVChannel = this.IFF.reader.getString( length );     break;     case 'IUTL': // widthWrappingMode: 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge     this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32();     break;    case 'IVTL': // heightWrappingMode     this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32();     break;     default:     this.IFF.parseUnknownCHUNK( blockID, length );    }    if ( blockID != 'FORM' ) {     this.IFF.debugger.node = 1;    this.IFF.debugger.nodeID = blockID;    this.IFF.debugger.log();    }    if ( this.IFF.reader.offset >= this.IFF.currentFormEnd ) {     this.IFF.currentForm = this.IFF.parentForm;    }   }  }  export { LWO3Parser }; 
^..^ FILENAME ^..^
addons|materials|MeshGouraudMaterial.js
^..^ CONTENTS ^..^
/**  * MeshGouraudMaterial  *  * Lambert illumination model with Gouraud (per-vertex) shading  *  */  import { UniformsUtils, UniformsLib, ShaderMaterial, Color, MultiplyOperation } from 'three';  const GouraudShader = {   name: 'GouraudShader',   uniforms: UniformsUtils.merge( [   UniformsLib.common,   UniformsLib.specularmap,   UniformsLib.envmap,   UniformsLib.aomap,   UniformsLib.lightmap,   UniformsLib.emissivemap,   UniformsLib.fog,   UniformsLib.lights,   {    emissive: { value: new Color( 0x000000 ) }   }  ] ),   vertexShader: /* glsl */|    #define GOURAUD    varying vec3 vLightFront;   varying vec3 vIndirectFront;    #ifdef DOUBLE_SIDED    varying vec3 vLightBack;    varying vec3 vIndirectBack;   #endif    #include <common>   #include <uv_pars_vertex>   #include <envmap_pars_vertex>   #include <bsdfs>   #include <lights_pars_begin>   #include <color_pars_vertex>   #include <fog_pars_vertex>   #include <morphtarget_pars_vertex>   #include <skinning_pars_vertex>   #include <shadowmap_pars_vertex>   #include <logdepthbuf_pars_vertex>   #include <clipping_planes_pars_vertex>    void main() {     #include <uv_vertex>    #include <color_vertex>    #include <morphcolor_vertex>     #include <beginnormal_vertex>    #include <morphnormal_vertex>    #include <skinbase_vertex>    #include <skinnormal_vertex>    #include <defaultnormal_vertex>     #include <begin_vertex>    #include <morphtarget_vertex>    #include <skinning_vertex>    #include <project_vertex>    #include <logdepthbuf_vertex>    #include <clipping_planes_vertex>     #include <worldpos_vertex>    #include <envmap_vertex>     // inlining legacy <lights_lambert_vertex>     vec3 diffuse = vec3( 1.0 );     vec3 geometryPosition = mvPosition.xyz;    vec3 geometryNormal = normalize( transformedNormal );    vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );     vec3 backGeometryNormal = - geometryNormal;     vLightFront = vec3( 0.0 );    vIndirectFront = vec3( 0.0 );    #ifdef DOUBLE_SIDED     vLightBack = vec3( 0.0 );     vIndirectBack = vec3( 0.0 );    #endif     IncidentLight directLight;    float dotNL;    vec3 directLightColor_Diffuse;     vIndirectFront += getAmbientLightIrradiance( ambientLightColor );     #if defined( USE_LIGHT_PROBES )      vIndirectFront += getLightProbeIrradiance( lightProbe, geometryNormal );     #endif     #ifdef DOUBLE_SIDED      vIndirectBack += getAmbientLightIrradiance( ambientLightColor );      #if defined( USE_LIGHT_PROBES )       vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometryNormal );      #endif     #endif     #if NUM_POINT_LIGHTS > 0      #pragma unroll_loop_start     for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {       getPointLightInfo( pointLights[ i ], geometryPosition, directLight );       dotNL = dot( geometryNormal, directLight.direction );      directLightColor_Diffuse = directLight.color;       vLightFront += saturate( dotNL ) * directLightColor_Diffuse;       #ifdef DOUBLE_SIDED        vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;       #endif      }     #pragma unroll_loop_end     #endif     #if NUM_SPOT_LIGHTS > 0      #pragma unroll_loop_start     for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {       getSpotLightInfo( spotLights[ i ], geometryPosition, directLight );       dotNL = dot( geometryNormal, directLight.direction );      directLightColor_Diffuse = directLight.color;       vLightFront += saturate( dotNL ) * directLightColor_Diffuse;       #ifdef DOUBLE_SIDED        vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;       #endif     }     #pragma unroll_loop_end     #endif     #if NUM_DIR_LIGHTS > 0      #pragma unroll_loop_start     for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {       getDirectionalLightInfo( directionalLights[ i ], directLight );       dotNL = dot( geometryNormal, directLight.direction );      directLightColor_Diffuse = directLight.color;       vLightFront += saturate( dotNL ) * directLightColor_Diffuse;       #ifdef DOUBLE_SIDED        vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;       #endif      }     #pragma unroll_loop_end     #endif     #if NUM_HEMI_LIGHTS > 0      #pragma unroll_loop_start     for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {       vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );       #ifdef DOUBLE_SIDED        vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometryNormal );       #endif      }     #pragma unroll_loop_end     #endif     #include <shadowmap_vertex>    #include <fog_vertex>    }|,   fragmentShader: /* glsl */|    #define GOURAUD    uniform vec3 diffuse;   uniform vec3 emissive;   uniform float opacity;    varying vec3 vLightFront;   varying vec3 vIndirectFront;    #ifdef DOUBLE_SIDED    varying vec3 vLightBack;    varying vec3 vIndirectBack;   #endif    #include <common>   #include <packing>   #include <dithering_pars_fragment>   #include <color_pars_fragment>   #include <uv_pars_fragment>   #include <map_pars_fragment>   #include <alphamap_pars_fragment>   #include <alphatest_pars_fragment>   #include <aomap_pars_fragment>   #include <lightmap_pars_fragment>   #include <emissivemap_pars_fragment>   #include <envmap_common_pars_fragment>   #include <envmap_pars_fragment>   #include <bsdfs>   #include <lights_pars_begin>   #include <fog_pars_fragment>   #include <shadowmap_pars_fragment>   #include <shadowmask_pars_fragment>   #include <specularmap_pars_fragment>   #include <logdepthbuf_pars_fragment>   #include <clipping_planes_pars_fragment>    void main() {     #include <clipping_planes_fragment>     vec4 diffuseColor = vec4( diffuse, opacity );    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );    vec3 totalEmissiveRadiance = emissive;     #include <logdepthbuf_fragment>    #include <map_fragment>    #include <color_fragment>    #include <alphamap_fragment>    #include <alphatest_fragment>    #include <specularmap_fragment>    #include <emissivemap_fragment>     // accumulation     #ifdef DOUBLE_SIDED      reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;     #else      reflectedLight.indirectDiffuse += vIndirectFront;     #endif     #ifdef USE_LIGHTMAP      vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );     vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;     reflectedLight.indirectDiffuse += lightMapIrradiance;     #endif     reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );     #ifdef DOUBLE_SIDED      reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;     #else      reflectedLight.directDiffuse = vLightFront;     #endif     reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();     // modulation     #include <aomap_fragment>     vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;     #include <envmap_fragment>     #include <opaque_fragment>    #include <tonemapping_fragment>    #include <colorspace_fragment>    #include <fog_fragment>    #include <premultiplied_alpha_fragment>    #include <dithering_fragment>    }|  };  //  class MeshGouraudMaterial extends ShaderMaterial {   constructor( parameters ) {    super();    this.isMeshGouraudMaterial = true;    this.type = 'MeshGouraudMaterial';    //this.color = new THREE.Color( 0xffffff ); // diffuse    //this.map = null;    //this.lightMap = null;   //this.lightMapIntensity = 1.0;    //this.aoMap = null;   //this.aoMapIntensity = 1.0;    //this.emissive = new THREE.Color( 0x000000 );   //this.emissiveIntensity = 1.0;   //this.emissiveMap = null;    //this.specularMap = null;    //this.alphaMap = null;    //this.envMap = null;   this.combine = MultiplyOperation; // combine has no uniform   //this.reflectivity = 1;   //this.refractionRatio = 0.98;    this.fog = false; // set to use scene fog   this.lights = true; // set to use scene lights   this.clipping = false; // set to use user-defined clipping planes    const shader = GouraudShader;    this.defines = Object.assign( {}, shader.defines );   this.uniforms = UniformsUtils.clone( shader.uniforms );   this.vertexShader = shader.vertexShader;   this.fragmentShader = shader.fragmentShader;    const exposePropertyNames = [    'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity',    'emissive', 'emissiveIntensity', 'emissiveMap', 'specularMap', 'alphaMap',    'envMap', 'reflectivity', 'refractionRatio', 'opacity', 'diffuse'   ];    for ( const propertyName of exposePropertyNames ) {     Object.defineProperty( this, propertyName, {      get: function () {       return this.uniforms[ propertyName ].value;      },      set: function ( value ) {       this.uniforms[ propertyName ].value = value;      }     } );    }    Object.defineProperty( this, 'color', Object.getOwnPropertyDescriptor( this, 'diffuse' ) );    this.setValues( parameters );   }   copy( source ) {    super.copy( source );    this.color.copy( source.color );    this.map = source.map;    this.lightMap = source.lightMap;   this.lightMapIntensity = source.lightMapIntensity;    this.aoMap = source.aoMap;   this.aoMapIntensity = source.aoMapIntensity;    this.emissive.copy( source.emissive );   this.emissiveMap = source.emissiveMap;   this.emissiveIntensity = source.emissiveIntensity;    this.specularMap = source.specularMap;    this.alphaMap = source.alphaMap;    this.envMap = source.envMap;   this.combine = source.combine;   this.reflectivity = source.reflectivity;   this.refractionRatio = source.refractionRatio;    this.wireframe = source.wireframe;   this.wireframeLinewidth = source.wireframeLinewidth;   this.wireframeLinecap = source.wireframeLinecap;   this.wireframeLinejoin = source.wireframeLinejoin;    this.fog = source.fog;    return this;   }  }  export { MeshGouraudMaterial }; 
^..^ FILENAME ^..^
addons|materials|MeshPostProcessingMaterial.js
^..^ CONTENTS ^..^
import { MeshPhysicalMaterial } from 'three';  /**  * The aim of this mesh material is to use information from a post processing pass in the diffuse color pass.  * This material is based on the MeshPhysicalMaterial.  *  * In the current state, only the information of a screen space AO pass can be used in the material.  * Actually, the output of any screen space AO (SSAO, GTAO) can be used,  * as it is only necessary to provide the AO in one color channel of a texture,  * however the AO pass must be rendered prior to the color pass,  * which makes the post-processing pass somewhat of a pre-processing pass.  * Fot this purpose a new map (|aoPassMap|) is added to the material.  * The value of the map is used the same way as the |aoMap| value.  *  * Motivation to use the outputs AO pass directly in the material:  * The incident light of a fragment is composed of ambient light, direct light and indirect light  * Ambient Occlusion only occludes ambient light and environment light, but not direct light.  * Direct light is only occluded by geometry that casts shadows.  * And of course the emitted light should not be darkened by ambient occlusion either.  * This cannot be achieved if the AO post processing pass is simply blended with the diffuse render pass.  *  * Further extension work might be to use the output of an SSR pass or an HBIL pass from a previous frame.  * This would then create the possibility of SSR and IR depending on material properties such as |roughness|, |metalness| and |reflectivity|. **/  class MeshPostProcessingMaterial extends MeshPhysicalMaterial {   constructor( parameters ) {    const aoPassMap = parameters.aoPassMap;   const aoPassMapScale = parameters.aoPassMapScale || 1.0;   delete parameters.aoPassMap;   delete parameters.aoPassMapScale;    super( parameters );    this.onBeforeCompile = this._onBeforeCompile;   this.customProgramCacheKey = this._customProgramCacheKey;   this._aoPassMap = aoPassMap;   this.aoPassMapScale = aoPassMapScale;   this._shader = null;   }   get aoPassMap() {    return this._aoPassMap;   }   set aoPassMap( aoPassMap ) {    this._aoPassMap = aoPassMap;   this.needsUpdate = true;   this._setUniforms();   }   _customProgramCacheKey() {    return this._aoPassMap !== undefined && this._aoPassMap !== null ? 'aoPassMap' : '';   }   _onBeforeCompile( shader ) {    this._shader = shader;    if ( this._aoPassMap !== undefined && this._aoPassMap !== null ) {     shader.fragmentShader = shader.fragmentShader.replace(     '#include <aomap_pars_fragment>',     aomap_pars_fragment_replacement    );    shader.fragmentShader = shader.fragmentShader.replace(     '#include <aomap_fragment>',     aomap_fragment_replacement    );    }    this._setUniforms();   }   _setUniforms() {    if ( this._shader ) {     this._shader.uniforms.tAoPassMap = { value: this._aoPassMap };    this._shader.uniforms.aoPassMapScale = { value: this.aoPassMapScale };    }   }  }  const aomap_pars_fragment_replacement = /* glsl */| #ifdef USE_AOMAP   uniform sampler2D aoMap;  uniform float aoMapIntensity;  #endif   uniform sampler2D tAoPassMap;  uniform float aoPassMapScale; |;  const aomap_fragment_replacement = /* glsl */| #ifndef AOPASSMAP_SWIZZLE  #define AOPASSMAP_SWIZZLE r #endif  float ambientOcclusion = texelFetch( tAoPassMap, ivec2( gl_FragCoord.xy * aoPassMapScale ), 0 ).AOPASSMAP_SWIZZLE;  #ifdef USE_AOMAP   // reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture  ambientOcclusion = min( ambientOcclusion, texture2D( aoMap, vAoMapUv ).r );  ambientOcclusion *= ( ambientOcclusion - 1.0 ) * aoMapIntensity + 1.0;  #endif   reflectedLight.indirectDiffuse *= ambientOcclusion;   #if defined( USE_CLEARCOAT )    clearcoatSpecularIndirect *= ambientOcclusion;  #endif   #if defined( USE_SHEEN )    sheenSpecularIndirect *= ambientOcclusion;  #endif   #if defined( USE_ENVMAP ) && defined( STANDARD )    float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );    reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );   #endif |;  export { MeshPostProcessingMaterial }; 
^..^ FILENAME ^..^
addons|math|Capsule.js
^..^ CONTENTS ^..^
import {  Vector3 } from 'three';  class Capsule {   constructor( start = new Vector3( 0, 0, 0 ), end = new Vector3( 0, 1, 0 ), radius = 1 ) {    this.start = start;   this.end = end;   this.radius = radius;   }   clone() {    return new Capsule( this.start.clone(), this.end.clone(), this.radius );   }   set( start, end, radius ) {    this.start.copy( start );   this.end.copy( end );   this.radius = radius;   }   copy( capsule ) {    this.start.copy( capsule.start );   this.end.copy( capsule.end );   this.radius = capsule.radius;   }   getCenter( target ) {    return target.copy( this.end ).add( this.start ).multiplyScalar( 0.5 );   }   translate( v ) {    this.start.add( v );   this.end.add( v );   }   checkAABBAxis( p1x, p1y, p2x, p2y, minx, maxx, miny, maxy, radius ) {    return (    ( minx - p1x < radius || minx - p2x < radius ) &&    ( p1x - maxx < radius || p2x - maxx < radius ) &&    ( miny - p1y < radius || miny - p2y < radius ) &&    ( p1y - maxy < radius || p2y - maxy < radius )   );   }   intersectsBox( box ) {    return (    this.checkAABBAxis(     this.start.x, this.start.y, this.end.x, this.end.y,     box.min.x, box.max.x, box.min.y, box.max.y,     this.radius ) &&    this.checkAABBAxis(     this.start.x, this.start.z, this.end.x, this.end.z,     box.min.x, box.max.x, box.min.z, box.max.z,     this.radius ) &&    this.checkAABBAxis(     this.start.y, this.start.z, this.end.y, this.end.z,     box.min.y, box.max.y, box.min.z, box.max.z,     this.radius )   );   }  }  export { Capsule }; 
^..^ FILENAME ^..^
addons|math|ColorConverter.js
^..^ CONTENTS ^..^
import { MathUtils } from 'three';  const _hsl = {};  class ColorConverter {   static setHSV( color, h, s, v ) {    // https://gist.github.com/xpansive/1337890#file-index-js    h = MathUtils.euclideanModulo( h, 1 );   s = MathUtils.clamp( s, 0, 1 );   v = MathUtils.clamp( v, 0, 1 );    return color.setHSL( h, ( s * v ) / ( ( h = ( 2 - s ) * v ) < 1 ? h : ( 2 - h ) ), h * 0.5 );   }   static getHSV( color, target ) {    color.getHSL( _hsl );    // based on https://gist.github.com/xpansive/1337890#file-index-js   _hsl.s *= ( _hsl.l < 0.5 ) ? _hsl.l : ( 1 - _hsl.l );    target.h = _hsl.h;   target.s = 2 * _hsl.s / ( _hsl.l + _hsl.s );   target.v = _hsl.l + _hsl.s;    return target;   }  }  export { ColorConverter }; 
^..^ FILENAME ^..^
addons|math|ConvexHull.js
^..^ CONTENTS ^..^
import {  Line3,  Plane,  Triangle,  Vector3 } from 'three';  /**  * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)  */  const Visible = 0; const Deleted = 1;  const _v1 = new Vector3(); const _line3 = new Line3(); const _plane = new Plane(); const _closestPoint = new Vector3(); const _triangle = new Triangle();  class ConvexHull {   constructor() {    this.tolerance = - 1;    this.faces = []; // the generated faces of the convex hull   this.newFaces = []; // this array holds the faces that are generated within a single iteration    // the vertex lists work as follows:   //   // let 'a' and 'b' be 'Face' instances   // let 'v' be points wrapped as instance of 'Vertex'   //   //     [v, v, ..., v, v, v, ...]   //      ^             ^   //      |             |   //  a.outside     b.outside   //   this.assigned = new VertexList();   this.unassigned = new VertexList();    this.vertices = [];  // vertices of the hull (internal representation of given geometry data)   }   setFromPoints( points ) {    // The algorithm needs at least four points.    if ( points.length >= 4 ) {     this.makeEmpty();     for ( let i = 0, l = points.length; i < l; i ++ ) {      this.vertices.push( new VertexNode( points[ i ] ) );     }     this.compute();    }    return this;   }   setFromObject( object ) {    const points = [];    object.updateMatrixWorld( true );    object.traverse( function ( node ) {     const geometry = node.geometry;     if ( geometry !== undefined ) {      const attribute = geometry.attributes.position;      if ( attribute !== undefined ) {       for ( let i = 0, l = attribute.count; i < l; i ++ ) {        const point = new Vector3();        point.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );        points.push( point );       }      }     }    } );    return this.setFromPoints( points );   }   containsPoint( point ) {    const faces = this.faces;    for ( let i = 0, l = faces.length; i < l; i ++ ) {     const face = faces[ i ];     // compute signed distance and check on what half space the point lies     if ( face.distanceToPoint( point ) > this.tolerance ) return false;    }    return true;   }   intersectRay( ray, target ) {    // based on "Fast Ray-Convex Polyhedron Intersection" by Eric Haines, GRAPHICS GEMS II    const faces = this.faces;    let tNear = - Infinity;   let tFar = Infinity;    for ( let i = 0, l = faces.length; i < l; i ++ ) {     const face = faces[ i ];     // interpret faces as planes for the further computation     const vN = face.distanceToPoint( ray.origin );    const vD = face.normal.dot( ray.direction );     // if the origin is on the positive side of a plane (so the plane can "see" the origin) and    // the ray is turned away or parallel to the plane, there is no intersection     if ( vN > 0 && vD >= 0 ) return null;     // compute the distance from the ray?Ts origin to the intersection with the plane     const t = ( vD !== 0 ) ? ( - vN / vD ) : 0;     // only proceed if the distance is positive. a negative distance means the intersection point    // lies "behind" the origin     if ( t <= 0 ) continue;     // now categorized plane as front-facing or back-facing     if ( vD > 0 ) {      // plane faces away from the ray, so this plane is a back-face      tFar = Math.min( t, tFar );     } else {      // front-face      tNear = Math.max( t, tNear );     }     if ( tNear > tFar ) {      // if tNear ever is greater than tFar, the ray must miss the convex hull      return null;     }    }    // evaluate intersection point    // always try tNear first since its the closer intersection point    if ( tNear !== - Infinity ) {     ray.at( tNear, target );    } else {     ray.at( tFar, target );    }    return target;   }   intersectsRay( ray ) {    return this.intersectRay( ray, _v1 ) !== null;   }   makeEmpty() {    this.faces = [];   this.vertices = [];    return this;   }   // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face   addVertexToFace( vertex, face ) {    vertex.face = face;    if ( face.outside === null ) {     this.assigned.append( vertex );    } else {     this.assigned.insertBefore( face.outside, vertex );    }    face.outside = vertex;    return this;   }   // Removes a vertex from the 'assigned' list of vertices and from the given face   removeVertexFromFace( vertex, face ) {    if ( vertex === face.outside ) {     // fix face.outside link     if ( vertex.next !== null && vertex.next.face === face ) {      // face has at least 2 outside vertices, move the 'outside' reference      face.outside = vertex.next;     } else {      // vertex was the only outside vertex that face had      face.outside = null;     }    }    this.assigned.remove( vertex );    return this;   }   // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list   removeAllVerticesFromFace( face ) {    if ( face.outside !== null ) {     // reference to the first and last vertex of this face     const start = face.outside;    let end = face.outside;     while ( end.next !== null && end.next.face === face ) {      end = end.next;     }     this.assigned.removeSubList( start, end );     // fix references     start.prev = end.next = null;    face.outside = null;     return start;    }   }   // Removes all the visible vertices that 'face' is able to see   deleteFaceVertices( face, absorbingFace ) {    const faceVertices = this.removeAllVerticesFromFace( face );    if ( faceVertices !== undefined ) {     if ( absorbingFace === undefined ) {      // mark the vertices to be reassigned to some other face      this.unassigned.appendChain( faceVertices );      } else {      // if there's an absorbing face try to assign as many vertices as possible to it      let vertex = faceVertices;      do {       // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference      // will be changed by upcoming method calls       const nextVertex = vertex.next;       const distance = absorbingFace.distanceToPoint( vertex.point );       // check if 'vertex' is able to see 'absorbingFace'       if ( distance > this.tolerance ) {        this.addVertexToFace( vertex, absorbingFace );       } else {        this.unassigned.append( vertex );       }       // now assign next vertex       vertex = nextVertex;      } while ( vertex !== null );     }    }    return this;   }   // Reassigns as many vertices as possible from the unassigned list to the new faces   resolveUnassignedPoints( newFaces ) {    if ( this.unassigned.isEmpty() === false ) {     let vertex = this.unassigned.first();     do {      // buffer 'next' reference, see .deleteFaceVertices()      const nextVertex = vertex.next;      let maxDistance = this.tolerance;      let maxFace = null;      for ( let i = 0; i < newFaces.length; i ++ ) {       const face = newFaces[ i ];       if ( face.mark === Visible ) {        const distance = face.distanceToPoint( vertex.point );        if ( distance > maxDistance ) {         maxDistance = distance;        maxFace = face;        }        if ( maxDistance > 1000 * this.tolerance ) break;       }      }      // 'maxFace' can be null e.g. if there are identical vertices      if ( maxFace !== null ) {       this.addVertexToFace( vertex, maxFace );      }      vertex = nextVertex;     } while ( vertex !== null );    }    return this;   }   // Computes the extremes of a simplex which will be the initial hull   computeExtremes() {    const min = new Vector3();   const max = new Vector3();    const minVertices = [];   const maxVertices = [];    // initially assume that the first vertex is the min/max    for ( let i = 0; i < 3; i ++ ) {     minVertices[ i ] = maxVertices[ i ] = this.vertices[ 0 ];    }    min.copy( this.vertices[ 0 ].point );   max.copy( this.vertices[ 0 ].point );    // compute the min/max vertex on all six directions    for ( let i = 0, l = this.vertices.length; i < l; i ++ ) {     const vertex = this.vertices[ i ];    const point = vertex.point;     // update the min coordinates     for ( let j = 0; j < 3; j ++ ) {      if ( point.getComponent( j ) < min.getComponent( j ) ) {       min.setComponent( j, point.getComponent( j ) );      minVertices[ j ] = vertex;      }     }     // update the max coordinates     for ( let j = 0; j < 3; j ++ ) {      if ( point.getComponent( j ) > max.getComponent( j ) ) {       max.setComponent( j, point.getComponent( j ) );      maxVertices[ j ] = vertex;      }     }    }    // use min/max vectors to compute an optimal epsilon    this.tolerance = 3 * Number.EPSILON * (    Math.max( Math.abs( min.x ), Math.abs( max.x ) ) +    Math.max( Math.abs( min.y ), Math.abs( max.y ) ) +    Math.max( Math.abs( min.z ), Math.abs( max.z ) )   );    return { min: minVertices, max: maxVertices };   }   // Computes the initial simplex assigning to its faces all the points  // that are candidates to form part of the hull   computeInitialHull() {    const vertices = this.vertices;   const extremes = this.computeExtremes();   const min = extremes.min;   const max = extremes.max;    // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation   // (max.x - min.x)   // (max.y - min.y)   // (max.z - min.z)    let maxDistance = 0;   let index = 0;    for ( let i = 0; i < 3; i ++ ) {     const distance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );     if ( distance > maxDistance ) {      maxDistance = distance;     index = i;     }    }    const v0 = min[ index ];   const v1 = max[ index ];   let v2;   let v3;    // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'    maxDistance = 0;   _line3.set( v0.point, v1.point );    for ( let i = 0, l = this.vertices.length; i < l; i ++ ) {     const vertex = vertices[ i ];     if ( vertex !== v0 && vertex !== v1 ) {      _line3.closestPointToPoint( vertex.point, true, _closestPoint );      const distance = _closestPoint.distanceToSquared( vertex.point );      if ( distance > maxDistance ) {       maxDistance = distance;      v2 = vertex;      }     }    }    // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'    maxDistance = - 1;   _plane.setFromCoplanarPoints( v0.point, v1.point, v2.point );    for ( let i = 0, l = this.vertices.length; i < l; i ++ ) {     const vertex = vertices[ i ];     if ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {      const distance = Math.abs( _plane.distanceToPoint( vertex.point ) );      if ( distance > maxDistance ) {       maxDistance = distance;      v3 = vertex;      }     }    }    const faces = [];    if ( _plane.distanceToPoint( v3.point ) < 0 ) {     // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron     faces.push(     Face.create( v0, v1, v2 ),     Face.create( v3, v1, v0 ),     Face.create( v3, v2, v1 ),     Face.create( v3, v0, v2 )    );     // set the twin edge     for ( let i = 0; i < 3; i ++ ) {      const j = ( i + 1 ) % 3;      // join face[ i ] i > 0, with the first face      faces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );      // join face[ i ] with face[ i + 1 ], 1 <= i <= 3      faces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );     }    } else {     // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron     faces.push(     Face.create( v0, v2, v1 ),     Face.create( v3, v0, v1 ),     Face.create( v3, v1, v2 ),     Face.create( v3, v2, v0 )    );     // set the twin edge     for ( let i = 0; i < 3; i ++ ) {      const j = ( i + 1 ) % 3;      // join face[ i ] i > 0, with the first face      faces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );      // join face[ i ] with face[ i + 1 ]      faces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );     }    }    // the initial hull is the tetrahedron    for ( let i = 0; i < 4; i ++ ) {     this.faces.push( faces[ i ] );    }    // initial assignment of vertices to the faces of the tetrahedron    for ( let i = 0, l = vertices.length; i < l; i ++ ) {     const vertex = vertices[ i ];     if ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {      maxDistance = this.tolerance;     let maxFace = null;      for ( let j = 0; j < 4; j ++ ) {       const distance = this.faces[ j ].distanceToPoint( vertex.point );       if ( distance > maxDistance ) {        maxDistance = distance;       maxFace = this.faces[ j ];       }      }      if ( maxFace !== null ) {       this.addVertexToFace( vertex, maxFace );      }     }    }    return this;   }   // Removes inactive faces   reindexFaces() {    const activeFaces = [];    for ( let i = 0; i < this.faces.length; i ++ ) {     const face = this.faces[ i ];     if ( face.mark === Visible ) {      activeFaces.push( face );     }    }    this.faces = activeFaces;    return this;   }   // Finds the next vertex to create faces with the current hull   nextVertexToAdd() {    // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'    if ( this.assigned.isEmpty() === false ) {     let eyeVertex, maxDistance = 0;     // grap the first available face and start with the first visible vertex of that face     const eyeFace = this.assigned.first().face;    let vertex = eyeFace.outside;     // now calculate the farthest vertex that face can see     do {      const distance = eyeFace.distanceToPoint( vertex.point );      if ( distance > maxDistance ) {       maxDistance = distance;      eyeVertex = vertex;      }      vertex = vertex.next;     } while ( vertex !== null && vertex.face === eyeFace );     return eyeVertex;    }   }   // Computes a chain of half edges in CCW order called the 'horizon'.  // For an edge to be part of the horizon it must join a face that can see  // 'eyePoint' and a face that cannot see 'eyePoint'.   computeHorizon( eyePoint, crossEdge, face, horizon ) {    // moves face's vertices to the 'unassigned' vertex list    this.deleteFaceVertices( face );    face.mark = Deleted;    let edge;    if ( crossEdge === null ) {     edge = crossEdge = face.getEdge( 0 );    } else {     // start from the next edge since 'crossEdge' was already analyzed    // (actually 'crossEdge.twin' was the edge who called this method recursively)     edge = crossEdge.next;    }    do {     const twinEdge = edge.twin;    const oppositeFace = twinEdge.face;     if ( oppositeFace.mark === Visible ) {      if ( oppositeFace.distanceToPoint( eyePoint ) > this.tolerance ) {       // the opposite face can see the vertex, so proceed with next edge       this.computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );      } else {       // the opposite face can't see the vertex, so this edge is part of the horizon       horizon.push( edge );      }     }     edge = edge.next;    } while ( edge !== crossEdge );    return this;   }   // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order   addAdjoiningFace( eyeVertex, horizonEdge ) {    // all the half edges are created in ccw order thus the face is always pointing outside the hull    const face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );    this.faces.push( face );    // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )    face.getEdge( - 1 ).setTwin( horizonEdge.twin );    return face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex    }   //  Adds 'horizon.length' faces to the hull, each face will be linked with the  //  horizon opposite face and the face on the left/right   addNewFaces( eyeVertex, horizon ) {    this.newFaces = [];    let firstSideEdge = null;   let previousSideEdge = null;    for ( let i = 0; i < horizon.length; i ++ ) {     const horizonEdge = horizon[ i ];     // returns the right side edge     const sideEdge = this.addAdjoiningFace( eyeVertex, horizonEdge );     if ( firstSideEdge === null ) {      firstSideEdge = sideEdge;     } else {      // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )      sideEdge.next.setTwin( previousSideEdge );     }     this.newFaces.push( sideEdge.face );    previousSideEdge = sideEdge;    }    // perform final join of new faces    firstSideEdge.next.setTwin( previousSideEdge );    return this;   }   // Adds a vertex to the hull   addVertexToHull( eyeVertex ) {    const horizon = [];    this.unassigned.clear();    // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list    this.removeVertexFromFace( eyeVertex, eyeVertex.face );    this.computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );    this.addNewFaces( eyeVertex, horizon );    // reassign 'unassigned' vertices to the new faces    this.resolveUnassignedPoints( this.newFaces );    return this;   }   cleanup() {    this.assigned.clear();   this.unassigned.clear();   this.newFaces = [];    return this;   }   compute() {    let vertex;    this.computeInitialHull();    // add all available vertices gradually to the hull    while ( ( vertex = this.nextVertexToAdd() ) !== undefined ) {     this.addVertexToHull( vertex );    }    this.reindexFaces();    this.cleanup();    return this;   }  }  //  class Face {   constructor() {    this.normal = new Vector3();   this.midpoint = new Vector3();   this.area = 0;    this.constant = 0; // signed distance from face to the origin   this.outside = null; // reference to a vertex in a vertex list this face can see   this.mark = Visible;   this.edge = null;   }   static create( a, b, c ) {    const face = new Face();    const e0 = new HalfEdge( a, face );   const e1 = new HalfEdge( b, face );   const e2 = new HalfEdge( c, face );    // join edges    e0.next = e2.prev = e1;   e1.next = e0.prev = e2;   e2.next = e1.prev = e0;    // main half edge reference    face.edge = e0;    return face.compute();   }   getEdge( i ) {    let edge = this.edge;    while ( i > 0 ) {     edge = edge.next;    i --;    }    while ( i < 0 ) {     edge = edge.prev;    i ++;    }    return edge;   }   compute() {    const a = this.edge.tail();   const b = this.edge.head();   const c = this.edge.next.head();    _triangle.set( a.point, b.point, c.point );    _triangle.getNormal( this.normal );   _triangle.getMidpoint( this.midpoint );   this.area = _triangle.getArea();    this.constant = this.normal.dot( this.midpoint );    return this;   }   distanceToPoint( point ) {    return this.normal.dot( point ) - this.constant;   }  }  // Entity for a Doubly-Connected Edge List (DCEL).  class HalfEdge {    constructor( vertex, face ) {    this.vertex = vertex;   this.prev = null;   this.next = null;   this.twin = null;   this.face = face;   }   head() {    return this.vertex;   }   tail() {    return this.prev ? this.prev.vertex : null;   }   length() {    const head = this.head();   const tail = this.tail();    if ( tail !== null ) {     return tail.point.distanceTo( head.point );    }    return - 1;   }   lengthSquared() {    const head = this.head();   const tail = this.tail();    if ( tail !== null ) {     return tail.point.distanceToSquared( head.point );    }    return - 1;   }   setTwin( edge ) {    this.twin = edge;   edge.twin = this;    return this;   }  }  // A vertex as a double linked list node.  class VertexNode {   constructor( point ) {    this.point = point;   this.prev = null;   this.next = null;   this.face = null; // the face that is able to see this vertex   }  }  // A double linked list that contains vertex nodes.  class VertexList {   constructor() {    this.head = null;   this.tail = null;   }   first() {    return this.head;   }   last() {    return this.tail;   }   clear() {    this.head = this.tail = null;    return this;   }   // Inserts a vertex before the target vertex   insertBefore( target, vertex ) {    vertex.prev = target.prev;   vertex.next = target;    if ( vertex.prev === null ) {     this.head = vertex;    } else {     vertex.prev.next = vertex;    }    target.prev = vertex;    return this;   }   // Inserts a vertex after the target vertex   insertAfter( target, vertex ) {    vertex.prev = target;   vertex.next = target.next;    if ( vertex.next === null ) {     this.tail = vertex;    } else {     vertex.next.prev = vertex;    }    target.next = vertex;    return this;   }   // Appends a vertex to the end of the linked list   append( vertex ) {    if ( this.head === null ) {     this.head = vertex;    } else {     this.tail.next = vertex;    }    vertex.prev = this.tail;   vertex.next = null; // the tail has no subsequent vertex    this.tail = vertex;    return this;   }   // Appends a chain of vertices where 'vertex' is the head.   appendChain( vertex ) {    if ( this.head === null ) {     this.head = vertex;    } else {     this.tail.next = vertex;    }    vertex.prev = this.tail;    // ensure that the 'tail' reference points to the last vertex of the chain    while ( vertex.next !== null ) {     vertex = vertex.next;    }    this.tail = vertex;    return this;   }   // Removes a vertex from the linked list   remove( vertex ) {    if ( vertex.prev === null ) {     this.head = vertex.next;    } else {     vertex.prev.next = vertex.next;    }    if ( vertex.next === null ) {     this.tail = vertex.prev;    } else {     vertex.next.prev = vertex.prev;    }    return this;   }   // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b   removeSubList( a, b ) {    if ( a.prev === null ) {     this.head = b.next;    } else {     a.prev.next = b.next;    }    if ( b.next === null ) {     this.tail = a.prev;    } else {     b.next.prev = a.prev;    }    return this;   }   isEmpty() {    return this.head === null;   }  }  export { ConvexHull, Face, HalfEdge, VertexNode, VertexList }; 
^..^ FILENAME ^..^
addons|math|ImprovedNoise.js
^..^ CONTENTS ^..^
// https://cs.nyu.edu/~perlin/noise/  const _p = [ 151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10,   23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87,   174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211,   133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208,   89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5,   202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119,   248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232,   178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249,   14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205,   93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180 ];  for ( let i = 0; i < 256; i ++ ) {   _p[ 256 + i ] = _p[ i ];  }  function fade( t ) {   return t * t * t * ( t * ( t * 6 - 15 ) + 10 );  }  function lerp( t, a, b ) {   return a + t * ( b - a );  }  function grad( hash, x, y, z ) {   const h = hash & 15;  const u = h < 8 ? x : y, v = h < 4 ? y : h == 12 || h == 14 ? x : z;  return ( ( h & 1 ) == 0 ? u : - u ) + ( ( h & 2 ) == 0 ? v : - v );  }  class ImprovedNoise {   noise( x, y, z ) {    const floorX = Math.floor( x ), floorY = Math.floor( y ), floorZ = Math.floor( z );    const X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;    x -= floorX;   y -= floorY;   z -= floorZ;    const xMinus1 = x - 1, yMinus1 = y - 1, zMinus1 = z - 1;    const u = fade( x ), v = fade( y ), w = fade( z );    const A = _p[ X ] + Y, AA = _p[ A ] + Z, AB = _p[ A + 1 ] + Z, B = _p[ X + 1 ] + Y, BA = _p[ B ] + Z, BB = _p[ B + 1 ] + Z;    return lerp( w, lerp( v, lerp( u, grad( _p[ AA ], x, y, z ),    grad( _p[ BA ], xMinus1, y, z ) ),   lerp( u, grad( _p[ AB ], x, yMinus1, z ),    grad( _p[ BB ], xMinus1, yMinus1, z ) ) ),   lerp( v, lerp( u, grad( _p[ AA + 1 ], x, y, zMinus1 ),    grad( _p[ BA + 1 ], xMinus1, y, zMinus1 ) ),   lerp( u, grad( _p[ AB + 1 ], x, yMinus1, zMinus1 ),    grad( _p[ BB + 1 ], xMinus1, yMinus1, zMinus1 ) ) ) );   }  }  export { ImprovedNoise }; 
^..^ FILENAME ^..^
addons|math|Lut.js
^..^ CONTENTS ^..^
import {  Color,  LinearSRGBColorSpace,  MathUtils } from 'three';  class Lut {    constructor( colormap, count = 32 ) {    this.isLut = true;    this.lut = [];   this.map = [];   this.n = 0;   this.minV = 0;   this.maxV = 1;    this.setColorMap( colormap, count );   }   set( value ) {    if ( value.isLut === true ) {     this.copy( value );    }    return this;   }   setMin( min ) {    this.minV = min;    return this;   }   setMax( max ) {    this.maxV = max;    return this;   }   setColorMap( colormap, count = 32 ) {    this.map = ColorMapKeywords[ colormap ] || ColorMapKeywords.rainbow;   this.n = count;    const step = 1.0 / this.n;   const minColor = new Color();   const maxColor = new Color();    this.lut.length = 0;    // sample at 0    this.lut.push( new Color( this.map[ 0 ][ 1 ] ) );    // sample at 1/n, ..., (n-1)/n    for ( let i = 1; i < count; i ++ ) {     const alpha = i * step;     for ( let j = 0; j < this.map.length - 1; j ++ ) {      if ( alpha > this.map[ j ][ 0 ] && alpha <= this.map[ j + 1 ][ 0 ] ) {       const min = this.map[ j ][ 0 ];      const max = this.map[ j + 1 ][ 0 ];       minColor.setHex( this.map[ j ][ 1 ], LinearSRGBColorSpace );      maxColor.setHex( this.map[ j + 1 ][ 1 ], LinearSRGBColorSpace );       const color = new Color().lerpColors( minColor, maxColor, ( alpha - min ) / ( max - min ) );       this.lut.push( color );      }     }    }    // sample at 1    this.lut.push( new Color( this.map[ this.map.length - 1 ][ 1 ] ) );    return this;   }   copy( lut ) {    this.lut = lut.lut;   this.map = lut.map;   this.n = lut.n;   this.minV = lut.minV;   this.maxV = lut.maxV;    return this;   }   getColor( alpha ) {    alpha = MathUtils.clamp( alpha, this.minV, this.maxV );    alpha = ( alpha - this.minV ) / ( this.maxV - this.minV );    const colorPosition = Math.round( alpha * this.n );    return this.lut[ colorPosition ];   }   addColorMap( name, arrayOfColors ) {    ColorMapKeywords[ name ] = arrayOfColors;    return this;   }   createCanvas() {    const canvas = document.createElement( 'canvas' );   canvas.width = 1;   canvas.height = this.n;    this.updateCanvas( canvas );    return canvas;   }   updateCanvas( canvas ) {    const ctx = canvas.getContext( '2d', { alpha: false } );    const imageData = ctx.getImageData( 0, 0, 1, this.n );    const data = imageData.data;    let k = 0;    const step = 1.0 / this.n;    const minColor = new Color();   const maxColor = new Color();   const finalColor = new Color();    for ( let i = 1; i >= 0; i -= step ) {     for ( let j = this.map.length - 1; j >= 0; j -- ) {      if ( i < this.map[ j ][ 0 ] && i >= this.map[ j - 1 ][ 0 ] ) {       const min = this.map[ j - 1 ][ 0 ];      const max = this.map[ j ][ 0 ];       minColor.setHex( this.map[ j - 1 ][ 1 ], LinearSRGBColorSpace );      maxColor.setHex( this.map[ j ][ 1 ], LinearSRGBColorSpace );       finalColor.lerpColors( minColor, maxColor, ( i - min ) / ( max - min ) );       data[ k * 4 ] = Math.round( finalColor.r * 255 );      data[ k * 4 + 1 ] = Math.round( finalColor.g * 255 );      data[ k * 4 + 2 ] = Math.round( finalColor.b * 255 );      data[ k * 4 + 3 ] = 255;       k += 1;      }     }    }    ctx.putImageData( imageData, 0, 0 );    return canvas;   }  }  const ColorMapKeywords = {   'rainbow': [[ 0.0, 0x0000FF ], [ 0.2, 0x00FFFF ], [ 0.5, 0x00FF00 ], [ 0.8, 0xFFFF00 ], [ 1.0, 0xFF0000 ]],  'cooltowarm': [[ 0.0, 0x3C4EC2 ], [ 0.2, 0x9BBCFF ], [ 0.5, 0xDCDCDC ], [ 0.8, 0xF6A385 ], [ 1.0, 0xB40426 ]],  'blackbody': [[ 0.0, 0x000000 ], [ 0.2, 0x780000 ], [ 0.5, 0xE63200 ], [ 0.8, 0xFFFF00 ], [ 1.0, 0xFFFFFF ]],  'grayscale': [[ 0.0, 0x000000 ], [ 0.2, 0x404040 ], [ 0.5, 0x7F7F80 ], [ 0.8, 0xBFBFBF ], [ 1.0, 0xFFFFFF ]]  };  export { Lut, ColorMapKeywords }; 
^..^ FILENAME ^..^
addons|math|MeshSurfaceSampler.js
^..^ CONTENTS ^..^
import {  Triangle,  Vector2,  Vector3 } from 'three';  /**  * Utility class for sampling weighted random points on the surface of a mesh.  *  * Building the sampler is a one-time O(n) operation. Once built, any number of  * random samples may be selected in O(logn) time. Memory usage is O(n).  *  * References:  * - http://www.joesfer.com/?p=84  * - https://stackoverflow.com/a/4322940/1314762  */  const _face = new Triangle(); const _color = new Vector3(); const _uva = new Vector2(), _uvb = new Vector2(), _uvc = new Vector2();  class MeshSurfaceSampler {   constructor( mesh ) {    this.geometry = mesh.geometry;   this.randomFunction = Math.random;    this.indexAttribute = this.geometry.index;   this.positionAttribute = this.geometry.getAttribute( 'position' );   this.normalAttribute = this.geometry.getAttribute( 'normal' );   this.colorAttribute = this.geometry.getAttribute( 'color' );   this.uvAttribute = this.geometry.getAttribute( 'uv' );   this.weightAttribute = null;    this.distribution = null;   }   setWeightAttribute( name ) {    this.weightAttribute = name ? this.geometry.getAttribute( name ) : null;    return this;   }   build() {    const indexAttribute = this.indexAttribute;   const positionAttribute = this.positionAttribute;   const weightAttribute = this.weightAttribute;    const totalFaces = indexAttribute ? ( indexAttribute.count / 3 ) : ( positionAttribute.count / 3 );   const faceWeights = new Float32Array( totalFaces );    // Accumulate weights for each mesh face.    for ( let i = 0; i < totalFaces; i ++ ) {     let faceWeight = 1;     let i0 = 3 * i;    let i1 = 3 * i + 1;    let i2 = 3 * i + 2;     if ( indexAttribute ) {      i0 = indexAttribute.getX( i0 );     i1 = indexAttribute.getX( i1 );     i2 = indexAttribute.getX( i2 );     }     if ( weightAttribute ) {      faceWeight = weightAttribute.getX( i0 )      + weightAttribute.getX( i1 )      + weightAttribute.getX( i2 );     }     _face.a.fromBufferAttribute( positionAttribute, i0 );    _face.b.fromBufferAttribute( positionAttribute, i1 );    _face.c.fromBufferAttribute( positionAttribute, i2 );    faceWeight *= _face.getArea();     faceWeights[ i ] = faceWeight;    }    // Store cumulative total face weights in an array, where weight index   // corresponds to face index.    const distribution = new Float32Array( totalFaces );   let cumulativeTotal = 0;    for ( let i = 0; i < totalFaces; i ++ ) {     cumulativeTotal += faceWeights[ i ];    distribution[ i ] = cumulativeTotal;    }    this.distribution = distribution;   return this;   }   setRandomGenerator( randomFunction ) {    this.randomFunction = randomFunction;   return this;   }   sample( targetPosition, targetNormal, targetColor, targetUV ) {    const faceIndex = this.sampleFaceIndex();   return this.sampleFace( faceIndex, targetPosition, targetNormal, targetColor, targetUV );   }   sampleFaceIndex() {    const cumulativeTotal = this.distribution[ this.distribution.length - 1 ];   return this.binarySearch( this.randomFunction() * cumulativeTotal );   }   binarySearch( x ) {    const dist = this.distribution;   let start = 0;   let end = dist.length - 1;    let index = - 1;    while ( start <= end ) {     const mid = Math.ceil( ( start + end ) / 2 );     if ( mid === 0 || dist[ mid - 1 ] <= x && dist[ mid ] > x ) {      index = mid;      break;     } else if ( x < dist[ mid ] ) {      end = mid - 1;     } else {      start = mid + 1;     }    }    return index;   }   sampleFace( faceIndex, targetPosition, targetNormal, targetColor, targetUV ) {    let u = this.randomFunction();   let v = this.randomFunction();    if ( u + v > 1 ) {     u = 1 - u;    v = 1 - v;    }    // get the vertex attribute indices   const indexAttribute = this.indexAttribute;   let i0 = faceIndex * 3;   let i1 = faceIndex * 3 + 1;   let i2 = faceIndex * 3 + 2;   if ( indexAttribute ) {     i0 = indexAttribute.getX( i0 );    i1 = indexAttribute.getX( i1 );    i2 = indexAttribute.getX( i2 );    }    _face.a.fromBufferAttribute( this.positionAttribute, i0 );   _face.b.fromBufferAttribute( this.positionAttribute, i1 );   _face.c.fromBufferAttribute( this.positionAttribute, i2 );    targetPosition    .set( 0, 0, 0 )    .addScaledVector( _face.a, u )    .addScaledVector( _face.b, v )    .addScaledVector( _face.c, 1 - ( u + v ) );    if ( targetNormal !== undefined ) {     if ( this.normalAttribute !== undefined ) {      _face.a.fromBufferAttribute( this.normalAttribute, i0 );     _face.b.fromBufferAttribute( this.normalAttribute, i1 );     _face.c.fromBufferAttribute( this.normalAttribute, i2 );     targetNormal.set( 0, 0, 0 ).addScaledVector( _face.a, u ).addScaledVector( _face.b, v ).addScaledVector( _face.c, 1 - ( u + v ) ).normalize();     } else {      _face.getNormal( targetNormal );     }    }    if ( targetColor !== undefined && this.colorAttribute !== undefined ) {     _face.a.fromBufferAttribute( this.colorAttribute, i0 );    _face.b.fromBufferAttribute( this.colorAttribute, i1 );    _face.c.fromBufferAttribute( this.colorAttribute, i2 );     _color     .set( 0, 0, 0 )     .addScaledVector( _face.a, u )     .addScaledVector( _face.b, v )     .addScaledVector( _face.c, 1 - ( u + v ) );     targetColor.r = _color.x;    targetColor.g = _color.y;    targetColor.b = _color.z;    }    if ( targetUV !== undefined && this.uvAttribute !== undefined ) {     _uva.fromBufferAttribute( this.uvAttribute, i0 );    _uvb.fromBufferAttribute( this.uvAttribute, i1 );    _uvc.fromBufferAttribute( this.uvAttribute, i2 );    targetUV.set( 0, 0 ).addScaledVector( _uva, u ).addScaledVector( _uvb, v ).addScaledVector( _uvc, 1 - ( u + v ) );    }    return this;   }  }  export { MeshSurfaceSampler }; 
^..^ FILENAME ^..^
addons|math|OBB.js
^..^ CONTENTS ^..^
import {  Box3,  MathUtils,  Matrix4,  Matrix3,  Ray,  Vector3 } from 'three';  // module scope helper variables  const a = {  c: null, // center  u: [ new Vector3(), new Vector3(), new Vector3() ], // basis vectors  e: [] // half width };  const b = {  c: null, // center  u: [ new Vector3(), new Vector3(), new Vector3() ], // basis vectors  e: [] // half width };  const R = [[], [], []]; const AbsR = [[], [], []]; const t = [];  const xAxis = new Vector3(); const yAxis = new Vector3(); const zAxis = new Vector3(); const v1 = new Vector3(); const size = new Vector3(); const closestPoint = new Vector3(); const rotationMatrix = new Matrix3(); const aabb = new Box3(); const matrix = new Matrix4(); const inverse = new Matrix4(); const localRay = new Ray();  // OBB  class OBB {   constructor( center = new Vector3(), halfSize = new Vector3(), rotation = new Matrix3() ) {    this.center = center;   this.halfSize = halfSize;   this.rotation = rotation;   }   set( center, halfSize, rotation ) {    this.center = center;   this.halfSize = halfSize;   this.rotation = rotation;    return this;   }   copy( obb ) {    this.center.copy( obb.center );   this.halfSize.copy( obb.halfSize );   this.rotation.copy( obb.rotation );    return this;   }   clone() {    return new this.constructor().copy( this );   }   getSize( result ) {    return result.copy( this.halfSize ).multiplyScalar( 2 );   }   /**  * Reference: Closest Point on OBB to Point in Real-Time Collision Detection  * by Christer Ericson (chapter 5.1.4)  */  clampPoint( point, result ) {    const halfSize = this.halfSize;    v1.subVectors( point, this.center );   this.rotation.extractBasis( xAxis, yAxis, zAxis );    // start at the center position of the OBB    result.copy( this.center );    // project the target onto the OBB axes and walk towards that point    const x = MathUtils.clamp( v1.dot( xAxis ), - halfSize.x, halfSize.x );   result.add( xAxis.multiplyScalar( x ) );    const y = MathUtils.clamp( v1.dot( yAxis ), - halfSize.y, halfSize.y );   result.add( yAxis.multiplyScalar( y ) );    const z = MathUtils.clamp( v1.dot( zAxis ), - halfSize.z, halfSize.z );   result.add( zAxis.multiplyScalar( z ) );    return result;   }   containsPoint( point ) {    v1.subVectors( point, this.center );   this.rotation.extractBasis( xAxis, yAxis, zAxis );    // project v1 onto each axis and check if these points lie inside the OBB    return Math.abs( v1.dot( xAxis ) ) <= this.halfSize.x &&     Math.abs( v1.dot( yAxis ) ) <= this.halfSize.y &&     Math.abs( v1.dot( zAxis ) ) <= this.halfSize.z;   }   intersectsBox3( box3 ) {    return this.intersectsOBB( obb.fromBox3( box3 ) );   }   intersectsSphere( sphere ) {    // find the point on the OBB closest to the sphere center    this.clampPoint( sphere.center, closestPoint );    // if that point is inside the sphere, the OBB and sphere intersect    return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );   }   /**  * Reference: OBB-OBB Intersection in Real-Time Collision Detection  * by Christer Ericson (chapter 4.4.1)  *  */  intersectsOBB( obb, epsilon = Number.EPSILON ) {    // prepare data structures (the code uses the same nomenclature like the reference)    a.c = this.center;   a.e[ 0 ] = this.halfSize.x;   a.e[ 1 ] = this.halfSize.y;   a.e[ 2 ] = this.halfSize.z;   this.rotation.extractBasis( a.u[ 0 ], a.u[ 1 ], a.u[ 2 ] );    b.c = obb.center;   b.e[ 0 ] = obb.halfSize.x;   b.e[ 1 ] = obb.halfSize.y;   b.e[ 2 ] = obb.halfSize.z;   obb.rotation.extractBasis( b.u[ 0 ], b.u[ 1 ], b.u[ 2 ] );    // compute rotation matrix expressing b in a's coordinate frame    for ( let i = 0; i < 3; i ++ ) {     for ( let j = 0; j < 3; j ++ ) {      R[ i ][ j ] = a.u[ i ].dot( b.u[ j ] );     }    }    // compute translation vector    v1.subVectors( b.c, a.c );    // bring translation into a's coordinate frame    t[ 0 ] = v1.dot( a.u[ 0 ] );   t[ 1 ] = v1.dot( a.u[ 1 ] );   t[ 2 ] = v1.dot( a.u[ 2 ] );    // compute common subexpressions. Add in an epsilon term to   // counteract arithmetic errors when two edges are parallel and   // their cross product is (near) null    for ( let i = 0; i < 3; i ++ ) {     for ( let j = 0; j < 3; j ++ ) {      AbsR[ i ][ j ] = Math.abs( R[ i ][ j ] ) + epsilon;     }    }    let ra, rb;    // test axes L = A0, L = A1, L = A2    for ( let i = 0; i < 3; i ++ ) {     ra = a.e[ i ];    rb = b.e[ 0 ] * AbsR[ i ][ 0 ] + b.e[ 1 ] * AbsR[ i ][ 1 ] + b.e[ 2 ] * AbsR[ i ][ 2 ];    if ( Math.abs( t[ i ] ) > ra + rb ) return false;     }    // test axes L = B0, L = B1, L = B2    for ( let i = 0; i < 3; i ++ ) {     ra = a.e[ 0 ] * AbsR[ 0 ][ i ] + a.e[ 1 ] * AbsR[ 1 ][ i ] + a.e[ 2 ] * AbsR[ 2 ][ i ];    rb = b.e[ i ];    if ( Math.abs( t[ 0 ] * R[ 0 ][ i ] + t[ 1 ] * R[ 1 ][ i ] + t[ 2 ] * R[ 2 ][ i ] ) > ra + rb ) return false;    }    // test axis L = A0 x B0    ra = a.e[ 1 ] * AbsR[ 2 ][ 0 ] + a.e[ 2 ] * AbsR[ 1 ][ 0 ];   rb = b.e[ 1 ] * AbsR[ 0 ][ 2 ] + b.e[ 2 ] * AbsR[ 0 ][ 1 ];   if ( Math.abs( t[ 2 ] * R[ 1 ][ 0 ] - t[ 1 ] * R[ 2 ][ 0 ] ) > ra + rb ) return false;    // test axis L = A0 x B1    ra = a.e[ 1 ] * AbsR[ 2 ][ 1 ] + a.e[ 2 ] * AbsR[ 1 ][ 1 ];   rb = b.e[ 0 ] * AbsR[ 0 ][ 2 ] + b.e[ 2 ] * AbsR[ 0 ][ 0 ];   if ( Math.abs( t[ 2 ] * R[ 1 ][ 1 ] - t[ 1 ] * R[ 2 ][ 1 ] ) > ra + rb ) return false;    // test axis L = A0 x B2    ra = a.e[ 1 ] * AbsR[ 2 ][ 2 ] + a.e[ 2 ] * AbsR[ 1 ][ 2 ];   rb = b.e[ 0 ] * AbsR[ 0 ][ 1 ] + b.e[ 1 ] * AbsR[ 0 ][ 0 ];   if ( Math.abs( t[ 2 ] * R[ 1 ][ 2 ] - t[ 1 ] * R[ 2 ][ 2 ] ) > ra + rb ) return false;    // test axis L = A1 x B0    ra = a.e[ 0 ] * AbsR[ 2 ][ 0 ] + a.e[ 2 ] * AbsR[ 0 ][ 0 ];   rb = b.e[ 1 ] * AbsR[ 1 ][ 2 ] + b.e[ 2 ] * AbsR[ 1 ][ 1 ];   if ( Math.abs( t[ 0 ] * R[ 2 ][ 0 ] - t[ 2 ] * R[ 0 ][ 0 ] ) > ra + rb ) return false;    // test axis L = A1 x B1    ra = a.e[ 0 ] * AbsR[ 2 ][ 1 ] + a.e[ 2 ] * AbsR[ 0 ][ 1 ];   rb = b.e[ 0 ] * AbsR[ 1 ][ 2 ] + b.e[ 2 ] * AbsR[ 1 ][ 0 ];   if ( Math.abs( t[ 0 ] * R[ 2 ][ 1 ] - t[ 2 ] * R[ 0 ][ 1 ] ) > ra + rb ) return false;    // test axis L = A1 x B2    ra = a.e[ 0 ] * AbsR[ 2 ][ 2 ] + a.e[ 2 ] * AbsR[ 0 ][ 2 ];   rb = b.e[ 0 ] * AbsR[ 1 ][ 1 ] + b.e[ 1 ] * AbsR[ 1 ][ 0 ];   if ( Math.abs( t[ 0 ] * R[ 2 ][ 2 ] - t[ 2 ] * R[ 0 ][ 2 ] ) > ra + rb ) return false;    // test axis L = A2 x B0    ra = a.e[ 0 ] * AbsR[ 1 ][ 0 ] + a.e[ 1 ] * AbsR[ 0 ][ 0 ];   rb = b.e[ 1 ] * AbsR[ 2 ][ 2 ] + b.e[ 2 ] * AbsR[ 2 ][ 1 ];   if ( Math.abs( t[ 1 ] * R[ 0 ][ 0 ] - t[ 0 ] * R[ 1 ][ 0 ] ) > ra + rb ) return false;    // test axis L = A2 x B1    ra = a.e[ 0 ] * AbsR[ 1 ][ 1 ] + a.e[ 1 ] * AbsR[ 0 ][ 1 ];   rb = b.e[ 0 ] * AbsR[ 2 ][ 2 ] + b.e[ 2 ] * AbsR[ 2 ][ 0 ];   if ( Math.abs( t[ 1 ] * R[ 0 ][ 1 ] - t[ 0 ] * R[ 1 ][ 1 ] ) > ra + rb ) return false;    // test axis L = A2 x B2    ra = a.e[ 0 ] * AbsR[ 1 ][ 2 ] + a.e[ 1 ] * AbsR[ 0 ][ 2 ];   rb = b.e[ 0 ] * AbsR[ 2 ][ 1 ] + b.e[ 1 ] * AbsR[ 2 ][ 0 ];   if ( Math.abs( t[ 1 ] * R[ 0 ][ 2 ] - t[ 0 ] * R[ 1 ][ 2 ] ) > ra + rb ) return false;    // since no separating axis is found, the OBBs must be intersecting    return true;   }   /**  * Reference: Testing Box Against Plane in Real-Time Collision Detection  * by Christer Ericson (chapter 5.2.3)  */  intersectsPlane( plane ) {    this.rotation.extractBasis( xAxis, yAxis, zAxis );    // compute the projection interval radius of this OBB onto L(t) = this->center + t * p.normal;    const r = this.halfSize.x * Math.abs( plane.normal.dot( xAxis ) ) +     this.halfSize.y * Math.abs( plane.normal.dot( yAxis ) ) +     this.halfSize.z * Math.abs( plane.normal.dot( zAxis ) );    // compute distance of the OBB's center from the plane    const d = plane.normal.dot( this.center ) - plane.constant;    // Intersection occurs when distance d falls within [-r,+r] interval    return Math.abs( d ) <= r;   }   /**  * Performs a ray/OBB intersection test and stores the intersection point  * to the given 3D vector. If no intersection is detected, *null* is returned.  */  intersectRay( ray, result ) {    // the idea is to perform the intersection test in the local space   // of the OBB.    this.getSize( size );   aabb.setFromCenterAndSize( v1.set( 0, 0, 0 ), size );    // create a 4x4 transformation matrix    matrix.setFromMatrix3( this.rotation );   matrix.setPosition( this.center );    // transform ray to the local space of the OBB    inverse.copy( matrix ).invert();   localRay.copy( ray ).applyMatrix4( inverse );    // perform ray <-> AABB intersection test    if ( localRay.intersectBox( aabb, result ) ) {     // transform the intersection point back to world space     return result.applyMatrix4( matrix );    } else {     return null;    }   }   /**  * Performs a ray/OBB intersection test. Returns either true or false if  * there is a intersection or not.  */  intersectsRay( ray ) {    return this.intersectRay( ray, v1 ) !== null;   }   fromBox3( box3 ) {    box3.getCenter( this.center );    box3.getSize( this.halfSize ).multiplyScalar( 0.5 );    this.rotation.identity();    return this;   }   equals( obb ) {    return obb.center.equals( this.center ) &&    obb.halfSize.equals( this.halfSize ) &&    obb.rotation.equals( this.rotation );   }   applyMatrix4( matrix ) {    const e = matrix.elements;    let sx = v1.set( e[ 0 ], e[ 1 ], e[ 2 ] ).length();   const sy = v1.set( e[ 4 ], e[ 5 ], e[ 6 ] ).length();   const sz = v1.set( e[ 8 ], e[ 9 ], e[ 10 ] ).length();    const det = matrix.determinant();   if ( det < 0 ) sx = - sx;    rotationMatrix.setFromMatrix4( matrix );    const invSX = 1 / sx;   const invSY = 1 / sy;   const invSZ = 1 / sz;    rotationMatrix.elements[ 0 ] *= invSX;   rotationMatrix.elements[ 1 ] *= invSX;   rotationMatrix.elements[ 2 ] *= invSX;    rotationMatrix.elements[ 3 ] *= invSY;   rotationMatrix.elements[ 4 ] *= invSY;   rotationMatrix.elements[ 5 ] *= invSY;    rotationMatrix.elements[ 6 ] *= invSZ;   rotationMatrix.elements[ 7 ] *= invSZ;   rotationMatrix.elements[ 8 ] *= invSZ;    this.rotation.multiply( rotationMatrix );    this.halfSize.x *= sx;   this.halfSize.y *= sy;   this.halfSize.z *= sz;    v1.setFromMatrixPosition( matrix );   this.center.add( v1 );    return this;   }  }  const obb = new OBB();  export { OBB }; 
^..^ FILENAME ^..^
addons|math|Octree.js
^..^ CONTENTS ^..^
import {  Box3,  Line3,  Plane,  Sphere,  Triangle,  Vector3,  Layers } from 'three'; import { Capsule } from '../math/Capsule.js';   const _v1 = new Vector3(); const _v2 = new Vector3(); const _point1 = new Vector3(); const _point2 = new Vector3(); const _plane = new Plane(); const _line1 = new Line3(); const _line2 = new Line3(); const _sphere = new Sphere(); const _capsule = new Capsule();  const _temp1 = new Vector3(); const _temp2 = new Vector3(); const _temp3 = new Vector3(); const EPS = 1e-10;  function lineToLineClosestPoints( line1, line2, target1 = null, target2 = null ) {   const r = _temp1.copy( line1.end ).sub( line1.start );  const s = _temp2.copy( line2.end ).sub( line2.start );  const w = _temp3.copy( line2.start ).sub( line1.start );   const a = r.dot( s ),   b = r.dot( r ),   c = s.dot( s ),   d = s.dot( w ),   e = r.dot( w );   let t1, t2;  const divisor = b * c - a * a;   if ( Math.abs( divisor ) < EPS ) {    const d1 = - d / c;   const d2 = ( a - d ) / c;    if ( Math.abs( d1 - 0.5 ) < Math.abs( d2 - 0.5 ) ) {     t1 = 0;    t2 = d1;    } else {     t1 = 1;    t2 = d2;    }   } else {    t1 = ( d * a + e * c ) / divisor;   t2 = ( t1 * a - d ) / c;   }   t2 = Math.max( 0, Math.min( 1, t2 ) );  t1 = Math.max( 0, Math.min( 1, t1 ) );   if ( target1 ) {    target1.copy( r ).multiplyScalar( t1 ).add( line1.start );   }   if ( target2 ) {    target2.copy( s ).multiplyScalar( t2 ).add( line2.start );   }  }  class Octree {   constructor( box ) {    this.box = box;   this.bounds = new Box3();    this.subTrees = [];   this.triangles = [];   this.layers = new Layers();   }   addTriangle( triangle ) {    this.bounds.min.x = Math.min( this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x );   this.bounds.min.y = Math.min( this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y );   this.bounds.min.z = Math.min( this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z );   this.bounds.max.x = Math.max( this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x );   this.bounds.max.y = Math.max( this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y );   this.bounds.max.z = Math.max( this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z );    this.triangles.push( triangle );    return this;   }   calcBox() {    this.box = this.bounds.clone();    // offset small amount to account for regular grid   this.box.min.x -= 0.01;   this.box.min.y -= 0.01;   this.box.min.z -= 0.01;    return this;   }   split( level ) {    if ( ! this.box ) return;    const subTrees = [];   const halfsize = _v2.copy( this.box.max ).sub( this.box.min ).multiplyScalar( 0.5 );    for ( let x = 0; x < 2; x ++ ) {     for ( let y = 0; y < 2; y ++ ) {      for ( let z = 0; z < 2; z ++ ) {       const box = new Box3();      const v = _v1.set( x, y, z );       box.min.copy( this.box.min ).add( v.multiply( halfsize ) );      box.max.copy( box.min ).add( halfsize );       subTrees.push( new Octree( box ) );      }     }    }    let triangle;    while ( triangle = this.triangles.pop() ) {     for ( let i = 0; i < subTrees.length; i ++ ) {      if ( subTrees[ i ].box.intersectsTriangle( triangle ) ) {       subTrees[ i ].triangles.push( triangle );      }     }    }    for ( let i = 0; i < subTrees.length; i ++ ) {     const len = subTrees[ i ].triangles.length;     if ( len > 8 && level < 16 ) {      subTrees[ i ].split( level + 1 );     }     if ( len !== 0 ) {      this.subTrees.push( subTrees[ i ] );     }    }    return this;   }   build() {    this.calcBox();   this.split( 0 );    return this;   }   getRayTriangles( ray, triangles ) {    for ( let i = 0; i < this.subTrees.length; i ++ ) {     const subTree = this.subTrees[ i ];    if ( ! ray.intersectsBox( subTree.box ) ) continue;     if ( subTree.triangles.length > 0 ) {      for ( let j = 0; j < subTree.triangles.length; j ++ ) {       if ( triangles.indexOf( subTree.triangles[ j ] ) === - 1 ) triangles.push( subTree.triangles[ j ] );      }     } else {      subTree.getRayTriangles( ray, triangles );     }    }    return triangles;   }   triangleCapsuleIntersect( capsule, triangle ) {    triangle.getPlane( _plane );    const d1 = _plane.distanceToPoint( capsule.start ) - capsule.radius;   const d2 = _plane.distanceToPoint( capsule.end ) - capsule.radius;    if ( ( d1 > 0 && d2 > 0 ) || ( d1 < - capsule.radius && d2 < - capsule.radius ) ) {     return false;    }    const delta = Math.abs( d1 / ( Math.abs( d1 ) + Math.abs( d2 ) ) );   const intersectPoint = _v1.copy( capsule.start ).lerp( capsule.end, delta );    if ( triangle.containsPoint( intersectPoint ) ) {     return { normal: _plane.normal.clone(), point: intersectPoint.clone(), depth: Math.abs( Math.min( d1, d2 ) ) };    }    const r2 = capsule.radius * capsule.radius;    const line1 = _line1.set( capsule.start, capsule.end );    const lines = [    [ triangle.a, triangle.b ],    [ triangle.b, triangle.c ],    [ triangle.c, triangle.a ]   ];    for ( let i = 0; i < lines.length; i ++ ) {     const line2 = _line2.set( lines[ i ][ 0 ], lines[ i ][ 1 ] );     lineToLineClosestPoints( line1, line2, _point1, _point2 );     if ( _point1.distanceToSquared( _point2 ) < r2 ) {      return {      normal: _point1.clone().sub( _point2 ).normalize(),      point: _point2.clone(),      depth: capsule.radius - _point1.distanceTo( _point2 )     };     }    }    return false;   }   triangleSphereIntersect( sphere, triangle ) {    triangle.getPlane( _plane );    if ( ! sphere.intersectsPlane( _plane ) ) return false;    const depth = Math.abs( _plane.distanceToSphere( sphere ) );   const r2 = sphere.radius * sphere.radius - depth * depth;    const plainPoint = _plane.projectPoint( sphere.center, _v1 );    if ( triangle.containsPoint( sphere.center ) ) {     return { normal: _plane.normal.clone(), point: plainPoint.clone(), depth: Math.abs( _plane.distanceToSphere( sphere ) ) };    }    const lines = [    [ triangle.a, triangle.b ],    [ triangle.b, triangle.c ],    [ triangle.c, triangle.a ]   ];    for ( let i = 0; i < lines.length; i ++ ) {     _line1.set( lines[ i ][ 0 ], lines[ i ][ 1 ] );    _line1.closestPointToPoint( plainPoint, true, _v2 );     const d = _v2.distanceToSquared( sphere.center );     if ( d < r2 ) {      return { normal: sphere.center.clone().sub( _v2 ).normalize(), point: _v2.clone(), depth: sphere.radius - Math.sqrt( d ) };     }    }    return false;   }   getSphereTriangles( sphere, triangles ) {    for ( let i = 0; i < this.subTrees.length; i ++ ) {     const subTree = this.subTrees[ i ];     if ( ! sphere.intersectsBox( subTree.box ) ) continue;     if ( subTree.triangles.length > 0 ) {      for ( let j = 0; j < subTree.triangles.length; j ++ ) {       if ( triangles.indexOf( subTree.triangles[ j ] ) === - 1 ) triangles.push( subTree.triangles[ j ] );      }     } else {      subTree.getSphereTriangles( sphere, triangles );     }    }   }   getCapsuleTriangles( capsule, triangles ) {    for ( let i = 0; i < this.subTrees.length; i ++ ) {     const subTree = this.subTrees[ i ];     if ( ! capsule.intersectsBox( subTree.box ) ) continue;     if ( subTree.triangles.length > 0 ) {      for ( let j = 0; j < subTree.triangles.length; j ++ ) {       if ( triangles.indexOf( subTree.triangles[ j ] ) === - 1 ) triangles.push( subTree.triangles[ j ] );      }     } else {      subTree.getCapsuleTriangles( capsule, triangles );     }    }   }   sphereIntersect( sphere ) {    _sphere.copy( sphere );    const triangles = [];   let result, hit = false;    this.getSphereTriangles( sphere, triangles );    for ( let i = 0; i < triangles.length; i ++ ) {     if ( result = this.triangleSphereIntersect( _sphere, triangles[ i ] ) ) {      hit = true;      _sphere.center.add( result.normal.multiplyScalar( result.depth ) );     }    }    if ( hit ) {     const collisionVector = _sphere.center.clone().sub( sphere.center );    const depth = collisionVector.length();     return { normal: collisionVector.normalize(), depth: depth };    }    return false;   }   capsuleIntersect( capsule ) {    _capsule.copy( capsule );    const triangles = [];   let result, hit = false;    this.getCapsuleTriangles( _capsule, triangles );    for ( let i = 0; i < triangles.length; i ++ ) {     if ( result = this.triangleCapsuleIntersect( _capsule, triangles[ i ] ) ) {      hit = true;      _capsule.translate( result.normal.multiplyScalar( result.depth ) );     }    }    if ( hit ) {     const collisionVector = _capsule.getCenter( new Vector3() ).sub( capsule.getCenter( _v1 ) );    const depth = collisionVector.length();     return { normal: collisionVector.normalize(), depth: depth };    }    return false;   }   rayIntersect( ray ) {    if ( ray.direction.length() === 0 ) return;    const triangles = [];   let triangle, position, distance = 1e100;    this.getRayTriangles( ray, triangles );    for ( let i = 0; i < triangles.length; i ++ ) {     const result = ray.intersectTriangle( triangles[ i ].a, triangles[ i ].b, triangles[ i ].c, true, _v1 );     if ( result ) {      const newdistance = result.sub( ray.origin ).length();      if ( distance > newdistance ) {       position = result.clone().add( ray.origin );      distance = newdistance;      triangle = triangles[ i ];      }     }    }    return distance < 1e100 ? { distance: distance, triangle: triangle, position: position } : false;   }   fromGraphNode( group ) {    group.updateWorldMatrix( true, true );    group.traverse( ( obj ) => {     if ( obj.isMesh === true ) {      if ( this.layers.test( obj.layers ) ) {       let geometry, isTemp = false;       if ( obj.geometry.index !== null ) {        isTemp = true;       geometry = obj.geometry.toNonIndexed();       } else {        geometry = obj.geometry;       }       const positionAttribute = geometry.getAttribute( 'position' );       for ( let i = 0; i < positionAttribute.count; i += 3 ) {        const v1 = new Vector3().fromBufferAttribute( positionAttribute, i );       const v2 = new Vector3().fromBufferAttribute( positionAttribute, i + 1 );       const v3 = new Vector3().fromBufferAttribute( positionAttribute, i + 2 );        v1.applyMatrix4( obj.matrixWorld );       v2.applyMatrix4( obj.matrixWorld );       v3.applyMatrix4( obj.matrixWorld );        this.addTriangle( new Triangle( v1, v2, v3 ) );       }       if ( isTemp ) {        geometry.dispose();       }      }     }    } );    this.build();    return this;   }   clear() {    this.box = null;   this.bounds.makeEmpty();    this.subTrees.length = 0;   this.triangles.length = 0;    return this;   }  }  export { Octree }; 
^..^ FILENAME ^..^
addons|math|SimplexNoise.js
^..^ CONTENTS ^..^
// Ported from Stefan Gustavson's java implementation // http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf // Read Stefan's excellent paper for details on how this code works. // // Sean McCullough banksean@gmail.com // // Added 4D noise  /**  * You can pass in a random number generator object if you like.  * It is assumed to have a random() method.  */ class SimplexNoise {   constructor( r = Math ) {    this.grad3 = [[ 1, 1, 0 ], [ - 1, 1, 0 ], [ 1, - 1, 0 ], [ - 1, - 1, 0 ],    [ 1, 0, 1 ], [ - 1, 0, 1 ], [ 1, 0, - 1 ], [ - 1, 0, - 1 ],    [ 0, 1, 1 ], [ 0, - 1, 1 ], [ 0, 1, - 1 ], [ 0, - 1, - 1 ]];    this.grad4 = [[ 0, 1, 1, 1 ], [ 0, 1, 1, - 1 ], [ 0, 1, - 1, 1 ], [ 0, 1, - 1, - 1 ],    [ 0, - 1, 1, 1 ], [ 0, - 1, 1, - 1 ], [ 0, - 1, - 1, 1 ], [ 0, - 1, - 1, - 1 ],    [ 1, 0, 1, 1 ], [ 1, 0, 1, - 1 ], [ 1, 0, - 1, 1 ], [ 1, 0, - 1, - 1 ],    [ - 1, 0, 1, 1 ], [ - 1, 0, 1, - 1 ], [ - 1, 0, - 1, 1 ], [ - 1, 0, - 1, - 1 ],    [ 1, 1, 0, 1 ], [ 1, 1, 0, - 1 ], [ 1, - 1, 0, 1 ], [ 1, - 1, 0, - 1 ],    [ - 1, 1, 0, 1 ], [ - 1, 1, 0, - 1 ], [ - 1, - 1, 0, 1 ], [ - 1, - 1, 0, - 1 ],    [ 1, 1, 1, 0 ], [ 1, 1, - 1, 0 ], [ 1, - 1, 1, 0 ], [ 1, - 1, - 1, 0 ],    [ - 1, 1, 1, 0 ], [ - 1, 1, - 1, 0 ], [ - 1, - 1, 1, 0 ], [ - 1, - 1, - 1, 0 ]];    this.p = [];    for ( let i = 0; i < 256; i ++ ) {     this.p[ i ] = Math.floor( r.random() * 256 );    }    // To remove the need for index wrapping, double the permutation table length   this.perm = [];    for ( let i = 0; i < 512; i ++ ) {     this.perm[ i ] = this.p[ i & 255 ];    }    // A lookup table to traverse the simplex around a given point in 4D.   // Details can be found where this table is used, in the 4D noise method.   this.simplex = [    [ 0, 1, 2, 3 ], [ 0, 1, 3, 2 ], [ 0, 0, 0, 0 ], [ 0, 2, 3, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 2, 3, 0 ],    [ 0, 2, 1, 3 ], [ 0, 0, 0, 0 ], [ 0, 3, 1, 2 ], [ 0, 3, 2, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 3, 2, 0 ],    [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],    [ 1, 2, 0, 3 ], [ 0, 0, 0, 0 ], [ 1, 3, 0, 2 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 2, 3, 0, 1 ], [ 2, 3, 1, 0 ],    [ 1, 0, 2, 3 ], [ 1, 0, 3, 2 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 2, 0, 3, 1 ], [ 0, 0, 0, 0 ], [ 2, 1, 3, 0 ],    [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],    [ 2, 0, 1, 3 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 3, 0, 1, 2 ], [ 3, 0, 2, 1 ], [ 0, 0, 0, 0 ], [ 3, 1, 2, 0 ],    [ 2, 1, 0, 3 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 3, 1, 0, 2 ], [ 0, 0, 0, 0 ], [ 3, 2, 0, 1 ], [ 3, 2, 1, 0 ]];   }   dot( g, x, y ) {    return g[ 0 ] * x + g[ 1 ] * y;   }   dot3( g, x, y, z ) {    return g[ 0 ] * x + g[ 1 ] * y + g[ 2 ] * z;   }   dot4( g, x, y, z, w ) {    return g[ 0 ] * x + g[ 1 ] * y + g[ 2 ] * z + g[ 3 ] * w;   }   noise( xin, yin ) {    let n0; // Noise contributions from the three corners   let n1;   let n2;   // Skew the input space to determine which simplex cell we're in   const F2 = 0.5 * ( Math.sqrt( 3.0 ) - 1.0 );   const s = ( xin + yin ) * F2; // Hairy factor for 2D   const i = Math.floor( xin + s );   const j = Math.floor( yin + s );   const G2 = ( 3.0 - Math.sqrt( 3.0 ) ) / 6.0;   const t = ( i + j ) * G2;   const X0 = i - t; // Unskew the cell origin back to (x,y) space   const Y0 = j - t;   const x0 = xin - X0; // The x,y distances from the cell origin   const y0 = yin - Y0;    // For the 2D case, the simplex shape is an equilateral triangle.   // Determine which simplex we are in.   let i1; // Offsets for second (middle) corner of simplex in (i,j) coords    let j1;   if ( x0 > y0 ) {     i1 = 1; j1 = 0;     // lower triangle, XY order: (0,0)->(1,0)->(1,1)    } else {     i1 = 0; j1 = 1;    } // upper triangle, YX order: (0,0)->(0,1)->(1,1)    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and   // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where   // c = (3-sqrt(3))/6   const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords   const y1 = y0 - j1 + G2;   const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords   const y2 = y0 - 1.0 + 2.0 * G2;   // Work out the hashed gradient indices of the three simplex corners   const ii = i & 255;   const jj = j & 255;   const gi0 = this.perm[ ii + this.perm[ jj ] ] % 12;   const gi1 = this.perm[ ii + i1 + this.perm[ jj + j1 ] ] % 12;   const gi2 = this.perm[ ii + 1 + this.perm[ jj + 1 ] ] % 12;   // Calculate the contribution from the three corners   let t0 = 0.5 - x0 * x0 - y0 * y0;   if ( t0 < 0 ) n0 = 0.0;   else {     t0 *= t0;    n0 = t0 * t0 * this.dot( this.grad3[ gi0 ], x0, y0 ); // (x,y) of grad3 used for 2D gradient    }    let t1 = 0.5 - x1 * x1 - y1 * y1;   if ( t1 < 0 ) n1 = 0.0;   else {     t1 *= t1;    n1 = t1 * t1 * this.dot( this.grad3[ gi1 ], x1, y1 );    }    let t2 = 0.5 - x2 * x2 - y2 * y2;   if ( t2 < 0 ) n2 = 0.0;   else {     t2 *= t2;    n2 = t2 * t2 * this.dot( this.grad3[ gi2 ], x2, y2 );    }    // Add contributions from each corner to get the final noise value.   // The result is scaled to return values in the interval [-1,1].   return 70.0 * ( n0 + n1 + n2 );   }   // 3D simplex noise  noise3d( xin, yin, zin ) {    let n0; // Noise contributions from the four corners   let n1;   let n2;   let n3;   // Skew the input space to determine which simplex cell we're in   const F3 = 1.0 / 3.0;   const s = ( xin + yin + zin ) * F3; // Very nice and simple skew factor for 3D   const i = Math.floor( xin + s );   const j = Math.floor( yin + s );   const k = Math.floor( zin + s );   const G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too   const t = ( i + j + k ) * G3;   const X0 = i - t; // Unskew the cell origin back to (x,y,z) space   const Y0 = j - t;   const Z0 = k - t;   const x0 = xin - X0; // The x,y,z distances from the cell origin   const y0 = yin - Y0;   const z0 = zin - Z0;    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.   // Determine which simplex we are in.   let i1; // Offsets for second corner of simplex in (i,j,k) coords    let j1;   let k1;   let i2; // Offsets for third corner of simplex in (i,j,k) coords   let j2;   let k2;   if ( x0 >= y0 ) {     if ( y0 >= z0 ) {      i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0;      // X Y Z order     } else if ( x0 >= z0 ) {      i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1;      // X Z Y order     } else {      i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1;     } // Z X Y order    } else { // x0<y0     if ( y0 < z0 ) {      i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1;      // Z Y X order     } else if ( x0 < z0 ) {      i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1;      // Y Z X order     } else {      i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0;     } // Y X Z order    }    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),   // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and   // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where   // c = 1/6.   const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords   const y1 = y0 - j1 + G3;   const z1 = z0 - k1 + G3;   const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords   const y2 = y0 - j2 + 2.0 * G3;   const z2 = z0 - k2 + 2.0 * G3;   const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords   const y3 = y0 - 1.0 + 3.0 * G3;   const z3 = z0 - 1.0 + 3.0 * G3;   // Work out the hashed gradient indices of the four simplex corners   const ii = i & 255;   const jj = j & 255;   const kk = k & 255;   const gi0 = this.perm[ ii + this.perm[ jj + this.perm[ kk ] ] ] % 12;   const gi1 = this.perm[ ii + i1 + this.perm[ jj + j1 + this.perm[ kk + k1 ] ] ] % 12;   const gi2 = this.perm[ ii + i2 + this.perm[ jj + j2 + this.perm[ kk + k2 ] ] ] % 12;   const gi3 = this.perm[ ii + 1 + this.perm[ jj + 1 + this.perm[ kk + 1 ] ] ] % 12;   // Calculate the contribution from the four corners   let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;   if ( t0 < 0 ) n0 = 0.0;   else {     t0 *= t0;    n0 = t0 * t0 * this.dot3( this.grad3[ gi0 ], x0, y0, z0 );    }    let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;   if ( t1 < 0 ) n1 = 0.0;   else {     t1 *= t1;    n1 = t1 * t1 * this.dot3( this.grad3[ gi1 ], x1, y1, z1 );    }    let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;   if ( t2 < 0 ) n2 = 0.0;   else {     t2 *= t2;    n2 = t2 * t2 * this.dot3( this.grad3[ gi2 ], x2, y2, z2 );    }    let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;   if ( t3 < 0 ) n3 = 0.0;   else {     t3 *= t3;    n3 = t3 * t3 * this.dot3( this.grad3[ gi3 ], x3, y3, z3 );    }    // Add contributions from each corner to get the final noise value.   // The result is scaled to stay just inside [-1,1]   return 32.0 * ( n0 + n1 + n2 + n3 );   }   // 4D simplex noise  noise4d( x, y, z, w ) {    // For faster and easier lookups   const grad4 = this.grad4;   const simplex = this.simplex;   const perm = this.perm;    // The skewing and unskewing factors are hairy again for the 4D case   const F4 = ( Math.sqrt( 5.0 ) - 1.0 ) / 4.0;   const G4 = ( 5.0 - Math.sqrt( 5.0 ) ) / 20.0;   let n0; // Noise contributions from the five corners   let n1;   let n2;   let n3;   let n4;   // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in   const s = ( x + y + z + w ) * F4; // Factor for 4D skewing   const i = Math.floor( x + s );   const j = Math.floor( y + s );   const k = Math.floor( z + s );   const l = Math.floor( w + s );   const t = ( i + j + k + l ) * G4; // Factor for 4D unskewing   const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space   const Y0 = j - t;   const Z0 = k - t;   const W0 = l - t;   const x0 = x - X0; // The x,y,z,w distances from the cell origin   const y0 = y - Y0;   const z0 = z - Z0;   const w0 = w - W0;    // For the 4D case, the simplex is a 4D shape I won't even try to describe.   // To find out which of the 24 possible simplices we're in, we need to   // determine the magnitude ordering of x0, y0, z0 and w0.   // The method below is a good way of finding the ordering of x,y,z,w and   // then find the correct traversal order for the simplex we?Tre in.   // First, six pair-wise comparisons are performed between each possible pair   // of the four coordinates, and the results are used to add up binary bits   // for an integer index.   const c1 = ( x0 > y0 ) ? 32 : 0;   const c2 = ( x0 > z0 ) ? 16 : 0;   const c3 = ( y0 > z0 ) ? 8 : 0;   const c4 = ( x0 > w0 ) ? 4 : 0;   const c5 = ( y0 > w0 ) ? 2 : 0;   const c6 = ( z0 > w0 ) ? 1 : 0;   const c = c1 + c2 + c3 + c4 + c5 + c6;    // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.   // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w   // impossible. Only the 24 indices which have non-zero entries make any sense.   // We use a thresholding to set the coordinates in turn from the largest magnitude.   // The number 3 in the "simplex" array is at the position of the largest coordinate.   const i1 = simplex[ c ][ 0 ] >= 3 ? 1 : 0;   const j1 = simplex[ c ][ 1 ] >= 3 ? 1 : 0;   const k1 = simplex[ c ][ 2 ] >= 3 ? 1 : 0;   const l1 = simplex[ c ][ 3 ] >= 3 ? 1 : 0;   // The number 2 in the "simplex" array is at the second largest coordinate.   const i2 = simplex[ c ][ 0 ] >= 2 ? 1 : 0;   const j2 = simplex[ c ][ 1 ] >= 2 ? 1 : 0;   const k2 = simplex[ c ][ 2 ] >= 2 ? 1 : 0;   const l2 = simplex[ c ][ 3 ] >= 2 ? 1 : 0;   // The number 1 in the "simplex" array is at the second smallest coordinate.   const i3 = simplex[ c ][ 0 ] >= 1 ? 1 : 0;   const j3 = simplex[ c ][ 1 ] >= 1 ? 1 : 0;   const k3 = simplex[ c ][ 2 ] >= 1 ? 1 : 0;   const l3 = simplex[ c ][ 3 ] >= 1 ? 1 : 0;   // The fifth corner has all coordinate offsets = 1, so no need to look that up.   const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords   const y1 = y0 - j1 + G4;   const z1 = z0 - k1 + G4;   const w1 = w0 - l1 + G4;   const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords   const y2 = y0 - j2 + 2.0 * G4;   const z2 = z0 - k2 + 2.0 * G4;   const w2 = w0 - l2 + 2.0 * G4;   const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords   const y3 = y0 - j3 + 3.0 * G4;   const z3 = z0 - k3 + 3.0 * G4;   const w3 = w0 - l3 + 3.0 * G4;   const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords   const y4 = y0 - 1.0 + 4.0 * G4;   const z4 = z0 - 1.0 + 4.0 * G4;   const w4 = w0 - 1.0 + 4.0 * G4;   // Work out the hashed gradient indices of the five simplex corners   const ii = i & 255;   const jj = j & 255;   const kk = k & 255;   const ll = l & 255;   const gi0 = perm[ ii + perm[ jj + perm[ kk + perm[ ll ] ] ] ] % 32;   const gi1 = perm[ ii + i1 + perm[ jj + j1 + perm[ kk + k1 + perm[ ll + l1 ] ] ] ] % 32;   const gi2 = perm[ ii + i2 + perm[ jj + j2 + perm[ kk + k2 + perm[ ll + l2 ] ] ] ] % 32;   const gi3 = perm[ ii + i3 + perm[ jj + j3 + perm[ kk + k3 + perm[ ll + l3 ] ] ] ] % 32;   const gi4 = perm[ ii + 1 + perm[ jj + 1 + perm[ kk + 1 + perm[ ll + 1 ] ] ] ] % 32;   // Calculate the contribution from the five corners   let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;   if ( t0 < 0 ) n0 = 0.0;   else {     t0 *= t0;    n0 = t0 * t0 * this.dot4( grad4[ gi0 ], x0, y0, z0, w0 );    }    let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;   if ( t1 < 0 ) n1 = 0.0;   else {     t1 *= t1;    n1 = t1 * t1 * this.dot4( grad4[ gi1 ], x1, y1, z1, w1 );    }    let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;   if ( t2 < 0 ) n2 = 0.0;   else {     t2 *= t2;    n2 = t2 * t2 * this.dot4( grad4[ gi2 ], x2, y2, z2, w2 );    }    let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;   if ( t3 < 0 ) n3 = 0.0;   else {     t3 *= t3;    n3 = t3 * t3 * this.dot4( grad4[ gi3 ], x3, y3, z3, w3 );    }    let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;   if ( t4 < 0 ) n4 = 0.0;   else {     t4 *= t4;    n4 = t4 * t4 * this.dot4( grad4[ gi4 ], x4, y4, z4, w4 );    }    // Sum up and scale the result to cover the range [-1,1]   return 27.0 * ( n0 + n1 + n2 + n3 + n4 );   }  }  export { SimplexNoise }; 
^..^ FILENAME ^..^
addons|misc|ConvexObjectBreaker.js
^..^ CONTENTS ^..^
import {  Line3,  Mesh,  Plane,  Vector3 } from 'three'; import { ConvexGeometry } from '../geometries/ConvexGeometry.js';  /**  * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.  *  * Usage:  *  * Use the function prepareBreakableObject to prepare a Mesh object to be broken.  *  * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)  *  * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.  *  * Requisites for the object:  *  *  - Mesh object must have a buffer geometry and a material  *  *  - Vertex normals must be planar (not smoothed)  *  *  - The geometry must be convex (this is not checked in the library). You can create convex  *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives  *  can also be used.  *  * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)  * Use with caution and read the code when using with other libs.  *  * @param {double} minSizeForBreak Min size a debris can have to break.  * @param {double} smallDelta Max distance to consider that a point belongs to a plane.  * */  const _v1 = new Vector3();  class ConvexObjectBreaker {   constructor( minSizeForBreak = 1.4, smallDelta = 0.0001 ) {    this.minSizeForBreak = minSizeForBreak;   this.smallDelta = smallDelta;    this.tempLine1 = new Line3();   this.tempPlane1 = new Plane();   this.tempPlane2 = new Plane();   this.tempPlane_Cut = new Plane();   this.tempCM1 = new Vector3();   this.tempCM2 = new Vector3();   this.tempVector3 = new Vector3();   this.tempVector3_2 = new Vector3();   this.tempVector3_3 = new Vector3();   this.tempVector3_P0 = new Vector3();   this.tempVector3_P1 = new Vector3();   this.tempVector3_P2 = new Vector3();   this.tempVector3_N0 = new Vector3();   this.tempVector3_N1 = new Vector3();   this.tempVector3_AB = new Vector3();   this.tempVector3_CB = new Vector3();   this.tempResultObjects = { object1: null, object2: null };    this.segments = [];   const n = 30 * 30;   for ( let i = 0; i < n; i ++ ) this.segments[ i ] = false;   }   prepareBreakableObject( object, mass, velocity, angularVelocity, breakable ) {    // object is a Object3d (normally a Mesh), must have a buffer geometry, and it must be convex.   // Its material property is propagated to its children (sub-pieces)   // mass must be > 0    const userData = object.userData;   userData.mass = mass;   userData.velocity = velocity.clone();   userData.angularVelocity = angularVelocity.clone();   userData.breakable = breakable;   }   /*   * @param {int} maxRadialIterations Iterations for radial cuts.   * @param {int} maxRandomIterations Max random iterations for not-radial cuts   *   * Returns the array of pieces   */  subdivideByImpact( object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations ) {    const debris = [];    const tempPlane1 = this.tempPlane1;   const tempPlane2 = this.tempPlane2;    this.tempVector3.addVectors( pointOfImpact, normal );   tempPlane1.setFromCoplanarPoints( pointOfImpact, object.position, this.tempVector3 );    const maxTotalIterations = maxRandomIterations + maxRadialIterations;    const scope = this;    function subdivideRadial( subObject, startAngle, endAngle, numIterations ) {     if ( Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations ) {      debris.push( subObject );      return;     }     let angle = Math.PI;     if ( numIterations === 0 ) {      tempPlane2.normal.copy( tempPlane1.normal );     tempPlane2.constant = tempPlane1.constant;     } else {      if ( numIterations <= maxRadialIterations ) {       angle = ( endAngle - startAngle ) * ( 0.2 + 0.6 * Math.random() ) + startAngle;       // Rotate tempPlane2 at impact point around normal axis and the angle      scope.tempVector3_2.copy( object.position ).sub( pointOfImpact ).applyAxisAngle( normal, angle ).add( pointOfImpact );      tempPlane2.setFromCoplanarPoints( pointOfImpact, scope.tempVector3, scope.tempVector3_2 );      } else {       angle = ( ( 0.5 * ( numIterations & 1 ) ) + 0.2 * ( 2 - Math.random() ) ) * Math.PI;       // Rotate tempPlane2 at object position around normal axis and the angle      scope.tempVector3_2.copy( pointOfImpact ).sub( subObject.position ).applyAxisAngle( normal, angle ).add( subObject.position );      scope.tempVector3_3.copy( normal ).add( subObject.position );      tempPlane2.setFromCoplanarPoints( subObject.position, scope.tempVector3_3, scope.tempVector3_2 );      }     }     // Perform the cut    scope.cutByPlane( subObject, tempPlane2, scope.tempResultObjects );     const obj1 = scope.tempResultObjects.object1;    const obj2 = scope.tempResultObjects.object2;     if ( obj1 ) {      subdivideRadial( obj1, startAngle, angle, numIterations + 1 );     }     if ( obj2 ) {      subdivideRadial( obj2, angle, endAngle, numIterations + 1 );     }    }    subdivideRadial( object, 0, 2 * Math.PI, 0 );    return debris;   }   cutByPlane( object, plane, output ) {    // Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.   // object2 can be null if the plane doesn't cut the object.   // object1 can be null only in case of internal error   // Returned value is number of pieces, 0 for error.    const geometry = object.geometry;   const coords = geometry.attributes.position.array;   const normals = geometry.attributes.normal.array;    const numPoints = coords.length / 3;   let numFaces = numPoints / 3;    let indices = geometry.getIndex();    if ( indices ) {     indices = indices.array;    numFaces = indices.length / 3;    }    function getVertexIndex( faceIdx, vert ) {     // vert = 0, 1 or 2.     const idx = faceIdx * 3 + vert;     return indices ? indices[ idx ] : idx;    }    const points1 = [];   const points2 = [];    const delta = this.smallDelta;    // Reset segments mark   const numPointPairs = numPoints * numPoints;   for ( let i = 0; i < numPointPairs; i ++ ) this.segments[ i ] = false;    const p0 = this.tempVector3_P0;   const p1 = this.tempVector3_P1;   const n0 = this.tempVector3_N0;   const n1 = this.tempVector3_N1;    // Iterate through the faces to mark edges shared by coplanar faces   for ( let i = 0; i < numFaces - 1; i ++ ) {     const a1 = getVertexIndex( i, 0 );    const b1 = getVertexIndex( i, 1 );    const c1 = getVertexIndex( i, 2 );     // Assuming all 3 vertices have the same normal    n0.set( normals[ a1 ], normals[ a1 ] + 1, normals[ a1 ] + 2 );     for ( let j = i + 1; j < numFaces; j ++ ) {      const a2 = getVertexIndex( j, 0 );     const b2 = getVertexIndex( j, 1 );     const c2 = getVertexIndex( j, 2 );      // Assuming all 3 vertices have the same normal     n1.set( normals[ a2 ], normals[ a2 ] + 1, normals[ a2 ] + 2 );      const coplanar = 1 - n0.dot( n1 ) < delta;      if ( coplanar ) {       if ( a1 === a2 || a1 === b2 || a1 === c2 ) {        if ( b1 === a2 || b1 === b2 || b1 === c2 ) {         this.segments[ a1 * numPoints + b1 ] = true;        this.segments[ b1 * numPoints + a1 ] = true;        } else {         this.segments[ c1 * numPoints + a1 ] = true;        this.segments[ a1 * numPoints + c1 ] = true;        }       } else if ( b1 === a2 || b1 === b2 || b1 === c2 ) {        this.segments[ c1 * numPoints + b1 ] = true;       this.segments[ b1 * numPoints + c1 ] = true;       }      }     }    }    // Transform the plane to object local space   const localPlane = this.tempPlane_Cut;   object.updateMatrix();   ConvexObjectBreaker.transformPlaneToLocalSpace( plane, object.matrix, localPlane );    // Iterate through the faces adding points to both pieces   for ( let i = 0; i < numFaces; i ++ ) {     const va = getVertexIndex( i, 0 );    const vb = getVertexIndex( i, 1 );    const vc = getVertexIndex( i, 2 );     for ( let segment = 0; segment < 3; segment ++ ) {      const i0 = segment === 0 ? va : ( segment === 1 ? vb : vc );     const i1 = segment === 0 ? vb : ( segment === 1 ? vc : va );      const segmentState = this.segments[ i0 * numPoints + i1 ];      if ( segmentState ) continue; // The segment already has been processed in another face      // Mark segment as processed (also inverted segment)     this.segments[ i0 * numPoints + i1 ] = true;     this.segments[ i1 * numPoints + i0 ] = true;      p0.set( coords[ 3 * i0 ], coords[ 3 * i0 + 1 ], coords[ 3 * i0 + 2 ] );     p1.set( coords[ 3 * i1 ], coords[ 3 * i1 + 1 ], coords[ 3 * i1 + 2 ] );      // mark: 1 for negative side, 2 for positive side, 3 for coplanar point     let mark0 = 0;      let d = localPlane.distanceToPoint( p0 );      if ( d > delta ) {       mark0 = 2;      points2.push( p0.clone() );      } else if ( d < - delta ) {       mark0 = 1;      points1.push( p0.clone() );      } else {       mark0 = 3;      points1.push( p0.clone() );      points2.push( p0.clone() );      }      // mark: 1 for negative side, 2 for positive side, 3 for coplanar point     let mark1 = 0;      d = localPlane.distanceToPoint( p1 );      if ( d > delta ) {       mark1 = 2;      points2.push( p1.clone() );      } else if ( d < - delta ) {       mark1 = 1;      points1.push( p1.clone() );      } else {       mark1 = 3;      points1.push( p1.clone() );      points2.push( p1.clone() );      }      if ( ( mark0 === 1 && mark1 === 2 ) || ( mark0 === 2 && mark1 === 1 ) ) {       // Intersection of segment with the plane       this.tempLine1.start.copy( p0 );      this.tempLine1.end.copy( p1 );       let intersection = new Vector3();      intersection = localPlane.intersectLine( this.tempLine1, intersection );       if ( intersection === null ) {        // Shouldn't happen       console.error( 'Internal error: segment does not intersect plane.' );       output.segmentedObject1 = null;       output.segmentedObject2 = null;       return 0;       }       points1.push( intersection );      points2.push( intersection.clone() );      }     }    }    // Calculate debris mass (very fast and imprecise):   const newMass = object.userData.mass * 0.5;    // Calculate debris Center of Mass (again fast and imprecise)   this.tempCM1.set( 0, 0, 0 );   let radius1 = 0;   const numPoints1 = points1.length;    if ( numPoints1 > 0 ) {     for ( let i = 0; i < numPoints1; i ++ ) this.tempCM1.add( points1[ i ] );     this.tempCM1.divideScalar( numPoints1 );    for ( let i = 0; i < numPoints1; i ++ ) {      const p = points1[ i ];     p.sub( this.tempCM1 );     radius1 = Math.max( radius1, p.x, p.y, p.z );     }     this.tempCM1.add( object.position );    }    this.tempCM2.set( 0, 0, 0 );   let radius2 = 0;   const numPoints2 = points2.length;   if ( numPoints2 > 0 ) {     for ( let i = 0; i < numPoints2; i ++ ) this.tempCM2.add( points2[ i ] );     this.tempCM2.divideScalar( numPoints2 );    for ( let i = 0; i < numPoints2; i ++ ) {      const p = points2[ i ];     p.sub( this.tempCM2 );     radius2 = Math.max( radius2, p.x, p.y, p.z );     }     this.tempCM2.add( object.position );    }    let object1 = null;   let object2 = null;    let numObjects = 0;    if ( numPoints1 > 4 ) {     object1 = new Mesh( new ConvexGeometry( points1 ), object.material );    object1.position.copy( this.tempCM1 );    object1.quaternion.copy( object.quaternion );     this.prepareBreakableObject( object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak );     numObjects ++;    }    if ( numPoints2 > 4 ) {     object2 = new Mesh( new ConvexGeometry( points2 ), object.material );    object2.position.copy( this.tempCM2 );    object2.quaternion.copy( object.quaternion );     this.prepareBreakableObject( object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak );     numObjects ++;    }    output.object1 = object1;   output.object2 = object2;    return numObjects;   }   static transformFreeVector( v, m ) {    // input:   // vector interpreted as a free vector   // THREE.Matrix4 orthogonal matrix (matrix without scale)    const x = v.x, y = v.y, z = v.z;   const e = m.elements;    v.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;   v.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;   v.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;    return v;   }   static transformFreeVectorInverse( v, m ) {    // input:   // vector interpreted as a free vector   // THREE.Matrix4 orthogonal matrix (matrix without scale)    const x = v.x, y = v.y, z = v.z;   const e = m.elements;    v.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z;   v.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z;   v.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z;    return v;   }   static transformTiedVectorInverse( v, m ) {    // input:   // vector interpreted as a tied (ordinary) vector   // THREE.Matrix4 orthogonal matrix (matrix without scale)    const x = v.x, y = v.y, z = v.z;   const e = m.elements;    v.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z - e[ 12 ];   v.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z - e[ 13 ];   v.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z - e[ 14 ];    return v;   }   static transformPlaneToLocalSpace( plane, m, resultPlane ) {    resultPlane.normal.copy( plane.normal );   resultPlane.constant = plane.constant;    const referencePoint = ConvexObjectBreaker.transformTiedVectorInverse( plane.coplanarPoint( _v1 ), m );    ConvexObjectBreaker.transformFreeVectorInverse( resultPlane.normal, m );    // recalculate constant (like in setFromNormalAndCoplanarPoint)   resultPlane.constant = - referencePoint.dot( resultPlane.normal );   }  }  export { ConvexObjectBreaker }; 
^..^ FILENAME ^..^
addons|misc|GPUComputationRenderer.js
^..^ CONTENTS ^..^
import {  ClampToEdgeWrapping,  DataTexture,  FloatType,  NearestFilter,  RGBAFormat,  ShaderMaterial,  WebGLRenderTarget } from 'three';  import { FullScreenQuad } from '../postprocessing/Pass.js';  /**  * GPUComputationRenderer, based on SimulationRenderer by zz85  *  * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats  * for each compute element (texel)  *  * Each variable has a fragment shader that defines the computation made to obtain the variable in question.  * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader  * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.  *  * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used  * as inputs to render the textures of the next frame.  *  * The render targets of the variables can be used as input textures for your visualization shaders.  *  * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.  * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...  *  * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:  * #DEFINE resolution vec2( 1024.0, 1024.0 )  *  * -------------  *  * Basic use:  *  * // Initialization...  *  * // Create computation renderer  * const gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );  *  * // Create initial state float textures  * const pos0 = gpuCompute.createTexture();  * const vel0 = gpuCompute.createTexture();  * // and fill in here the texture data...  *  * // Add texture variables  * const velVar = gpuCompute.addVariable( "textureVelocity", fragmentShaderVel, vel0 );  * const posVar = gpuCompute.addVariable( "texturePosition", fragmentShaderPos, pos0 );  *  * // Add variable dependencies  * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );  * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );  *  * // Add custom uniforms  * velVar.material.uniforms.time = { value: 0.0 };  *  * // Check for completeness  * const error = gpuCompute.init();  * if ( error !== null ) {  *  console.error( error );   * }  *  *  * // In each frame...  *  * // Compute!  * gpuCompute.compute();  *  * // Update texture uniforms in your visualization materials with the gpu renderer output  * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;  *  * // Do your rendering  * renderer.render( myScene, myCamera );  *  * -------------  *  * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)  * Note that the shaders can have multiple input textures.  *  * const myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );  * const myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );  *  * const inputTexture = gpuCompute.createTexture();  *  * // Fill in here inputTexture...  *  * myFilter1.uniforms.theTexture.value = inputTexture;  *  * const myRenderTarget = gpuCompute.createRenderTarget();  * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;  *  * const outputRenderTarget = gpuCompute.createRenderTarget();  *  * // Now use the output texture where you want:  * myMaterial.uniforms.map.value = outputRenderTarget.texture;  *  * // And compute each frame, before rendering to screen:  * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );  * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );  *  *  *  * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.  * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.  * @param {WebGLRenderer} renderer The renderer   */  class GPUComputationRenderer {   constructor( sizeX, sizeY, renderer ) {    this.variables = [];    this.currentTextureIndex = 0;    let dataType = FloatType;    const passThruUniforms = {    passThruTexture: { value: null }   };    const passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );    const quad = new FullScreenQuad( passThruShader );    this.setDataType = function ( type ) {     dataType = type;    return this;    };    this.addVariable = function ( variableName, computeFragmentShader, initialValueTexture ) {     const material = this.createShaderMaterial( computeFragmentShader );     const variable = {     name: variableName,     initialValueTexture: initialValueTexture,     material: material,     dependencies: null,     renderTargets: [],     wrapS: null,     wrapT: null,     minFilter: NearestFilter,     magFilter: NearestFilter    };     this.variables.push( variable );     return variable;    };    this.setVariableDependencies = function ( variable, dependencies ) {     variable.dependencies = dependencies;    };    this.init = function () {     if ( renderer.capabilities.maxVertexTextures === 0 ) {      return 'No support for vertex shader textures.';     }     for ( let i = 0; i < this.variables.length; i ++ ) {      const variable = this.variables[ i ];      // Creates rendertargets and initialize them with input texture     variable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );     variable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );     this.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );     this.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );      // Adds dependencies uniforms to the ShaderMaterial     const material = variable.material;     const uniforms = material.uniforms;      if ( variable.dependencies !== null ) {       for ( let d = 0; d < variable.dependencies.length; d ++ ) {        const depVar = variable.dependencies[ d ];        if ( depVar.name !== variable.name ) {         // Checks if variable exists        let found = false;         for ( let j = 0; j < this.variables.length; j ++ ) {          if ( depVar.name === this.variables[ j ].name ) {           found = true;          break;          }         }         if ( ! found ) {          return 'Variable dependency not found. Variable=' + variable.name + ', dependency=' + depVar.name;         }        }        uniforms[ depVar.name ] = { value: null };        material.fragmentShader = '|nuniform sampler2D ' + depVar.name + ';|n' + material.fragmentShader;       }      }     }     this.currentTextureIndex = 0;     return null;    };    this.compute = function () {     const currentTextureIndex = this.currentTextureIndex;    const nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;     for ( let i = 0, il = this.variables.length; i < il; i ++ ) {      const variable = this.variables[ i ];      // Sets texture dependencies uniforms     if ( variable.dependencies !== null ) {       const uniforms = variable.material.uniforms;       for ( let d = 0, dl = variable.dependencies.length; d < dl; d ++ ) {        const depVar = variable.dependencies[ d ];        uniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;       }      }      // Performs the computation for this variable     this.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );     }     this.currentTextureIndex = nextTextureIndex;    };    this.getCurrentRenderTarget = function ( variable ) {     return variable.renderTargets[ this.currentTextureIndex ];    };    this.getAlternateRenderTarget = function ( variable ) {     return variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];    };    this.dispose = function () {     quad.dispose();     const variables = this.variables;     for ( let i = 0; i < variables.length; i ++ ) {      const variable = variables[ i ];      if ( variable.initialValueTexture ) variable.initialValueTexture.dispose();      const renderTargets = variable.renderTargets;      for ( let j = 0; j < renderTargets.length; j ++ ) {       const renderTarget = renderTargets[ j ];      renderTarget.dispose();      }     }    };    function addResolutionDefine( materialShader ) {     materialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + ' )';    }    this.addResolutionDefine = addResolutionDefine;     // The following functions can be used to compute things manually    function createShaderMaterial( computeFragmentShader, uniforms ) {     uniforms = uniforms || {};     const material = new ShaderMaterial( {     name: 'GPUComputationShader',     uniforms: uniforms,     vertexShader: getPassThroughVertexShader(),     fragmentShader: computeFragmentShader    } );     addResolutionDefine( material );     return material;    }    this.createShaderMaterial = createShaderMaterial;    this.createRenderTarget = function ( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {     sizeXTexture = sizeXTexture || sizeX;    sizeYTexture = sizeYTexture || sizeY;     wrapS = wrapS || ClampToEdgeWrapping;    wrapT = wrapT || ClampToEdgeWrapping;     minFilter = minFilter || NearestFilter;    magFilter = magFilter || NearestFilter;     const renderTarget = new WebGLRenderTarget( sizeXTexture, sizeYTexture, {     wrapS: wrapS,     wrapT: wrapT,     minFilter: minFilter,     magFilter: magFilter,     format: RGBAFormat,     type: dataType,     depthBuffer: false    } );     return renderTarget;    };    this.createTexture = function () {     const data = new Float32Array( sizeX * sizeY * 4 );    const texture = new DataTexture( data, sizeX, sizeY, RGBAFormat, FloatType );    texture.needsUpdate = true;    return texture;    };    this.renderTexture = function ( input, output ) {     // Takes a texture, and render out in rendertarget    // input = Texture    // output = RenderTarget     passThruUniforms.passThruTexture.value = input;     this.doRenderTarget( passThruShader, output );     passThruUniforms.passThruTexture.value = null;    };    this.doRenderTarget = function ( material, output ) {     const currentRenderTarget = renderer.getRenderTarget();     const currentXrEnabled = renderer.xr.enabled;    const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;     renderer.xr.enabled = false; // Avoid camera modification    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows    quad.material = material;    renderer.setRenderTarget( output );    quad.render( renderer );    quad.material = passThruShader;     renderer.xr.enabled = currentXrEnabled;    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;     renderer.setRenderTarget( currentRenderTarget );    };    // Shaders    function getPassThroughVertexShader() {     return 'void main() {|n' +      '|n' +      ' gl_Position = vec4( position, 1.0 );|n' +      '|n' +      '}|n';    }    function getPassThroughFragmentShader() {     return 'uniform sampler2D passThruTexture;|n' +      '|n' +      'void main() {|n' +      '|n' +      ' vec2 uv = gl_FragCoord.xy / resolution.xy;|n' +      '|n' +      ' gl_FragColor = texture2D( passThruTexture, uv );|n' +      '|n' +      '}|n';    }   }  }  export { GPUComputationRenderer }; 
^..^ FILENAME ^..^
addons|misc|Gyroscope.js
^..^ CONTENTS ^..^
import {  Object3D,  Quaternion,  Vector3 } from 'three';  const _translationObject = new Vector3(); const _quaternionObject = new Quaternion(); const _scaleObject = new Vector3();  const _translationWorld = new Vector3(); const _quaternionWorld = new Quaternion(); const _scaleWorld = new Vector3();  class Gyroscope extends Object3D {   constructor() {    super();   }   updateMatrixWorld( force ) {    this.matrixAutoUpdate && this.updateMatrix();    // update matrixWorld    if ( this.matrixWorldNeedsUpdate || force ) {     if ( this.parent !== null ) {      this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );      this.matrixWorld.decompose( _translationWorld, _quaternionWorld, _scaleWorld );     this.matrix.decompose( _translationObject, _quaternionObject, _scaleObject );      this.matrixWorld.compose( _translationWorld, _quaternionObject, _scaleWorld );      } else {      this.matrixWorld.copy( this.matrix );     }      this.matrixWorldNeedsUpdate = false;     force = true;    }    // update children    for ( let i = 0, l = this.children.length; i < l; i ++ ) {     this.children[ i ].updateMatrixWorld( force );    }   }  }  export { Gyroscope }; 
^..^ FILENAME ^..^
addons|misc|MD2Character.js
^..^ CONTENTS ^..^
import {  AnimationMixer,  Box3,  Mesh,  MeshLambertMaterial,  Object3D,  TextureLoader,  UVMapping,  SRGBColorSpace } from 'three'; import { MD2Loader } from '../loaders/MD2Loader.js';  class MD2Character {   constructor() {    this.scale = 1;   this.animationFPS = 6;    this.root = new Object3D();    this.meshBody = null;   this.meshWeapon = null;    this.skinsBody = [];   this.skinsWeapon = [];    this.weapons = [];    this.activeAnimation = null;    this.mixer = null;    this.onLoadComplete = function () {};    this.loadCounter = 0;   }   loadParts( config ) {    const scope = this;    function createPart( geometry, skinMap ) {     const materialWireframe = new MeshLambertMaterial( { color: 0xffaa00, wireframe: true } );    const materialTexture = new MeshLambertMaterial( { color: 0xffffff, wireframe: false, map: skinMap } );     //     const mesh = new Mesh( geometry, materialTexture );    mesh.rotation.y = - Math.PI / 2;     mesh.castShadow = true;    mesh.receiveShadow = true;     //     mesh.materialTexture = materialTexture;    mesh.materialWireframe = materialWireframe;     return mesh;    }    function loadTextures( baseUrl, textureUrls ) {     const textureLoader = new TextureLoader();    const textures = [];     for ( let i = 0; i < textureUrls.length; i ++ ) {      textures[ i ] = textureLoader.load( baseUrl + textureUrls[ i ], checkLoadingComplete );     textures[ i ].mapping = UVMapping;     textures[ i ].name = textureUrls[ i ];     textures[ i ].colorSpace = SRGBColorSpace;     }     return textures;    }    function checkLoadingComplete() {     scope.loadCounter -= 1;     if ( scope.loadCounter === 0 ) scope.onLoadComplete();    }    this.loadCounter = config.weapons.length * 2 + config.skins.length + 1;    const weaponsTextures = [];   for ( let i = 0; i < config.weapons.length; i ++ ) weaponsTextures[ i ] = config.weapons[ i ][ 1 ];   // SKINS    this.skinsBody = loadTextures( config.baseUrl + 'skins/', config.skins );   this.skinsWeapon = loadTextures( config.baseUrl + 'skins/', weaponsTextures );    // BODY    const loader = new MD2Loader();    loader.load( config.baseUrl + config.body, function ( geo ) {     const boundingBox = new Box3();    boundingBox.setFromBufferAttribute( geo.attributes.position );     scope.root.position.y = - scope.scale * boundingBox.min.y;     const mesh = createPart( geo, scope.skinsBody[ 0 ] );    mesh.scale.set( scope.scale, scope.scale, scope.scale );     scope.root.add( mesh );     scope.meshBody = mesh;     scope.meshBody.clipOffset = 0;    scope.activeAnimationClipName = mesh.geometry.animations[ 0 ].name;     scope.mixer = new AnimationMixer( mesh );     checkLoadingComplete();    } );    // WEAPONS    const generateCallback = function ( index, name ) {     return function ( geo ) {      const mesh = createPart( geo, scope.skinsWeapon[ index ] );     mesh.scale.set( scope.scale, scope.scale, scope.scale );     mesh.visible = false;      mesh.name = name;      scope.root.add( mesh );      scope.weapons[ index ] = mesh;     scope.meshWeapon = mesh;      checkLoadingComplete();     };    };    for ( let i = 0; i < config.weapons.length; i ++ ) {     loader.load( config.baseUrl + config.weapons[ i ][ 0 ], generateCallback( i, config.weapons[ i ][ 0 ] ) );    }   }   setPlaybackRate( rate ) {    if ( rate !== 0 ) {     this.mixer.timeScale = 1 / rate;    } else {     this.mixer.timeScale = 0;    }   }   setWireframe( wireframeEnabled ) {    if ( wireframeEnabled ) {     if ( this.meshBody ) this.meshBody.material = this.meshBody.materialWireframe;    if ( this.meshWeapon ) this.meshWeapon.material = this.meshWeapon.materialWireframe;    } else {     if ( this.meshBody ) this.meshBody.material = this.meshBody.materialTexture;    if ( this.meshWeapon ) this.meshWeapon.material = this.meshWeapon.materialTexture;    }   }   setSkin( index ) {    if ( this.meshBody && this.meshBody.material.wireframe === false ) {     this.meshBody.material.map = this.skinsBody[ index ];    }   }   setWeapon( index ) {    for ( let i = 0; i < this.weapons.length; i ++ ) this.weapons[ i ].visible = false;    const activeWeapon = this.weapons[ index ];    if ( activeWeapon ) {     activeWeapon.visible = true;    this.meshWeapon = activeWeapon;     this.syncWeaponAnimation();    }   }   setAnimation( clipName ) {    if ( this.meshBody ) {     if ( this.meshBody.activeAction ) {      this.meshBody.activeAction.stop();     this.meshBody.activeAction = null;     }     const action = this.mixer.clipAction( clipName, this.meshBody );     if ( action ) {      this.meshBody.activeAction = action.play();     }    }    this.activeClipName = clipName;    this.syncWeaponAnimation();   }   syncWeaponAnimation() {    const clipName = this.activeClipName;    if ( this.meshWeapon ) {     if ( this.meshWeapon.activeAction ) {      this.meshWeapon.activeAction.stop();     this.meshWeapon.activeAction = null;     }     const action = this.mixer.clipAction( clipName, this.meshWeapon );     if ( action ) {      this.meshWeapon.activeAction = action.syncWith( this.meshBody.activeAction ).play();     }    }   }   update( delta ) {    if ( this.mixer ) this.mixer.update( delta );   }  }  export { MD2Character }; 
^..^ FILENAME ^..^
addons|misc|MD2CharacterComplex.js
^..^ CONTENTS ^..^
import {  Box3,  MathUtils,  MeshLambertMaterial,  Object3D,  TextureLoader,  UVMapping,  SRGBColorSpace } from 'three'; import { MD2Loader } from '../loaders/MD2Loader.js'; import { MorphBlendMesh } from '../misc/MorphBlendMesh.js';  class MD2CharacterComplex {   constructor() {    this.scale = 1;    // animation parameters    this.animationFPS = 6;   this.transitionFrames = 15;    // movement model parameters    this.maxSpeed = 275;   this.maxReverseSpeed = - 275;    this.frontAcceleration = 600;   this.backAcceleration = 600;    this.frontDecceleration = 600;    this.angularSpeed = 2.5;    // rig    this.root = new Object3D();    this.meshBody = null;   this.meshWeapon = null;    this.controls = null;    // skins    this.skinsBody = [];   this.skinsWeapon = [];    this.weapons = [];    this.currentSkin = undefined;    //    this.onLoadComplete = function () {};    // internals    this.meshes = [];   this.animations = {};    this.loadCounter = 0;    // internal movement control variables    this.speed = 0;   this.bodyOrientation = 0;    this.walkSpeed = this.maxSpeed;   this.crouchSpeed = this.maxSpeed * 0.5;    // internal animation parameters    this.activeAnimation = null;   this.oldAnimation = null;    // API   }   enableShadows( enable ) {    for ( let i = 0; i < this.meshes.length; i ++ ) {     this.meshes[ i ].castShadow = enable;    this.meshes[ i ].receiveShadow = enable;    }   }   setVisible( enable ) {    for ( let i = 0; i < this.meshes.length; i ++ ) {     this.meshes[ i ].visible = enable;    this.meshes[ i ].visible = enable;    }   }   shareParts( original ) {    this.animations = original.animations;   this.walkSpeed = original.walkSpeed;   this.crouchSpeed = original.crouchSpeed;    this.skinsBody = original.skinsBody;   this.skinsWeapon = original.skinsWeapon;    // BODY    const mesh = this._createPart( original.meshBody.geometry, this.skinsBody[ 0 ] );   mesh.scale.set( this.scale, this.scale, this.scale );    this.root.position.y = original.root.position.y;   this.root.add( mesh );    this.meshBody = mesh;    this.meshes.push( mesh );    // WEAPONS    for ( let i = 0; i < original.weapons.length; i ++ ) {     const meshWeapon = this._createPart( original.weapons[ i ].geometry, this.skinsWeapon[ i ] );    meshWeapon.scale.set( this.scale, this.scale, this.scale );    meshWeapon.visible = false;     meshWeapon.name = original.weapons[ i ].name;     this.root.add( meshWeapon );     this.weapons[ i ] = meshWeapon;    this.meshWeapon = meshWeapon;     this.meshes.push( meshWeapon );    }   }   loadParts( config ) {    const scope = this;    function loadTextures( baseUrl, textureUrls ) {     const textureLoader = new TextureLoader();    const textures = [];     for ( let i = 0; i < textureUrls.length; i ++ ) {      textures[ i ] = textureLoader.load( baseUrl + textureUrls[ i ], checkLoadingComplete );     textures[ i ].mapping = UVMapping;     textures[ i ].name = textureUrls[ i ];     textures[ i ].colorSpace = SRGBColorSpace;     }     return textures;    }    function checkLoadingComplete() {     scope.loadCounter -= 1;    if ( scope.loadCounter === 0 )  scope.onLoadComplete();    }    this.animations = config.animations;   this.walkSpeed = config.walkSpeed;   this.crouchSpeed = config.crouchSpeed;    this.loadCounter = config.weapons.length * 2 + config.skins.length + 1;    const weaponsTextures = [];   for ( let i = 0; i < config.weapons.length; i ++ ) weaponsTextures[ i ] = config.weapons[ i ][ 1 ];    // SKINS    this.skinsBody = loadTextures( config.baseUrl + 'skins/', config.skins );   this.skinsWeapon = loadTextures( config.baseUrl + 'skins/', weaponsTextures );    // BODY    const loader = new MD2Loader();    loader.load( config.baseUrl + config.body, function ( geo ) {     const boundingBox = new Box3();    boundingBox.setFromBufferAttribute( geo.attributes.position );     scope.root.position.y = - scope.scale * boundingBox.min.y;     const mesh = scope._createPart( geo, scope.skinsBody[ 0 ] );    mesh.scale.set( scope.scale, scope.scale, scope.scale );     scope.root.add( mesh );     scope.meshBody = mesh;    scope.meshes.push( mesh );     checkLoadingComplete();    } );    // WEAPONS    const generateCallback = function ( index, name ) {     return function ( geo ) {      const mesh = scope._createPart( geo, scope.skinsWeapon[ index ] );     mesh.scale.set( scope.scale, scope.scale, scope.scale );     mesh.visible = false;      mesh.name = name;      scope.root.add( mesh );      scope.weapons[ index ] = mesh;     scope.meshWeapon = mesh;     scope.meshes.push( mesh );      checkLoadingComplete();     };    };    for ( let i = 0; i < config.weapons.length; i ++ ) {     loader.load( config.baseUrl + config.weapons[ i ][ 0 ], generateCallback( i, config.weapons[ i ][ 0 ] ) );    }   }   setPlaybackRate( rate ) {    if ( this.meshBody ) this.meshBody.duration = this.meshBody.baseDuration / rate;   if ( this.meshWeapon ) this.meshWeapon.duration = this.meshWeapon.baseDuration / rate;   }   setWireframe( wireframeEnabled ) {    if ( wireframeEnabled ) {     if ( this.meshBody ) this.meshBody.material = this.meshBody.materialWireframe;    if ( this.meshWeapon ) this.meshWeapon.material = this.meshWeapon.materialWireframe;    } else {     if ( this.meshBody ) this.meshBody.material = this.meshBody.materialTexture;    if ( this.meshWeapon ) this.meshWeapon.material = this.meshWeapon.materialTexture;    }   }   setSkin( index ) {    if ( this.meshBody && this.meshBody.material.wireframe === false ) {     this.meshBody.material.map = this.skinsBody[ index ];    this.currentSkin = index;    }   }   setWeapon( index ) {    for ( let i = 0; i < this.weapons.length; i ++ ) this.weapons[ i ].visible = false;    const activeWeapon = this.weapons[ index ];    if ( activeWeapon ) {     activeWeapon.visible = true;    this.meshWeapon = activeWeapon;     if ( this.activeAnimation ) {      activeWeapon.playAnimation( this.activeAnimation );     this.meshWeapon.setAnimationTime( this.activeAnimation, this.meshBody.getAnimationTime( this.activeAnimation ) );     }    }   }   setAnimation( animationName ) {    if ( animationName === this.activeAnimation || ! animationName ) return;    if ( this.meshBody ) {     this.meshBody.setAnimationWeight( animationName, 0 );    this.meshBody.playAnimation( animationName );     this.oldAnimation = this.activeAnimation;    this.activeAnimation = animationName;     this.blendCounter = this.transitionFrames;    }    if ( this.meshWeapon ) {     this.meshWeapon.setAnimationWeight( animationName, 0 );    this.meshWeapon.playAnimation( animationName );    }    }   update( delta ) {    if ( this.controls ) this.updateMovementModel( delta );    if ( this.animations ) {     this.updateBehaviors();    this.updateAnimations( delta );    }   }   updateAnimations( delta ) {    let mix = 1;    if ( this.blendCounter > 0 ) {     mix = ( this.transitionFrames - this.blendCounter ) / this.transitionFrames;    this.blendCounter -= 1;    }    if ( this.meshBody ) {     this.meshBody.update( delta );     this.meshBody.setAnimationWeight( this.activeAnimation, mix );    this.meshBody.setAnimationWeight( this.oldAnimation, 1 - mix );    }    if ( this.meshWeapon ) {     this.meshWeapon.update( delta );     this.meshWeapon.setAnimationWeight( this.activeAnimation, mix );    this.meshWeapon.setAnimationWeight( this.oldAnimation, 1 - mix );    }   }   updateBehaviors() {    const controls = this.controls;   const animations = this.animations;    let moveAnimation, idleAnimation;    // crouch vs stand    if ( controls.crouch ) {     moveAnimation = animations[ 'crouchMove' ];    idleAnimation = animations[ 'crouchIdle' ];    } else {     moveAnimation = animations[ 'move' ];    idleAnimation = animations[ 'idle' ];    }    // actions    if ( controls.jump ) {     moveAnimation = animations[ 'jump' ];    idleAnimation = animations[ 'jump' ];    }    if ( controls.attack ) {     if ( controls.crouch ) {      moveAnimation = animations[ 'crouchAttack' ];     idleAnimation = animations[ 'crouchAttack' ];     } else {      moveAnimation = animations[ 'attack' ];     idleAnimation = animations[ 'attack' ];     }    }    // set animations    if ( controls.moveForward || controls.moveBackward || controls.moveLeft || controls.moveRight ) {     if ( this.activeAnimation !== moveAnimation ) {      this.setAnimation( moveAnimation );     }    }     if ( Math.abs( this.speed ) < 0.2 * this.maxSpeed && ! ( controls.moveLeft || controls.moveRight || controls.moveForward || controls.moveBackward ) ) {     if ( this.activeAnimation !== idleAnimation ) {      this.setAnimation( idleAnimation );     }    }    // set animation direction    if ( controls.moveForward ) {     if ( this.meshBody ) {      this.meshBody.setAnimationDirectionForward( this.activeAnimation );     this.meshBody.setAnimationDirectionForward( this.oldAnimation );     }     if ( this.meshWeapon ) {      this.meshWeapon.setAnimationDirectionForward( this.activeAnimation );     this.meshWeapon.setAnimationDirectionForward( this.oldAnimation );     }    }    if ( controls.moveBackward ) {     if ( this.meshBody ) {      this.meshBody.setAnimationDirectionBackward( this.activeAnimation );     this.meshBody.setAnimationDirectionBackward( this.oldAnimation );     }     if ( this.meshWeapon ) {      this.meshWeapon.setAnimationDirectionBackward( this.activeAnimation );     this.meshWeapon.setAnimationDirectionBackward( this.oldAnimation );     }    }   }   updateMovementModel( delta ) {    function exponentialEaseOut( k ) {     return k === 1 ? 1 : - Math.pow( 2, - 10 * k ) + 1;    }    const controls = this.controls;    // speed based on controls    if ( controls.crouch )  this.maxSpeed = this.crouchSpeed;   else this.maxSpeed = this.walkSpeed;    this.maxReverseSpeed = - this.maxSpeed;    if ( controls.moveForward ) this.speed = MathUtils.clamp( this.speed + delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed );   if ( controls.moveBackward ) this.speed = MathUtils.clamp( this.speed - delta * this.backAcceleration, this.maxReverseSpeed, this.maxSpeed );    // orientation based on controls   // (don't just stand while turning)    const dir = 1;    if ( controls.moveLeft ) {     this.bodyOrientation += delta * this.angularSpeed;    this.speed = MathUtils.clamp( this.speed + dir * delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed );    }    if ( controls.moveRight ) {     this.bodyOrientation -= delta * this.angularSpeed;    this.speed = MathUtils.clamp( this.speed + dir * delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed );    }    // speed decay    if ( ! ( controls.moveForward || controls.moveBackward ) ) {     if ( this.speed > 0 ) {      const k = exponentialEaseOut( this.speed / this.maxSpeed );     this.speed = MathUtils.clamp( this.speed - k * delta * this.frontDecceleration, 0, this.maxSpeed );     } else {      const k = exponentialEaseOut( this.speed / this.maxReverseSpeed );     this.speed = MathUtils.clamp( this.speed + k * delta * this.backAcceleration, this.maxReverseSpeed, 0 );     }    }    // displacement    const forwardDelta = this.speed * delta;    this.root.position.x += Math.sin( this.bodyOrientation ) * forwardDelta;   this.root.position.z += Math.cos( this.bodyOrientation ) * forwardDelta;    // steering    this.root.rotation.y = this.bodyOrientation;   }   // internal   _createPart( geometry, skinMap ) {    const materialWireframe = new MeshLambertMaterial( { color: 0xffaa00, wireframe: true } );   const materialTexture = new MeshLambertMaterial( { color: 0xffffff, wireframe: false, map: skinMap } );    //    const mesh = new MorphBlendMesh( geometry, materialTexture );   mesh.rotation.y = - Math.PI / 2;    //    mesh.materialTexture = materialTexture;   mesh.materialWireframe = materialWireframe;    //    mesh.autoCreateAnimations( this.animationFPS );    return mesh;   }  }  export { MD2CharacterComplex }; 
^..^ FILENAME ^..^
addons|misc|MorphAnimMesh.js
^..^ CONTENTS ^..^
import {  AnimationClip,  AnimationMixer,  Mesh } from 'three';  class MorphAnimMesh extends Mesh {   constructor( geometry, material ) {    super( geometry, material );    this.type = 'MorphAnimMesh';    this.mixer = new AnimationMixer( this );   this.activeAction = null;   }   setDirectionForward() {    this.mixer.timeScale = 1.0;   }   setDirectionBackward() {    this.mixer.timeScale = - 1.0;   }   playAnimation( label, fps ) {    if ( this.activeAction ) {     this.activeAction.stop();    this.activeAction = null;    }    const clip = AnimationClip.findByName( this, label );    if ( clip ) {     const action = this.mixer.clipAction( clip );    action.timeScale = ( clip.tracks.length * fps ) / clip.duration;    this.activeAction = action.play();    } else {     throw new Error( 'THREE.MorphAnimMesh: animations[' + label + '] undefined in .playAnimation()' );    }   }   updateAnimation( delta ) {    this.mixer.update( delta );   }   copy( source, recursive ) {    super.copy( source, recursive );    this.mixer = new AnimationMixer( this );    return this;   }  }  export { MorphAnimMesh }; 
^..^ FILENAME ^..^
addons|misc|MorphBlendMesh.js
^..^ CONTENTS ^..^
import {  MathUtils,  Mesh } from 'three';  class MorphBlendMesh extends Mesh {   constructor( geometry, material ) {    super( geometry, material );    this.animationsMap = {};   this.animationsList = [];    // prepare default animation   // (all frames played together in 1 second)    const numFrames = Object.keys( this.morphTargetDictionary ).length;    const name = '__default';    const startFrame = 0;   const endFrame = numFrames - 1;    const fps = numFrames / 1;    this.createAnimation( name, startFrame, endFrame, fps );   this.setAnimationWeight( name, 1 );   }   createAnimation( name, start, end, fps ) {    const animation = {     start: start,    end: end,     length: end - start + 1,     fps: fps,    duration: ( end - start ) / fps,     lastFrame: 0,    currentFrame: 0,     active: false,     time: 0,    direction: 1,    weight: 1,     directionBackwards: false,    mirroredLoop: false    };    this.animationsMap[ name ] = animation;   this.animationsList.push( animation );   }   autoCreateAnimations( fps ) {    const pattern = /([a-z]+)_?(|d+)/i;    let firstAnimation;    const frameRanges = {};    let i = 0;    for ( const key in this.morphTargetDictionary ) {     const chunks = key.match( pattern );     if ( chunks && chunks.length > 1 ) {      const name = chunks[ 1 ];      if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };      const range = frameRanges[ name ];      if ( i < range.start ) range.start = i;     if ( i > range.end ) range.end = i;      if ( ! firstAnimation ) firstAnimation = name;     }     i ++;    }    for ( const name in frameRanges ) {     const range = frameRanges[ name ];    this.createAnimation( name, range.start, range.end, fps );    }    this.firstAnimation = firstAnimation;   }   setAnimationDirectionForward( name ) {    const animation = this.animationsMap[ name ];    if ( animation ) {     animation.direction = 1;    animation.directionBackwards = false;    }   }   setAnimationDirectionBackward( name ) {    const animation = this.animationsMap[ name ];    if ( animation ) {     animation.direction = - 1;    animation.directionBackwards = true;    }   }   setAnimationFPS( name, fps ) {    const animation = this.animationsMap[ name ];    if ( animation ) {     animation.fps = fps;    animation.duration = ( animation.end - animation.start ) / animation.fps;    }   }   setAnimationDuration( name, duration ) {    const animation = this.animationsMap[ name ];    if ( animation ) {     animation.duration = duration;    animation.fps = ( animation.end - animation.start ) / animation.duration;    }   }   setAnimationWeight( name, weight ) {    const animation = this.animationsMap[ name ];    if ( animation ) {     animation.weight = weight;    }   }   setAnimationTime( name, time ) {    const animation = this.animationsMap[ name ];    if ( animation ) {     animation.time = time;    }   }   getAnimationTime( name ) {    let time = 0;    const animation = this.animationsMap[ name ];    if ( animation ) {     time = animation.time;    }    return time;   }   getAnimationDuration( name ) {    let duration = - 1;    const animation = this.animationsMap[ name ];    if ( animation ) {     duration = animation.duration;    }    return duration;   }   playAnimation( name ) {    const animation = this.animationsMap[ name ];    if ( animation ) {     animation.time = 0;    animation.active = true;    } else {     console.warn( 'THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()' );    }   }   stopAnimation( name ) {    const animation = this.animationsMap[ name ];    if ( animation ) {     animation.active = false;    }   }   update( delta ) {    for ( let i = 0, il = this.animationsList.length; i < il; i ++ ) {     const animation = this.animationsList[ i ];     if ( ! animation.active ) continue;     const frameTime = animation.duration / animation.length;     animation.time += animation.direction * delta;     if ( animation.mirroredLoop ) {      if ( animation.time > animation.duration || animation.time < 0 ) {       animation.direction *= - 1;       if ( animation.time > animation.duration ) {        animation.time = animation.duration;       animation.directionBackwards = true;       }       if ( animation.time < 0 ) {        animation.time = 0;       animation.directionBackwards = false;       }      }     } else {      animation.time = animation.time % animation.duration;      if ( animation.time < 0 ) animation.time += animation.duration;     }     const keyframe = animation.start + MathUtils.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );    const weight = animation.weight;     if ( keyframe !== animation.currentFrame ) {      this.morphTargetInfluences[ animation.lastFrame ] = 0;     this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;      this.morphTargetInfluences[ keyframe ] = 0;      animation.lastFrame = animation.currentFrame;     animation.currentFrame = keyframe;     }     let mix = ( animation.time % frameTime ) / frameTime;     if ( animation.directionBackwards ) mix = 1 - mix;     if ( animation.currentFrame !== animation.lastFrame ) {      this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;     this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;     } else {      this.morphTargetInfluences[ animation.currentFrame ] = weight;     }    }   }  }  export { MorphBlendMesh }; 
^..^ FILENAME ^..^
addons|misc|ProgressiveLightMap.js
^..^ CONTENTS ^..^
import * as THREE from 'three'; import { potpack } from '../libs/potpack.module.js';  /**  * Progressive Light Map Accumulator, by [zalo](https://github.com/zalo/)  *  * To use, simply construct a |ProgressiveLightMap| object,  * |plmap.addObjectsToLightMap(object)| an array of semi-static  * objects and lights to the class once, and then call  * |plmap.update(camera)| every frame to begin accumulating  * lighting samples.  *  * This should begin accumulating lightmaps which apply to  * your objects, so you can start jittering lighting to achieve  * the texture-space effect you're looking for.  *  * @param {WebGLRenderer} renderer A WebGL Rendering Context  * @param {number} res The side-long dimension of you total lightmap  */ class ProgressiveLightMap {   constructor( renderer, res = 1024 ) {    this.renderer = renderer;   this.res = res;   this.lightMapContainers = [];   this.compiled = false;   this.scene = new THREE.Scene();   this.scene.background = null;   this.tinyTarget = new THREE.WebGLRenderTarget( 1, 1 );   this.buffer1Active = false;   this.firstUpdate = true;   this.warned = false;    // Create the Progressive LightMap Texture   const format = /(Android|iPad|iPhone|iPod)/g.test( navigator.userAgent ) ? THREE.HalfFloatType : THREE.FloatType;   this.progressiveLightMap1 = new THREE.WebGLRenderTarget( this.res, this.res, { type: format } );   this.progressiveLightMap2 = new THREE.WebGLRenderTarget( this.res, this.res, { type: format } );   this.progressiveLightMap2.texture.channel = 1;    // Inject some spicy new logic into a standard phong material   this.uvMat = new THREE.MeshPhongMaterial();   this.uvMat.uniforms = {};   this.uvMat.onBeforeCompile = ( shader ) => {     // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions    shader.vertexShader =     'attribute vec2 uv1;|n' +     '#define USE_LIGHTMAP|n' +     '#define LIGHTMAP_UV uv1|n' +     shader.vertexShader.slice( 0, - 1 ) +     ' gl_Position = vec4((LIGHTMAP_UV - 0.5) * 2.0, 1.0, 1.0); }';     // Fragment Shader: Set Pixels to average in the Previous frame's Shadows    const bodyStart = shader.fragmentShader.indexOf( 'void main() {' );    shader.fragmentShader =     '#define USE_LIGHTMAP|n' +     shader.fragmentShader.slice( 0, bodyStart ) +     ' uniform sampler2D previousShadowMap;|n uniform float averagingWindow;|n' +     shader.fragmentShader.slice( bodyStart - 1, - 1 ) +     ||nvec3 texelOld = texture2D(previousShadowMap, vLightMapUv).rgb;     gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);    }|;     // Set the Previous Frame's Texture Buffer and Averaging Window    shader.uniforms.previousShadowMap = { value: this.progressiveLightMap1.texture };    shader.uniforms.averagingWindow = { value: 100 };     this.uvMat.uniforms = shader.uniforms;     // Set the new Shader to this    this.uvMat.userData.shader = shader;     this.compiled = true;    };   }   /**   * Sets these objects' materials' lightmaps and modifies their uv1's.   * @param {Object3D} objects An array of objects and lights to set up your lightmap.   */  addObjectsToLightMap( objects ) {    // Prepare list of UV bounding boxes for packing later...   this.uv_boxes = []; const padding = 3 / this.res;    for ( let ob = 0; ob < objects.length; ob ++ ) {     const object = objects[ ob ];     // If this object is a light, simply add it to the internal scene    if ( object.isLight ) {      this.scene.attach( object ); continue;     }     if ( ! object.geometry.hasAttribute( 'uv' ) ) {      console.warn( 'All lightmap objects need UVs!' ); continue;     }     if ( this.blurringPlane == null ) {      this._initializeBlurPlane( this.res, this.progressiveLightMap1 );     }     // Apply the lightmap to the object    object.material.lightMap = this.progressiveLightMap2.texture;    object.material.dithering = true;    object.castShadow = true;    object.receiveShadow = true;    object.renderOrder = 1000 + ob;     // Prepare UV boxes for potpack    // TODO: Size these by object surface area    this.uv_boxes.push( { w: 1 + ( padding * 2 ),           h: 1 + ( padding * 2 ), index: ob } );     this.lightMapContainers.push( { basicMat: object.material, object: object } );     this.compiled = false;    }    // Pack the objects' lightmap UVs into the same global space   const dimensions = potpack( this.uv_boxes );   this.uv_boxes.forEach( ( box ) => {     const uv1 = objects[ box.index ].geometry.getAttribute( 'uv' ).clone();    for ( let i = 0; i < uv1.array.length; i += uv1.itemSize ) {      uv1.array[ i ] = ( uv1.array[ i ] + box.x + padding ) / dimensions.w;     uv1.array[ i + 1 ] = ( uv1.array[ i + 1 ] + box.y + padding ) / dimensions.h;     }     objects[ box.index ].geometry.setAttribute( 'uv1', uv1 );    objects[ box.index ].geometry.getAttribute( 'uv1' ).needsUpdate = true;    } );   }   /**   * This function renders each mesh one at a time into their respective surface maps   * @param {Camera} camera Standard Rendering Camera   * @param {number} blendWindow When >1, samples will accumulate over time.   * @param {boolean} blurEdges  Whether to fix UV Edges via blurring   */  update( camera, blendWindow = 100, blurEdges = true ) {    if ( this.blurringPlane == null ) {     return;    }    // Store the original Render Target   const oldTarget = this.renderer.getRenderTarget();    // The blurring plane applies blur to the seams of the lightmap   this.blurringPlane.visible = blurEdges;    // Steal the Object3D from the real world to our special dimension   for ( let l = 0; l < this.lightMapContainers.length; l ++ ) {     this.lightMapContainers[ l ].object.oldScene =     this.lightMapContainers[ l ].object.parent;    this.scene.attach( this.lightMapContainers[ l ].object );    }    // Render once normally to initialize everything   if ( this.firstUpdate ) {     this.renderer.setRenderTarget( this.tinyTarget ); // Tiny for Speed    this.renderer.render( this.scene, camera );    this.firstUpdate = false;    }    // Set each object's material to the UV Unwrapped Surface Mapping Version   for ( let l = 0; l < this.lightMapContainers.length; l ++ ) {     this.uvMat.uniforms.averagingWindow = { value: blendWindow };    this.lightMapContainers[ l ].object.material = this.uvMat;    this.lightMapContainers[ l ].object.oldFrustumCulled =     this.lightMapContainers[ l ].object.frustumCulled;    this.lightMapContainers[ l ].object.frustumCulled = false;    }    // Ping-pong two surface buffers for reading/writing   const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;   const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;    // Render the object's surface maps   this.renderer.setRenderTarget( activeMap );   this.uvMat.uniforms.previousShadowMap = { value: inactiveMap.texture };   this.blurringPlane.material.uniforms.previousShadowMap = { value: inactiveMap.texture };   this.buffer1Active = ! this.buffer1Active;   this.renderer.render( this.scene, camera );    // Restore the object's Real-time Material and add it back to the original world   for ( let l = 0; l < this.lightMapContainers.length; l ++ ) {     this.lightMapContainers[ l ].object.frustumCulled =     this.lightMapContainers[ l ].object.oldFrustumCulled;    this.lightMapContainers[ l ].object.material = this.lightMapContainers[ l ].basicMat;    this.lightMapContainers[ l ].object.oldScene.attach( this.lightMapContainers[ l ].object );    }    // Restore the original Render Target   this.renderer.setRenderTarget( oldTarget );   }   /** DEBUG   * Draw the lightmap in the main scene.  Call this after adding the objects to it.   * @param {boolean} visible Whether the debug plane should be visible   * @param {Vector3} position Where the debug plane should be drawn  */  showDebugLightmap( visible, position = undefined ) {    if ( this.lightMapContainers.length == 0 ) {     if ( ! this.warned ) {      console.warn( 'Call this after adding the objects!' ); this.warned = true;     }     return;    }    if ( this.labelMesh == null ) {     this.labelMaterial = new THREE.MeshBasicMaterial(     { map: this.progressiveLightMap1.texture, side: THREE.DoubleSide } );    this.labelPlane = new THREE.PlaneGeometry( 100, 100 );    this.labelMesh = new THREE.Mesh( this.labelPlane, this.labelMaterial );    this.labelMesh.position.y = 250;    this.lightMapContainers[ 0 ].object.parent.add( this.labelMesh );    }    if ( position != undefined ) {     this.labelMesh.position.copy( position );    }    this.labelMesh.visible = visible;   }   /**   * INTERNAL Creates the Blurring Plane   * @param {number} res The square resolution of this object's lightMap.   * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.   */  _initializeBlurPlane( res, lightMap = null ) {    const blurMaterial = new THREE.MeshBasicMaterial();   blurMaterial.uniforms = { previousShadowMap: { value: null },           pixelOffset: { value: 1.0 / res },           polygonOffset: true, polygonOffsetFactor: - 1, polygonOffsetUnits: 3.0 };   blurMaterial.onBeforeCompile = ( shader ) => {     // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions    shader.vertexShader =     '#define USE_UV|n' +     shader.vertexShader.slice( 0, - 1 ) +     ' gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }';     // Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows    const bodyStart = shader.fragmentShader.indexOf( 'void main() {' );    shader.fragmentShader =     '#define USE_UV|n' +     shader.fragmentShader.slice( 0, bodyStart ) +     ' uniform sampler2D previousShadowMap;|n uniform float pixelOffset;|n' +     shader.fragmentShader.slice( bodyStart - 1, - 1 ) +      | gl_FragColor.rgb = (          texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +          texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +          texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +          texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +          texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +          texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +          texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +          texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;     }|;     // Set the LightMap Accumulation Buffer    shader.uniforms.previousShadowMap = { value: lightMap.texture };    shader.uniforms.pixelOffset = { value: 0.5 / res };    blurMaterial.uniforms = shader.uniforms;     // Set the new Shader to this    blurMaterial.userData.shader = shader;     this.compiled = true;    };    this.blurringPlane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), blurMaterial );   this.blurringPlane.name = 'Blurring Plane';   this.blurringPlane.frustumCulled = false;   this.blurringPlane.renderOrder = 0;   this.blurringPlane.material.depthWrite = false;   this.scene.add( this.blurringPlane );   }  }  export { ProgressiveLightMap }; 
^..^ FILENAME ^..^
addons|misc|RollerCoaster.js
^..^ CONTENTS ^..^
import {  BufferAttribute,  BufferGeometry,  Color,  Quaternion,  Raycaster,  SRGBColorSpace,  Vector3 } from 'three';  class RollerCoasterGeometry extends BufferGeometry {   constructor( curve, divisions ) {    super();    const vertices = [];   const normals = [];   const colors = [];    const color1 = [ 1, 1, 1 ];   const color2 = [ 1, 1, 0 ];    const up = new Vector3( 0, 1, 0 );   const forward = new Vector3();   const right = new Vector3();    const quaternion = new Quaternion();   const prevQuaternion = new Quaternion();   prevQuaternion.setFromAxisAngle( up, Math.PI / 2 );    const point = new Vector3();   const prevPoint = new Vector3();   prevPoint.copy( curve.getPointAt( 0 ) );    // shapes    const step = [    new Vector3( - 0.225, 0, 0 ),    new Vector3( 0, - 0.050, 0 ),    new Vector3( 0, - 0.175, 0 ),     new Vector3( 0, - 0.050, 0 ),    new Vector3( 0.225, 0, 0 ),    new Vector3( 0, - 0.175, 0 )   ];    const PI2 = Math.PI * 2;    let sides = 5;   const tube1 = [];    for ( let i = 0; i < sides; i ++ ) {     const angle = ( i / sides ) * PI2;    tube1.push( new Vector3( Math.sin( angle ) * 0.06, Math.cos( angle ) * 0.06, 0 ) );    }    sides = 6;   const tube2 = [];    for ( let i = 0; i < sides; i ++ ) {     const angle = ( i / sides ) * PI2;    tube2.push( new Vector3( Math.sin( angle ) * 0.025, Math.cos( angle ) * 0.025, 0 ) );    }    const vector = new Vector3();   const normal = new Vector3();    function drawShape( shape, color ) {     normal.set( 0, 0, - 1 ).applyQuaternion( quaternion );     for ( let j = 0; j < shape.length; j ++ ) {      vector.copy( shape[ j ] );     vector.applyQuaternion( quaternion );     vector.add( point );      vertices.push( vector.x, vector.y, vector.z );     normals.push( normal.x, normal.y, normal.z );     colors.push( color[ 0 ], color[ 1 ], color[ 2 ] );     }     normal.set( 0, 0, 1 ).applyQuaternion( quaternion );     for ( let j = shape.length - 1; j >= 0; j -- ) {      vector.copy( shape[ j ] );     vector.applyQuaternion( quaternion );     vector.add( point );      vertices.push( vector.x, vector.y, vector.z );     normals.push( normal.x, normal.y, normal.z );     colors.push( color[ 0 ], color[ 1 ], color[ 2 ] );     }    }    const vector1 = new Vector3();   const vector2 = new Vector3();   const vector3 = new Vector3();   const vector4 = new Vector3();    const normal1 = new Vector3();   const normal2 = new Vector3();   const normal3 = new Vector3();   const normal4 = new Vector3();    function extrudeShape( shape, offset, color ) {     for ( let j = 0, jl = shape.length; j < jl; j ++ ) {      const point1 = shape[ j ];     const point2 = shape[ ( j + 1 ) % jl ];      vector1.copy( point1 ).add( offset );     vector1.applyQuaternion( quaternion );     vector1.add( point );      vector2.copy( point2 ).add( offset );     vector2.applyQuaternion( quaternion );     vector2.add( point );      vector3.copy( point2 ).add( offset );     vector3.applyQuaternion( prevQuaternion );     vector3.add( prevPoint );      vector4.copy( point1 ).add( offset );     vector4.applyQuaternion( prevQuaternion );     vector4.add( prevPoint );      vertices.push( vector1.x, vector1.y, vector1.z );     vertices.push( vector2.x, vector2.y, vector2.z );     vertices.push( vector4.x, vector4.y, vector4.z );      vertices.push( vector2.x, vector2.y, vector2.z );     vertices.push( vector3.x, vector3.y, vector3.z );     vertices.push( vector4.x, vector4.y, vector4.z );      //      normal1.copy( point1 );     normal1.applyQuaternion( quaternion );     normal1.normalize();      normal2.copy( point2 );     normal2.applyQuaternion( quaternion );     normal2.normalize();      normal3.copy( point2 );     normal3.applyQuaternion( prevQuaternion );     normal3.normalize();      normal4.copy( point1 );     normal4.applyQuaternion( prevQuaternion );     normal4.normalize();      normals.push( normal1.x, normal1.y, normal1.z );     normals.push( normal2.x, normal2.y, normal2.z );     normals.push( normal4.x, normal4.y, normal4.z );      normals.push( normal2.x, normal2.y, normal2.z );     normals.push( normal3.x, normal3.y, normal3.z );     normals.push( normal4.x, normal4.y, normal4.z );      colors.push( color[ 0 ], color[ 1 ], color[ 2 ] );     colors.push( color[ 0 ], color[ 1 ], color[ 2 ] );     colors.push( color[ 0 ], color[ 1 ], color[ 2 ] );      colors.push( color[ 0 ], color[ 1 ], color[ 2 ] );     colors.push( color[ 0 ], color[ 1 ], color[ 2 ] );     colors.push( color[ 0 ], color[ 1 ], color[ 2 ] );     }    }    const offset = new Vector3();    for ( let i = 1; i <= divisions; i ++ ) {     point.copy( curve.getPointAt( i / divisions ) );     up.set( 0, 1, 0 );     forward.subVectors( point, prevPoint ).normalize();    right.crossVectors( up, forward ).normalize();    up.crossVectors( forward, right );     const angle = Math.atan2( forward.x, forward.z );     quaternion.setFromAxisAngle( up, angle );     if ( i % 2 === 0 ) {      drawShape( step, color2 );     }     extrudeShape( tube1, offset.set( 0, - 0.125, 0 ), color2 );    extrudeShape( tube2, offset.set( 0.2, 0, 0 ), color1 );    extrudeShape( tube2, offset.set( - 0.2, 0, 0 ), color1 );     prevPoint.copy( point );    prevQuaternion.copy( quaternion );    }    // console.log( vertices.length );    this.setAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );   this.setAttribute( 'normal', new BufferAttribute( new Float32Array( normals ), 3 ) );   this.setAttribute( 'color', new BufferAttribute( new Float32Array( colors ), 3 ) );   }  }  class RollerCoasterLiftersGeometry extends BufferGeometry {   constructor( curve, divisions ) {    super();    const vertices = [];   const normals = [];    const quaternion = new Quaternion();    const up = new Vector3( 0, 1, 0 );    const point = new Vector3();   const tangent = new Vector3();    // shapes    const tube1 = [    new Vector3( 0, 0.05, - 0.05 ),    new Vector3( 0, 0.05, 0.05 ),    new Vector3( 0, - 0.05, 0 )   ];    const tube2 = [    new Vector3( - 0.05, 0, 0.05 ),    new Vector3( - 0.05, 0, - 0.05 ),    new Vector3( 0.05, 0, 0 )   ];    const tube3 = [    new Vector3( 0.05, 0, - 0.05 ),    new Vector3( 0.05, 0, 0.05 ),    new Vector3( - 0.05, 0, 0 )   ];    const vector1 = new Vector3();   const vector2 = new Vector3();   const vector3 = new Vector3();   const vector4 = new Vector3();    const normal1 = new Vector3();   const normal2 = new Vector3();   const normal3 = new Vector3();   const normal4 = new Vector3();    function extrudeShape( shape, fromPoint, toPoint ) {     for ( let j = 0, jl = shape.length; j < jl; j ++ ) {      const point1 = shape[ j ];     const point2 = shape[ ( j + 1 ) % jl ];      vector1.copy( point1 );     vector1.applyQuaternion( quaternion );     vector1.add( fromPoint );      vector2.copy( point2 );     vector2.applyQuaternion( quaternion );     vector2.add( fromPoint );      vector3.copy( point2 );     vector3.applyQuaternion( quaternion );     vector3.add( toPoint );      vector4.copy( point1 );     vector4.applyQuaternion( quaternion );     vector4.add( toPoint );      vertices.push( vector1.x, vector1.y, vector1.z );     vertices.push( vector2.x, vector2.y, vector2.z );     vertices.push( vector4.x, vector4.y, vector4.z );      vertices.push( vector2.x, vector2.y, vector2.z );     vertices.push( vector3.x, vector3.y, vector3.z );     vertices.push( vector4.x, vector4.y, vector4.z );      //      normal1.copy( point1 );     normal1.applyQuaternion( quaternion );     normal1.normalize();      normal2.copy( point2 );     normal2.applyQuaternion( quaternion );     normal2.normalize();      normal3.copy( point2 );     normal3.applyQuaternion( quaternion );     normal3.normalize();      normal4.copy( point1 );     normal4.applyQuaternion( quaternion );     normal4.normalize();      normals.push( normal1.x, normal1.y, normal1.z );     normals.push( normal2.x, normal2.y, normal2.z );     normals.push( normal4.x, normal4.y, normal4.z );      normals.push( normal2.x, normal2.y, normal2.z );     normals.push( normal3.x, normal3.y, normal3.z );     normals.push( normal4.x, normal4.y, normal4.z );     }    }    const fromPoint = new Vector3();   const toPoint = new Vector3();    for ( let i = 1; i <= divisions; i ++ ) {     point.copy( curve.getPointAt( i / divisions ) );    tangent.copy( curve.getTangentAt( i / divisions ) );     const angle = Math.atan2( tangent.x, tangent.z );     quaternion.setFromAxisAngle( up, angle );     //     if ( point.y > 10 ) {      fromPoint.set( - 0.75, - 0.35, 0 );     fromPoint.applyQuaternion( quaternion );     fromPoint.add( point );      toPoint.set( 0.75, - 0.35, 0 );     toPoint.applyQuaternion( quaternion );     toPoint.add( point );      extrudeShape( tube1, fromPoint, toPoint );      fromPoint.set( - 0.7, - 0.3, 0 );     fromPoint.applyQuaternion( quaternion );     fromPoint.add( point );      toPoint.set( - 0.7, - point.y, 0 );     toPoint.applyQuaternion( quaternion );     toPoint.add( point );      extrudeShape( tube2, fromPoint, toPoint );      fromPoint.set( 0.7, - 0.3, 0 );     fromPoint.applyQuaternion( quaternion );     fromPoint.add( point );      toPoint.set( 0.7, - point.y, 0 );     toPoint.applyQuaternion( quaternion );     toPoint.add( point );      extrudeShape( tube3, fromPoint, toPoint );     } else {      fromPoint.set( 0, - 0.2, 0 );     fromPoint.applyQuaternion( quaternion );     fromPoint.add( point );      toPoint.set( 0, - point.y, 0 );     toPoint.applyQuaternion( quaternion );     toPoint.add( point );      extrudeShape( tube3, fromPoint, toPoint );     }    }    this.setAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );   this.setAttribute( 'normal', new BufferAttribute( new Float32Array( normals ), 3 ) );   }  }  class RollerCoasterShadowGeometry extends BufferGeometry {   constructor( curve, divisions ) {    super();    const vertices = [];    const up = new Vector3( 0, 1, 0 );   const forward = new Vector3();    const quaternion = new Quaternion();   const prevQuaternion = new Quaternion();   prevQuaternion.setFromAxisAngle( up, Math.PI / 2 );    const point = new Vector3();    const prevPoint = new Vector3();   prevPoint.copy( curve.getPointAt( 0 ) );   prevPoint.y = 0;    const vector1 = new Vector3();   const vector2 = new Vector3();   const vector3 = new Vector3();   const vector4 = new Vector3();    for ( let i = 1; i <= divisions; i ++ ) {     point.copy( curve.getPointAt( i / divisions ) );    point.y = 0;     forward.subVectors( point, prevPoint );     const angle = Math.atan2( forward.x, forward.z );     quaternion.setFromAxisAngle( up, angle );     vector1.set( - 0.3, 0, 0 );    vector1.applyQuaternion( quaternion );    vector1.add( point );     vector2.set( 0.3, 0, 0 );    vector2.applyQuaternion( quaternion );    vector2.add( point );     vector3.set( 0.3, 0, 0 );    vector3.applyQuaternion( prevQuaternion );    vector3.add( prevPoint );     vector4.set( - 0.3, 0, 0 );    vector4.applyQuaternion( prevQuaternion );    vector4.add( prevPoint );     vertices.push( vector1.x, vector1.y, vector1.z );    vertices.push( vector2.x, vector2.y, vector2.z );    vertices.push( vector4.x, vector4.y, vector4.z );     vertices.push( vector2.x, vector2.y, vector2.z );    vertices.push( vector3.x, vector3.y, vector3.z );    vertices.push( vector4.x, vector4.y, vector4.z );     prevPoint.copy( point );    prevQuaternion.copy( quaternion );    }    this.setAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );   }  }  class SkyGeometry extends BufferGeometry {   constructor() {    super();    const vertices = [];    for ( let i = 0; i < 100; i ++ ) {     const x = Math.random() * 800 - 400;    const y = Math.random() * 50 + 50;    const z = Math.random() * 800 - 400;     const size = Math.random() * 40 + 20;     vertices.push( x - size, y, z - size );    vertices.push( x + size, y, z - size );    vertices.push( x - size, y, z + size );     vertices.push( x + size, y, z - size );    vertices.push( x + size, y, z + size );    vertices.push( x - size, y, z + size );    }     this.setAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );   }  }  class TreesGeometry extends BufferGeometry {   constructor( landscape ) {    super();    const vertices = [];   const colors = [];    const raycaster = new Raycaster();   raycaster.ray.direction.set( 0, - 1, 0 );    const _color = new Color();    for ( let i = 0; i < 2000; i ++ ) {     const x = Math.random() * 500 - 250;    const z = Math.random() * 500 - 250;     raycaster.ray.origin.set( x, 50, z );     const intersections = raycaster.intersectObject( landscape );     if ( intersections.length === 0 ) continue;     const y = intersections[ 0 ].point.y;     const height = Math.random() * 5 + 0.5;     let angle = Math.random() * Math.PI * 2;     vertices.push( x + Math.sin( angle ), y, z + Math.cos( angle ) );    vertices.push( x, y + height, z );    vertices.push( x + Math.sin( angle + Math.PI ), y, z + Math.cos( angle + Math.PI ) );     angle += Math.PI / 2;     vertices.push( x + Math.sin( angle ), y, z + Math.cos( angle ) );    vertices.push( x, y + height, z );    vertices.push( x + Math.sin( angle + Math.PI ), y, z + Math.cos( angle + Math.PI ) );     const random = Math.random() * 0.1;     for ( let j = 0; j < 6; j ++ ) {      _color.setRGB( 0.2 + random, 0.4 + random, 0, SRGBColorSpace );      colors.push( _color.r, _color.g, _color.b );     }    }    this.setAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );   this.setAttribute( 'color', new BufferAttribute( new Float32Array( colors ), 3 ) );   }  }  export { RollerCoasterGeometry, RollerCoasterLiftersGeometry, RollerCoasterShadowGeometry, SkyGeometry, TreesGeometry }; 
^..^ FILENAME ^..^
addons|misc|Timer.js
^..^ CONTENTS ^..^
class Timer {   constructor() {    this._previousTime = 0;   this._currentTime = 0;   this._startTime = now();    this._delta = 0;   this._elapsed = 0;    this._timescale = 1;    // use Page Visibility API to avoid large time delta values    this._usePageVisibilityAPI = ( typeof document !== 'undefined' && document.hidden !== undefined );    if ( this._usePageVisibilityAPI === true ) {     this._pageVisibilityHandler = handleVisibilityChange.bind( this );     document.addEventListener( 'visibilitychange', this._pageVisibilityHandler, false );    }   }   getDelta() {    return this._delta / 1000;   }   getElapsed() {    return this._elapsed / 1000;   }   getTimescale() {    return this._timescale;   }   setTimescale( timescale ) {    this._timescale = timescale;    return this;   }   reset() {    this._currentTime = now() - this._startTime;    return this;   }   dispose() {    if ( this._usePageVisibilityAPI === true ) {     document.removeEventListener( 'visibilitychange', this._pageVisibilityHandler );    }    return this;   }   update( timestamp ) {     if ( this._usePageVisibilityAPI === true && document.hidden === true ) {     this._delta = 0;    } else {     this._previousTime = this._currentTime;    this._currentTime = ( timestamp !== undefined ? timestamp : now() ) - this._startTime;     this._delta = ( this._currentTime - this._previousTime ) * this._timescale;    this._elapsed += this._delta; // _elapsed is the accumulation of all previous deltas    }    return this;   }  }  class FixedTimer extends Timer {   constructor( fps = 60 ) {    super();   this._delta = ( 1 / fps ) * 1000;   }   update() {    this._elapsed += ( this._delta * this._timescale ); // _elapsed is the accumulation of all previous deltas    return this;   }  }  function now() {   return performance.now();  }  function handleVisibilityChange() {   if ( document.hidden === false ) this.reset();  }  export { Timer, FixedTimer }; 
^..^ FILENAME ^..^
addons|misc|TubePainter.js
^..^ CONTENTS ^..^
import {  BufferAttribute,  BufferGeometry,  Color,  DynamicDrawUsage,  Matrix4,  Mesh,  MeshStandardMaterial,  Vector3 } from 'three';  function TubePainter() {   const BUFFER_SIZE = 1000000 * 3;   const positions = new BufferAttribute( new Float32Array( BUFFER_SIZE ), 3 );  positions.usage = DynamicDrawUsage;   const normals = new BufferAttribute( new Float32Array( BUFFER_SIZE ), 3 );  normals.usage = DynamicDrawUsage;   const colors = new BufferAttribute( new Float32Array( BUFFER_SIZE ), 3 );  colors.usage = DynamicDrawUsage;   const geometry = new BufferGeometry();  geometry.setAttribute( 'position', positions );  geometry.setAttribute( 'normal', normals );  geometry.setAttribute( 'color', colors );  geometry.drawRange.count = 0;   const material = new MeshStandardMaterial( {   vertexColors: true  } );   const mesh = new Mesh( geometry, material );  mesh.frustumCulled = false;   //   function getPoints( size ) {    const PI2 = Math.PI * 2;    const sides = 10;   const array = [];   const radius = 0.01 * size;    for ( let i = 0; i < sides; i ++ ) {     const angle = ( i / sides ) * PI2;    array.push( new Vector3( Math.sin( angle ) * radius, Math.cos( angle ) * radius, 0 ) );    }    return array;   }   //   const vector1 = new Vector3();  const vector2 = new Vector3();  const vector3 = new Vector3();  const vector4 = new Vector3();   const color = new Color( 0xffffff );  let size = 1;   function stroke( position1, position2, matrix1, matrix2 ) {    if ( position1.distanceToSquared( position2 ) === 0 ) return;    let count = geometry.drawRange.count;    const points = getPoints( size );    for ( let i = 0, il = points.length; i < il; i ++ ) {     const vertex1 = points[ i ];    const vertex2 = points[ ( i + 1 ) % il ];     // positions     vector1.copy( vertex1 ).applyMatrix4( matrix2 ).add( position2 );    vector2.copy( vertex2 ).applyMatrix4( matrix2 ).add( position2 );    vector3.copy( vertex2 ).applyMatrix4( matrix1 ).add( position1 );    vector4.copy( vertex1 ).applyMatrix4( matrix1 ).add( position1 );     vector1.toArray( positions.array, ( count + 0 ) * 3 );    vector2.toArray( positions.array, ( count + 1 ) * 3 );    vector4.toArray( positions.array, ( count + 2 ) * 3 );     vector2.toArray( positions.array, ( count + 3 ) * 3 );    vector3.toArray( positions.array, ( count + 4 ) * 3 );    vector4.toArray( positions.array, ( count + 5 ) * 3 );     // normals     vector1.copy( vertex1 ).applyMatrix4( matrix2 ).normalize();    vector2.copy( vertex2 ).applyMatrix4( matrix2 ).normalize();    vector3.copy( vertex2 ).applyMatrix4( matrix1 ).normalize();    vector4.copy( vertex1 ).applyMatrix4( matrix1 ).normalize();     vector1.toArray( normals.array, ( count + 0 ) * 3 );    vector2.toArray( normals.array, ( count + 1 ) * 3 );    vector4.toArray( normals.array, ( count + 2 ) * 3 );     vector2.toArray( normals.array, ( count + 3 ) * 3 );    vector3.toArray( normals.array, ( count + 4 ) * 3 );    vector4.toArray( normals.array, ( count + 5 ) * 3 );     // colors     color.toArray( colors.array, ( count + 0 ) * 3 );    color.toArray( colors.array, ( count + 1 ) * 3 );    color.toArray( colors.array, ( count + 2 ) * 3 );     color.toArray( colors.array, ( count + 3 ) * 3 );    color.toArray( colors.array, ( count + 4 ) * 3 );    color.toArray( colors.array, ( count + 5 ) * 3 );     count += 6;    }    geometry.drawRange.count = count;   }   //   const up = new Vector3( 0, 1, 0 );   const point1 = new Vector3();  const point2 = new Vector3();   const matrix1 = new Matrix4();  const matrix2 = new Matrix4();   function moveTo( position ) {    point1.copy( position );   matrix1.lookAt( point2, point1, up );    point2.copy( position );   matrix2.copy( matrix1 );   }   function lineTo( position ) {    point1.copy( position );   matrix1.lookAt( point2, point1, up );    stroke( point1, point2, matrix1, matrix2 );    point2.copy( point1 );   matrix2.copy( matrix1 );   }   function setSize( value ) {    size = value;   }   //   let count = 0;   function update() {    const start = count;   const end = geometry.drawRange.count;    if ( start === end ) return;    positions.addUpdateRange( start * 3, ( end - start ) * 3 );   positions.needsUpdate = true;    normals.addUpdateRange( start * 3, ( end - start ) * 3 );   normals.needsUpdate = true;    colors.addUpdateRange( start * 3, ( end - start ) * 3 );   colors.needsUpdate = true;    count = geometry.drawRange.count;   }   return {   mesh: mesh,   moveTo: moveTo,   lineTo: lineTo,   setSize: setSize,   update: update  };  }  export { TubePainter }; 
^..^ FILENAME ^..^
addons|misc|Volume.js
^..^ CONTENTS ^..^
import {  Matrix3,  Matrix4,  Vector3 } from 'three'; import { VolumeSlice } from '../misc/VolumeSlice.js';  /**  * This class had been written to handle the output of the NRRD loader.  * It contains a volume of data and informations about it.  * For now it only handles 3 dimensional data.  * See the webgl_loader_nrrd.html example and the loaderNRRD.js file to see how to use this class.  * @class  * @param   {number}        xLength         Width of the volume  * @param   {number}        yLength         Length of the volume  * @param   {number}        zLength         Depth of the volume  * @param   {string}        type            The type of data (uint8, uint16, ...)  * @param   {ArrayBuffer}   arrayBuffer     The buffer with volume data  */ class Volume {   constructor( xLength, yLength, zLength, type, arrayBuffer ) {    if ( xLength !== undefined ) {     /**     * @member {number} xLength Width of the volume in the IJK coordinate system     */    this.xLength = Number( xLength ) || 1;    /**     * @member {number} yLength Height of the volume in the IJK coordinate system     */    this.yLength = Number( yLength ) || 1;    /**     * @member {number} zLength Depth of the volume in the IJK coordinate system     */    this.zLength = Number( zLength ) || 1;    /**     * @member {Array<string>} The order of the Axis dictated by the NRRD header     */    this.axisOrder = [ 'x', 'y', 'z' ];    /**     * @member {TypedArray} data Data of the volume     */     switch ( type ) {      case 'Uint8' :     case 'uint8' :     case 'uchar' :     case 'unsigned char' :     case 'uint8_t' :      this.data = new Uint8Array( arrayBuffer );      break;     case 'Int8' :     case 'int8' :     case 'signed char' :     case 'int8_t' :      this.data = new Int8Array( arrayBuffer );      break;     case 'Int16' :     case 'int16' :     case 'short' :     case 'short int' :     case 'signed short' :     case 'signed short int' :     case 'int16_t' :      this.data = new Int16Array( arrayBuffer );      break;     case 'Uint16' :     case 'uint16' :     case 'ushort' :     case 'unsigned short' :     case 'unsigned short int' :     case 'uint16_t' :      this.data = new Uint16Array( arrayBuffer );      break;     case 'Int32' :     case 'int32' :     case 'int' :     case 'signed int' :     case 'int32_t' :      this.data = new Int32Array( arrayBuffer );      break;     case 'Uint32' :     case 'uint32' :     case 'uint' :     case 'unsigned int' :     case 'uint32_t' :      this.data = new Uint32Array( arrayBuffer );      break;     case 'longlong' :     case 'long long' :     case 'long long int' :     case 'signed long long' :     case 'signed long long int' :     case 'int64' :     case 'int64_t' :     case 'ulonglong' :     case 'unsigned long long' :     case 'unsigned long long int' :     case 'uint64' :     case 'uint64_t' :      throw new Error( 'Error in Volume constructor : this type is not supported in JavaScript' );      break;     case 'Float32' :     case 'float32' :     case 'float' :      this.data = new Float32Array( arrayBuffer );      break;     case 'Float64' :     case 'float64' :     case 'double' :      this.data = new Float64Array( arrayBuffer );      break;     default :      this.data = new Uint8Array( arrayBuffer );     }     if ( this.data.length !== this.xLength * this.yLength * this.zLength ) {      throw new Error( 'Error in Volume constructor, lengths are not matching arrayBuffer size' );     }    }    /**    * @member {Array}  spacing Spacing to apply to the volume from IJK to RAS coordinate system    */   this.spacing = [ 1, 1, 1 ];   /**    * @member {Array}  offset Offset of the volume in the RAS coordinate system    */   this.offset = [ 0, 0, 0 ];   /**    * @member {Martrix3} matrix The IJK to RAS matrix    */   this.matrix = new Matrix3();   this.matrix.identity();   /**    * @member {Martrix3} inverseMatrix The RAS to IJK matrix    */   /**    * @member {number} lowerThreshold The voxels with values under this threshold won't appear in the slices.    *                      If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume    */   let lowerThreshold = - Infinity;   Object.defineProperty( this, 'lowerThreshold', {    get: function () {      return lowerThreshold;     },    set: function ( value ) {      lowerThreshold = value;     this.sliceList.forEach( function ( slice ) {       slice.geometryNeedsUpdate = true;      } );     }   } );   /**    * @member {number} upperThreshold The voxels with values over this threshold won't appear in the slices.    *                      If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume    */   let upperThreshold = Infinity;   Object.defineProperty( this, 'upperThreshold', {    get: function () {      return upperThreshold;     },    set: function ( value ) {      upperThreshold = value;     this.sliceList.forEach( function ( slice ) {       slice.geometryNeedsUpdate = true;      } );     }   } );     /**    * @member {Array} sliceList The list of all the slices associated to this volume    */   this.sliceList = [];     /**    * @member {boolean} segmentation in segmentation mode, it can load 16-bits nrrds correctly    */   this.segmentation = false;     /**    * @member {Array} RASDimensions This array holds the dimensions of the volume in the RAS space    */     }   /**   * @member {Function} getData Shortcut for data[access(i,j,k)]   * @memberof Volume   * @param {number} i    First coordinate   * @param {number} j    Second coordinate   * @param {number} k    Third coordinate   * @returns {number}  value in the data array   */  getData( i, j, k ) {    return this.data[ k * this.xLength * this.yLength + j * this.xLength + i ];   }   /**   * @member {Function} access compute the index in the data array corresponding to the given coordinates in IJK system   * @memberof Volume   * @param {number} i    First coordinate   * @param {number} j    Second coordinate   * @param {number} k    Third coordinate   * @returns {number}  index   */  access( i, j, k ) {    return k * this.xLength * this.yLength + j * this.xLength + i;   }   /**   * @member {Function} reverseAccess Retrieve the IJK coordinates of the voxel corresponding of the given index in the data   * @memberof Volume   * @param {number} index index of the voxel   * @returns {Array}  [x,y,z]   */  reverseAccess( index ) {    const z = Math.floor( index / ( this.yLength * this.xLength ) );   const y = Math.floor( ( index - z * this.yLength * this.xLength ) / this.xLength );   const x = index - z * this.yLength * this.xLength - y * this.xLength;   return [ x, y, z ];   }   /**   * @member {Function} map Apply a function to all the voxels, be careful, the value will be replaced   * @memberof Volume   * @param {Function} functionToMap A function to apply to every voxel, will be called with the following parameters :   *                                 value of the voxel   *                                 index of the voxel   *                                 the data (TypedArray)   * @param {Object}   context    You can specify a context in which call the function, default if this Volume   * @returns {Volume}   this   */  map( functionToMap, context ) {    const length = this.data.length;   context = context || this;    for ( let i = 0; i < length; i ++ ) {     this.data[ i ] = functionToMap.call( context, this.data[ i ], i, this.data );    }    return this;   }   /**   * @member {Function} extractPerpendicularPlane Compute the orientation of the slice and returns all the information relative to the geometry such as sliceAccess, the plane matrix (orientation and position in RAS coordinate) and the dimensions of the plane in both coordinate system.   * @memberof Volume   * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'   * @param {number}            index the index of the slice   * @returns {Object} an object containing all the usefull information on the geometry of the slice   */  extractPerpendicularPlane( axis, RASIndex ) {    let firstSpacing,    secondSpacing,    positionOffset,    IJKIndex;    const axisInIJK = new Vector3(),    firstDirection = new Vector3(),    secondDirection = new Vector3(),    planeMatrix = ( new Matrix4() ).identity(),    volume = this;    const dimensions = new Vector3( this.xLength, this.yLength, this.zLength );     switch ( axis ) {     case 'x' :     axisInIJK.set( 1, 0, 0 );     firstDirection.set( 0, 0, - 1 );     secondDirection.set( 0, - 1, 0 );     firstSpacing = this.spacing[ this.axisOrder.indexOf( 'z' ) ];     secondSpacing = this.spacing[ this.axisOrder.indexOf( 'y' ) ];     IJKIndex = new Vector3( RASIndex, 0, 0 );      planeMatrix.multiply( ( new Matrix4() ).makeRotationY( Math.PI / 2 ) );     positionOffset = ( volume.RASDimensions[ 0 ] - 1 ) / 2;     planeMatrix.setPosition( new Vector3( RASIndex - positionOffset, 0, 0 ) );     break;    case 'y' :     axisInIJK.set( 0, 1, 0 );     firstDirection.set( 1, 0, 0 );     secondDirection.set( 0, 0, 1 );     firstSpacing = this.spacing[ this.axisOrder.indexOf( 'x' ) ];     secondSpacing = this.spacing[ this.axisOrder.indexOf( 'z' ) ];     IJKIndex = new Vector3( 0, RASIndex, 0 );      planeMatrix.multiply( ( new Matrix4() ).makeRotationX( - Math.PI / 2 ) );     positionOffset = ( volume.RASDimensions[ 1 ] - 1 ) / 2;     planeMatrix.setPosition( new Vector3( 0, RASIndex - positionOffset, 0 ) );     break;    case 'z' :    default :     axisInIJK.set( 0, 0, 1 );     firstDirection.set( 1, 0, 0 );     secondDirection.set( 0, - 1, 0 );     firstSpacing = this.spacing[ this.axisOrder.indexOf( 'x' ) ];     secondSpacing = this.spacing[ this.axisOrder.indexOf( 'y' ) ];     IJKIndex = new Vector3( 0, 0, RASIndex );      positionOffset = ( volume.RASDimensions[ 2 ] - 1 ) / 2;     planeMatrix.setPosition( new Vector3( 0, 0, RASIndex - positionOffset ) );     break;    }    if ( ! this.segmentation ) {     firstDirection.applyMatrix4( volume.inverseMatrix ).normalize();    secondDirection.applyMatrix4( volume.inverseMatrix ).normalize();    axisInIJK.applyMatrix4( volume.inverseMatrix ).normalize();    }    firstDirection.arglet = 'i';   secondDirection.arglet = 'j';   const iLength = Math.floor( Math.abs( firstDirection.dot( dimensions ) ) );   const jLength = Math.floor( Math.abs( secondDirection.dot( dimensions ) ) );   const planeWidth = Math.abs( iLength * firstSpacing );   const planeHeight = Math.abs( jLength * secondSpacing );    IJKIndex = Math.abs( Math.round( IJKIndex.applyMatrix4( volume.inverseMatrix ).dot( axisInIJK ) ) );   const base = [ new Vector3( 1, 0, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ) ];   const iDirection = [ firstDirection, secondDirection, axisInIJK ].find( function ( x ) {     return Math.abs( x.dot( base[ 0 ] ) ) > 0.9;    } );   const jDirection = [ firstDirection, secondDirection, axisInIJK ].find( function ( x ) {     return Math.abs( x.dot( base[ 1 ] ) ) > 0.9;    } );   const kDirection = [ firstDirection, secondDirection, axisInIJK ].find( function ( x ) {     return Math.abs( x.dot( base[ 2 ] ) ) > 0.9;    } );    function sliceAccess( i, j ) {     const si = ( iDirection === axisInIJK ) ? IJKIndex : ( iDirection.arglet === 'i' ? i : j );    const sj = ( jDirection === axisInIJK ) ? IJKIndex : ( jDirection.arglet === 'i' ? i : j );    const sk = ( kDirection === axisInIJK ) ? IJKIndex : ( kDirection.arglet === 'i' ? i : j );     // invert indices if necessary     const accessI = ( iDirection.dot( base[ 0 ] ) > 0 ) ? si : ( volume.xLength - 1 ) - si;    const accessJ = ( jDirection.dot( base[ 1 ] ) > 0 ) ? sj : ( volume.yLength - 1 ) - sj;    const accessK = ( kDirection.dot( base[ 2 ] ) > 0 ) ? sk : ( volume.zLength - 1 ) - sk;     return volume.access( accessI, accessJ, accessK );    }    return {    iLength: iLength,    jLength: jLength,    sliceAccess: sliceAccess,    matrix: planeMatrix,    planeWidth: planeWidth,    planeHeight: planeHeight   };   }   /**   * @member {Function} extractSlice Returns a slice corresponding to the given axis and index   *                        The coordinate are given in the Right Anterior Superior coordinate format   * @memberof Volume   * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'   * @param {number}            index the index of the slice   * @returns {VolumeSlice} the extracted slice   */  extractSlice( axis, index ) {    const slice = new VolumeSlice( this, index, axis );   this.sliceList.push( slice );   return slice;   }   /**   * @member {Function} repaintAllSlices Call repaint on all the slices extracted from this volume   * @see VolumeSlice.repaint   * @memberof Volume   * @returns {Volume} this   */  repaintAllSlices() {    this.sliceList.forEach( function ( slice ) {     slice.repaint();    } );    return this;   }   /**   * @member {Function} computeMinMax Compute the minimum and the maximum of the data in the volume   * @memberof Volume   * @returns {Array} [min,max]   */  computeMinMax() {    let min = Infinity;   let max = - Infinity;    // buffer the length   const datasize = this.data.length;    let i = 0;    for ( i = 0; i < datasize; i ++ ) {     if ( ! isNaN( this.data[ i ] ) ) {      const value = this.data[ i ];     min = Math.min( min, value );     max = Math.max( max, value );     }    }    this.min = min;   this.max = max;    return [ min, max ];   }  }  export { Volume }; 
^..^ FILENAME ^..^
addons|misc|VolumeSlice.js
^..^ CONTENTS ^..^
import {  ClampToEdgeWrapping,  DoubleSide,  LinearFilter,  Mesh,  MeshBasicMaterial,  PlaneGeometry,  Texture,  SRGBColorSpace } from 'three';  /**  * This class has been made to hold a slice of a volume data  * @class  * @param   {Volume} volume    The associated volume  * @param   {number}       [index=0] The index of the slice  * @param   {string}       [axis='z']      For now only 'x', 'y' or 'z' but later it will change to a normal vector  * @see Volume  */ class VolumeSlice {   constructor( volume, index, axis ) {    const slice = this;   /**    * @member {Volume} volume The associated volume    */   this.volume = volume;   /**    * @member {Number} index The index of the slice, if changed, will automatically call updateGeometry at the next repaint    */   index = index || 0;   Object.defineProperty( this, 'index', {    get: function () {      return index;     },    set: function ( value ) {      index = value;     slice.geometryNeedsUpdate = true;     return index;     }   } );   /**    * @member {String} axis The normal axis    */   this.axis = axis || 'z';    /**    * @member {HTMLCanvasElement} canvas The final canvas used for the texture    */   /**    * @member {CanvasRenderingContext2D} ctx Context of the canvas    */   this.canvas = document.createElement( 'canvas' );   /**    * @member {HTMLCanvasElement} canvasBuffer The intermediary canvas used to paint the data    */   /**    * @member {CanvasRenderingContext2D} ctxBuffer Context of the canvas buffer    */   this.canvasBuffer = document.createElement( 'canvas' );   this.updateGeometry();     const canvasMap = new Texture( this.canvas );   canvasMap.minFilter = LinearFilter;   canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;   canvasMap.colorSpace = SRGBColorSpace;   const material = new MeshBasicMaterial( { map: canvasMap, side: DoubleSide, transparent: true } );   /**    * @member {Mesh} mesh The mesh ready to get used in the scene    */   this.mesh = new Mesh( this.geometry, material );   this.mesh.matrixAutoUpdate = false;   /**    * @member {Boolean} geometryNeedsUpdate If set to true, updateGeometry will be triggered at the next repaint    */   this.geometryNeedsUpdate = true;   this.repaint();    /**    * @member {Number} iLength Width of slice in the original coordinate system, corresponds to the width of the buffer canvas    */    /**    * @member {Number} jLength Height of slice in the original coordinate system, corresponds to the height of the buffer canvas    */    /**    * @member {Function} sliceAccess Function that allow the slice to access right data    * @see Volume.extractPerpendicularPlane    * @param {Number} i The first coordinate    * @param {Number} j The second coordinate    * @returns {Number} the index corresponding to the voxel in volume.data of the given position in the slice    */    }   /**   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true   * @memberof VolumeSlice   */  repaint() {    if ( this.geometryNeedsUpdate ) {     this.updateGeometry();    }    const iLength = this.iLength,    jLength = this.jLength,    sliceAccess = this.sliceAccess,    volume = this.volume,    canvas = this.canvasBuffer,    ctx = this.ctxBuffer;     // get the imageData and pixel array from the canvas   const imgData = ctx.getImageData( 0, 0, iLength, jLength );   const data = imgData.data;   const volumeData = volume.data;   const upperThreshold = volume.upperThreshold;   const lowerThreshold = volume.lowerThreshold;   const windowLow = volume.windowLow;   const windowHigh = volume.windowHigh;    // manipulate some pixel elements   let pixelCount = 0;    if ( volume.dataType === 'label' ) {     //this part is currently useless but will be used when colortables will be handled    for ( let j = 0; j < jLength; j ++ ) {      for ( let i = 0; i < iLength; i ++ ) {       let label = volumeData[ sliceAccess( i, j ) ];      label = label >= this.colorMap.length ? ( label % this.colorMap.length ) + 1 : label;      const color = this.colorMap[ label ];      data[ 4 * pixelCount ] = ( color >> 24 ) & 0xff;      data[ 4 * pixelCount + 1 ] = ( color >> 16 ) & 0xff;      data[ 4 * pixelCount + 2 ] = ( color >> 8 ) & 0xff;      data[ 4 * pixelCount + 3 ] = color & 0xff;      pixelCount ++;      }     }    } else {     for ( let j = 0; j < jLength; j ++ ) {      for ( let i = 0; i < iLength; i ++ ) {       let value = volumeData[ sliceAccess( i, j ) ];      let alpha = 0xff;      //apply threshold      alpha = upperThreshold >= value ? ( lowerThreshold <= value ? alpha : 0 ) : 0;      //apply window level      value = Math.floor( 255 * ( value - windowLow ) / ( windowHigh - windowLow ) );      value = value > 255 ? 255 : ( value < 0 ? 0 : value | 0 );       data[ 4 * pixelCount ] = value;      data[ 4 * pixelCount + 1 ] = value;      data[ 4 * pixelCount + 2 ] = value;      data[ 4 * pixelCount + 3 ] = alpha;      pixelCount ++;      }     }    }    ctx.putImageData( imgData, 0, 0 );   this.ctx.drawImage( canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height );     this.mesh.material.map.needsUpdate = true;   }   /**   * @member {Function} Refresh the geometry according to axis and index   * @see Volume.extractPerpendicularPlane   * @memberof VolumeSlice   */  updateGeometry() {    const extracted = this.volume.extractPerpendicularPlane( this.axis, this.index );   this.sliceAccess = extracted.sliceAccess;   this.jLength = extracted.jLength;   this.iLength = extracted.iLength;   this.matrix = extracted.matrix;    this.canvas.width = extracted.planeWidth;   this.canvas.height = extracted.planeHeight;   this.canvasBuffer.width = this.iLength;   this.canvasBuffer.height = this.jLength;   this.ctx = this.canvas.getContext( '2d' );   this.ctxBuffer = this.canvasBuffer.getContext( '2d' );    if ( this.geometry ) this.geometry.dispose(); // dispose existing geometry    this.geometry = new PlaneGeometry( extracted.planeWidth, extracted.planeHeight );    if ( this.mesh ) {     this.mesh.geometry = this.geometry;    //reset mesh matrix    this.mesh.matrix.identity();    this.mesh.applyMatrix4( this.matrix );    }    this.geometryNeedsUpdate = false;   }  }  export { VolumeSlice }; 
^..^ FILENAME ^..^
addons|modifiers|CurveModifier.js
^..^ CONTENTS ^..^
// Original src: https://github.com/zz85/threejs-path-flow const CHANNELS = 4; const TEXTURE_WIDTH = 1024; const TEXTURE_HEIGHT = 4;  import {  DataTexture,  DataUtils,  RGBAFormat,  HalfFloatType,  RepeatWrapping,  Mesh,  InstancedMesh,  LinearFilter,  DynamicDrawUsage,  Matrix4 } from 'three';  /**  * Make a new DataTexture to store the descriptions of the curves.  *  * @param { number } numberOfCurves the number of curves needed to be described by this texture.  */ export function initSplineTexture( numberOfCurves = 1 ) {   const dataArray = new Uint16Array( TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS );  const dataTexture = new DataTexture(   dataArray,   TEXTURE_WIDTH,   TEXTURE_HEIGHT * numberOfCurves,   RGBAFormat,   HalfFloatType  );   dataTexture.wrapS = RepeatWrapping;  dataTexture.wrapY = RepeatWrapping;  dataTexture.magFilter = LinearFilter;  dataTexture.minFilter = LinearFilter;  dataTexture.needsUpdate = true;   return dataTexture;  }  /**  * Write the curve description to the data texture  *  * @param { DataTexture } texture The DataTexture to write to  * @param { Curve } splineCurve The curve to describe  * @param { number } offset Which curve slot to write to  */ export function updateSplineTexture( texture, splineCurve, offset = 0 ) {   const numberOfPoints = Math.floor( TEXTURE_WIDTH * ( TEXTURE_HEIGHT / 4 ) );  splineCurve.arcLengthDivisions = numberOfPoints / 2;  splineCurve.updateArcLengths();  const points = splineCurve.getSpacedPoints( numberOfPoints );  const frenetFrames = splineCurve.computeFrenetFrames( numberOfPoints, true );   for ( let i = 0; i < numberOfPoints; i ++ ) {    const rowOffset = Math.floor( i / TEXTURE_WIDTH );   const rowIndex = i % TEXTURE_WIDTH;    let pt = points[ i ];   setTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + ( TEXTURE_HEIGHT * offset ) );   pt = frenetFrames.tangents[ i ];   setTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + ( TEXTURE_HEIGHT * offset ) );   pt = frenetFrames.normals[ i ];   setTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + ( TEXTURE_HEIGHT * offset ) );   pt = frenetFrames.binormals[ i ];   setTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + ( TEXTURE_HEIGHT * offset ) );   }   texture.needsUpdate = true;  }   function setTextureValue( texture, index, x, y, z, o ) {   const image = texture.image;  const { data } = image;  const i = CHANNELS * TEXTURE_WIDTH * o; // Row Offset  data[ index * CHANNELS + i + 0 ] = DataUtils.toHalfFloat( x );  data[ index * CHANNELS + i + 1 ] = DataUtils.toHalfFloat( y );  data[ index * CHANNELS + i + 2 ] = DataUtils.toHalfFloat( z );  data[ index * CHANNELS + i + 3 ] = DataUtils.toHalfFloat( 1 );  }  /**  * Create a new set of uniforms for describing the curve modifier  *  * @param { DataTexture } Texture which holds the curve description  */ export function getUniforms( splineTexture ) {   const uniforms = {   spineTexture: { value: splineTexture },   pathOffset: { type: 'f', value: 0 }, // time of path curve   pathSegment: { type: 'f', value: 1 }, // fractional length of path   spineOffset: { type: 'f', value: 161 },   spineLength: { type: 'f', value: 400 },   flow: { type: 'i', value: 1 },  };  return uniforms;  }  export function modifyShader( material, uniforms, numberOfCurves = 1 ) {   if ( material.__ok ) return;  material.__ok = true;   material.onBeforeCompile = ( shader ) => {    if ( shader.__modified ) return;   shader.__modified = true;    Object.assign( shader.uniforms, uniforms );    const vertexShader = |   uniform sampler2D spineTexture;   uniform float pathOffset;   uniform float pathSegment;   uniform float spineOffset;   uniform float spineLength;   uniform int flow;    float textureLayers = |TEXTURE_HEIGHT * numberOfCurves}.;   float textureStacks = |TEXTURE_HEIGHT / 4}.;    |shader.vertexShader}   |   // chunk import moved in front of modified shader below    .replace( '#include <beginnormal_vertex>', '' )     // vec3 transformedNormal declaration overriden below    .replace( '#include <defaultnormal_vertex>', '' )     // vec3 transformed declaration overriden below    .replace( '#include <begin_vertex>', '' )     // shader override    .replace(     /void|s*main|s*|(|)|s*|{/,     | void main() { #include <beginnormal_vertex>  vec4 worldPos = modelMatrix * vec4(position, 1.);  bool bend = flow > 0; float xWeight = bend ? 0. : 1.;  #ifdef USE_INSTANCING float pathOffsetFromInstanceMatrix = instanceMatrix[3][2]; float spineLengthFromInstanceMatrix = instanceMatrix[3][0]; float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.; float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks; #else float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.; float mt = (spinePortion * pathSegment + pathOffset)*textureStacks; #endif  mt = mod(mt, textureStacks); float rowOffset = floor(mt);  #ifdef USE_INSTANCING rowOffset += instanceMatrix[3][1] * |TEXTURE_HEIGHT}.; #endif  vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz; vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz; vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz; vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz; mat3 basis = mat3(a, b, c);  vec3 transformed = basis  * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)  + spinePos;  vec3 transformedNormal = normalMatrix * (basis * objectNormal);    | ).replace(     '#include <project_vertex>',     |vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );     gl_Position = projectionMatrix * mvPosition;|    );    shader.vertexShader = vertexShader;   };  }  /**  * A helper class for making meshes bend aroudn curves  */ export class Flow {   /**   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves   */  constructor( mesh, numberOfCurves = 1 ) {    const obj3D = mesh.clone();   const splineTexure = initSplineTexture( numberOfCurves );   const uniforms = getUniforms( splineTexure );   obj3D.traverse( function ( child ) {     if (     child instanceof Mesh ||     child instanceof InstancedMesh    ) {      if ( Array.isArray( child.material ) ) {       const materials = [];       for ( const material of child.material ) {        const newMaterial = material.clone();       modifyShader( newMaterial, uniforms, numberOfCurves );       materials.push( newMaterial );       }       child.material = materials;      } else {       child.material = child.material.clone();      modifyShader( child.material, uniforms, numberOfCurves );      }     }    } );    this.curveArray = new Array( numberOfCurves );   this.curveLengthArray = new Array( numberOfCurves );    this.object3D = obj3D;   this.splineTexure = splineTexure;   this.uniforms = uniforms;   }   updateCurve( index, curve ) {    if ( index >= this.curveArray.length ) throw Error( 'Index out of range for Flow' );   const curveLength = curve.getLength();   this.uniforms.spineLength.value = curveLength;   this.curveLengthArray[ index ] = curveLength;   this.curveArray[ index ] = curve;   updateSplineTexture( this.splineTexure, curve, index );   }   moveAlongCurve( amount ) {    this.uniforms.pathOffset.value += amount;   }  } const matrix = new Matrix4();  /**  * A helper class for creating instanced versions of flow, where the instances are placed on the curve.  */ export class InstancedFlow extends Flow {   /**   *   * @param {number} count The number of instanced elements   * @param {number} curveCount The number of curves to preallocate for   * @param {Geometry} geometry The geometry to use for the instanced mesh   * @param {Material} material The material to use for the instanced mesh   */  constructor( count, curveCount, geometry, material ) {    const mesh = new InstancedMesh(    geometry,    material,    count   );   mesh.instanceMatrix.setUsage( DynamicDrawUsage );   mesh.frustumCulled = false;   super( mesh, curveCount );    this.offsets = new Array( count ).fill( 0 );   this.whichCurve = new Array( count ).fill( 0 );   }   /**   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects   * This writes that information to the matrix and marks it as needing update.   *   * @param {number} index of the instanced element to update   */  writeChanges( index ) {    matrix.makeTranslation(    this.curveLengthArray[ this.whichCurve[ index ] ],    this.whichCurve[ index ],    this.offsets[ index ]   );   this.object3D.setMatrixAt( index, matrix );   this.object3D.instanceMatrix.needsUpdate = true;   }   /**   * Move an individual element along the curve by a specific amount   *   * @param {number} index Which element to update   * @param {number} offset Move by how much   */  moveIndividualAlongCurve( index, offset ) {    this.offsets[ index ] += offset;   this.writeChanges( index );   }   /**   * Select which curve to use for an element   *   * @param {number} index the index of the instanced element to update   * @param {number} curveNo the index of the curve it should use   */  setCurve( index, curveNo ) {    if ( isNaN( curveNo ) ) throw Error( 'curve index being set is Not a Number (NaN)' );   this.whichCurve[ index ] = curveNo;   this.writeChanges( index );   }  } 
^..^ FILENAME ^..^
addons|modifiers|CurveModifierGPU.js
^..^ CONTENTS ^..^
// Original src: https://github.com/zz85/threejs-path-flow const CHANNELS = 4; const TEXTURE_WIDTH = 1024; const TEXTURE_HEIGHT = 4;  import {  DataTexture,  DataUtils,  RGBAFormat,  HalfFloatType,  RepeatWrapping,  Mesh,  InstancedMesh,  LinearFilter } from 'three';  import { modelWorldMatrix, normalLocal, vec2, vec3, vec4, mat3, varyingProperty, texture, reference, Fn, select, positionLocal } from 'three/tsl';  /**  * Make a new DataTexture to store the descriptions of the curves.  *  * @param { number } numberOfCurves the number of curves needed to be described by this texture.  */ export function initSplineTexture( numberOfCurves = 1 ) {   const dataArray = new Uint16Array( TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS );  const dataTexture = new DataTexture(   dataArray,   TEXTURE_WIDTH,   TEXTURE_HEIGHT * numberOfCurves,   RGBAFormat,   HalfFloatType  );   dataTexture.wrapS = RepeatWrapping;  dataTexture.wrapY = RepeatWrapping;  dataTexture.magFilter = LinearFilter;  dataTexture.minFilter = LinearFilter;  dataTexture.needsUpdate = true;   return dataTexture;  }  /**  * Write the curve description to the data texture  *  * @param { DataTexture } texture The DataTexture to write to  * @param { Curve } splineCurve The curve to describe  * @param { number } offset Which curve slot to write to  */ export function updateSplineTexture( texture, splineCurve, offset = 0 ) {   const numberOfPoints = Math.floor( TEXTURE_WIDTH * ( TEXTURE_HEIGHT / 4 ) );  splineCurve.arcLengthDivisions = numberOfPoints / 2;  splineCurve.updateArcLengths();  const points = splineCurve.getSpacedPoints( numberOfPoints );  const frenetFrames = splineCurve.computeFrenetFrames( numberOfPoints, true );   for ( let i = 0; i < numberOfPoints; i ++ ) {    const rowOffset = Math.floor( i / TEXTURE_WIDTH );   const rowIndex = i % TEXTURE_WIDTH;    let pt = points[ i ];   setTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + ( TEXTURE_HEIGHT * offset ) );   pt = frenetFrames.tangents[ i ];   setTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + ( TEXTURE_HEIGHT * offset ) );   pt = frenetFrames.normals[ i ];   setTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + ( TEXTURE_HEIGHT * offset ) );   pt = frenetFrames.binormals[ i ];   setTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + ( TEXTURE_HEIGHT * offset ) );   }   texture.needsUpdate = true;  }   function setTextureValue( texture, index, x, y, z, o ) {   const image = texture.image;  const { data } = image;  const i = CHANNELS * TEXTURE_WIDTH * o; // Row Offset   data[ index * CHANNELS + i + 0 ] = DataUtils.toHalfFloat( x );  data[ index * CHANNELS + i + 1 ] = DataUtils.toHalfFloat( y );  data[ index * CHANNELS + i + 2 ] = DataUtils.toHalfFloat( z );  data[ index * CHANNELS + i + 3 ] = DataUtils.toHalfFloat( 1 );  }  /**  * Create a new set of uniforms for describing the curve modifier  *  * @param { DataTexture } Texture which holds the curve description  */ export function getUniforms( splineTexture ) {   return {   spineTexture: splineTexture,   pathOffset: 0, // time of path curve   pathSegment: 1, // fractional length of path   spineOffset: 161,   spineLength: 400,   flow: 1, // int  };  }  export function modifyShader( material, uniforms, numberOfCurves ) {   const spineTexture = uniforms.spineTexture;   const pathOffset = reference( 'pathOffset', 'float', uniforms );  const pathSegment = reference( 'pathSegment', 'float', uniforms );  const spineOffset = reference( 'spineOffset', 'float', uniforms );  const spineLength = reference( 'spineLength', 'float', uniforms );  const flow = reference( 'flow', 'float', uniforms );   material.positionNode = Fn( () => {    const textureStacks = TEXTURE_HEIGHT / 4;   const textureScale = TEXTURE_HEIGHT * numberOfCurves;    const worldPos = modelWorldMatrix.mul( vec4( positionLocal, 1 ) ).toVar();    const bend = flow.greaterThan( 0 ).toVar();   const xWeight = select( bend, 0, 1 ).toVar();    const spinePortion = select( bend, worldPos.x.add( spineOffset ).div( spineLength ), 0 );   const mt = spinePortion.mul( pathSegment ).add( pathOffset ).mul( textureStacks ).toVar();    mt.assign( mt.mod( textureStacks ) );    const rowOffset = mt.floor().toVar();    const spinePos = texture( spineTexture, vec2( mt, rowOffset.add( 0.5 ).div( textureScale ) ) ).xyz;    const a = texture( spineTexture, vec2( mt, rowOffset.add( 1.5 ).div( textureScale ) ) ).xyz;   const b = texture( spineTexture, vec2( mt, rowOffset.add( 2.5 ).div( textureScale ) ) ).xyz;   const c = texture( spineTexture, vec2( mt, rowOffset.add( 3.5 ).div( textureScale ) ) ).xyz;    const basis = mat3( a, b, c ).toVar();    varyingProperty( 'vec3', 'curveNormal' ).assign( basis.mul( normalLocal ) );    return basis.mul( vec3( worldPos.x.mul( xWeight ), worldPos.y, worldPos.z ) ).add( spinePos );   } )();   material.normalNode = varyingProperty( 'vec3', 'curveNormal' );  }  /**  * A helper class for making meshes bend aroudn curves  */ export class Flow {   /**   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves   */  constructor( mesh, numberOfCurves = 1 ) {    const obj3D = mesh.clone();   const splineTexure = initSplineTexture( numberOfCurves );   const uniforms = getUniforms( splineTexure );    obj3D.traverse( function ( child ) {     if (     child instanceof Mesh ||     child instanceof InstancedMesh    ) {      if ( Array.isArray( child.material ) ) {       const materials = [];       for ( const material of child.material ) {        const newMaterial = material.clone();       modifyShader( newMaterial, uniforms, numberOfCurves );       materials.push( newMaterial );       }       child.material = materials;      } else {       child.material = child.material.clone();      modifyShader( child.material, uniforms, numberOfCurves );      }     }    } );    this.curveArray = new Array( numberOfCurves );   this.curveLengthArray = new Array( numberOfCurves );    this.object3D = obj3D;   this.splineTexure = splineTexure;   this.uniforms = uniforms;   }   updateCurve( index, curve ) {    if ( index >= this.curveArray.length ) throw Error( 'Index out of range for Flow' );    const curveLength = curve.getLength();    this.uniforms.spineLength = curveLength;   this.curveLengthArray[ index ] = curveLength;   this.curveArray[ index ] = curve;    updateSplineTexture( this.splineTexure, curve, index );   }   moveAlongCurve( amount ) {    this.uniforms.pathOffset += amount;   }  } 
^..^ FILENAME ^..^
addons|modifiers|EdgeSplitModifier.js
^..^ CONTENTS ^..^
import {  BufferAttribute,  BufferGeometry,  Vector3 } from 'three'; import * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';  const _A = new Vector3(); const _B = new Vector3(); const _C = new Vector3();  class EdgeSplitModifier {   modify( geometry, cutOffAngle, tryKeepNormals = true ) {    function computeNormals() {     normals = new Float32Array( indexes.length * 3 );     for ( let i = 0; i < indexes.length; i += 3 ) {      let index = indexes[ i ];      _A.set(      positions[ 3 * index ],      positions[ 3 * index + 1 ],      positions[ 3 * index + 2 ] );      index = indexes[ i + 1 ];     _B.set(      positions[ 3 * index ],      positions[ 3 * index + 1 ],      positions[ 3 * index + 2 ] );      index = indexes[ i + 2 ];     _C.set(      positions[ 3 * index ],      positions[ 3 * index + 1 ],      positions[ 3 * index + 2 ] );      _C.sub( _B );     _A.sub( _B );      const normal = _C.cross( _A ).normalize();      for ( let j = 0; j < 3; j ++ ) {       normals[ 3 * ( i + j ) ] = normal.x;      normals[ 3 * ( i + j ) + 1 ] = normal.y;      normals[ 3 * ( i + j ) + 2 ] = normal.z;      }     }    }     function mapPositionsToIndexes() {     pointToIndexMap = Array( positions.length / 3 );     for ( let i = 0; i < indexes.length; i ++ ) {      const index = indexes[ i ];      if ( pointToIndexMap[ index ] == null ) {       pointToIndexMap[ index ] = [];      }      pointToIndexMap[ index ].push( i );     }    }     function edgeSplitToGroups( indexes, cutOff, firstIndex ) {     _A.set( normals[ 3 * firstIndex ], normals[ 3 * firstIndex + 1 ], normals[ 3 * firstIndex + 2 ] ).normalize();     const result = {     splitGroup: [],     currentGroup: [ firstIndex ]    };     for ( const j of indexes ) {      if ( j !== firstIndex ) {       _B.set( normals[ 3 * j ], normals[ 3 * j + 1 ], normals[ 3 * j + 2 ] ).normalize();       if ( _B.dot( _A ) < cutOff ) {        result.splitGroup.push( j );       } else {        result.currentGroup.push( j );       }      }     }     return result;    }     function edgeSplit( indexes, cutOff, original = null ) {     if ( indexes.length === 0 ) return;     const groupResults = [];     for ( const index of indexes ) {      groupResults.push( edgeSplitToGroups( indexes, cutOff, index ) );     }     let result = groupResults[ 0 ];     for ( const groupResult of groupResults ) {      if ( groupResult.currentGroup.length > result.currentGroup.length ) {       result = groupResult;      }     }      if ( original != null ) {      splitIndexes.push( {      original: original,      indexes: result.currentGroup     } );     }     if ( result.splitGroup.length ) {      edgeSplit( result.splitGroup, cutOff, original || result.currentGroup[ 0 ] );     }    }    let hadNormals = false;   let oldNormals = null;    if ( geometry.attributes.normal ) {     hadNormals = true;     geometry = geometry.clone();     if ( tryKeepNormals === true && geometry.index !== null ) {      oldNormals = geometry.attributes.normal.array;     }     geometry.deleteAttribute( 'normal' );    }    if ( geometry.index == null ) {     geometry = BufferGeometryUtils.mergeVertices( geometry );    }    const indexes = geometry.index.array;   const positions = geometry.getAttribute( 'position' ).array;    let normals;   let pointToIndexMap;    computeNormals();   mapPositionsToIndexes();    const splitIndexes = [];    for ( const vertexIndexes of pointToIndexMap ) {     edgeSplit( vertexIndexes, Math.cos( cutOffAngle ) - 0.001 );    }    const newAttributes = {};   for ( const name of Object.keys( geometry.attributes ) ) {     const oldAttribute = geometry.attributes[ name ];    const newArray = new oldAttribute.array.constructor( ( indexes.length + splitIndexes.length ) * oldAttribute.itemSize );    newArray.set( oldAttribute.array );    newAttributes[ name ] = new BufferAttribute( newArray, oldAttribute.itemSize, oldAttribute.normalized );    }    const newIndexes = new Uint32Array( indexes.length );   newIndexes.set( indexes );    for ( let i = 0; i < splitIndexes.length; i ++ ) {     const split = splitIndexes[ i ];    const index = indexes[ split.original ];     for ( const attribute of Object.values( newAttributes ) ) {      for ( let j = 0; j < attribute.itemSize; j ++ ) {       attribute.array[ ( indexes.length + i ) * attribute.itemSize + j ] =       attribute.array[ index * attribute.itemSize + j ];      }     }     for ( const j of split.indexes ) {      newIndexes[ j ] = indexes.length + i;     }    }    geometry = new BufferGeometry();   geometry.setIndex( new BufferAttribute( newIndexes, 1 ) );    for ( const name of Object.keys( newAttributes ) ) {     geometry.setAttribute( name, newAttributes[ name ] );    }    if ( hadNormals ) {     geometry.computeVertexNormals();     if ( oldNormals !== null ) {      const changedNormals = new Array( oldNormals.length / 3 ).fill( false );      for ( const splitData of splitIndexes )      changedNormals[ splitData.original ] = true;      for ( let i = 0; i < changedNormals.length; i ++ ) {       if ( changedNormals[ i ] === false ) {        for ( let j = 0; j < 3; j ++ )        geometry.attributes.normal.array[ 3 * i + j ] = oldNormals[ 3 * i + j ];       }      }      }    }    return geometry;   }  }    export { EdgeSplitModifier }; 
^..^ FILENAME ^..^
addons|modifiers|SimplifyModifier.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  Color,  Float32BufferAttribute,  Vector2,  Vector3,  Vector4 } from 'three'; import * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';  /**  * Simplification Geometry Modifier  *    - based on code and technique  *   - by Stan Melax in 1998  *   - Progressive Mesh type Polygon Reduction Algorithm  *    - http://www.melax.com/polychop/  */  const _cb = new Vector3(), _ab = new Vector3();  class SimplifyModifier {   modify( geometry, count ) {    geometry = geometry.clone();    // currently morphAttributes are not supported   delete geometry.morphAttributes.position;   delete geometry.morphAttributes.normal;   const attributes = geometry.attributes;    // this modifier can only process indexed and non-indexed geomtries with at least a position attribute    for ( const name in attributes ) {     if ( name !== 'position' && name !== 'uv' && name !== 'normal' && name !== 'tangent' && name !== 'color' ) geometry.deleteAttribute( name );    }    geometry = BufferGeometryUtils.mergeVertices( geometry );    //   // put data of original geometry in different data structures   //    const vertices = [];   const faces = [];    // add vertices    const positionAttribute = geometry.getAttribute( 'position' );   const uvAttribute = geometry.getAttribute( 'uv' );   const normalAttribute = geometry.getAttribute( 'normal' );   const tangentAttribute = geometry.getAttribute( 'tangent' );   const colorAttribute = geometry.getAttribute( 'color' );    let t = null;   let v2 = null;   let nor = null;   let col = null;    for ( let i = 0; i < positionAttribute.count; i ++ ) {     const v = new Vector3().fromBufferAttribute( positionAttribute, i );    if ( uvAttribute ) {      v2 = new Vector2().fromBufferAttribute( uvAttribute, i );     }     if ( normalAttribute ) {      nor = new Vector3().fromBufferAttribute( normalAttribute, i );     }     if ( tangentAttribute ) {      t = new Vector4().fromBufferAttribute( tangentAttribute, i );     }     if ( colorAttribute ) {      col = new Color().fromBufferAttribute( colorAttribute, i );     }     const vertex = new Vertex( v, v2, nor, t, col );    vertices.push( vertex );    }    // add faces    let index = geometry.getIndex();    if ( index !== null ) {     for ( let i = 0; i < index.count; i += 3 ) {      const a = index.getX( i );     const b = index.getX( i + 1 );     const c = index.getX( i + 2 );      const triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );     faces.push( triangle );     }    } else {     for ( let i = 0; i < positionAttribute.count; i += 3 ) {      const a = i;     const b = i + 1;     const c = i + 2;      const triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );     faces.push( triangle );     }    }    // compute all edge collapse costs    for ( let i = 0, il = vertices.length; i < il; i ++ ) {     computeEdgeCostAtVertex( vertices[ i ] );    }    let nextVertex;    let z = count;    while ( z -- ) {     nextVertex = minimumCostEdge( vertices );     if ( ! nextVertex ) {      console.log( 'THREE.SimplifyModifier: No next vertex' );     break;     }     collapse( vertices, faces, nextVertex, nextVertex.collapseNeighbor );    }    //    const simplifiedGeometry = new BufferGeometry();   const position = [];   const uv = [];   const normal = [];   const tangent = [];   const color = [];    index = [];    //    for ( let i = 0; i < vertices.length; i ++ ) {     const vertex = vertices[ i ];    position.push( vertex.position.x, vertex.position.y, vertex.position.z );    if ( vertex.uv ) {      uv.push( vertex.uv.x, vertex.uv.y );     }     if ( vertex.normal ) {      normal.push( vertex.normal.x, vertex.normal.y, vertex.normal.z );     }     if ( vertex.tangent ) {      tangent.push( vertex.tangent.x, vertex.tangent.y, vertex.tangent.z, vertex.tangent.w );     }     if ( vertex.color ) {      color.push( vertex.color.r, vertex.color.g, vertex.color.b );     }      // cache final index to GREATLY speed up faces reconstruction    vertex.id = i;    }    //    for ( let i = 0; i < faces.length; i ++ ) {     const face = faces[ i ];    index.push( face.v1.id, face.v2.id, face.v3.id );    }    simplifiedGeometry.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );   if ( uv.length > 0 ) simplifiedGeometry.setAttribute( 'uv', new Float32BufferAttribute( uv, 2 ) );   if ( normal.length > 0 ) simplifiedGeometry.setAttribute( 'normal', new Float32BufferAttribute( normal, 3 ) );   if ( tangent.length > 0 ) simplifiedGeometry.setAttribute( 'tangent', new Float32BufferAttribute( tangent, 4 ) );   if ( color.length > 0 ) simplifiedGeometry.setAttribute( 'color', new Float32BufferAttribute( color, 3 ) );    simplifiedGeometry.setIndex( index );    return simplifiedGeometry;   }  }  function pushIfUnique( array, object ) {   if ( array.indexOf( object ) === - 1 ) array.push( object );  }  function removeFromArray( array, object ) {   const k = array.indexOf( object );  if ( k > - 1 ) array.splice( k, 1 );  }  function computeEdgeCollapseCost( u, v ) {   // if we collapse edge uv by moving u to v then how  // much different will the model change, i.e. the "error".   const edgelength = v.position.distanceTo( u.position );  let curvature = 0;   const sideFaces = [];   // find the "sides" triangles that are on the edge uv  for ( let i = 0, il = u.faces.length; i < il; i ++ ) {    const face = u.faces[ i ];    if ( face.hasVertex( v ) ) {     sideFaces.push( face );    }   }   // use the triangle facing most away from the sides  // to determine our curvature term  for ( let i = 0, il = u.faces.length; i < il; i ++ ) {    let minCurvature = 1;   const face = u.faces[ i ];    for ( let j = 0; j < sideFaces.length; j ++ ) {     const sideFace = sideFaces[ j ];    // use dot product of face normals.    const dotProd = face.normal.dot( sideFace.normal );    minCurvature = Math.min( minCurvature, ( 1.001 - dotProd ) / 2 );    }    curvature = Math.max( curvature, minCurvature );   }   // crude approach in attempt to preserve borders  // though it seems not to be totally correct  const borders = 0;   if ( sideFaces.length < 2 ) {    // we add some arbitrary cost for borders,   // borders += 10;   curvature = 1;   }   const amt = edgelength * curvature + borders;   return amt;  }  function computeEdgeCostAtVertex( v ) {   // compute the edge collapse cost for all edges that start  // from vertex v.  Since we are only interested in reducing  // the object by selecting the min cost edge at each step, we  // only cache the cost of the least cost edge at this vertex  // (in member variable collapse) as well as the value of the  // cost (in member variable collapseCost).   if ( v.neighbors.length === 0 ) {    // collapse if no neighbors.   v.collapseNeighbor = null;   v.collapseCost = - 0.01;    return;   }   v.collapseCost = 100000;  v.collapseNeighbor = null;   // search all neighboring edges for "least cost" edge  for ( let i = 0; i < v.neighbors.length; i ++ ) {    const collapseCost = computeEdgeCollapseCost( v, v.neighbors[ i ] );    if ( ! v.collapseNeighbor ) {     v.collapseNeighbor = v.neighbors[ i ];    v.collapseCost = collapseCost;    v.minCost = collapseCost;    v.totalCost = 0;    v.costCount = 0;    }    v.costCount ++;   v.totalCost += collapseCost;    if ( collapseCost < v.minCost ) {     v.collapseNeighbor = v.neighbors[ i ];    v.minCost = collapseCost;    }   }   // we average the cost of collapsing at this vertex  v.collapseCost = v.totalCost / v.costCount;  // v.collapseCost = v.minCost;  }  function removeVertex( v, vertices ) {   console.assert( v.faces.length === 0 );   while ( v.neighbors.length ) {    const n = v.neighbors.pop();   removeFromArray( n.neighbors, v );   }   removeFromArray( vertices, v );  }  function removeFace( f, faces ) {   removeFromArray( faces, f );   if ( f.v1 ) removeFromArray( f.v1.faces, f );  if ( f.v2 ) removeFromArray( f.v2.faces, f );  if ( f.v3 ) removeFromArray( f.v3.faces, f );   // TODO optimize this!  const vs = [ f.v1, f.v2, f.v3 ];   for ( let i = 0; i < 3; i ++ ) {    const v1 = vs[ i ];   const v2 = vs[ ( i + 1 ) % 3 ];    if ( ! v1 || ! v2 ) continue;    v1.removeIfNonNeighbor( v2 );   v2.removeIfNonNeighbor( v1 );   }  }  function collapse( vertices, faces, u, v ) {   // Collapse the edge uv by moving vertex u onto v   if ( ! v ) {    // u is a vertex all by itself so just delete it..   removeVertex( u, vertices );   return;   }   if ( v.uv ) {    u.uv.copy( v.uv );   }   if ( v.normal ) {    v.normal.add( u.normal ).normalize();   }   if ( v.tangent ) {    v.tangent.add( u.tangent ).normalize();   }   const tmpVertices = [];   for ( let i = 0; i < u.neighbors.length; i ++ ) {    tmpVertices.push( u.neighbors[ i ] );   }    // delete triangles on edge uv:  for ( let i = u.faces.length - 1; i >= 0; i -- ) {    if ( u.faces[ i ] && u.faces[ i ].hasVertex( v ) ) {     removeFace( u.faces[ i ], faces );    }   }   // update remaining triangles to have v instead of u  for ( let i = u.faces.length - 1; i >= 0; i -- ) {    u.faces[ i ].replaceVertex( u, v );   }    removeVertex( u, vertices );   // recompute the edge collapse costs in neighborhood  for ( let i = 0; i < tmpVertices.length; i ++ ) {    computeEdgeCostAtVertex( tmpVertices[ i ] );   }  }    function minimumCostEdge( vertices ) {   // O(n * n) approach. TODO optimize this   let least = vertices[ 0 ];   for ( let i = 0; i < vertices.length; i ++ ) {    if ( vertices[ i ].collapseCost < least.collapseCost ) {     least = vertices[ i ];    }   }   return least;  }  // we use a triangle class to represent structure of face slightly differently  class Triangle {   constructor( v1, v2, v3, a, b, c ) {    this.a = a;   this.b = b;   this.c = c;    this.v1 = v1;   this.v2 = v2;   this.v3 = v3;    this.normal = new Vector3();    this.computeNormal();    v1.faces.push( this );   v1.addUniqueNeighbor( v2 );   v1.addUniqueNeighbor( v3 );    v2.faces.push( this );   v2.addUniqueNeighbor( v1 );   v2.addUniqueNeighbor( v3 );     v3.faces.push( this );   v3.addUniqueNeighbor( v1 );   v3.addUniqueNeighbor( v2 );   }   computeNormal() {    const vA = this.v1.position;   const vB = this.v2.position;   const vC = this.v3.position;    _cb.subVectors( vC, vB );   _ab.subVectors( vA, vB );   _cb.cross( _ab ).normalize();    this.normal.copy( _cb );   }   hasVertex( v ) {    return v === this.v1 || v === this.v2 || v === this.v3;   }   replaceVertex( oldv, newv ) {    if ( oldv === this.v1 ) this.v1 = newv;   else if ( oldv === this.v2 ) this.v2 = newv;   else if ( oldv === this.v3 ) this.v3 = newv;    removeFromArray( oldv.faces, this );   newv.faces.push( this );     oldv.removeIfNonNeighbor( this.v1 );   this.v1.removeIfNonNeighbor( oldv );    oldv.removeIfNonNeighbor( this.v2 );   this.v2.removeIfNonNeighbor( oldv );    oldv.removeIfNonNeighbor( this.v3 );   this.v3.removeIfNonNeighbor( oldv );    this.v1.addUniqueNeighbor( this.v2 );   this.v1.addUniqueNeighbor( this.v3 );    this.v2.addUniqueNeighbor( this.v1 );   this.v2.addUniqueNeighbor( this.v3 );    this.v3.addUniqueNeighbor( this.v1 );   this.v3.addUniqueNeighbor( this.v2 );    this.computeNormal();   }  }  class Vertex {   constructor( v, uv, normal, tangent, color ) {    this.position = v;   this.uv = uv;   this.normal = normal;   this.tangent = tangent;   this.color = color;    this.id = - 1; // external use position in vertices list (for e.g. face generation)    this.faces = []; // faces vertex is connected   this.neighbors = []; // neighbouring vertices aka "adjacentVertices"    // these will be computed in computeEdgeCostAtVertex()   this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist   this.collapseNeighbor = null; // best candinate for collapsing   }   addUniqueNeighbor( vertex ) {    pushIfUnique( this.neighbors, vertex );   }   removeIfNonNeighbor( n ) {    const neighbors = this.neighbors;   const faces = this.faces;    const offset = neighbors.indexOf( n );    if ( offset === - 1 ) return;    for ( let i = 0; i < faces.length; i ++ ) {     if ( faces[ i ].hasVertex( n ) ) return;    }    neighbors.splice( offset, 1 );   }  }  export { SimplifyModifier }; 
^..^ FILENAME ^..^
addons|modifiers|TessellateModifier.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  Color,  Float32BufferAttribute,  Vector2,  Vector3 } from 'three';  /**  * Break faces with edges longer than maxEdgeLength  */  class TessellateModifier {   constructor( maxEdgeLength = 0.1, maxIterations = 6 ) {    this.maxEdgeLength = maxEdgeLength;   this.maxIterations = maxIterations;   }   modify( geometry ) {    if ( geometry.index !== null ) {     geometry = geometry.toNonIndexed();    }    //    const maxIterations = this.maxIterations;   const maxEdgeLengthSquared = this.maxEdgeLength * this.maxEdgeLength;    const va = new Vector3();   const vb = new Vector3();   const vc = new Vector3();   const vm = new Vector3();   const vs = [ va, vb, vc, vm ];    const na = new Vector3();   const nb = new Vector3();   const nc = new Vector3();   const nm = new Vector3();   const ns = [ na, nb, nc, nm ];    const ca = new Color();   const cb = new Color();   const cc = new Color();   const cm = new Color();   const cs = [ ca, cb, cc, cm ];    const ua = new Vector2();   const ub = new Vector2();   const uc = new Vector2();   const um = new Vector2();   const us = [ ua, ub, uc, um ];    const u2a = new Vector2();   const u2b = new Vector2();   const u2c = new Vector2();   const u2m = new Vector2();   const u2s = [ u2a, u2b, u2c, u2m ];    const attributes = geometry.attributes;   const hasNormals = attributes.normal !== undefined;   const hasColors = attributes.color !== undefined;   const hasUVs = attributes.uv !== undefined;   const hasUV1s = attributes.uv1 !== undefined;    let positions = attributes.position.array;   let normals = hasNormals ? attributes.normal.array : null;   let colors = hasColors ? attributes.color.array : null;   let uvs = hasUVs ? attributes.uv.array : null;   let uv1s = hasUV1s ? attributes.uv1.array : null;    let positions2 = positions;   let normals2 = normals;   let colors2 = colors;   let uvs2 = uvs;   let uv1s2 = uv1s;    let iteration = 0;   let tessellating = true;    function addTriangle( a, b, c ) {     const v1 = vs[ a ];    const v2 = vs[ b ];    const v3 = vs[ c ];     positions2.push( v1.x, v1.y, v1.z );    positions2.push( v2.x, v2.y, v2.z );    positions2.push( v3.x, v3.y, v3.z );     if ( hasNormals ) {      const n1 = ns[ a ];     const n2 = ns[ b ];     const n3 = ns[ c ];      normals2.push( n1.x, n1.y, n1.z );     normals2.push( n2.x, n2.y, n2.z );     normals2.push( n3.x, n3.y, n3.z );     }     if ( hasColors ) {      const c1 = cs[ a ];     const c2 = cs[ b ];     const c3 = cs[ c ];      colors2.push( c1.r, c1.g, c1.b );     colors2.push( c2.r, c2.g, c2.b );     colors2.push( c3.r, c3.g, c3.b );     }     if ( hasUVs ) {      const u1 = us[ a ];     const u2 = us[ b ];     const u3 = us[ c ];      uvs2.push( u1.x, u1.y );     uvs2.push( u2.x, u2.y );     uvs2.push( u3.x, u3.y );     }     if ( hasUV1s ) {      const u21 = u2s[ a ];     const u22 = u2s[ b ];     const u23 = u2s[ c ];      uv1s2.push( u21.x, u21.y );     uv1s2.push( u22.x, u22.y );     uv1s2.push( u23.x, u23.y );     }    }    while ( tessellating && iteration < maxIterations ) {     iteration ++;    tessellating = false;     positions = positions2;    positions2 = [];     if ( hasNormals ) {      normals = normals2;     normals2 = [];     }     if ( hasColors ) {      colors = colors2;     colors2 = [];     }     if ( hasUVs ) {      uvs = uvs2;     uvs2 = [];     }     if ( hasUV1s ) {      uv1s = uv1s2;     uv1s2 = [];     }     for ( let i = 0, i2 = 0, il = positions.length; i < il; i += 9, i2 += 6 ) {      va.fromArray( positions, i + 0 );     vb.fromArray( positions, i + 3 );     vc.fromArray( positions, i + 6 );      if ( hasNormals ) {       na.fromArray( normals, i + 0 );      nb.fromArray( normals, i + 3 );      nc.fromArray( normals, i + 6 );      }      if ( hasColors ) {       ca.fromArray( colors, i + 0 );      cb.fromArray( colors, i + 3 );      cc.fromArray( colors, i + 6 );      }      if ( hasUVs ) {       ua.fromArray( uvs, i2 + 0 );      ub.fromArray( uvs, i2 + 2 );      uc.fromArray( uvs, i2 + 4 );      }      if ( hasUV1s ) {       u2a.fromArray( uv1s, i2 + 0 );      u2b.fromArray( uv1s, i2 + 2 );      u2c.fromArray( uv1s, i2 + 4 );      }      const dab = va.distanceToSquared( vb );     const dbc = vb.distanceToSquared( vc );     const dac = va.distanceToSquared( vc );      if ( dab > maxEdgeLengthSquared || dbc > maxEdgeLengthSquared || dac > maxEdgeLengthSquared ) {       tessellating = true;       if ( dab >= dbc && dab >= dac ) {        vm.lerpVectors( va, vb, 0.5 );       if ( hasNormals ) nm.lerpVectors( na, nb, 0.5 );       if ( hasColors ) cm.lerpColors( ca, cb, 0.5 );       if ( hasUVs ) um.lerpVectors( ua, ub, 0.5 );       if ( hasUV1s ) u2m.lerpVectors( u2a, u2b, 0.5 );        addTriangle( 0, 3, 2 );       addTriangle( 3, 1, 2 );       } else if ( dbc >= dab && dbc >= dac ) {        vm.lerpVectors( vb, vc, 0.5 );       if ( hasNormals ) nm.lerpVectors( nb, nc, 0.5 );       if ( hasColors ) cm.lerpColors( cb, cc, 0.5 );       if ( hasUVs ) um.lerpVectors( ub, uc, 0.5 );       if ( hasUV1s ) u2m.lerpVectors( u2b, u2c, 0.5 );        addTriangle( 0, 1, 3 );       addTriangle( 3, 2, 0 );       } else {        vm.lerpVectors( va, vc, 0.5 );       if ( hasNormals ) nm.lerpVectors( na, nc, 0.5 );       if ( hasColors ) cm.lerpColors( ca, cc, 0.5 );       if ( hasUVs ) um.lerpVectors( ua, uc, 0.5 );       if ( hasUV1s ) u2m.lerpVectors( u2a, u2c, 0.5 );        addTriangle( 0, 1, 3 );       addTriangle( 3, 1, 2 );       }      } else {       addTriangle( 0, 1, 2 );      }     }    }    const geometry2 = new BufferGeometry();    geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );    if ( hasNormals ) {     geometry2.setAttribute( 'normal', new Float32BufferAttribute( normals2, 3 ) );    }    if ( hasColors ) {     geometry2.setAttribute( 'color', new Float32BufferAttribute( colors2, 3 ) );    }    if ( hasUVs ) {     geometry2.setAttribute( 'uv', new Float32BufferAttribute( uvs2, 2 ) );    }    if ( hasUV1s ) {     geometry2.setAttribute( 'uv1', new Float32BufferAttribute( uv1s2, 2 ) );    }    return geometry2;   }  }  export { TessellateModifier }; 
^..^ FILENAME ^..^
addons|objects|GroundedSkybox.js
^..^ CONTENTS ^..^
import { Mesh, MeshBasicMaterial, SphereGeometry, Vector3 } from 'three';  /**  * A ground-projected skybox. The height is how far the camera that took the photo was above the ground -   * a larger value will magnify the downward part of the image. By default the object is centered at the camera,   * so it is often helpful to set skybox.position.y = height to put the ground at the origin. Set the radius   * large enough to ensure your user's camera stays inside.  */  class GroundedSkybox extends Mesh {   constructor( map, height, radius, resolution = 128 ) {    if ( height <= 0 || radius <= 0 || resolution <= 0 ) {     throw new Error( 'GroundedSkybox height, radius, and resolution must be positive.' );    }    const geometry = new SphereGeometry( radius, 2 * resolution, resolution );   geometry.scale( 1, 1, -1 );    const pos = geometry.getAttribute( 'position' );   const tmp = new Vector3();    for ( let i = 0; i < pos.count; ++ i ) {     tmp.fromBufferAttribute( pos, i );    if ( tmp.y < 0 ) {      // Smooth out the transition from flat floor to sphere:     const y1 = - height * 3 / 2;     const f =       tmp.y < y1 ? - height / tmp.y : ( 1 - tmp.y * tmp.y / ( 3 * y1 * y1 ) );     tmp.multiplyScalar( f );     tmp.toArray( pos.array, 3 * i );     }    }    pos.needsUpdate = true;    super( geometry, new MeshBasicMaterial( { map, depthWrite: false } ) );   }  }  export { GroundedSkybox }; 
^..^ FILENAME ^..^
addons|objects|InstancedPoints.js
^..^ CONTENTS ^..^
import {  Mesh,  InstancedPointsNodeMaterial } from 'three'; import InstancedPointsGeometry from '../geometries/InstancedPointsGeometry.js';  class InstancedPoints extends Mesh {   constructor( geometry = new InstancedPointsGeometry(), material = new InstancedPointsNodeMaterial() ) {    super( geometry, material );    this.isInstancedPoints = true;    this.type = 'InstancedPoints';   }  }  export default InstancedPoints; 
^..^ FILENAME ^..^
addons|objects|Lensflare.js
^..^ CONTENTS ^..^
import {  AdditiveBlending,  Box2,  BufferGeometry,  Color,  FramebufferTexture,  InterleavedBuffer,  InterleavedBufferAttribute,  Mesh,  MeshBasicMaterial,  RawShaderMaterial,  UnsignedByteType,  Vector2,  Vector3,  Vector4 } from 'three';  class Lensflare extends Mesh {   constructor() {    super( Lensflare.Geometry, new MeshBasicMaterial( { opacity: 0, transparent: true } ) );    this.isLensflare = true;    this.type = 'Lensflare';   this.frustumCulled = false;   this.renderOrder = Infinity;    //    const positionScreen = new Vector3();   const positionView = new Vector3();    // textures    const tempMap = new FramebufferTexture( 16, 16 );   const occlusionMap = new FramebufferTexture( 16, 16 );    let currentType = UnsignedByteType;    // material    const geometry = Lensflare.Geometry;    const material1a = new RawShaderMaterial( {    uniforms: {     'scale': { value: null },     'screenPosition': { value: null }    },    vertexShader: /* glsl */|      precision highp float;      uniform vec3 screenPosition;     uniform vec2 scale;      attribute vec3 position;      void main() {       gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );      }|,     fragmentShader: /* glsl */|      precision highp float;      void main() {       gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );      }|,    depthTest: true,    depthWrite: false,    transparent: false   } );    const material1b = new RawShaderMaterial( {    uniforms: {     'map': { value: tempMap },     'scale': { value: null },     'screenPosition': { value: null }    },    vertexShader: /* glsl */|      precision highp float;      uniform vec3 screenPosition;     uniform vec2 scale;      attribute vec3 position;     attribute vec2 uv;      varying vec2 vUV;      void main() {       vUV = uv;       gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );      }|,     fragmentShader: /* glsl */|      precision highp float;      uniform sampler2D map;      varying vec2 vUV;      void main() {       gl_FragColor = texture2D( map, vUV );      }|,    depthTest: false,    depthWrite: false,    transparent: false   } );    // the following object is used for occlusionMap generation    const mesh1 = new Mesh( geometry, material1a );    //    const elements = [];    const shader = LensflareElement.Shader;    const material2 = new RawShaderMaterial( {    name: shader.name,    uniforms: {     'map': { value: null },     'occlusionMap': { value: occlusionMap },     'color': { value: new Color( 0xffffff ) },     'scale': { value: new Vector2() },     'screenPosition': { value: new Vector3() }    },    vertexShader: shader.vertexShader,    fragmentShader: shader.fragmentShader,    blending: AdditiveBlending,    transparent: true,    depthWrite: false   } );    const mesh2 = new Mesh( geometry, material2 );    this.addElement = function ( element ) {     elements.push( element );    };    //    const scale = new Vector2();   const screenPositionPixels = new Vector2();   const validArea = new Box2();   const viewport = new Vector4();    this.onBeforeRender = function ( renderer, scene, camera ) {     renderer.getCurrentViewport( viewport );     const renderTarget = renderer.getRenderTarget();    const type = ( renderTarget !== null ) ? renderTarget.texture.type : UnsignedByteType;     if ( currentType !== type ) {      tempMap.dispose();     occlusionMap.dispose();      tempMap.type = occlusionMap.type = type;      currentType = type;     }     const invAspect = viewport.w / viewport.z;    const halfViewportWidth = viewport.z / 2.0;    const halfViewportHeight = viewport.w / 2.0;     let size = 16 / viewport.w;    scale.set( size * invAspect, size );     validArea.min.set( viewport.x, viewport.y );    validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );     // calculate position in screen space     positionView.setFromMatrixPosition( this.matrixWorld );    positionView.applyMatrix4( camera.matrixWorldInverse );     if ( positionView.z > 0 ) return; // lensflare is behind the camera     positionScreen.copy( positionView ).applyMatrix4( camera.projectionMatrix );     // horizontal and vertical coordinate of the lower left corner of the pixels to copy     screenPositionPixels.x = viewport.x + ( positionScreen.x * halfViewportWidth ) + halfViewportWidth - 8;    screenPositionPixels.y = viewport.y + ( positionScreen.y * halfViewportHeight ) + halfViewportHeight - 8;     // screen cull     if ( validArea.containsPoint( screenPositionPixels ) ) {      // save current RGB to temp texture      renderer.copyFramebufferToTexture( tempMap, screenPositionPixels );      // render pink quad      let uniforms = material1a.uniforms;     uniforms[ 'scale' ].value = scale;     uniforms[ 'screenPosition' ].value = positionScreen;      renderer.renderBufferDirect( camera, null, geometry, material1a, mesh1, null );      // copy result to occlusionMap      renderer.copyFramebufferToTexture( occlusionMap, screenPositionPixels );      // restore graphics      uniforms = material1b.uniforms;     uniforms[ 'scale' ].value = scale;     uniforms[ 'screenPosition' ].value = positionScreen;      renderer.renderBufferDirect( camera, null, geometry, material1b, mesh1, null );      // render elements      const vecX = - positionScreen.x * 2;     const vecY = - positionScreen.y * 2;      for ( let i = 0, l = elements.length; i < l; i ++ ) {       const element = elements[ i ];       const uniforms = material2.uniforms;       uniforms[ 'color' ].value.copy( element.color );      uniforms[ 'map' ].value = element.texture;      uniforms[ 'screenPosition' ].value.x = positionScreen.x + vecX * element.distance;      uniforms[ 'screenPosition' ].value.y = positionScreen.y + vecY * element.distance;       size = element.size / viewport.w;      const invAspect = viewport.w / viewport.z;       uniforms[ 'scale' ].value.set( size * invAspect, size );       material2.uniformsNeedUpdate = true;       renderer.renderBufferDirect( camera, null, geometry, material2, mesh2, null );      }     }    };    this.dispose = function () {     material1a.dispose();    material1b.dispose();    material2.dispose();     tempMap.dispose();    occlusionMap.dispose();     for ( let i = 0, l = elements.length; i < l; i ++ ) {      elements[ i ].texture.dispose();     }    };   }  }  //  class LensflareElement {   constructor( texture, size = 1, distance = 0, color = new Color( 0xffffff ) ) {    this.texture = texture;   this.size = size;   this.distance = distance;   this.color = color;   }  }  LensflareElement.Shader = {   name: 'LensflareElementShader',   uniforms: {    'map': { value: null },   'occlusionMap': { value: null },   'color': { value: null },   'scale': { value: null },   'screenPosition': { value: null }   },   vertexShader: /* glsl */|    precision highp float;    uniform vec3 screenPosition;   uniform vec2 scale;    uniform sampler2D occlusionMap;    attribute vec3 position;   attribute vec2 uv;    varying vec2 vUV;   varying float vVisibility;    void main() {     vUV = uv;     vec2 pos = position.xy;     vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );    visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );    visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );    visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );    visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );    visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );    visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );    visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );    visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );     vVisibility =        visibility.r / 9.0;    vVisibility *= 1.0 - visibility.g / 9.0;    vVisibility *=       visibility.b / 9.0;     gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );    }|,   fragmentShader: /* glsl */|    precision highp float;    uniform sampler2D map;   uniform vec3 color;    varying vec2 vUV;   varying float vVisibility;    void main() {     vec4 texture = texture2D( map, vUV );    texture.a *= vVisibility;    gl_FragColor = texture;    gl_FragColor.rgb *= color;    }|  };  Lensflare.Geometry = ( function () {   const geometry = new BufferGeometry();   const float32Array = new Float32Array( [   - 1, - 1, 0, 0, 0,   1, - 1, 0, 1, 0,   1, 1, 0, 1, 1,   - 1, 1, 0, 0, 1  ] );   const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );   geometry.setIndex( [ 0, 1, 2, 0, 2, 3 ] );  geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );  geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );   return geometry;  } )();  export { Lensflare, LensflareElement }; 
^..^ FILENAME ^..^
addons|objects|LensflareMesh.js
^..^ CONTENTS ^..^
import {  AdditiveBlending,  Box2,  BufferGeometry,  Color,  FramebufferTexture,  InterleavedBuffer,  InterleavedBufferAttribute,  Mesh,  MeshBasicNodeMaterial,  NodeMaterial,  UnsignedByteType,  Vector2,  Vector3,  Vector4 } from 'three';  import { texture, textureLoad, uv, ivec2, vec2, vec4, positionGeometry, reference, varyingProperty, materialReference, Fn, Node } from 'three/tsl';  class LensflareMesh extends Mesh {   constructor() {    super( LensflareMesh.Geometry, new MeshBasicNodeMaterial( { opacity: 0, transparent: true } ) );    this.isLensflare = true;    this.type = 'LensflareMesh';   this.frustumCulled = false;   this.renderOrder = Infinity;    //    const positionView = new Vector3();    // textures    const tempMap = new FramebufferTexture( 16, 16 );   const occlusionMap = new FramebufferTexture( 16, 16 );    let currentType = UnsignedByteType;    const geometry = LensflareMesh.Geometry;    // values for shared material uniforms    const sharedValues = {    scale: new Vector2(),    positionScreen: new Vector3()   };    // materials    const scale = reference( 'scale', 'vec2', sharedValues );   const screenPosition = reference( 'positionScreen', 'vec3', sharedValues );    const vertexNode = vec4( positionGeometry.xy.mul( scale ).add( screenPosition.xy ), screenPosition.z, 1.0 );    const material1a = new NodeMaterial();    material1a.depthTest = true;   material1a.depthWrite = false;   material1a.transparent = false;   material1a.fog = false;   material1a.type = 'Lensflare-1a';    material1a.vertexNode = vertexNode;   material1a.fragmentNode = vec4( 1.0, 0.0, 1.0, 1.0 );    const material1b = new NodeMaterial();    material1b.depthTest = false;   material1b.depthWrite = false;   material1b.transparent = false;   material1b.fog = false;   material1b.type = 'Lensflare-1b';    material1b.vertexNode = vertexNode;   material1b.fragmentNode = texture( tempMap, vec2( uv().flipY() ) );    // the following object is used for occlusionMap generation    const mesh1 = new Mesh( geometry, material1a );    //    const elements = [];   const elementMeshes = [];    const material2 = new NodeMaterial();    material2.transparent = true;   material2.blending = AdditiveBlending;   material2.depthWrite = false;   material2.depthTest = false;   material2.fog = false;   material2.type = 'Lensflare-2';    material2.screenPosition = new Vector3();   material2.scale = new Vector2();   material2.occlusionMap = occlusionMap;    material2.vertexNode = Fn( ( { material } ) => {     const scale = materialReference( 'scale', 'vec2' );    const screenPosition = materialReference( 'screenPosition', 'vec3' );     const occlusionMap = material.occlusionMap;     const pos = positionGeometry.xy.toVar();     const visibility = textureLoad( occlusionMap, ivec2( 2, 2 ) ).toVar();    visibility.addAssign( textureLoad( occlusionMap, ivec2( 8, 2 ) ) );    visibility.addAssign( textureLoad( occlusionMap, ivec2( 14, 2 ) ) );    visibility.addAssign( textureLoad( occlusionMap, ivec2( 14, 8 ) ) );    visibility.addAssign( textureLoad( occlusionMap, ivec2( 14, 14 ) ) );    visibility.addAssign( textureLoad( occlusionMap, ivec2( 8, 14 ) ) );    visibility.addAssign( textureLoad( occlusionMap, ivec2( 2, 14 ) ) );    visibility.addAssign( textureLoad( occlusionMap, ivec2( 2, 8 ) ) );    visibility.addAssign( textureLoad( occlusionMap, ivec2( 8, 8 ) ) );     const vVisibility = varyingProperty( 'float', 'vVisibility' );     vVisibility.assign( visibility.r.div( 9.0 ) );    vVisibility.mulAssign( visibility.g.div( 9.0 ).oneMinus() );    vVisibility.mulAssign( visibility.b.div( 9.0 ) );     return vec4( ( pos.mul( scale ).add( screenPosition.xy ).xy ), screenPosition.z, 1.0 );    } )();    material2.fragmentNode = Fn( () => {     const color = reference( 'color', 'color' );    const map = reference( 'map', 'texture' );     const vVisibility = varyingProperty( 'float', 'vVisibility' );     const output = map.toVar();     output.a.mulAssign( vVisibility );    output.rgb.mulAssign( color );     return output;    } )();     this.addElement = function ( element ) {     elements.push( element );    };    //    const positionScreen = sharedValues.positionScreen;   const screenPositionPixels = new Vector4( 0, 0, 16, 16 );   const validArea = new Box2();   const viewport = new Vector4();    // dummy node for renderer.renderObject()   const lightsNode = new Node();    this.onBeforeRender = ( renderer, scene, camera ) => {     renderer.getViewport( viewport );     viewport.multiplyScalar( window.devicePixelRatio );     const renderTarget = renderer.getRenderTarget();    const type = ( renderTarget !== null ) ? renderTarget.texture.type : UnsignedByteType;     if ( currentType !== type ) {      tempMap.dispose();     occlusionMap.dispose();      tempMap.type = occlusionMap.type = type;      currentType = type;     }     const invAspect = viewport.w / viewport.z;    const halfViewportWidth = viewport.z / 2.0;    const halfViewportHeight = viewport.w / 2.0;     const size = 16 / viewport.w;     sharedValues.scale.set( size * invAspect, size );     validArea.min.set( viewport.x, viewport.y );    validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );     // calculate position in screen space     positionView.setFromMatrixPosition( this.matrixWorld );    positionView.applyMatrix4( camera.matrixWorldInverse );     if ( positionView.z > 0 ) return; // lensflare is behind the camera     positionScreen.copy( positionView ).applyMatrix4( camera.projectionMatrix );     // horizontal and vertical coordinate of the lower left corner of the pixels to copy     screenPositionPixels.x = viewport.x + ( positionScreen.x * halfViewportWidth ) + halfViewportWidth - 8;    screenPositionPixels.y = viewport.y - ( positionScreen.y * halfViewportHeight ) + halfViewportHeight - 8;     // screen cull     if ( validArea.containsPoint( screenPositionPixels ) ) {      // save current RGB to temp texture      renderer.copyFramebufferToTexture( tempMap, screenPositionPixels );      // render pink quad      renderer.renderObject( mesh1, scene, camera, geometry, material1a, null, lightsNode );      // copy result to occlusionMap      renderer.copyFramebufferToTexture( occlusionMap, screenPositionPixels );      // restore graphics      renderer.renderObject( mesh1, scene, camera, geometry, material1b, null, lightsNode );      // render elements      const vecX = - positionScreen.x * 2;     const vecY = - positionScreen.y * 2;      for ( let i = 0, l = elements.length; i < l; i ++ ) {       const element = elements[ i ];       let mesh2 = elementMeshes[ i ];       if ( mesh2 === undefined ) {        mesh2 = elementMeshes[ i ] = new Mesh( geometry, material2 );        mesh2.color = element.color.convertSRGBToLinear();       mesh2.map = element.texture;       }       material2.screenPosition.x = positionScreen.x + vecX * element.distance;      material2.screenPosition.y = positionScreen.y - vecY * element.distance;      material2.screenPosition.z = positionScreen.z;       const size = element.size / viewport.w;       material2.scale.set( size * invAspect, size );       renderer.renderObject( mesh2, scene, camera, geometry, material2, null, lightsNode );      }     }    };    this.dispose = function () {     material1a.dispose();    material1b.dispose();    material2.dispose();     tempMap.dispose();    occlusionMap.dispose();     for ( let i = 0, l = elements.length; i < l; i ++ ) {      elements[ i ].texture.dispose();     }    };   }  }  //  class LensflareElement {   constructor( texture, size = 1, distance = 0, color = new Color( 0xffffff ) ) {    this.texture = texture;   this.size = size;   this.distance = distance;   this.color = color;   }  }  LensflareMesh.Geometry = ( function () {   const geometry = new BufferGeometry();   const float32Array = new Float32Array( [   - 1, - 1, 0, 0, 0,   1, - 1, 0, 1, 0,   1, 1, 0, 1, 1,   - 1, 1, 0, 0, 1  ] );   const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );   geometry.setIndex( [ 0, 1, 2, 0, 2, 3 ] );  geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );  geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );   return geometry;  } )();  export { LensflareMesh, LensflareElement }; 
^..^ FILENAME ^..^
addons|objects|MarchingCubes.js
^..^ CONTENTS ^..^
import {  BufferAttribute,  BufferGeometry,  Color,  DynamicDrawUsage,  Mesh,  Sphere,  Vector3 } from 'three';  /**  * Port of http://webglsamples.org/blob/blob.html  */  class MarchingCubes extends Mesh {   constructor( resolution, material, enableUvs = false, enableColors = false, maxPolyCount = 10000 ) {    const geometry = new BufferGeometry();    super( geometry, material );    this.isMarchingCubes = true;    const scope = this;    // temp buffers used in polygonize    const vlist = new Float32Array( 12 * 3 );   const nlist = new Float32Array( 12 * 3 );   const clist = new Float32Array( 12 * 3 );    this.enableUvs = enableUvs;   this.enableColors = enableColors;    // functions have to be object properties   // prototype functions kill performance   // (tested and it was 4x slower !!!)    this.init = function ( resolution ) {     this.resolution = resolution;     // parameters     this.isolation = 80.0;     // size of field, 32 is pushing it in Javascript :)     this.size = resolution;    this.size2 = this.size * this.size;    this.size3 = this.size2 * this.size;    this.halfsize = this.size / 2.0;     // deltas     this.delta = 2.0 / this.size;    this.yd = this.size;    this.zd = this.size2;     this.field = new Float32Array( this.size3 );    this.normal_cache = new Float32Array( this.size3 * 3 );    this.palette = new Float32Array( this.size3 * 3 );     //     this.count = 0;     const maxVertexCount = maxPolyCount * 3;     this.positionArray = new Float32Array( maxVertexCount * 3 );    const positionAttribute = new BufferAttribute( this.positionArray, 3 );    positionAttribute.setUsage( DynamicDrawUsage );    geometry.setAttribute( 'position', positionAttribute );     this.normalArray = new Float32Array( maxVertexCount * 3 );    const normalAttribute = new BufferAttribute( this.normalArray, 3 );    normalAttribute.setUsage( DynamicDrawUsage );    geometry.setAttribute( 'normal', normalAttribute );     if ( this.enableUvs ) {      this.uvArray = new Float32Array( maxVertexCount * 2 );     const uvAttribute = new BufferAttribute( this.uvArray, 2 );     uvAttribute.setUsage( DynamicDrawUsage );     geometry.setAttribute( 'uv', uvAttribute );     }     if ( this.enableColors ) {      this.colorArray = new Float32Array( maxVertexCount * 3 );     const colorAttribute = new BufferAttribute( this.colorArray, 3 );     colorAttribute.setUsage( DynamicDrawUsage );     geometry.setAttribute( 'color', colorAttribute );     }     geometry.boundingSphere = new Sphere( new Vector3(), 1 );    };    ///////////////////////   // Polygonization   ///////////////////////    function lerp( a, b, t ) {     return a + ( b - a ) * t;    }    function VIntX( q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2 ) {     const mu = ( isol - valp1 ) / ( valp2 - valp1 ),     nc = scope.normal_cache;     vlist[ offset + 0 ] = x + mu * scope.delta;    vlist[ offset + 1 ] = y;    vlist[ offset + 2 ] = z;     nlist[ offset + 0 ] = lerp( nc[ q + 0 ], nc[ q + 3 ], mu );    nlist[ offset + 1 ] = lerp( nc[ q + 1 ], nc[ q + 4 ], mu );    nlist[ offset + 2 ] = lerp( nc[ q + 2 ], nc[ q + 5 ], mu );     clist[ offset + 0 ] = lerp( scope.palette[ c_offset1 * 3 + 0 ], scope.palette[ c_offset2 * 3 + 0 ], mu );    clist[ offset + 1 ] = lerp( scope.palette[ c_offset1 * 3 + 1 ], scope.palette[ c_offset2 * 3 + 1 ], mu );    clist[ offset + 2 ] = lerp( scope.palette[ c_offset1 * 3 + 2 ], scope.palette[ c_offset2 * 3 + 2 ], mu );    }    function VIntY( q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2 ) {     const mu = ( isol - valp1 ) / ( valp2 - valp1 ),     nc = scope.normal_cache;     vlist[ offset + 0 ] = x;    vlist[ offset + 1 ] = y + mu * scope.delta;    vlist[ offset + 2 ] = z;     const q2 = q + scope.yd * 3;     nlist[ offset + 0 ] = lerp( nc[ q + 0 ], nc[ q2 + 0 ], mu );    nlist[ offset + 1 ] = lerp( nc[ q + 1 ], nc[ q2 + 1 ], mu );    nlist[ offset + 2 ] = lerp( nc[ q + 2 ], nc[ q2 + 2 ], mu );     clist[ offset + 0 ] = lerp( scope.palette[ c_offset1 * 3 + 0 ], scope.palette[ c_offset2 * 3 + 0 ], mu );    clist[ offset + 1 ] = lerp( scope.palette[ c_offset1 * 3 + 1 ], scope.palette[ c_offset2 * 3 + 1 ], mu );    clist[ offset + 2 ] = lerp( scope.palette[ c_offset1 * 3 + 2 ], scope.palette[ c_offset2 * 3 + 2 ], mu );    }    function VIntZ( q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2 ) {     const mu = ( isol - valp1 ) / ( valp2 - valp1 ),     nc = scope.normal_cache;     vlist[ offset + 0 ] = x;    vlist[ offset + 1 ] = y;    vlist[ offset + 2 ] = z + mu * scope.delta;     const q2 = q + scope.zd * 3;     nlist[ offset + 0 ] = lerp( nc[ q + 0 ], nc[ q2 + 0 ], mu );    nlist[ offset + 1 ] = lerp( nc[ q + 1 ], nc[ q2 + 1 ], mu );    nlist[ offset + 2 ] = lerp( nc[ q + 2 ], nc[ q2 + 2 ], mu );     clist[ offset + 0 ] = lerp( scope.palette[ c_offset1 * 3 + 0 ], scope.palette[ c_offset2 * 3 + 0 ], mu );    clist[ offset + 1 ] = lerp( scope.palette[ c_offset1 * 3 + 1 ], scope.palette[ c_offset2 * 3 + 1 ], mu );    clist[ offset + 2 ] = lerp( scope.palette[ c_offset1 * 3 + 2 ], scope.palette[ c_offset2 * 3 + 2 ], mu );    }    function compNorm( q ) {     const q3 = q * 3;     if ( scope.normal_cache[ q3 ] === 0.0 ) {      scope.normal_cache[ q3 + 0 ] = scope.field[ q - 1 ] - scope.field[ q + 1 ];     scope.normal_cache[ q3 + 1 ] =      scope.field[ q - scope.yd ] - scope.field[ q + scope.yd ];     scope.normal_cache[ q3 + 2 ] =      scope.field[ q - scope.zd ] - scope.field[ q + scope.zd ];     }    }    // Returns total number of triangles. Fills triangles.   // (this is where most of time is spent - it's inner work of O(n3) loop )    function polygonize( fx, fy, fz, q, isol ) {     // cache indices    const q1 = q + 1,     qy = q + scope.yd,     qz = q + scope.zd,     q1y = q1 + scope.yd,     q1z = q1 + scope.zd,     qyz = q + scope.yd + scope.zd,     q1yz = q1 + scope.yd + scope.zd;     let cubeindex = 0;    const field0 = scope.field[ q ],     field1 = scope.field[ q1 ],     field2 = scope.field[ qy ],     field3 = scope.field[ q1y ],     field4 = scope.field[ qz ],     field5 = scope.field[ q1z ],     field6 = scope.field[ qyz ],     field7 = scope.field[ q1yz ];     if ( field0 < isol ) cubeindex |= 1;    if ( field1 < isol ) cubeindex |= 2;    if ( field2 < isol ) cubeindex |= 8;    if ( field3 < isol ) cubeindex |= 4;    if ( field4 < isol ) cubeindex |= 16;    if ( field5 < isol ) cubeindex |= 32;    if ( field6 < isol ) cubeindex |= 128;    if ( field7 < isol ) cubeindex |= 64;     // if cube is entirely in/out of the surface - bail, nothing to draw     const bits = edgeTable[ cubeindex ];    if ( bits === 0 ) return 0;     const d = scope.delta,     fx2 = fx + d,     fy2 = fy + d,     fz2 = fz + d;     // top of the cube     if ( bits & 1 ) {      compNorm( q );     compNorm( q1 );     VIntX( q * 3, 0, isol, fx, fy, fz, field0, field1, q, q1 );     }     if ( bits & 2 ) {      compNorm( q1 );     compNorm( q1y );     VIntY( q1 * 3, 3, isol, fx2, fy, fz, field1, field3, q1, q1y );     }     if ( bits & 4 ) {      compNorm( qy );     compNorm( q1y );     VIntX( qy * 3, 6, isol, fx, fy2, fz, field2, field3, qy, q1y );     }     if ( bits & 8 ) {      compNorm( q );     compNorm( qy );     VIntY( q * 3, 9, isol, fx, fy, fz, field0, field2, q, qy );     }     // bottom of the cube     if ( bits & 16 ) {      compNorm( qz );     compNorm( q1z );     VIntX( qz * 3, 12, isol, fx, fy, fz2, field4, field5, qz, q1z );     }     if ( bits & 32 ) {      compNorm( q1z );     compNorm( q1yz );     VIntY(      q1z * 3,      15,      isol,      fx2,      fy,      fz2,      field5,      field7,      q1z,      q1yz     );     }     if ( bits & 64 ) {      compNorm( qyz );     compNorm( q1yz );     VIntX(      qyz * 3,      18,      isol,      fx,      fy2,      fz2,      field6,      field7,      qyz,      q1yz     );     }     if ( bits & 128 ) {      compNorm( qz );     compNorm( qyz );     VIntY( qz * 3, 21, isol, fx, fy, fz2, field4, field6, qz, qyz );     }     // vertical lines of the cube    if ( bits & 256 ) {      compNorm( q );     compNorm( qz );     VIntZ( q * 3, 24, isol, fx, fy, fz, field0, field4, q, qz );     }     if ( bits & 512 ) {      compNorm( q1 );     compNorm( q1z );     VIntZ( q1 * 3, 27, isol, fx2, fy, fz, field1, field5, q1, q1z );     }     if ( bits & 1024 ) {      compNorm( q1y );     compNorm( q1yz );     VIntZ(      q1y * 3,      30,      isol,      fx2,      fy2,      fz,      field3,      field7,      q1y,      q1yz     );     }     if ( bits & 2048 ) {      compNorm( qy );     compNorm( qyz );     VIntZ( qy * 3, 33, isol, fx, fy2, fz, field2, field6, qy, qyz );     }     cubeindex <<= 4; // re-purpose cubeindex into an offset into triTable     let o1,     o2,     o3,     numtris = 0,     i = 0;     // here is where triangles are created     while ( triTable[ cubeindex + i ] != - 1 ) {      o1 = cubeindex + i;     o2 = o1 + 1;     o3 = o1 + 2;      posnormtriv(      vlist,      nlist,      clist,      3 * triTable[ o1 ],      3 * triTable[ o2 ],      3 * triTable[ o3 ]     );      i += 3;     numtris ++;     }     return numtris;    }    function posnormtriv( pos, norm, colors, o1, o2, o3 ) {     const c = scope.count * 3;     // positions     scope.positionArray[ c + 0 ] = pos[ o1 ];    scope.positionArray[ c + 1 ] = pos[ o1 + 1 ];    scope.positionArray[ c + 2 ] = pos[ o1 + 2 ];     scope.positionArray[ c + 3 ] = pos[ o2 ];    scope.positionArray[ c + 4 ] = pos[ o2 + 1 ];    scope.positionArray[ c + 5 ] = pos[ o2 + 2 ];     scope.positionArray[ c + 6 ] = pos[ o3 ];    scope.positionArray[ c + 7 ] = pos[ o3 + 1 ];    scope.positionArray[ c + 8 ] = pos[ o3 + 2 ];     // normals     if ( scope.material.flatShading === true ) {      const nx = ( norm[ o1 + 0 ] + norm[ o2 + 0 ] + norm[ o3 + 0 ] ) / 3;     const ny = ( norm[ o1 + 1 ] + norm[ o2 + 1 ] + norm[ o3 + 1 ] ) / 3;     const nz = ( norm[ o1 + 2 ] + norm[ o2 + 2 ] + norm[ o3 + 2 ] ) / 3;      scope.normalArray[ c + 0 ] = nx;     scope.normalArray[ c + 1 ] = ny;     scope.normalArray[ c + 2 ] = nz;      scope.normalArray[ c + 3 ] = nx;     scope.normalArray[ c + 4 ] = ny;     scope.normalArray[ c + 5 ] = nz;      scope.normalArray[ c + 6 ] = nx;     scope.normalArray[ c + 7 ] = ny;     scope.normalArray[ c + 8 ] = nz;     } else {      scope.normalArray[ c + 0 ] = norm[ o1 + 0 ];     scope.normalArray[ c + 1 ] = norm[ o1 + 1 ];     scope.normalArray[ c + 2 ] = norm[ o1 + 2 ];      scope.normalArray[ c + 3 ] = norm[ o2 + 0 ];     scope.normalArray[ c + 4 ] = norm[ o2 + 1 ];     scope.normalArray[ c + 5 ] = norm[ o2 + 2 ];      scope.normalArray[ c + 6 ] = norm[ o3 + 0 ];     scope.normalArray[ c + 7 ] = norm[ o3 + 1 ];     scope.normalArray[ c + 8 ] = norm[ o3 + 2 ];     }     // uvs     if ( scope.enableUvs ) {      const d = scope.count * 2;      scope.uvArray[ d + 0 ] = pos[ o1 + 0 ];     scope.uvArray[ d + 1 ] = pos[ o1 + 2 ];      scope.uvArray[ d + 2 ] = pos[ o2 + 0 ];     scope.uvArray[ d + 3 ] = pos[ o2 + 2 ];      scope.uvArray[ d + 4 ] = pos[ o3 + 0 ];     scope.uvArray[ d + 5 ] = pos[ o3 + 2 ];     }     // colors     if ( scope.enableColors ) {      scope.colorArray[ c + 0 ] = colors[ o1 + 0 ];     scope.colorArray[ c + 1 ] = colors[ o1 + 1 ];     scope.colorArray[ c + 2 ] = colors[ o1 + 2 ];      scope.colorArray[ c + 3 ] = colors[ o2 + 0 ];     scope.colorArray[ c + 4 ] = colors[ o2 + 1 ];     scope.colorArray[ c + 5 ] = colors[ o2 + 2 ];      scope.colorArray[ c + 6 ] = colors[ o3 + 0 ];     scope.colorArray[ c + 7 ] = colors[ o3 + 1 ];     scope.colorArray[ c + 8 ] = colors[ o3 + 2 ];     }     scope.count += 3;    }    /////////////////////////////////////   // Metaballs   /////////////////////////////////////    // Adds a reciprocal ball (nice and blobby) that, to be fast, fades to zero after   // a fixed distance, determined by strength and subtract.    this.addBall = function ( ballx, bally, ballz, strength, subtract, colors ) {     const sign = Math.sign( strength );    strength = Math.abs( strength );    const userDefineColor = ! ( colors === undefined || colors === null );    let ballColor = new Color( ballx, bally, ballz );     if ( userDefineColor ) {      try {       ballColor =       colors instanceof Color        ? colors        : Array.isArray( colors )         ? new Color(          Math.min( Math.abs( colors[ 0 ] ), 1 ),          Math.min( Math.abs( colors[ 1 ] ), 1 ),          Math.min( Math.abs( colors[ 2 ] ), 1 )          )         : new Color( colors );      } catch ( err ) {       ballColor = new Color( ballx, bally, ballz );      }     }     // Let's solve the equation to find the radius:    // 1.0 / (0.000001 + radius^2) * strength - subtract = 0    // strength / (radius^2) = subtract    // strength = subtract * radius^2    // radius^2 = strength / subtract    // radius = sqrt(strength / subtract)     const radius = this.size * Math.sqrt( strength / subtract ),     zs = ballz * this.size,     ys = bally * this.size,     xs = ballx * this.size;     let min_z = Math.floor( zs - radius );    if ( min_z < 1 ) min_z = 1;    let max_z = Math.floor( zs + radius );    if ( max_z > this.size - 1 ) max_z = this.size - 1;    let min_y = Math.floor( ys - radius );    if ( min_y < 1 ) min_y = 1;    let max_y = Math.floor( ys + radius );    if ( max_y > this.size - 1 ) max_y = this.size - 1;    let min_x = Math.floor( xs - radius );    if ( min_x < 1 ) min_x = 1;    let max_x = Math.floor( xs + radius );    if ( max_x > this.size - 1 ) max_x = this.size - 1;     // Don't polygonize in the outer layer because normals aren't    // well-defined there.     let x, y, z, y_offset, z_offset, fx, fy, fz, fz2, fy2, val;     for ( z = min_z; z < max_z; z ++ ) {      z_offset = this.size2 * z;     fz = z / this.size - ballz;     fz2 = fz * fz;      for ( y = min_y; y < max_y; y ++ ) {       y_offset = z_offset + this.size * y;      fy = y / this.size - bally;      fy2 = fy * fy;       for ( x = min_x; x < max_x; x ++ ) {        fx = x / this.size - ballx;       val = strength / ( 0.000001 + fx * fx + fy2 + fz2 ) - subtract;       if ( val > 0.0 ) {         this.field[ y_offset + x ] += val * sign;         // optimization        // http://www.geisswerks.com/ryan/BLOBS/blobs.html        const ratio =         Math.sqrt( ( x - xs ) * ( x - xs ) + ( y - ys ) * ( y - ys ) + ( z - zs ) * ( z - zs ) ) / radius;        const contrib =         1 - ratio * ratio * ratio * ( ratio * ( ratio * 6 - 15 ) + 10 );        this.palette[ ( y_offset + x ) * 3 + 0 ] += ballColor.r * contrib;        this.palette[ ( y_offset + x ) * 3 + 1 ] += ballColor.g * contrib;        this.palette[ ( y_offset + x ) * 3 + 2 ] += ballColor.b * contrib;        }       }      }     }    };    this.addPlaneX = function ( strength, subtract ) {     // cache attribute lookups    const size = this.size,     yd = this.yd,     zd = this.zd,     field = this.field;     let x,     y,     z,     xx,     val,     xdiv,     cxy,     dist = size * Math.sqrt( strength / subtract );     if ( dist > size ) dist = size;     for ( x = 0; x < dist; x ++ ) {      xdiv = x / size;     xx = xdiv * xdiv;     val = strength / ( 0.0001 + xx ) - subtract;      if ( val > 0.0 ) {       for ( y = 0; y < size; y ++ ) {        cxy = x + y * yd;        for ( z = 0; z < size; z ++ ) {         field[ zd * z + cxy ] += val;        }       }      }     }    };    this.addPlaneY = function ( strength, subtract ) {     // cache attribute lookups    const size = this.size,     yd = this.yd,     zd = this.zd,     field = this.field;     let x,     y,     z,     yy,     val,     ydiv,     cy,     cxy,     dist = size * Math.sqrt( strength / subtract );     if ( dist > size ) dist = size;     for ( y = 0; y < dist; y ++ ) {      ydiv = y / size;     yy = ydiv * ydiv;     val = strength / ( 0.0001 + yy ) - subtract;      if ( val > 0.0 ) {       cy = y * yd;       for ( x = 0; x < size; x ++ ) {        cxy = cy + x;        for ( z = 0; z < size; z ++ ) field[ zd * z + cxy ] += val;       }      }     }    };    this.addPlaneZ = function ( strength, subtract ) {     // cache attribute lookups     const size = this.size,     yd = this.yd,     zd = this.zd,     field = this.field;     let x,     y,     z,     zz,     val,     zdiv,     cz,     cyz,     dist = size * Math.sqrt( strength / subtract );     if ( dist > size ) dist = size;     for ( z = 0; z < dist; z ++ ) {      zdiv = z / size;     zz = zdiv * zdiv;     val = strength / ( 0.0001 + zz ) - subtract;     if ( val > 0.0 ) {       cz = zd * z;       for ( y = 0; y < size; y ++ ) {        cyz = cz + y * yd;        for ( x = 0; x < size; x ++ ) field[ cyz + x ] += val;       }      }     }    };    /////////////////////////////////////   // Updates   /////////////////////////////////////    this.setCell = function ( x, y, z, value ) {     const index = this.size2 * z + this.size * y + x;    this.field[ index ] = value;    };    this.getCell = function ( x, y, z ) {     const index = this.size2 * z + this.size * y + x;    return this.field[ index ];    };    this.blur = function ( intensity = 1 ) {     const field = this.field;    const fieldCopy = field.slice();    const size = this.size;    const size2 = this.size2;    for ( let x = 0; x < size; x ++ ) {      for ( let y = 0; y < size; y ++ ) {       for ( let z = 0; z < size; z ++ ) {        const index = size2 * z + size * y + x;       let val = fieldCopy[ index ];       let count = 1;        for ( let x2 = - 1; x2 <= 1; x2 += 2 ) {         const x3 = x2 + x;        if ( x3 < 0 || x3 >= size ) continue;         for ( let y2 = - 1; y2 <= 1; y2 += 2 ) {          const y3 = y2 + y;         if ( y3 < 0 || y3 >= size ) continue;          for ( let z2 = - 1; z2 <= 1; z2 += 2 ) {           const z3 = z2 + z;          if ( z3 < 0 || z3 >= size ) continue;           const index2 = size2 * z3 + size * y3 + x3;          const val2 = fieldCopy[ index2 ];           count ++;          val += intensity * ( val2 - val ) / count;          }         }        }        field[ index ] = val;       }      }     }    };    this.reset = function () {     // wipe the normal cache     for ( let i = 0; i < this.size3; i ++ ) {      this.normal_cache[ i * 3 ] = 0.0;     this.field[ i ] = 0.0;     this.palette[ i * 3 ] = this.palette[ i * 3 + 1 ] = this.palette[      i * 3 + 2     ] = 0.0;     }    };    this.update = function () {     this.count = 0;     // Triangulate. Yeah, this is slow.     const smin2 = this.size - 2;     for ( let z = 1; z < smin2; z ++ ) {      const z_offset = this.size2 * z;     const fz = ( z - this.halfsize ) / this.halfsize; //+ 1      for ( let y = 1; y < smin2; y ++ ) {       const y_offset = z_offset + this.size * y;      const fy = ( y - this.halfsize ) / this.halfsize; //+ 1       for ( let x = 1; x < smin2; x ++ ) {        const fx = ( x - this.halfsize ) / this.halfsize; //+ 1       const q = y_offset + x;         polygonize( fx, fy, fz, q, this.isolation );       }      }     }     // set the draw range to only the processed triangles     this.geometry.setDrawRange( 0, this.count );     // update geometry data     geometry.getAttribute( 'position' ).needsUpdate = true;    geometry.getAttribute( 'normal' ).needsUpdate = true;     if ( this.enableUvs ) geometry.getAttribute( 'uv' ).needsUpdate = true;    if ( this.enableColors ) geometry.getAttribute( 'color' ).needsUpdate = true;     // safety check     if ( this.count / 3 > maxPolyCount ) console.warn( 'THREE.MarchingCubes: Geometry buffers too small for rendering. Please create an instance with a higher poly count.' );    };    this.init( resolution );   }  }  ///////////////////////////////////// // Marching cubes lookup tables /////////////////////////////////////  // These tables are straight from Paul Bourke's page: // http://paulbourke.net/geometry/polygonise/ // who in turn got them from Cory Gene Bloyd.  const edgeTable = new Int32Array( [  0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,  0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,  0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,  0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,  0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,  0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,  0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,  0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,  0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,  0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,  0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,  0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,  0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,  0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,  0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,  0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,  0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,  0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,  0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,  0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,  0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,  0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,  0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,  0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,  0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,  0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,  0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,  0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,  0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,  0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,  0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,  0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0 ] );  const triTable = new Int32Array( [  - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 8, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 1, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 8, 3, 9, 8, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 2, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 8, 3, 1, 2, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 2, 10, 0, 2, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  2, 8, 3, 2, 10, 8, 10, 9, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  3, 11, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 11, 2, 8, 11, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 9, 0, 2, 3, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 11, 2, 1, 9, 11, 9, 8, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  3, 10, 1, 11, 10, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 10, 1, 0, 8, 10, 8, 11, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  3, 9, 0, 3, 11, 9, 11, 10, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 8, 10, 10, 8, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  4, 7, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  4, 3, 0, 7, 3, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 1, 9, 8, 4, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  4, 1, 9, 4, 7, 1, 7, 3, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 2, 10, 8, 4, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  3, 4, 7, 3, 0, 4, 1, 2, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 2, 10, 9, 0, 2, 8, 4, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, - 1, - 1, - 1, - 1,  8, 4, 7, 3, 11, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  11, 4, 7, 11, 2, 4, 2, 0, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 0, 1, 8, 4, 7, 2, 3, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, - 1, - 1, - 1, - 1,  3, 10, 1, 3, 11, 10, 7, 8, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, - 1, - 1, - 1, - 1,  4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, - 1, - 1, - 1, - 1,  4, 7, 11, 4, 11, 9, 9, 11, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 5, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 5, 4, 0, 8, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 5, 4, 1, 5, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  8, 5, 4, 8, 3, 5, 3, 1, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 2, 10, 9, 5, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  3, 0, 8, 1, 2, 10, 4, 9, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  5, 2, 10, 5, 4, 2, 4, 0, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, - 1, - 1, - 1, - 1,  9, 5, 4, 2, 3, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 11, 2, 0, 8, 11, 4, 9, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 5, 4, 0, 1, 5, 2, 3, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, - 1, - 1, - 1, - 1,  10, 3, 11, 10, 1, 3, 9, 5, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, - 1, - 1, - 1, - 1,  5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, - 1, - 1, - 1, - 1,  5, 4, 8, 5, 8, 10, 10, 8, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 7, 8, 5, 7, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 3, 0, 9, 5, 3, 5, 7, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 7, 8, 0, 1, 7, 1, 5, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 5, 3, 3, 5, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 7, 8, 9, 5, 7, 10, 1, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, - 1, - 1, - 1, - 1,  8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, - 1, - 1, - 1, - 1,  2, 10, 5, 2, 5, 3, 3, 5, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  7, 9, 5, 7, 8, 9, 3, 11, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, - 1, - 1, - 1, - 1,  2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, - 1, - 1, - 1, - 1,  11, 2, 1, 11, 1, 7, 7, 1, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, - 1, - 1, - 1, - 1,  5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, - 1,  11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, - 1,  11, 10, 5, 7, 11, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  10, 6, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 8, 3, 5, 10, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 0, 1, 5, 10, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 8, 3, 1, 9, 8, 5, 10, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 6, 5, 2, 6, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 6, 5, 1, 2, 6, 3, 0, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 6, 5, 9, 0, 6, 0, 2, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, - 1, - 1, - 1, - 1,  2, 3, 11, 10, 6, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  11, 0, 8, 11, 2, 0, 10, 6, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 1, 9, 2, 3, 11, 5, 10, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, - 1, - 1, - 1, - 1,  6, 3, 11, 6, 5, 3, 5, 1, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, - 1, - 1, - 1, - 1,  3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, - 1, - 1, - 1, - 1,  6, 5, 9, 6, 9, 11, 11, 9, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  5, 10, 6, 4, 7, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  4, 3, 0, 4, 7, 3, 6, 5, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 9, 0, 5, 10, 6, 8, 4, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, - 1, - 1, - 1, - 1,  6, 1, 2, 6, 5, 1, 4, 7, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, - 1, - 1, - 1, - 1,  8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, - 1, - 1, - 1, - 1,  7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, - 1,  3, 11, 2, 7, 8, 4, 10, 6, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, - 1, - 1, - 1, - 1,  0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, - 1, - 1, - 1, - 1,  9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, - 1,  8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, - 1, - 1, - 1, - 1,  5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, - 1,  0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, - 1,  6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, - 1, - 1, - 1, - 1,  10, 4, 9, 6, 4, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  4, 10, 6, 4, 9, 10, 0, 8, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  10, 0, 1, 10, 6, 0, 6, 4, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, - 1, - 1, - 1, - 1,  1, 4, 9, 1, 2, 4, 2, 6, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, - 1, - 1, - 1, - 1,  0, 2, 4, 4, 2, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  8, 3, 2, 8, 2, 4, 4, 2, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  10, 4, 9, 10, 6, 4, 11, 2, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, - 1, - 1, - 1, - 1,  3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, - 1, - 1, - 1, - 1,  6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, - 1,  9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, - 1, - 1, - 1, - 1,  8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, - 1,  3, 11, 6, 3, 6, 0, 0, 6, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  6, 4, 8, 11, 6, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  7, 10, 6, 7, 8, 10, 8, 9, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, - 1, - 1, - 1, - 1,  10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, - 1, - 1, - 1, - 1,  10, 6, 7, 10, 7, 1, 1, 7, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, - 1, - 1, - 1, - 1,  2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, - 1,  7, 8, 0, 7, 0, 6, 6, 0, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  7, 3, 2, 6, 7, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, - 1, - 1, - 1, - 1,  2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, - 1,  1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, - 1,  11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, - 1, - 1, - 1, - 1,  8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, - 1,  0, 9, 1, 11, 6, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, - 1, - 1, - 1, - 1,  7, 11, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  7, 6, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  3, 0, 8, 11, 7, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 1, 9, 11, 7, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  8, 1, 9, 8, 3, 1, 11, 7, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  10, 1, 2, 6, 11, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 2, 10, 3, 0, 8, 6, 11, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  2, 9, 0, 2, 10, 9, 6, 11, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, - 1, - 1, - 1, - 1,  7, 2, 3, 6, 2, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  7, 0, 8, 7, 6, 0, 6, 2, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  2, 7, 6, 2, 3, 7, 0, 1, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, - 1, - 1, - 1, - 1,  10, 7, 6, 10, 1, 7, 1, 3, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, - 1, - 1, - 1, - 1,  0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, - 1, - 1, - 1, - 1,  7, 6, 10, 7, 10, 8, 8, 10, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  6, 8, 4, 11, 8, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  3, 6, 11, 3, 0, 6, 0, 4, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  8, 6, 11, 8, 4, 6, 9, 0, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, - 1, - 1, - 1, - 1,  6, 8, 4, 6, 11, 8, 2, 10, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, - 1, - 1, - 1, - 1,  4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, - 1, - 1, - 1, - 1,  10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, - 1,  8, 2, 3, 8, 4, 2, 4, 6, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 4, 2, 4, 6, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, - 1, - 1, - 1, - 1,  1, 9, 4, 1, 4, 2, 2, 4, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, - 1, - 1, - 1, - 1,  10, 1, 0, 10, 0, 6, 6, 0, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, - 1,  10, 9, 4, 6, 10, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  4, 9, 5, 7, 6, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 8, 3, 4, 9, 5, 11, 7, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  5, 0, 1, 5, 4, 0, 7, 6, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, - 1, - 1, - 1, - 1,  9, 5, 4, 10, 1, 2, 7, 6, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, - 1, - 1, - 1, - 1,  7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, - 1, - 1, - 1, - 1,  3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, - 1,  7, 2, 3, 7, 6, 2, 5, 4, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, - 1, - 1, - 1, - 1,  3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, - 1, - 1, - 1, - 1,  6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, - 1,  9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, - 1, - 1, - 1, - 1,  1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, - 1,  4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, - 1,  7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, - 1, - 1, - 1, - 1,  6, 9, 5, 6, 11, 9, 11, 8, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, - 1, - 1, - 1, - 1,  0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, - 1, - 1, - 1, - 1,  6, 11, 3, 6, 3, 5, 5, 3, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, - 1, - 1, - 1, - 1,  0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, - 1,  11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, - 1,  6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, - 1, - 1, - 1, - 1,  5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, - 1, - 1, - 1, - 1,  9, 5, 6, 9, 6, 0, 0, 6, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, - 1,  1, 5, 6, 2, 1, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, - 1,  10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, - 1, - 1, - 1, - 1,  0, 3, 8, 5, 6, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  10, 5, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  11, 5, 10, 7, 5, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  11, 5, 10, 11, 7, 5, 8, 3, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  5, 11, 7, 5, 10, 11, 1, 9, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, - 1, - 1, - 1, - 1,  11, 1, 2, 11, 7, 1, 7, 5, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, - 1, - 1, - 1, - 1,  9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, - 1, - 1, - 1, - 1,  7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, - 1,  2, 5, 10, 2, 3, 5, 3, 7, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, - 1, - 1, - 1, - 1,  9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, - 1, - 1, - 1, - 1,  9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, - 1,  1, 3, 5, 3, 7, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 8, 7, 0, 7, 1, 1, 7, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 0, 3, 9, 3, 5, 5, 3, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 8, 7, 5, 9, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  5, 8, 4, 5, 10, 8, 10, 11, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, - 1, - 1, - 1, - 1,  0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, - 1, - 1, - 1, - 1,  10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, - 1,  2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, - 1, - 1, - 1, - 1,  0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, - 1,  0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, - 1,  9, 4, 5, 2, 11, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, - 1, - 1, - 1, - 1,  5, 10, 2, 5, 2, 4, 4, 2, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, - 1,  5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, - 1, - 1, - 1, - 1,  8, 4, 5, 8, 5, 3, 3, 5, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 4, 5, 1, 0, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, - 1, - 1, - 1, - 1,  9, 4, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  4, 11, 7, 4, 9, 11, 9, 10, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, - 1, - 1, - 1, - 1,  1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, - 1, - 1, - 1, - 1,  3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, - 1,  4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, - 1, - 1, - 1, - 1,  9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, - 1,  11, 7, 4, 11, 4, 2, 2, 4, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, - 1, - 1, - 1, - 1,  2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, - 1, - 1, - 1, - 1,  9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, - 1,  3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, - 1,  1, 10, 2, 8, 7, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  4, 9, 1, 4, 1, 7, 7, 1, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, - 1, - 1, - 1, - 1,  4, 0, 3, 7, 4, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  4, 8, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 10, 8, 10, 11, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  3, 0, 9, 3, 9, 11, 11, 9, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 1, 10, 0, 10, 8, 8, 10, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  3, 1, 10, 11, 3, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 2, 11, 1, 11, 9, 9, 11, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, - 1, - 1, - 1, - 1,  0, 2, 11, 8, 0, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  3, 2, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  2, 3, 8, 2, 8, 10, 10, 8, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  9, 10, 2, 0, 9, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, - 1, - 1, - 1, - 1,  1, 10, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  1, 3, 8, 9, 1, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 9, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  0, 3, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,  - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1 ] );  export { MarchingCubes, edgeTable, triTable }; 
^..^ FILENAME ^..^
addons|objects|Reflector.js
^..^ CONTENTS ^..^
import {  Color,  Matrix4,  Mesh,  PerspectiveCamera,  Plane,  ShaderMaterial,  UniformsUtils,  Vector3,  Vector4,  WebGLRenderTarget,  HalfFloatType } from 'three';  class Reflector extends Mesh {   constructor( geometry, options = {} ) {    super( geometry );    this.isReflector = true;    this.type = 'Reflector';   this.camera = new PerspectiveCamera();    const scope = this;    const color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );   const textureWidth = options.textureWidth || 512;   const textureHeight = options.textureHeight || 512;   const clipBias = options.clipBias || 0;   const shader = options.shader || Reflector.ReflectorShader;   const multisample = ( options.multisample !== undefined ) ? options.multisample : 4;    //    const reflectorPlane = new Plane();   const normal = new Vector3();   const reflectorWorldPosition = new Vector3();   const cameraWorldPosition = new Vector3();   const rotationMatrix = new Matrix4();   const lookAtPosition = new Vector3( 0, 0, - 1 );   const clipPlane = new Vector4();    const view = new Vector3();   const target = new Vector3();   const q = new Vector4();    const textureMatrix = new Matrix4();   const virtualCamera = this.camera;    const renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, { samples: multisample, type: HalfFloatType } );    const material = new ShaderMaterial( {    name: ( shader.name !== undefined ) ? shader.name : 'unspecified',    uniforms: UniformsUtils.clone( shader.uniforms ),    fragmentShader: shader.fragmentShader,    vertexShader: shader.vertexShader   } );    material.uniforms[ 'tDiffuse' ].value = renderTarget.texture;   material.uniforms[ 'color' ].value = color;   material.uniforms[ 'textureMatrix' ].value = textureMatrix;    this.material = material;    this.onBeforeRender = function ( renderer, scene, camera ) {     reflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );    cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );     rotationMatrix.extractRotation( scope.matrixWorld );     normal.set( 0, 0, 1 );    normal.applyMatrix4( rotationMatrix );     view.subVectors( reflectorWorldPosition, cameraWorldPosition );     // Avoid rendering when reflector is facing away     if ( view.dot( normal ) > 0 ) return;     view.reflect( normal ).negate();    view.add( reflectorWorldPosition );     rotationMatrix.extractRotation( camera.matrixWorld );     lookAtPosition.set( 0, 0, - 1 );    lookAtPosition.applyMatrix4( rotationMatrix );    lookAtPosition.add( cameraWorldPosition );     target.subVectors( reflectorWorldPosition, lookAtPosition );    target.reflect( normal ).negate();    target.add( reflectorWorldPosition );     virtualCamera.position.copy( view );    virtualCamera.up.set( 0, 1, 0 );    virtualCamera.up.applyMatrix4( rotationMatrix );    virtualCamera.up.reflect( normal );    virtualCamera.lookAt( target );     virtualCamera.far = camera.far; // Used in WebGLBackground     virtualCamera.updateMatrixWorld();    virtualCamera.projectionMatrix.copy( camera.projectionMatrix );     // Update the texture matrix    textureMatrix.set(     0.5, 0.0, 0.0, 0.5,     0.0, 0.5, 0.0, 0.5,     0.0, 0.0, 0.5, 0.5,     0.0, 0.0, 0.0, 1.0    );    textureMatrix.multiply( virtualCamera.projectionMatrix );    textureMatrix.multiply( virtualCamera.matrixWorldInverse );    textureMatrix.multiply( scope.matrixWorld );     // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf    reflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );    reflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );     clipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );     const projectionMatrix = virtualCamera.projectionMatrix;     q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];    q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];    q.z = - 1.0;    q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];     // Calculate the scaled plane vector    clipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );     // Replacing the third row of the projection matrix    projectionMatrix.elements[ 2 ] = clipPlane.x;    projectionMatrix.elements[ 6 ] = clipPlane.y;    projectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;    projectionMatrix.elements[ 14 ] = clipPlane.w;     // Render    scope.visible = false;     const currentRenderTarget = renderer.getRenderTarget();     const currentXrEnabled = renderer.xr.enabled;    const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;     renderer.xr.enabled = false; // Avoid camera modification    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows     renderer.setRenderTarget( renderTarget );     renderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897     if ( renderer.autoClear === false ) renderer.clear();    renderer.render( scene, virtualCamera );     renderer.xr.enabled = currentXrEnabled;    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;     renderer.setRenderTarget( currentRenderTarget );     // Restore viewport     const viewport = camera.viewport;     if ( viewport !== undefined ) {      renderer.state.viewport( viewport );     }     scope.visible = true;    };    this.getRenderTarget = function () {     return renderTarget;    };    this.dispose = function () {     renderTarget.dispose();    scope.material.dispose();    };   }  }  Reflector.ReflectorShader = {   name: 'ReflectorShader',   uniforms: {    'color': {    value: null   },    'tDiffuse': {    value: null   },    'textureMatrix': {    value: null   }   },   vertexShader: /* glsl */|   uniform mat4 textureMatrix;   varying vec4 vUv;    #include <common>   #include <logdepthbuf_pars_vertex>    void main() {     vUv = textureMatrix * vec4( position, 1.0 );     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );     #include <logdepthbuf_vertex>    }|,   fragmentShader: /* glsl */|   uniform vec3 color;   uniform sampler2D tDiffuse;   varying vec4 vUv;    #include <logdepthbuf_pars_fragment>    float blendOverlay( float base, float blend ) {     return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );    }    vec3 blendOverlay( vec3 base, vec3 blend ) {     return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );    }    void main() {     #include <logdepthbuf_fragment>     vec4 base = texture2DProj( tDiffuse, vUv );    gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );     #include <tonemapping_fragment>    #include <colorspace_fragment>    }| };  export { Reflector }; 
^..^ FILENAME ^..^
addons|objects|ReflectorForSSRPass.js
^..^ CONTENTS ^..^
import {  Color,  Matrix4,  Mesh,  PerspectiveCamera,  ShaderMaterial,  UniformsUtils,  Vector2,  Vector3,  WebGLRenderTarget,  DepthTexture,  UnsignedShortType,  NearestFilter,  Plane,  HalfFloatType } from 'three';  class ReflectorForSSRPass extends Mesh {   constructor( geometry, options = {} ) {    super( geometry );    this.isReflectorForSSRPass = true;    this.type = 'ReflectorForSSRPass';    const scope = this;    const color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );   const textureWidth = options.textureWidth || 512;   const textureHeight = options.textureHeight || 512;   const clipBias = options.clipBias || 0;   const shader = options.shader || ReflectorForSSRPass.ReflectorShader;   const useDepthTexture = options.useDepthTexture === true;   const yAxis = new Vector3( 0, 1, 0 );   const vecTemp0 = new Vector3();   const vecTemp1 = new Vector3();    //    scope.needsUpdate = false;   scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;   scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;   scope.color = color;   scope.resolution = options.resolution || new Vector2( window.innerWidth, window.innerHeight );     scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;   Object.defineProperty( scope, 'distanceAttenuation', {    get() {      return scope._distanceAttenuation;     },    set( val ) {      if ( scope._distanceAttenuation === val ) return;     scope._distanceAttenuation = val;     scope.material.defines.DISTANCE_ATTENUATION = val;     scope.material.needsUpdate = true;     }   } );    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;   Object.defineProperty( scope, 'fresnel', {    get() {      return scope._fresnel;     },    set( val ) {      if ( scope._fresnel === val ) return;     scope._fresnel = val;     scope.material.defines.FRESNEL = val;     scope.material.needsUpdate = true;     }   } );    const normal = new Vector3();   const reflectorWorldPosition = new Vector3();   const cameraWorldPosition = new Vector3();   const rotationMatrix = new Matrix4();   const lookAtPosition = new Vector3( 0, 0, - 1 );    const view = new Vector3();   const target = new Vector3();    const textureMatrix = new Matrix4();   const virtualCamera = new PerspectiveCamera();    let depthTexture;    if ( useDepthTexture ) {     depthTexture = new DepthTexture();    depthTexture.type = UnsignedShortType;    depthTexture.minFilter = NearestFilter;    depthTexture.magFilter = NearestFilter;    }    const parameters = {    depthTexture: useDepthTexture ? depthTexture : null,    type: HalfFloatType   };    const renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, parameters );    const material = new ShaderMaterial( {    name: ( shader.name !== undefined ) ? shader.name : 'unspecified',    transparent: useDepthTexture,    defines: Object.assign( {}, ReflectorForSSRPass.ReflectorShader.defines, {     useDepthTexture    } ),    uniforms: UniformsUtils.clone( shader.uniforms ),    fragmentShader: shader.fragmentShader,    vertexShader: shader.vertexShader   } );    material.uniforms[ 'tDiffuse' ].value = renderTarget.texture;   material.uniforms[ 'color' ].value = scope.color;   material.uniforms[ 'textureMatrix' ].value = textureMatrix;   if ( useDepthTexture ) {     material.uniforms[ 'tDepth' ].value = renderTarget.depthTexture;    }    this.material = material;    const globalPlane = new Plane( new Vector3( 0, 1, 0 ), clipBias );   const globalPlanes = [ globalPlane ];    this.doRender = function ( renderer, scene, camera ) {     material.uniforms[ 'maxDistance' ].value = scope.maxDistance;    material.uniforms[ 'color' ].value = scope.color;    material.uniforms[ 'opacity' ].value = scope.opacity;     vecTemp0.copy( camera.position ).normalize();    vecTemp1.copy( vecTemp0 ).reflect( yAxis );    material.uniforms[ 'fresnelCoe' ].value = ( vecTemp0.dot( vecTemp1 ) + 1. ) / 2.; // TODO: Also need to use glsl viewPosition and viewNormal per pixel.     reflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );    cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );     rotationMatrix.extractRotation( scope.matrixWorld );     normal.set( 0, 0, 1 );    normal.applyMatrix4( rotationMatrix );     view.subVectors( reflectorWorldPosition, cameraWorldPosition );     // Avoid rendering when reflector is facing away     if ( view.dot( normal ) > 0 ) return;     view.reflect( normal ).negate();    view.add( reflectorWorldPosition );     rotationMatrix.extractRotation( camera.matrixWorld );     lookAtPosition.set( 0, 0, - 1 );    lookAtPosition.applyMatrix4( rotationMatrix );    lookAtPosition.add( cameraWorldPosition );     target.subVectors( reflectorWorldPosition, lookAtPosition );    target.reflect( normal ).negate();    target.add( reflectorWorldPosition );     virtualCamera.position.copy( view );    virtualCamera.up.set( 0, 1, 0 );    virtualCamera.up.applyMatrix4( rotationMatrix );    virtualCamera.up.reflect( normal );    virtualCamera.lookAt( target );     virtualCamera.far = camera.far; // Used in WebGLBackground     virtualCamera.updateMatrixWorld();    virtualCamera.projectionMatrix.copy( camera.projectionMatrix );     material.uniforms[ 'virtualCameraNear' ].value = camera.near;    material.uniforms[ 'virtualCameraFar' ].value = camera.far;    material.uniforms[ 'virtualCameraMatrixWorld' ].value = virtualCamera.matrixWorld;    material.uniforms[ 'virtualCameraProjectionMatrix' ].value = camera.projectionMatrix;    material.uniforms[ 'virtualCameraProjectionMatrixInverse' ].value = camera.projectionMatrixInverse;    material.uniforms[ 'resolution' ].value = scope.resolution;     // Update the texture matrix    textureMatrix.set(     0.5, 0.0, 0.0, 0.5,     0.0, 0.5, 0.0, 0.5,     0.0, 0.0, 0.5, 0.5,     0.0, 0.0, 0.0, 1.0    );    textureMatrix.multiply( virtualCamera.projectionMatrix );    textureMatrix.multiply( virtualCamera.matrixWorldInverse );    textureMatrix.multiply( scope.matrixWorld );     // scope.visible = false;     const currentRenderTarget = renderer.getRenderTarget();     const currentXrEnabled = renderer.xr.enabled;    const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;    const currentClippingPlanes = renderer.clippingPlanes;     renderer.xr.enabled = false; // Avoid camera modification    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows    renderer.clippingPlanes = globalPlanes;     renderer.setRenderTarget( renderTarget );     renderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897     if ( renderer.autoClear === false ) renderer.clear();    renderer.render( scene, virtualCamera );     renderer.xr.enabled = currentXrEnabled;    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;    renderer.clippingPlanes = currentClippingPlanes;     renderer.setRenderTarget( currentRenderTarget );     // Restore viewport     const viewport = camera.viewport;     if ( viewport !== undefined ) {      renderer.state.viewport( viewport );     }     // scope.visible = true;    };    this.getRenderTarget = function () {     return renderTarget;    };   }  }  ReflectorForSSRPass.ReflectorShader = {   name: 'ReflectorShader',   defines: {   DISTANCE_ATTENUATION: true,   FRESNEL: true,  },   uniforms: {    color: { value: null },   tDiffuse: { value: null },   tDepth: { value: null },   textureMatrix: { value: new Matrix4() },   maxDistance: { value: 180 },   opacity: { value: 0.5 },   fresnelCoe: { value: null },   virtualCameraNear: { value: null },   virtualCameraFar: { value: null },   virtualCameraProjectionMatrix: { value: new Matrix4() },   virtualCameraMatrixWorld: { value: new Matrix4() },   virtualCameraProjectionMatrixInverse: { value: new Matrix4() },   resolution: { value: new Vector2() },   },   vertexShader: /* glsl */|   uniform mat4 textureMatrix;   varying vec4 vUv;    void main() {     vUv = textureMatrix * vec4( position, 1.0 );     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|   uniform vec3 color;   uniform sampler2D tDiffuse;   uniform sampler2D tDepth;   uniform float maxDistance;   uniform float opacity;   uniform float fresnelCoe;   uniform float virtualCameraNear;   uniform float virtualCameraFar;   uniform mat4 virtualCameraProjectionMatrix;   uniform mat4 virtualCameraProjectionMatrixInverse;   uniform mat4 virtualCameraMatrixWorld;   uniform vec2 resolution;   varying vec4 vUv;   #include <packing>   float blendOverlay( float base, float blend ) {    return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );   }   vec3 blendOverlay( vec3 base, vec3 blend ) {    return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );   }   float getDepth( const in vec2 uv ) {    return texture2D( tDepth, uv ).x;   }   float getViewZ( const in float depth ) {    return perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );   }   vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {    vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc    clipPosition *= clipW; //clip    return ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view   }   void main() {    vec4 base = texture2DProj( tDiffuse, vUv );    #ifdef useDepthTexture     vec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;     uv.x=1.-uv.x;     float depth = texture2DProj( tDepth, vUv ).r;     float viewZ = getViewZ( depth );     float clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];     vec3 viewPosition=getViewPosition( uv, depth, clipW );     vec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;     if(worldPosition.y>maxDistance) discard;     float op=opacity;     #ifdef DISTANCE_ATTENUATION      float ratio=1.-(worldPosition.y/maxDistance);      float attenuation=ratio*ratio;      op=opacity*attenuation;     #endif     #ifdef FRESNEL      op*=fresnelCoe;     #endif     gl_FragColor = vec4( blendOverlay( base.rgb, color ), op );    #else     gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );    #endif   }  |, };  export { ReflectorForSSRPass }; 
^..^ FILENAME ^..^
addons|objects|Refractor.js
^..^ CONTENTS ^..^
import {  Color,  Matrix4,  Mesh,  PerspectiveCamera,  Plane,  Quaternion,  ShaderMaterial,  UniformsUtils,  Vector3,  Vector4,  WebGLRenderTarget,  HalfFloatType } from 'three';  class Refractor extends Mesh {   constructor( geometry, options = {} ) {    super( geometry );    this.isRefractor = true;    this.type = 'Refractor';   this.camera = new PerspectiveCamera();    const scope = this;    const color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );   const textureWidth = options.textureWidth || 512;   const textureHeight = options.textureHeight || 512;   const clipBias = options.clipBias || 0;   const shader = options.shader || Refractor.RefractorShader;   const multisample = ( options.multisample !== undefined ) ? options.multisample : 4;    //    const virtualCamera = this.camera;   virtualCamera.matrixAutoUpdate = false;   virtualCamera.userData.refractor = true;    //    const refractorPlane = new Plane();   const textureMatrix = new Matrix4();    // render target    const renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, { samples: multisample, type: HalfFloatType } );    // material    this.material = new ShaderMaterial( {    name: ( shader.name !== undefined ) ? shader.name : 'unspecified',    uniforms: UniformsUtils.clone( shader.uniforms ),    vertexShader: shader.vertexShader,    fragmentShader: shader.fragmentShader,    transparent: true // ensures, refractors are drawn from farthest to closest   } );    this.material.uniforms[ 'color' ].value = color;   this.material.uniforms[ 'tDiffuse' ].value = renderTarget.texture;   this.material.uniforms[ 'textureMatrix' ].value = textureMatrix;    // functions    const visible = ( function () {     const refractorWorldPosition = new Vector3();    const cameraWorldPosition = new Vector3();    const rotationMatrix = new Matrix4();     const view = new Vector3();    const normal = new Vector3();     return function visible( camera ) {      refractorWorldPosition.setFromMatrixPosition( scope.matrixWorld );     cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );      view.subVectors( refractorWorldPosition, cameraWorldPosition );      rotationMatrix.extractRotation( scope.matrixWorld );      normal.set( 0, 0, 1 );     normal.applyMatrix4( rotationMatrix );      return view.dot( normal ) < 0;     };    } )();    const updateRefractorPlane = ( function () {     const normal = new Vector3();    const position = new Vector3();    const quaternion = new Quaternion();    const scale = new Vector3();     return function updateRefractorPlane() {      scope.matrixWorld.decompose( position, quaternion, scale );     normal.set( 0, 0, 1 ).applyQuaternion( quaternion ).normalize();      // flip the normal because we want to cull everything above the plane      normal.negate();      refractorPlane.setFromNormalAndCoplanarPoint( normal, position );     };    } )();    const updateVirtualCamera = ( function () {     const clipPlane = new Plane();    const clipVector = new Vector4();    const q = new Vector4();     return function updateVirtualCamera( camera ) {      virtualCamera.matrixWorld.copy( camera.matrixWorld );     virtualCamera.matrixWorldInverse.copy( virtualCamera.matrixWorld ).invert();     virtualCamera.projectionMatrix.copy( camera.projectionMatrix );     virtualCamera.far = camera.far; // used in WebGLBackground      // The following code creates an oblique view frustum for clipping.     // see: Lengyel, Eric. ??Oblique View Frustum Depth Projection and Clipping??.     // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5?"16      clipPlane.copy( refractorPlane );     clipPlane.applyMatrix4( virtualCamera.matrixWorldInverse );      clipVector.set( clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant );      // calculate the clip-space corner point opposite the clipping plane and     // transform it into camera space by multiplying it by the inverse of the projection matrix      const projectionMatrix = virtualCamera.projectionMatrix;      q.x = ( Math.sign( clipVector.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];     q.y = ( Math.sign( clipVector.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];     q.z = - 1.0;     q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];      // calculate the scaled plane vector      clipVector.multiplyScalar( 2.0 / clipVector.dot( q ) );      // replacing the third row of the projection matrix      projectionMatrix.elements[ 2 ] = clipVector.x;     projectionMatrix.elements[ 6 ] = clipVector.y;     projectionMatrix.elements[ 10 ] = clipVector.z + 1.0 - clipBias;     projectionMatrix.elements[ 14 ] = clipVector.w;     };    } )();    // This will update the texture matrix that is used for projective texture mapping in the shader.   // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf    function updateTextureMatrix( camera ) {     // this matrix does range mapping to [ 0, 1 ]     textureMatrix.set(     0.5, 0.0, 0.0, 0.5,     0.0, 0.5, 0.0, 0.5,     0.0, 0.0, 0.5, 0.5,     0.0, 0.0, 0.0, 1.0    );     // we use "Object Linear Texgen", so we need to multiply the texture matrix T    // (matrix above) with the projection and view matrix of the virtual camera    // and the model matrix of the refractor     textureMatrix.multiply( camera.projectionMatrix );    textureMatrix.multiply( camera.matrixWorldInverse );    textureMatrix.multiply( scope.matrixWorld );    }    //    function render( renderer, scene, camera ) {     scope.visible = false;     const currentRenderTarget = renderer.getRenderTarget();    const currentXrEnabled = renderer.xr.enabled;    const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;     renderer.xr.enabled = false; // avoid camera modification    renderer.shadowMap.autoUpdate = false; // avoid re-computing shadows     renderer.setRenderTarget( renderTarget );    if ( renderer.autoClear === false ) renderer.clear();    renderer.render( scene, virtualCamera );     renderer.xr.enabled = currentXrEnabled;    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;    renderer.setRenderTarget( currentRenderTarget );     // restore viewport     const viewport = camera.viewport;     if ( viewport !== undefined ) {      renderer.state.viewport( viewport );     }     scope.visible = true;    }    //    this.onBeforeRender = function ( renderer, scene, camera ) {     // ensure refractors are rendered only once per frame     if ( camera.userData.refractor === true ) return;     // avoid rendering when the refractor is viewed from behind     if ( ! visible( camera ) === true ) return;     // update     updateRefractorPlane();     updateTextureMatrix( camera );     updateVirtualCamera( camera );     render( renderer, scene, camera );    };    this.getRenderTarget = function () {     return renderTarget;    };    this.dispose = function () {     renderTarget.dispose();    scope.material.dispose();    };   }  }  Refractor.RefractorShader = {   name: 'RefractorShader',   uniforms: {    'color': {    value: null   },    'tDiffuse': {    value: null   },    'textureMatrix': {    value: null   }   },   vertexShader: /* glsl */|    uniform mat4 textureMatrix;    varying vec4 vUv;    void main() {     vUv = textureMatrix * vec4( position, 1.0 );    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform vec3 color;   uniform sampler2D tDiffuse;    varying vec4 vUv;    float blendOverlay( float base, float blend ) {     return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );    }    vec3 blendOverlay( vec3 base, vec3 blend ) {     return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );    }    void main() {     vec4 base = texture2DProj( tDiffuse, vUv );    gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );     #include <tonemapping_fragment>    #include <colorspace_fragment>    }|  };  export { Refractor }; 
^..^ FILENAME ^..^
addons|objects|ShadowMesh.js
^..^ CONTENTS ^..^
import {  Matrix4,  Mesh,  MeshBasicMaterial,  EqualStencilFunc,  IncrementStencilOp } from 'three';  /**  * A shadow Mesh that follows a shadow-casting Mesh in the scene, but is confined to a single plane.  */  const _shadowMatrix = new Matrix4();  class ShadowMesh extends Mesh {   constructor( mesh ) {    const shadowMaterial = new MeshBasicMaterial( {     color: 0x000000,    transparent: true,    opacity: 0.6,    depthWrite: false,    stencilWrite: true,    stencilFunc: EqualStencilFunc,    stencilRef: 0,    stencilZPass: IncrementStencilOp    } );    super( mesh.geometry, shadowMaterial );    this.isShadowMesh = true;    this.meshMatrix = mesh.matrixWorld;    this.frustumCulled = false;   this.matrixAutoUpdate = false;   }   update( plane, lightPosition4D ) {    // based on https://www.opengl.org/archives/resources/features/StencilTalk/tsld021.htm    const dot = plane.normal.x * lightPosition4D.x +      plane.normal.y * lightPosition4D.y +      plane.normal.z * lightPosition4D.z +      - plane.constant * lightPosition4D.w;    const sme = _shadowMatrix.elements;    sme[ 0 ] = dot - lightPosition4D.x * plane.normal.x;   sme[ 4 ] = - lightPosition4D.x * plane.normal.y;   sme[ 8 ] = - lightPosition4D.x * plane.normal.z;   sme[ 12 ] = - lightPosition4D.x * - plane.constant;    sme[ 1 ] = - lightPosition4D.y * plane.normal.x;   sme[ 5 ] = dot - lightPosition4D.y * plane.normal.y;   sme[ 9 ] = - lightPosition4D.y * plane.normal.z;   sme[ 13 ] = - lightPosition4D.y * - plane.constant;    sme[ 2 ] = - lightPosition4D.z * plane.normal.x;   sme[ 6 ] = - lightPosition4D.z * plane.normal.y;   sme[ 10 ] = dot - lightPosition4D.z * plane.normal.z;   sme[ 14 ] = - lightPosition4D.z * - plane.constant;    sme[ 3 ] = - lightPosition4D.w * plane.normal.x;   sme[ 7 ] = - lightPosition4D.w * plane.normal.y;   sme[ 11 ] = - lightPosition4D.w * plane.normal.z;   sme[ 15 ] = dot - lightPosition4D.w * - plane.constant;    this.matrix.multiplyMatrices( _shadowMatrix, this.meshMatrix );   }  }  export { ShadowMesh }; 
^..^ FILENAME ^..^
addons|objects|Sky.js
^..^ CONTENTS ^..^
import {  BackSide,  BoxGeometry,  Mesh,  ShaderMaterial,  UniformsUtils,  Vector3 } from 'three';  /**  * Based on "A Practical Analytic Model for Daylight"  * aka The Preetham Model, the de facto standard analytic skydome model  * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight  *  * First implemented by Simon Wallner  * http://simonwallner.at/project/atmospheric-scattering/  *  * Improved by Martin Upitis  * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR  *  * Three.js integration by zz85 http://twitter.com/blurspline */  class Sky extends Mesh {   constructor() {    const shader = Sky.SkyShader;    const material = new ShaderMaterial( {    name: shader.name,    uniforms: UniformsUtils.clone( shader.uniforms ),    vertexShader: shader.vertexShader,    fragmentShader: shader.fragmentShader,    side: BackSide,    depthWrite: false   } );    super( new BoxGeometry( 1, 1, 1 ), material );    this.isSky = true;   }  }  Sky.SkyShader = {   name: 'SkyShader',   uniforms: {   'turbidity': { value: 2 },   'rayleigh': { value: 1 },   'mieCoefficient': { value: 0.005 },   'mieDirectionalG': { value: 0.8 },   'sunPosition': { value: new Vector3() },   'up': { value: new Vector3( 0, 1, 0 ) }  },   vertexShader: /* glsl */|   uniform vec3 sunPosition;   uniform float rayleigh;   uniform float turbidity;   uniform float mieCoefficient;   uniform vec3 up;    varying vec3 vWorldPosition;   varying vec3 vSunDirection;   varying float vSunfade;   varying vec3 vBetaR;   varying vec3 vBetaM;   varying float vSunE;    // constants for atmospheric scattering   const float e = 2.71828182845904523536028747135266249775724709369995957;   const float pi = 3.141592653589793238462643383279502884197169;    // wavelength of used primaries, according to preetham   const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );   // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:   // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))   const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );    // mie stuff   // K coefficient for the primaries   const float v = 4.0;   const vec3 K = vec3( 0.686, 0.678, 0.666 );   // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K   const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );    // earth shadow hack   // cutoffAngle = pi / 1.95;   const float cutoffAngle = 1.6110731556870734;   const float steepness = 1.5;   const float EE = 1000.0;    float sunIntensity( float zenithAngleCos ) {    zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );    return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );   }    vec3 totalMie( float T ) {    float c = ( 0.2 * T ) * 10E-18;    return 0.434 * c * MieConst;   }    void main() {     vec4 worldPosition = modelMatrix * vec4( position, 1.0 );    vWorldPosition = worldPosition.xyz;     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    gl_Position.z = gl_Position.w; // set z to camera.far     vSunDirection = normalize( sunPosition );     vSunE = sunIntensity( dot( vSunDirection, up ) );     vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );     float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );     // extinction (absorbtion + out scattering)    // rayleigh coefficients    vBetaR = totalRayleigh * rayleighCoefficient;     // mie coefficients    vBetaM = totalMie( turbidity ) * mieCoefficient;    }|,   fragmentShader: /* glsl */|   varying vec3 vWorldPosition;   varying vec3 vSunDirection;   varying float vSunfade;   varying vec3 vBetaR;   varying vec3 vBetaM;   varying float vSunE;    uniform float mieDirectionalG;   uniform vec3 up;    // constants for atmospheric scattering   const float pi = 3.141592653589793238462643383279502884197169;    const float n = 1.0003; // refractive index of air   const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)    // optical length at zenith for molecules   const float rayleighZenithLength = 8.4E3;   const float mieZenithLength = 1.25E3;   // 66 arc seconds -> degrees, and the cosine of that   const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;    // 3.0 / ( 16.0 * pi )   const float THREE_OVER_SIXTEENPI = 0.05968310365946075;   // 1.0 / ( 4.0 * pi )   const float ONE_OVER_FOURPI = 0.07957747154594767;    float rayleighPhase( float cosTheta ) {    return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );   }    float hgPhase( float cosTheta, float g ) {    float g2 = pow( g, 2.0 );    float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );    return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );   }    void main() {     vec3 direction = normalize( vWorldPosition - cameraPosition );     // optical length    // cutoff angle at 90 to avoid singularity in next formula.    float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );    float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );    float sR = rayleighZenithLength * inverse;    float sM = mieZenithLength * inverse;     // combined extinction factor    vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );     // in scattering    float cosTheta = dot( direction, vSunDirection );     float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );    vec3 betaRTheta = vBetaR * rPhase;     float mPhase = hgPhase( cosTheta, mieDirectionalG );    vec3 betaMTheta = vBetaM * mPhase;     vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );    Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );     // nightsky    float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]    float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]    vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );    vec3 L0 = vec3( 0.1 ) * Fex;     // composition + solar disc    float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );    L0 += ( vSunE * 19000.0 * Fex ) * sundisk;     vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );     vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );     gl_FragColor = vec4( retColor, 1.0 );     #include <tonemapping_fragment>    #include <colorspace_fragment>    }|  };  export { Sky }; 
^..^ FILENAME ^..^
addons|objects|SkyMesh.js
^..^ CONTENTS ^..^
import {  BackSide,  BoxGeometry,  Mesh,  Vector3 } from 'three'; import { Fn, NodeMaterial, float, vec3, acos, add, mul, clamp, cos, dot, exp, max, mix, modelViewProjection, normalize, positionWorld, pow, smoothstep, sub, varying, varyingProperty, vec4, uniform, cameraPosition } from 'three/tsl';  /**  * Based on "A Practical Analytic Model for Daylight"  * aka The Preetham Model, the de facto standard analytic skydome model  * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight  *  * First implemented by Simon Wallner  * http://simonwallner.at/project/atmospheric-scattering/  *  * Improved by Martin Upitis  * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR  *  * Three.js integration by zz85 http://twitter.com/blurspline */  class SkyMesh extends Mesh {   constructor() {    const material = new NodeMaterial();    super( new BoxGeometry( 1, 1, 1 ), material );    this.turbidity = uniform( 2 );   this.rayleigh = uniform( 1 );   this.mieCoefficient = uniform( 0.005 );   this.mieDirectionalG = uniform( 0.8 );   this.sunPosition = uniform( new Vector3() );   this.upUniform = uniform( new Vector3( 0, 1, 0 ) );    this.isSky = true;    const vertexNode = /*@__PURE__*/ Fn( () => {     // constants for atmospheric scattering    const e = float( 2.71828182845904523536028747135266249775724709369995957 );    // const pi = float( 3.141592653589793238462643383279502884197169 );     // wavelength of used primaries, according to preetham    // const lambda = vec3( 680E-9, 550E-9, 450E-9 );    // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:    // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))    const totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );     // mie stuff    // K coefficient for the primaries    // const v = float( 4.0 );    // const K = vec3( 0.686, 0.678, 0.666 );    // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K    const MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );     // earth shadow hack    // cutoffAngle = pi / 1.95;    const cutoffAngle = float( 1.6110731556870734 );    const steepness = float( 1.5 );    const EE = float( 1000.0 );     // varying sun position     const vSunDirection = normalize( this.sunPosition );    varyingProperty( 'vec3', 'vSunDirection' ).assign( vSunDirection );     // varying sun intensity     const angle = dot( vSunDirection, this.upUniform );    const zenithAngleCos = clamp( angle, - 1, 1 );    const sunIntensity = EE.mul( max( 0.0, float( 1.0 ).sub( pow( e, cutoffAngle.sub( acos( zenithAngleCos ) ).div( steepness ).negate() ) ) ) );    varyingProperty( 'float', 'vSunE' ).assign( sunIntensity );     // varying sun fade     const vSunfade = float( 1.0 ).sub( clamp( float( 1.0 ).sub( exp( this.sunPosition.y.div( 450000.0 ) ) ), 0, 1 ) );    varyingProperty( 'float', 'vSunfade' ).assign( vSunfade );     // varying vBetaR     const rayleighCoefficient = this.rayleigh.sub( float( 1.0 ).mul( float( 1.0 ).sub( vSunfade ) ) );     // extinction (absorbtion + out scattering)    // rayleigh coefficients    varyingProperty( 'vec3', 'vBetaR' ).assign( totalRayleigh.mul( rayleighCoefficient ) );     // varying vBetaM     const c = float( 0.2 ).mul( this.turbidity ).mul( 10E-18 );    const totalMie = float( 0.434 ).mul( c ).mul( MieConst );     varyingProperty( 'vec3', 'vBetaM' ).assign( totalMie.mul( this.mieCoefficient ) );     // position     const position = modelViewProjection();    position.z.assign( position.w ); // set z to camera.far     return position;    } )();    const fragmentNode = /*@__PURE__*/ Fn( () => {     const vSunDirection = varying( vec3(), 'vSunDirection' );    const vSunE = varying( float(), 'vSunE' );    const vSunfade = varying( float(), 'vSunfade' );    const vBetaR = varying( vec3(), 'vBetaR' );    const vBetaM = varying( vec3(), 'vBetaM' );     // constants for atmospheric scattering    const pi = float( 3.141592653589793238462643383279502884197169 );     // optical length at zenith for molecules    const rayleighZenithLength = float( 8.4E3 );    const mieZenithLength = float( 1.25E3 );    // 66 arc seconds -> degrees, and the cosine of that    const sunAngularDiameterCos = float( 0.999956676946448443553574619906976478926848692873900859324 );     // 3.0 / ( 16.0 * pi )    const THREE_OVER_SIXTEENPI = float( 0.05968310365946075 );    // 1.0 / ( 4.0 * pi )    const ONE_OVER_FOURPI = float( 0.07957747154594767 );     //     const direction = normalize( positionWorld.sub( cameraPosition ) );     // optical length    // cutoff angle at 90 to avoid singularity in next formula.    const zenithAngle = acos( max( 0.0, dot( this.upUniform, direction ) ) );    const inverse = float( 1.0 ).div( cos( zenithAngle ).add( float( 0.15 ).mul( pow( float( 93.885 ).sub( zenithAngle.mul( 180.0 ).div( pi ) ), - 1.253 ) ) ) );    const sR = rayleighZenithLength.mul( inverse );    const sM = mieZenithLength.mul( inverse );     // combined extinction factor    const Fex = exp( mul( vBetaR, sR ).add( mul( vBetaM, sM ) ).negate() );     // in scattering    const cosTheta = dot( direction, vSunDirection );     // betaRTheta     const c = cosTheta.mul( 0.5 ).add( 0.5 );    const rPhase = THREE_OVER_SIXTEENPI.mul( float( 1.0 ).add( pow( c, 2.0 ) ) );    const betaRTheta = vBetaR.mul( rPhase );     // betaMTheta     const g2 = pow( this.mieDirectionalG, 2.0 );    const inv = float( 1.0 ).div( pow( float( 1.0 ).sub( float( 2.0 ).mul( this.mieDirectionalG ).mul( cosTheta ) ).add( g2 ), 1.5 ) );    const mPhase = ONE_OVER_FOURPI.mul( float( 1.0 ).sub( g2 ) ).mul( inv );    const betaMTheta = vBetaM.mul( mPhase );     const Lin = pow( vSunE.mul( add( betaRTheta, betaMTheta ).div( add( vBetaR, vBetaM ) ) ).mul( sub( 1.0, Fex ) ), vec3( 1.5 ) );    Lin.mulAssign( mix( vec3( 1.0 ), pow( vSunE.mul( add( betaRTheta, betaMTheta ).div( add( vBetaR, vBetaM ) ) ).mul( Fex ), vec3( 1.0 / 2.0 ) ), clamp( pow( sub( 1.0, dot( this.upUniform, vSunDirection ) ), 5.0 ), 0.0, 1.0 ) ) );     // nightsky     const L0 = vec3( 0.1 ).mul( Fex );     // composition + solar disc    const sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos.add( 0.00002 ), cosTheta );    L0.addAssign( vSunE.mul( 19000.0 ).mul( Fex ).mul( sundisk ) );     const texColor = add( Lin, L0 ).mul( 0.04 ).add( vec3( 0.0, 0.0003, 0.00075 ) );     const retColor = pow( texColor, vec3( float( 1.0 ).div( float( 1.2 ).add( vSunfade.mul( 1.2 ) ) ) ) );     return vec4( retColor, 1.0 );    } )();    material.side = BackSide;   material.depthWrite = false;    material.vertexNode = vertexNode;   material.fragmentNode = fragmentNode;   }  }  export { SkyMesh }; 
^..^ FILENAME ^..^
addons|objects|Water.js
^..^ CONTENTS ^..^
import {  Color,  FrontSide,  Matrix4,  Mesh,  PerspectiveCamera,  Plane,  ShaderMaterial,  UniformsLib,  UniformsUtils,  Vector3,  Vector4,  WebGLRenderTarget } from 'three';  /**  * Work based on :  * https://github.com/Slayvin: Flat mirror for three.js  * https://home.adelphi.edu/~stemkoski/ : An implementation of water shader based on the flat mirror  * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL  */  class Water extends Mesh {   constructor( geometry, options = {} ) {    super( geometry );    this.isWater = true;    const scope = this;    const textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;   const textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;    const clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;   const alpha = options.alpha !== undefined ? options.alpha : 1.0;   const time = options.time !== undefined ? options.time : 0.0;   const normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;   const sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3( 0.70707, 0.70707, 0.0 );   const sunColor = new Color( options.sunColor !== undefined ? options.sunColor : 0xffffff );   const waterColor = new Color( options.waterColor !== undefined ? options.waterColor : 0x7F7F7F );   const eye = options.eye !== undefined ? options.eye : new Vector3( 0, 0, 0 );   const distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;   const side = options.side !== undefined ? options.side : FrontSide;   const fog = options.fog !== undefined ? options.fog : false;    //    const mirrorPlane = new Plane();   const normal = new Vector3();   const mirrorWorldPosition = new Vector3();   const cameraWorldPosition = new Vector3();   const rotationMatrix = new Matrix4();   const lookAtPosition = new Vector3( 0, 0, - 1 );   const clipPlane = new Vector4();    const view = new Vector3();   const target = new Vector3();   const q = new Vector4();    const textureMatrix = new Matrix4();    const mirrorCamera = new PerspectiveCamera();    const renderTarget = new WebGLRenderTarget( textureWidth, textureHeight );    const mirrorShader = {     name: 'MirrorShader',     uniforms: UniformsUtils.merge( [     UniformsLib[ 'fog' ],     UniformsLib[ 'lights' ],     {      'normalSampler': { value: null },      'mirrorSampler': { value: null },      'alpha': { value: 1.0 },      'time': { value: 0.0 },      'size': { value: 1.0 },      'distortionScale': { value: 20.0 },      'textureMatrix': { value: new Matrix4() },      'sunColor': { value: new Color( 0x7F7F7F ) },      'sunDirection': { value: new Vector3( 0.70707, 0.70707, 0 ) },      'eye': { value: new Vector3() },      'waterColor': { value: new Color( 0x555555 ) }     }    ] ),     vertexShader: /* glsl */|     uniform mat4 textureMatrix;     uniform float time;      varying vec4 mirrorCoord;     varying vec4 worldPosition;      #include <common>     #include <fog_pars_vertex>     #include <shadowmap_pars_vertex>     #include <logdepthbuf_pars_vertex>      void main() {      mirrorCoord = modelMatrix * vec4( position, 1.0 );      worldPosition = mirrorCoord.xyzw;      mirrorCoord = textureMatrix * mirrorCoord;      vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );      gl_Position = projectionMatrix * mvPosition;      #include <beginnormal_vertex>     #include <defaultnormal_vertex>     #include <logdepthbuf_vertex>     #include <fog_vertex>     #include <shadowmap_vertex>    }|,     fragmentShader: /* glsl */|     uniform sampler2D mirrorSampler;     uniform float alpha;     uniform float time;     uniform float size;     uniform float distortionScale;     uniform sampler2D normalSampler;     uniform vec3 sunColor;     uniform vec3 sunDirection;     uniform vec3 eye;     uniform vec3 waterColor;      varying vec4 mirrorCoord;     varying vec4 worldPosition;      vec4 getNoise( vec2 uv ) {      vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);      vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );      vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );      vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );      vec4 noise = texture2D( normalSampler, uv0 ) +       texture2D( normalSampler, uv1 ) +       texture2D( normalSampler, uv2 ) +       texture2D( normalSampler, uv3 );      return noise * 0.5 - 1.0;     }      void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {      vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );      float direction = max( 0.0, dot( eyeDirection, reflection ) );      specularColor += pow( direction, shiny ) * sunColor * spec;      diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;     }      #include <common>     #include <packing>     #include <bsdfs>     #include <fog_pars_fragment>     #include <logdepthbuf_pars_fragment>     #include <lights_pars_begin>     #include <shadowmap_pars_fragment>     #include <shadowmask_pars_fragment>      void main() {       #include <logdepthbuf_fragment>      vec4 noise = getNoise( worldPosition.xz * size );      vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );       vec3 diffuseLight = vec3(0.0);      vec3 specularLight = vec3(0.0);       vec3 worldToEye = eye-worldPosition.xyz;      vec3 eyeDirection = normalize( worldToEye );      sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );       float distance = length(worldToEye);       vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;      vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );       float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );      float rf0 = 0.3;      float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );      vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;      vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);      vec3 outgoingLight = albedo;      gl_FragColor = vec4( outgoingLight, alpha );       #include <tonemapping_fragment>      #include <colorspace_fragment>      #include <fog_fragment>      }|    };    const material = new ShaderMaterial( {    name: mirrorShader.name,    uniforms: UniformsUtils.clone( mirrorShader.uniforms ),    vertexShader: mirrorShader.vertexShader,    fragmentShader: mirrorShader.fragmentShader,    lights: true,    side: side,    fog: fog   } );    material.uniforms[ 'mirrorSampler' ].value = renderTarget.texture;   material.uniforms[ 'textureMatrix' ].value = textureMatrix;   material.uniforms[ 'alpha' ].value = alpha;   material.uniforms[ 'time' ].value = time;   material.uniforms[ 'normalSampler' ].value = normalSampler;   material.uniforms[ 'sunColor' ].value = sunColor;   material.uniforms[ 'waterColor' ].value = waterColor;   material.uniforms[ 'sunDirection' ].value = sunDirection;   material.uniforms[ 'distortionScale' ].value = distortionScale;    material.uniforms[ 'eye' ].value = eye;    scope.material = material;    scope.onBeforeRender = function ( renderer, scene, camera ) {     mirrorWorldPosition.setFromMatrixPosition( scope.matrixWorld );    cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );     rotationMatrix.extractRotation( scope.matrixWorld );     normal.set( 0, 0, 1 );    normal.applyMatrix4( rotationMatrix );     view.subVectors( mirrorWorldPosition, cameraWorldPosition );     // Avoid rendering when mirror is facing away     if ( view.dot( normal ) > 0 ) return;     view.reflect( normal ).negate();    view.add( mirrorWorldPosition );     rotationMatrix.extractRotation( camera.matrixWorld );     lookAtPosition.set( 0, 0, - 1 );    lookAtPosition.applyMatrix4( rotationMatrix );    lookAtPosition.add( cameraWorldPosition );     target.subVectors( mirrorWorldPosition, lookAtPosition );    target.reflect( normal ).negate();    target.add( mirrorWorldPosition );     mirrorCamera.position.copy( view );    mirrorCamera.up.set( 0, 1, 0 );    mirrorCamera.up.applyMatrix4( rotationMatrix );    mirrorCamera.up.reflect( normal );    mirrorCamera.lookAt( target );     mirrorCamera.far = camera.far; // Used in WebGLBackground     mirrorCamera.updateMatrixWorld();    mirrorCamera.projectionMatrix.copy( camera.projectionMatrix );     // Update the texture matrix    textureMatrix.set(     0.5, 0.0, 0.0, 0.5,     0.0, 0.5, 0.0, 0.5,     0.0, 0.0, 0.5, 0.5,     0.0, 0.0, 0.0, 1.0    );    textureMatrix.multiply( mirrorCamera.projectionMatrix );    textureMatrix.multiply( mirrorCamera.matrixWorldInverse );     // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf    mirrorPlane.setFromNormalAndCoplanarPoint( normal, mirrorWorldPosition );    mirrorPlane.applyMatrix4( mirrorCamera.matrixWorldInverse );     clipPlane.set( mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant );     const projectionMatrix = mirrorCamera.projectionMatrix;     q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];    q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];    q.z = - 1.0;    q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];     // Calculate the scaled plane vector    clipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );     // Replacing the third row of the projection matrix    projectionMatrix.elements[ 2 ] = clipPlane.x;    projectionMatrix.elements[ 6 ] = clipPlane.y;    projectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;    projectionMatrix.elements[ 14 ] = clipPlane.w;     eye.setFromMatrixPosition( camera.matrixWorld );     // Render     const currentRenderTarget = renderer.getRenderTarget();     const currentXrEnabled = renderer.xr.enabled;    const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;     scope.visible = false;     renderer.xr.enabled = false; // Avoid camera modification and recursion    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows     renderer.setRenderTarget( renderTarget );     renderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897     if ( renderer.autoClear === false ) renderer.clear();    renderer.render( scene, mirrorCamera );     scope.visible = true;     renderer.xr.enabled = currentXrEnabled;    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;     renderer.setRenderTarget( currentRenderTarget );     // Restore viewport     const viewport = camera.viewport;     if ( viewport !== undefined ) {      renderer.state.viewport( viewport );     }    };   }  }  export { Water }; 
^..^ FILENAME ^..^
addons|objects|Water2.js
^..^ CONTENTS ^..^
import {  Clock,  Color,  Matrix4,  Mesh,  RepeatWrapping,  ShaderMaterial,  TextureLoader,  UniformsLib,  UniformsUtils,  Vector2,  Vector4 } from 'three'; import { Reflector } from '../objects/Reflector.js'; import { Refractor } from '../objects/Refractor.js';  /**  * References:  * https://alex.vlachos.com/graphics/Vlachos-SIGGRAPH10-WaterFlow.pdf  * http://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html  *  */  class Water extends Mesh {   constructor( geometry, options = {} ) {    super( geometry );    this.isWater = true;    this.type = 'Water';    const scope = this;    const color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0xFFFFFF );   const textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;   const textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;   const clipBias = options.clipBias !== undefined ? options.clipBias : 0;   const flowDirection = options.flowDirection !== undefined ? options.flowDirection : new Vector2( 1, 0 );   const flowSpeed = options.flowSpeed !== undefined ? options.flowSpeed : 0.03;   const reflectivity = options.reflectivity !== undefined ? options.reflectivity : 0.02;   const scale = options.scale !== undefined ? options.scale : 1;   const shader = options.shader !== undefined ? options.shader : Water.WaterShader;    const textureLoader = new TextureLoader();    const flowMap = options.flowMap || undefined;   const normalMap0 = options.normalMap0 || textureLoader.load( 'textures/water/Water_1_M_Normal.jpg' );   const normalMap1 = options.normalMap1 || textureLoader.load( 'textures/water/Water_2_M_Normal.jpg' );    const cycle = 0.15; // a cycle of a flow map phase   const halfCycle = cycle * 0.5;   const textureMatrix = new Matrix4();   const clock = new Clock();    // internal components    if ( Reflector === undefined ) {     console.error( 'THREE.Water: Required component Reflector not found.' );    return;    }    if ( Refractor === undefined ) {     console.error( 'THREE.Water: Required component Refractor not found.' );    return;    }    const reflector = new Reflector( geometry, {    textureWidth: textureWidth,    textureHeight: textureHeight,    clipBias: clipBias   } );    const refractor = new Refractor( geometry, {    textureWidth: textureWidth,    textureHeight: textureHeight,    clipBias: clipBias   } );    reflector.matrixAutoUpdate = false;   refractor.matrixAutoUpdate = false;    // material    this.material = new ShaderMaterial( {    name: shader.name,    uniforms: UniformsUtils.merge( [     UniformsLib[ 'fog' ],     shader.uniforms    ] ),    vertexShader: shader.vertexShader,    fragmentShader: shader.fragmentShader,    transparent: true,    fog: true   } );    if ( flowMap !== undefined ) {     this.material.defines.USE_FLOWMAP = '';    this.material.uniforms[ 'tFlowMap' ] = {     type: 't',     value: flowMap    };    } else {     this.material.uniforms[ 'flowDirection' ] = {     type: 'v2',     value: flowDirection    };    }    // maps    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;   normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;    this.material.uniforms[ 'tReflectionMap' ].value = reflector.getRenderTarget().texture;   this.material.uniforms[ 'tRefractionMap' ].value = refractor.getRenderTarget().texture;   this.material.uniforms[ 'tNormalMap0' ].value = normalMap0;   this.material.uniforms[ 'tNormalMap1' ].value = normalMap1;    // water    this.material.uniforms[ 'color' ].value = color;   this.material.uniforms[ 'reflectivity' ].value = reflectivity;   this.material.uniforms[ 'textureMatrix' ].value = textureMatrix;    // inital values    this.material.uniforms[ 'config' ].value.x = 0; // flowMapOffset0   this.material.uniforms[ 'config' ].value.y = halfCycle; // flowMapOffset1   this.material.uniforms[ 'config' ].value.z = halfCycle; // halfCycle   this.material.uniforms[ 'config' ].value.w = scale; // scale    // functions    function updateTextureMatrix( camera ) {     textureMatrix.set(     0.5, 0.0, 0.0, 0.5,     0.0, 0.5, 0.0, 0.5,     0.0, 0.0, 0.5, 0.5,     0.0, 0.0, 0.0, 1.0    );     textureMatrix.multiply( camera.projectionMatrix );    textureMatrix.multiply( camera.matrixWorldInverse );    textureMatrix.multiply( scope.matrixWorld );    }    function updateFlow() {     const delta = clock.getDelta();    const config = scope.material.uniforms[ 'config' ];     config.value.x += flowSpeed * delta; // flowMapOffset0    config.value.y = config.value.x + halfCycle; // flowMapOffset1     // Important: The distance between offsets should be always the value of "halfCycle".    // Moreover, both offsets should be in the range of [ 0, cycle ].    // This approach ensures a smooth water flow and avoids "reset" effects.     if ( config.value.x >= cycle ) {      config.value.x = 0;     config.value.y = halfCycle;     } else if ( config.value.y >= cycle ) {      config.value.y = config.value.y - cycle;     }    }    //    this.onBeforeRender = function ( renderer, scene, camera ) {     updateTextureMatrix( camera );    updateFlow();     scope.visible = false;     reflector.matrixWorld.copy( scope.matrixWorld );    refractor.matrixWorld.copy( scope.matrixWorld );     reflector.onBeforeRender( renderer, scene, camera );    refractor.onBeforeRender( renderer, scene, camera );     scope.visible = true;    };   }  }  Water.WaterShader = {   name: 'WaterShader',   uniforms: {    'color': {    type: 'c',    value: null   },    'reflectivity': {    type: 'f',    value: 0   },    'tReflectionMap': {    type: 't',    value: null   },    'tRefractionMap': {    type: 't',    value: null   },    'tNormalMap0': {    type: 't',    value: null   },    'tNormalMap1': {    type: 't',    value: null   },    'textureMatrix': {    type: 'm4',    value: null   },    'config': {    type: 'v4',    value: new Vector4()   }   },   vertexShader: /* glsl */|    #include <common>   #include <fog_pars_vertex>   #include <logdepthbuf_pars_vertex>    uniform mat4 textureMatrix;    varying vec4 vCoord;   varying vec2 vUv;   varying vec3 vToEye;    void main() {     vUv = uv;    vCoord = textureMatrix * vec4( position, 1.0 );     vec4 worldPosition = modelMatrix * vec4( position, 1.0 );    vToEye = cameraPosition - worldPosition.xyz;     vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex    gl_Position = projectionMatrix * mvPosition;     #include <logdepthbuf_vertex>    #include <fog_vertex>    }|,   fragmentShader: /* glsl */|    #include <common>   #include <fog_pars_fragment>   #include <logdepthbuf_pars_fragment>    uniform sampler2D tReflectionMap;   uniform sampler2D tRefractionMap;   uniform sampler2D tNormalMap0;   uniform sampler2D tNormalMap1;    #ifdef USE_FLOWMAP    uniform sampler2D tFlowMap;   #else    uniform vec2 flowDirection;   #endif    uniform vec3 color;   uniform float reflectivity;   uniform vec4 config;    varying vec4 vCoord;   varying vec2 vUv;   varying vec3 vToEye;    void main() {     #include <logdepthbuf_fragment>     float flowMapOffset0 = config.x;    float flowMapOffset1 = config.y;    float halfCycle = config.z;    float scale = config.w;     vec3 toEye = normalize( vToEye );     // determine flow direction    vec2 flow;    #ifdef USE_FLOWMAP     flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;    #else     flow = flowDirection;    #endif    flow.x *= - 1.0;     // sample normal maps (distort uvs with flowdata)    vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );    vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );     // linear interpolate to get the final normal color    float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;    vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );     // calculate normal vector    vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );     // calculate the fresnel term to blend reflection and refraction maps    float theta = max( dot( toEye, normal ), 0.0 );    float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );     // calculate final uv coords    vec3 coord = vCoord.xyz / vCoord.w;    vec2 uv = coord.xy + coord.z * normal.xz * 0.05;     vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );    vec4 refractColor = texture2D( tRefractionMap, uv );     // multiply water color with the mix of both textures    gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );     #include <tonemapping_fragment>    #include <colorspace_fragment>    #include <fog_fragment>    }|  };  export { Water }; 
^..^ FILENAME ^..^
addons|objects|Water2Mesh.js
^..^ CONTENTS ^..^
import {  Color,  Mesh,  Vector2,  Vector3 } from 'three'; import { Fn, NodeMaterial, NodeUpdateType, TempNode, vec2, viewportSafeUV, viewportSharedTexture, reflector, pow, float, abs, texture, uniform, vec4, cameraPosition, positionWorld, uv, mix, vec3, normalize, max, dot, screenUV } from 'three/tsl';  /**  * References:  * https://alex.vlachos.com/graphics/Vlachos-SIGGRAPH10-WaterFlow.pdf  * http://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html  *  */  class WaterMesh extends Mesh {   constructor( geometry, options = {} ) {    const material = new NodeMaterial();    super( geometry, material );    this.isWater = true;    material.fragmentNode = new WaterNode( options, this );   }  }  class WaterNode extends TempNode {   constructor( options, waterBody ) {    super( 'vec4' );    this.waterBody = waterBody;    this.normalMap0 = texture( options.normalMap0 );   this.normalMap1 = texture( options.normalMap1 );   this.flowMap = texture( options.flowMap !== undefined ? options.flowMap : null );    this.color = uniform( options.color !== undefined ? new Color( options.color ) : new Color( 0xffffff ) );   this.flowDirection = uniform( options.flowDirection !== undefined ? options.flowDirection : new Vector2( 1, 0 ) );   this.flowSpeed = uniform( options.flowSpeed !== undefined ? options.flowSpeed : 0.03 );   this.reflectivity = uniform( options.reflectivity !== undefined ? options.reflectivity : 0.02 );   this.scale = uniform( options.scale !== undefined ? options.scale : 1 );   this.flowConfig = uniform( new Vector3() );    this.updateBeforeType = NodeUpdateType.RENDER;    this._cycle = 0.15; // a cycle of a flow map phase   this._halfCycle = this._cycle * 0.5;    this._USE_FLOW = options.flowMap !== undefined;   }   updateFlow( delta ) {    this.flowConfig.value.x += this.flowSpeed.value * delta; // flowMapOffset0   this.flowConfig.value.y = this.flowConfig.value.x + this._halfCycle; // flowMapOffset1    // Important: The distance between offsets should be always the value of "halfCycle".   // Moreover, both offsets should be in the range of [ 0, cycle ].   // This approach ensures a smooth water flow and avoids "reset" effects.    if ( this.flowConfig.value.x >= this._cycle ) {     this.flowConfig.value.x = 0;    this.flowConfig.value.y = this._halfCycle;    } else if ( this.flowConfig.value.y >= this._cycle ) {     this.flowConfig.value.y = this.flowConfig.value.y - this._cycle;    }    this.flowConfig.value.z = this._halfCycle;   }   updateBefore( frame ) {    this.updateFlow( frame.deltaTime );   }   setup() {    const outputNode = Fn( () => {     const flowMapOffset0 = this.flowConfig.x;    const flowMapOffset1 = this.flowConfig.y;    const halfCycle = this.flowConfig.z;     const toEye = normalize( cameraPosition.sub( positionWorld ) );     let flow;     if ( this._USE_FLOW === true ) {      flow = this.flowMap.rg.mul( 2 ).sub( 1 );     } else {      flow = vec2( this.flowDirection.x, this.flowDirection.y );     }     flow.x.mulAssign( - 1 );     // sample normal maps (distort uvs with flowdata)     const uvs = uv();     const normalUv0 = uvs.mul( this.scale ).add( flow.mul( flowMapOffset0 ) );    const normalUv1 = uvs.mul( this.scale ).add( flow.mul( flowMapOffset1 ) );     const normalColor0 = this.normalMap0.uv( normalUv0 );    const normalColor1 = this.normalMap1.uv( normalUv1 );     // linear interpolate to get the final normal color    const flowLerp = abs( halfCycle.sub( flowMapOffset0 ) ).div( halfCycle );    const normalColor = mix( normalColor0, normalColor1, flowLerp );     // calculate normal vector    const normal = normalize( vec3( normalColor.r.mul( 2 ).sub( 1 ), normalColor.b, normalColor.g.mul( 2 ).sub( 1 ) ) );     // calculate the fresnel term to blend reflection and refraction maps    const theta = max( dot( toEye, normal ), 0 );    const reflectance = pow( float( 1.0 ).sub( theta ), 5.0 ).mul( float( 1.0 ).sub( this.reflectivity ) ).add( this.reflectivity );     // reflector, refractor     const offset = normal.xz.mul( 0.05 ).toVar();     const reflectionSampler = reflector();    this.waterBody.add( reflectionSampler.target );    reflectionSampler.uvNode = reflectionSampler.uvNode.add( offset );     const refractorUV = screenUV.add( offset );    const refractionSampler = viewportSharedTexture( viewportSafeUV( refractorUV ) );     // calculate final uv coords     return vec4( this.color, 1.0 ).mul( mix( refractionSampler, reflectionSampler, reflectance ) );    } )();    return outputNode;   }  }  export { WaterMesh }; 
^..^ FILENAME ^..^
addons|objects|WaterMesh.js
^..^ CONTENTS ^..^
import {  Color,  Mesh,  Vector3 } from 'three'; import { Fn, NodeMaterial, add, cameraPosition, div, normalize, positionWorld, sub, timerLocal, texture, vec2, vec3, vec4, max, dot, reflect, pow, length, float, uniform, reflector, mul, mix } from 'three/tsl';  /**  * Work based on :  * https://github.com/Slayvin: Flat mirror for three.js  * https://home.adelphi.edu/~stemkoski/ : An implementation of water shader based on the flat mirror  * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL  */  class WaterMesh extends Mesh {   constructor( geometry, options ) {    const material = new NodeMaterial();    super( geometry, material );    this.isWater = true;    this.resolution = options.resolution !== undefined ? options.resolution : 0.5;    // uniforms    this.waterNormals = texture( options.waterNormals );   this.alpha = uniform( options.alpha !== undefined ? options.alpha : 1.0 );   this.size = uniform( options.size !== undefined ? options.size : 1.0 );   this.sunColor = uniform( new Color( options.sunColor !== undefined ? options.sunColor : 0xffffff ) );   this.sunDirection = uniform( options.sunDirection !== undefined ? options.sunDirection : new Vector3( 0.70707, 0.70707, 0.0 ) );   this.waterColor = uniform( new Color( options.waterColor !== undefined ? options.waterColor : 0x7f7f7f ) );   this.distortionScale = uniform( options.distortionScale !== undefined ? options.distortionScale : 20.0 );    // TSL    const timeNode = timerLocal();    const getNoise = Fn( ( [ uv ] ) => {     const uv0 = add( div( uv, 103 ), vec2( div( timeNode, 17 ), div( timeNode, 29 ) ) ).toVar();    const uv1 = div( uv, 107 ).sub( vec2( div( timeNode, - 19 ), div( timeNode, 31 ) ) ).toVar();    const uv2 = add( div( uv, vec2( 8907.0, 9803.0 ) ), vec2( div( timeNode, 101 ), div( timeNode, 97 ) ) ).toVar();    const uv3 = sub( div( uv, vec2( 1091.0, 1027.0 ) ), vec2( div( timeNode, 109 ), div( timeNode, - 113 ) ) ).toVar();     const sample0 = this.waterNormals.uv( uv0 );    const sample1 = this.waterNormals.uv( uv1 );    const sample2 = this.waterNormals.uv( uv2 );    const sample3 = this.waterNormals.uv( uv3 );     const noise = sample0.add( sample1 ).add( sample2 ).add( sample3 );     return noise.mul( 0.5 ).sub( 1 );    } );    const fragmentNode = Fn( () => {     const noise = getNoise( positionWorld.xz.mul( this.size ) );    const surfaceNormal = normalize( noise.xzy.mul( 1.5, 1.0, 1.5 ) );     const diffuseLight = vec3( 0 ).toVar();    const specularLight = vec3( 0 ).toVar();     const worldToEye = cameraPosition.sub( positionWorld );    const eyeDirection = normalize( worldToEye );     const reflection = normalize( reflect( this.sunDirection.negate(), surfaceNormal ) );    const direction = max( 0.0, dot( eyeDirection, reflection ) );    specularLight.addAssign( pow( direction, 100 ).mul( this.sunColor ).mul( 2.0 ) );    diffuseLight.addAssign( max( dot( this.sunDirection, surfaceNormal ), 0.0 ).mul( this.sunColor ).mul( 0.5 ) );     const distance = length( worldToEye );     const distortion = surfaceNormal.xy.mul( float( 0.001 ).add( float( 1.0 ).div( distance ) ) ).mul( this.distortionScale );     const mirrorSampler = reflector();    mirrorSampler.uvNode = mirrorSampler.uvNode.add( distortion );    mirrorSampler.resolution = this.resolution;     this.add( mirrorSampler.target );     const theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );    const rf0 = float( 0.3 );    const reflectance = mul( pow( float( 1.0 ).sub( theta ), 5.0 ), float( 1.0 ).sub( rf0 ) ).add( rf0 );    const scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ).mul( this.waterColor );    const albedo = mix( this.sunColor.mul( diffuseLight ).mul( 0.3 ).add( scatter ), mirrorSampler.rgb.mul( specularLight ).add( mirrorSampler.rgb.mul( 0.9 ) ).add( vec3( 0.1 ) ), reflectance );     return vec4( albedo, this.alpha );    } )();    material.fragmentNode = fragmentNode;   }  }  export { WaterMesh }; 
^..^ FILENAME ^..^
addons|offscreen|jank.js
^..^ CONTENTS ^..^
let interval = null; let result = null;  function initJank() {   const button = document.getElementById( 'button' );  button.addEventListener( 'click', function () {    if ( interval === null ) {     interval = setInterval( jank, 1000 / 60 );     button.textContent = 'STOP JANK';    } else {     clearInterval( interval );    interval = null;     button.textContent = 'START JANK';    result.textContent = '';    }   } );   result = document.getElementById( 'result' );  }  function jank() {   let number = 0;   for ( let i = 0; i < 10000000; i ++ ) {    number += Math.random();   }   result.textContent = number;  }  export default initJank; 
^..^ FILENAME ^..^
addons|offscreen|offscreen.js
^..^ CONTENTS ^..^
import init from './scene.js';  self.onmessage = function ( message ) {   const data = message.data;  init( data.drawingSurface, data.width, data.height, data.pixelRatio, data.path );  }; 
^..^ FILENAME ^..^
addons|offscreen|scene.js
^..^ CONTENTS ^..^
import * as THREE from '../../../build/three.module.js';  let camera, scene, renderer, group;  function init( canvas, width, height, pixelRatio, path ) {   camera = new THREE.PerspectiveCamera( 40, width / height, 1, 1000 );  camera.position.z = 200;   scene = new THREE.Scene();  scene.fog = new THREE.Fog( 0x444466, 100, 400 );  scene.background = new THREE.Color( 0x444466 );   group = new THREE.Group();  scene.add( group );   // we don't use ImageLoader since it has a DOM dependency (HTML5 image element)   const loader = new THREE.ImageBitmapLoader().setPath( path );  loader.setOptions( { imageOrientation: 'flipY' } );  loader.load( 'textures/matcaps/matcap-porcelain-white.jpg', function ( imageBitmap ) {    const texture = new THREE.CanvasTexture( imageBitmap );    const geometry = new THREE.IcosahedronGeometry( 5, 8 );   const materials = [    new THREE.MeshMatcapMaterial( { color: 0xaa24df, matcap: texture } ),    new THREE.MeshMatcapMaterial( { color: 0x605d90, matcap: texture } ),    new THREE.MeshMatcapMaterial( { color: 0xe04a3f, matcap: texture } ),    new THREE.MeshMatcapMaterial( { color: 0xe30456, matcap: texture } )   ];    for ( let i = 0; i < 100; i ++ ) {     const material = materials[ i % materials.length ];    const mesh = new THREE.Mesh( geometry, material );    mesh.position.x = random() * 200 - 100;    mesh.position.y = random() * 200 - 100;    mesh.position.z = random() * 200 - 100;    mesh.scale.setScalar( random() + 1 );    group.add( mesh );    }    renderer = new THREE.WebGLRenderer( { antialias: true, canvas: canvas } );   renderer.setPixelRatio( pixelRatio );   renderer.setSize( width, height, false );    animate();   } );  }  function animate() {   // group.rotation.x = Date.now() / 4000;  group.rotation.y = - Date.now() / 4000;   renderer.render( scene, camera );   if ( self.requestAnimationFrame ) {    self.requestAnimationFrame( animate );   } else {    // Firefox   }  }  // PRNG  let seed = 1;  function random() {   const x = Math.sin( seed ++ ) * 10000;   return x - Math.floor( x );  }  export default init; 
^..^ FILENAME ^..^
addons|physics|AmmoPhysics.js
^..^ CONTENTS ^..^
async function AmmoPhysics() {   if ( 'Ammo' in window === false ) {    console.error( 'AmmoPhysics: Couldn|'t find Ammo.js' );   return;   }   const AmmoLib = await Ammo(); // eslint-disable-line no-undef   const frameRate = 60;   const collisionConfiguration = new AmmoLib.btDefaultCollisionConfiguration();  const dispatcher = new AmmoLib.btCollisionDispatcher( collisionConfiguration );  const broadphase = new AmmoLib.btDbvtBroadphase();  const solver = new AmmoLib.btSequentialImpulseConstraintSolver();  const world = new AmmoLib.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration );  world.setGravity( new AmmoLib.btVector3( 0, - 9.8, 0 ) );   const worldTransform = new AmmoLib.btTransform();   //   function getShape( geometry ) {    const parameters = geometry.parameters;    // TODO change type to is*    if ( geometry.type === 'BoxGeometry' ) {     const sx = parameters.width !== undefined ? parameters.width / 2 : 0.5;    const sy = parameters.height !== undefined ? parameters.height / 2 : 0.5;    const sz = parameters.depth !== undefined ? parameters.depth / 2 : 0.5;     const shape = new AmmoLib.btBoxShape( new AmmoLib.btVector3( sx, sy, sz ) );    shape.setMargin( 0.05 );     return shape;    } else if ( geometry.type === 'SphereGeometry' || geometry.type === 'IcosahedronGeometry' ) {     const radius = parameters.radius !== undefined ? parameters.radius : 1;     const shape = new AmmoLib.btSphereShape( radius );    shape.setMargin( 0.05 );     return shape;    }    return null;   }   const meshes = [];  const meshMap = new WeakMap();   function addScene( scene ) {    scene.traverse( function ( child ) {     if ( child.isMesh ) {      const physics = child.userData.physics;      if ( physics ) {       addMesh( child, physics.mass );      }     }    } );   }   function addMesh( mesh, mass = 0 ) {    const shape = getShape( mesh.geometry );    if ( shape !== null ) {     if ( mesh.isInstancedMesh ) {      handleInstancedMesh( mesh, mass, shape );     } else if ( mesh.isMesh ) {      handleMesh( mesh, mass, shape );     }    }   }   function handleMesh( mesh, mass, shape ) {    const position = mesh.position;   const quaternion = mesh.quaternion;    const transform = new AmmoLib.btTransform();   transform.setIdentity();   transform.setOrigin( new AmmoLib.btVector3( position.x, position.y, position.z ) );   transform.setRotation( new AmmoLib.btQuaternion( quaternion.x, quaternion.y, quaternion.z, quaternion.w ) );    const motionState = new AmmoLib.btDefaultMotionState( transform );    const localInertia = new AmmoLib.btVector3( 0, 0, 0 );   shape.calculateLocalInertia( mass, localInertia );    const rbInfo = new AmmoLib.btRigidBodyConstructionInfo( mass, motionState, shape, localInertia );    const body = new AmmoLib.btRigidBody( rbInfo );   // body.setFriction( 4 );   world.addRigidBody( body );    if ( mass > 0 ) {     meshes.push( mesh );    meshMap.set( mesh, body );    }    }   function handleInstancedMesh( mesh, mass, shape ) {    const array = mesh.instanceMatrix.array;    const bodies = [];    for ( let i = 0; i < mesh.count; i ++ ) {     const index = i * 16;     const transform = new AmmoLib.btTransform();    transform.setFromOpenGLMatrix( array.slice( index, index + 16 ) );     const motionState = new AmmoLib.btDefaultMotionState( transform );     const localInertia = new AmmoLib.btVector3( 0, 0, 0 );    shape.calculateLocalInertia( mass, localInertia );     const rbInfo = new AmmoLib.btRigidBodyConstructionInfo( mass, motionState, shape, localInertia );     const body = new AmmoLib.btRigidBody( rbInfo );    world.addRigidBody( body );     bodies.push( body );    }    if ( mass > 0 ) {     meshes.push( mesh );     meshMap.set( mesh, bodies );    }   }   //   function setMeshPosition( mesh, position, index = 0 ) {    if ( mesh.isInstancedMesh ) {     const bodies = meshMap.get( mesh );    const body = bodies[ index ];     body.setAngularVelocity( new AmmoLib.btVector3( 0, 0, 0 ) );    body.setLinearVelocity( new AmmoLib.btVector3( 0, 0, 0 ) );     worldTransform.setIdentity();    worldTransform.setOrigin( new AmmoLib.btVector3( position.x, position.y, position.z ) );    body.setWorldTransform( worldTransform );    } else if ( mesh.isMesh ) {     const body = meshMap.get( mesh );     body.setAngularVelocity( new AmmoLib.btVector3( 0, 0, 0 ) );    body.setLinearVelocity( new AmmoLib.btVector3( 0, 0, 0 ) );     worldTransform.setIdentity();    worldTransform.setOrigin( new AmmoLib.btVector3( position.x, position.y, position.z ) );    body.setWorldTransform( worldTransform );    }   }   //   let lastTime = 0;   function step() {    const time = performance.now();    if ( lastTime > 0 ) {     const delta = ( time - lastTime ) / 1000;     world.stepSimulation( delta, 10 );     //     for ( let i = 0, l = meshes.length; i < l; i ++ ) {      const mesh = meshes[ i ];      if ( mesh.isInstancedMesh ) {       const array = mesh.instanceMatrix.array;      const bodies = meshMap.get( mesh );       for ( let j = 0; j < bodies.length; j ++ ) {        const body = bodies[ j ];        const motionState = body.getMotionState();       motionState.getWorldTransform( worldTransform );        const position = worldTransform.getOrigin();       const quaternion = worldTransform.getRotation();        compose( position, quaternion, array, j * 16 );       }       mesh.instanceMatrix.needsUpdate = true;      mesh.computeBoundingSphere();      } else if ( mesh.isMesh ) {       const body = meshMap.get( mesh );       const motionState = body.getMotionState();      motionState.getWorldTransform( worldTransform );       const position = worldTransform.getOrigin();      const quaternion = worldTransform.getRotation();      mesh.position.set( position.x(), position.y(), position.z() );      mesh.quaternion.set( quaternion.x(), quaternion.y(), quaternion.z(), quaternion.w() );      }     }    }    lastTime = time;   }   // animate   setInterval( step, 1000 / frameRate );   return {   addScene: addScene,   addMesh: addMesh,   setMeshPosition: setMeshPosition   // addCompoundMesh  };  }  function compose( position, quaternion, array, index ) {   const x = quaternion.x(), y = quaternion.y(), z = quaternion.z(), w = quaternion.w();  const x2 = x + x, y2 = y + y, z2 = z + z;  const xx = x * x2, xy = x * y2, xz = x * z2;  const yy = y * y2, yz = y * z2, zz = z * z2;  const wx = w * x2, wy = w * y2, wz = w * z2;   array[ index + 0 ] = ( 1 - ( yy + zz ) );  array[ index + 1 ] = ( xy + wz );  array[ index + 2 ] = ( xz - wy );  array[ index + 3 ] = 0;   array[ index + 4 ] = ( xy - wz );  array[ index + 5 ] = ( 1 - ( xx + zz ) );  array[ index + 6 ] = ( yz + wx );  array[ index + 7 ] = 0;   array[ index + 8 ] = ( xz + wy );  array[ index + 9 ] = ( yz - wx );  array[ index + 10 ] = ( 1 - ( xx + yy ) );  array[ index + 11 ] = 0;   array[ index + 12 ] = position.x();  array[ index + 13 ] = position.y();  array[ index + 14 ] = position.z();  array[ index + 15 ] = 1;  }  export { AmmoPhysics }; 
^..^ FILENAME ^..^
addons|physics|JoltPhysics.js
^..^ CONTENTS ^..^
import { Clock, Vector3, Quaternion, Matrix4 } from 'three';  const JOLT_PATH = 'https://cdn.jsdelivr.net/npm/jolt-physics@0.23.0/dist/jolt-physics.wasm-compat.js';  const frameRate = 60;  let Jolt = null;  function getShape( geometry ) {   const parameters = geometry.parameters;   // TODO change type to is*   if ( geometry.type === 'BoxGeometry' ) {    const sx = parameters.width !== undefined ? parameters.width / 2 : 0.5;   const sy = parameters.height !== undefined ? parameters.height / 2 : 0.5;   const sz = parameters.depth !== undefined ? parameters.depth / 2 : 0.5;    return new Jolt.BoxShape( new Jolt.Vec3( sx, sy, sz ), 0.05 * Math.min( sx, sy, sz ), null );   } else if ( geometry.type === 'SphereGeometry' || geometry.type === 'IcosahedronGeometry' ) {    const radius = parameters.radius !== undefined ? parameters.radius : 1;    return new Jolt.SphereShape( radius, null );   }   return null;  }  // Object layers const LAYER_NON_MOVING = 0; const LAYER_MOVING = 1; const NUM_OBJECT_LAYERS = 2;  function setupCollisionFiltering( settings ) {   let objectFilter = new Jolt.ObjectLayerPairFilterTable( NUM_OBJECT_LAYERS );  objectFilter.EnableCollision( LAYER_NON_MOVING, LAYER_MOVING );  objectFilter.EnableCollision( LAYER_MOVING, LAYER_MOVING );   const BP_LAYER_NON_MOVING = new Jolt.BroadPhaseLayer( 0 );  const BP_LAYER_MOVING = new Jolt.BroadPhaseLayer( 1 );  const NUM_BROAD_PHASE_LAYERS = 2;   let bpInterface = new Jolt.BroadPhaseLayerInterfaceTable( NUM_OBJECT_LAYERS, NUM_BROAD_PHASE_LAYERS );  bpInterface.MapObjectToBroadPhaseLayer( LAYER_NON_MOVING, BP_LAYER_NON_MOVING );  bpInterface.MapObjectToBroadPhaseLayer( LAYER_MOVING, BP_LAYER_MOVING );   settings.mObjectLayerPairFilter = objectFilter;  settings.mBroadPhaseLayerInterface = bpInterface;  settings.mObjectVsBroadPhaseLayerFilter = new Jolt.ObjectVsBroadPhaseLayerFilterTable( settings.mBroadPhaseLayerInterface, NUM_BROAD_PHASE_LAYERS, settings.mObjectLayerPairFilter, NUM_OBJECT_LAYERS );  };  async function JoltPhysics() {   if ( Jolt === null ) {    const { default: initJolt } = await import( ||JOLT_PATH}| );   Jolt = await initJolt();   }   const settings = new Jolt.JoltSettings();  setupCollisionFiltering( settings );   const jolt = new Jolt.JoltInterface( settings );  Jolt.destroy( settings );   const physicsSystem = jolt.GetPhysicsSystem();  const bodyInterface = physicsSystem.GetBodyInterface();   const meshes = [];  const meshMap = new WeakMap();   const _position = new Vector3();  const _quaternion = new Quaternion();  const _scale = new Vector3( 1, 1, 1 );   const _matrix = new Matrix4();   function addScene( scene ) {    scene.traverse( function ( child ) {     if ( child.isMesh ) {      const physics = child.userData.physics;      if ( physics ) {       addMesh( child, physics.mass, physics.restitution );      }     }    } );   }   function addMesh( mesh, mass = 0, restitution = 0 ) {    const shape = getShape( mesh.geometry );    if ( shape === null ) return;    const body = mesh.isInstancedMesh        ? createInstancedBody( mesh, mass, restitution, shape )        : createBody( mesh.position, mesh.quaternion, mass, restitution, shape );    if ( mass > 0 ) {     meshes.push( mesh );    meshMap.set( mesh, body );    }   }   function createInstancedBody( mesh, mass, restitution, shape ) {    const array = mesh.instanceMatrix.array;    const bodies = [];    for ( let i = 0; i < mesh.count; i ++ ) {     const position = _position.fromArray( array, i * 16 + 12 );    const quaternion = _quaternion.setFromRotationMatrix( _matrix.fromArray( array, i * 16 ) ); // TODO Copilot did this    bodies.push( createBody( position, quaternion, mass, restitution, shape ) );    }    return bodies;   }   function createBody( position, rotation, mass, restitution, shape ) {    const pos = new Jolt.Vec3( position.x, position.y, position.z );   const rot = new Jolt.Quat( rotation.x, rotation.y, rotation.z, rotation.w );    const motion = mass > 0 ? Jolt.EMotionType_Dynamic : Jolt.EMotionType_Static;   const layer = mass > 0 ? LAYER_MOVING : LAYER_NON_MOVING;    const creationSettings = new Jolt.BodyCreationSettings( shape, pos, rot, motion, layer );   creationSettings.mRestitution = restitution;    const body = bodyInterface.CreateBody( creationSettings );    bodyInterface.AddBody( body.GetID(), Jolt.EActivation_Activate );    Jolt.destroy( creationSettings );    return body;   }   function setMeshPosition( mesh, position, index = 0 ) {    if ( mesh.isInstancedMesh ) {     const bodies = meshMap.get( mesh );     const body = bodies[ index ];     bodyInterface.RemoveBody( body.GetID() );    bodyInterface.DestroyBody( body.GetID() );     const physics = mesh.userData.physics;     let shape = body.GetShape();    let body2 = createBody( position, { x: 0, y: 0, z: 0, w: 1 }, physics.mass, physics.restitution, shape );     bodies[ index ] = body2;    } else {     // TODO: Implement this    }   }   function setMeshVelocity( mesh, velocity, index = 0 ) {    /*   let body = meshMap.get( mesh );    if ( mesh.isInstancedMesh ) {     body = body[ index ];    }    body.setLinvel( velocity );   */   }   //   const clock = new Clock();   function step() {    let deltaTime = clock.getDelta();    // Don't go below 30 Hz to prevent spiral of death   deltaTime = Math.min( deltaTime, 1.0 / 30.0 );    // When running below 55 Hz, do 2 steps instead of 1   const numSteps = deltaTime > 1.0 / 55.0 ? 2 : 1;    // Step the physics world   jolt.Step( deltaTime, numSteps );    //    for ( let i = 0, l = meshes.length; i < l; i ++ ) {     const mesh = meshes[ i ];     if ( mesh.isInstancedMesh ) {      const array = mesh.instanceMatrix.array;     const bodies = meshMap.get( mesh );      for ( let j = 0; j < bodies.length; j ++ ) {       const body = bodies[ j ];       const position = body.GetPosition();      const quaternion = body.GetRotation();       _position.set( position.GetX(), position.GetY(), position.GetZ() );      _quaternion.set( quaternion.GetX(), quaternion.GetY(), quaternion.GetZ(), quaternion.GetW() );       _matrix.compose( _position, _quaternion, _scale ).toArray( array, j * 16 );      }      mesh.instanceMatrix.needsUpdate = true;     mesh.computeBoundingSphere();     } else {      const body = meshMap.get( mesh );      const position = body.GetPosition();     const rotation = body.GetRotation();      mesh.position.set( position.GetX(), position.GetY(), position.GetZ() );     mesh.quaternion.set( rotation.GetX(), rotation.GetY(), rotation.GetZ(), rotation.GetW() );     }    }   }   // animate   setInterval( step, 1000 / frameRate );   return {   addScene: addScene,   addMesh: addMesh,   setMeshPosition: setMeshPosition,   setMeshVelocity: setMeshVelocity  };  }  export { JoltPhysics }; 
^..^ FILENAME ^..^
addons|physics|RapierPhysics.js
^..^ CONTENTS ^..^
import { Clock, Vector3, Quaternion, Matrix4 } from 'three';  const RAPIER_PATH = 'https://cdn.skypack.dev/@dimforge/rapier3d-compat@0.12.0';  const frameRate = 60;  const _scale = new Vector3( 1, 1, 1 ); const ZERO = new Vector3();  let RAPIER = null;  function getShape( geometry ) {   const parameters = geometry.parameters;   // TODO change type to is*   if ( geometry.type === 'BoxGeometry' ) {    const sx = parameters.width !== undefined ? parameters.width / 2 : 0.5;   const sy = parameters.height !== undefined ? parameters.height / 2 : 0.5;   const sz = parameters.depth !== undefined ? parameters.depth / 2 : 0.5;    return RAPIER.ColliderDesc.cuboid( sx, sy, sz );   } else if ( geometry.type === 'SphereGeometry' || geometry.type === 'IcosahedronGeometry' ) {    const radius = parameters.radius !== undefined ? parameters.radius : 1;   return RAPIER.ColliderDesc.ball( radius );   } else if ( geometry.type === 'BufferGeometry' ) {    const vertices = [];   const vertex = new Vector3();   const position = geometry.getAttribute( 'position' );    for ( let i = 0; i < position.count; i ++ ) {     vertex.fromBufferAttribute( position, i );    vertices.push( vertex.x, vertex.y, vertex.z );    }    // if the buffer is non-indexed, generate an index buffer   const indices = geometry.getIndex() === null        ? Uint32Array.from( Array( parseInt( vertices.length / 3 ) ).keys() )        : geometry.getIndex().array;    return RAPIER.ColliderDesc.trimesh( vertices, indices );   }   return null;  }  async function RapierPhysics() {   if ( RAPIER === null ) {    RAPIER = await import( ||RAPIER_PATH}| );   await RAPIER.init();   }   // Docs: https://rapier.rs/docs/api/javascript/JavaScript3D/   const gravity = new Vector3( 0.0, - 9.81, 0.0 );  const world = new RAPIER.World( gravity );   const meshes = [];  const meshMap = new WeakMap();   const _vector = new Vector3();  const _quaternion = new Quaternion();  const _matrix = new Matrix4();   function addScene( scene ) {    scene.traverse( function ( child ) {     if ( child.isMesh ) {      const physics = child.userData.physics;      if ( physics ) {       addMesh( child, physics.mass, physics.restitution );      }     }    } );   }   function addMesh( mesh, mass = 0, restitution = 0 ) {    const shape = getShape( mesh.geometry );    if ( shape === null ) return;    shape.setMass( mass );   shape.setRestitution( restitution );    const body = mesh.isInstancedMesh        ? createInstancedBody( mesh, mass, shape )        : createBody( mesh.position, mesh.quaternion, mass, shape );    if ( mass > 0 ) {     meshes.push( mesh );    meshMap.set( mesh, body );    }   }   function createInstancedBody( mesh, mass, shape ) {    const array = mesh.instanceMatrix.array;    const bodies = [];    for ( let i = 0; i < mesh.count; i ++ ) {     const position = _vector.fromArray( array, i * 16 + 12 );    bodies.push( createBody( position, null, mass, shape ) );    }    return bodies;   }   function createBody( position, quaternion, mass, shape ) {    const desc = mass > 0 ? RAPIER.RigidBodyDesc.dynamic() : RAPIER.RigidBodyDesc.fixed();   desc.setTranslation( ...position );   if ( quaternion !== null ) desc.setRotation( quaternion );    const body = world.createRigidBody( desc );   world.createCollider( shape, body );    return body;   }   function setMeshPosition( mesh, position, index = 0 ) {    let body = meshMap.get( mesh );    if ( mesh.isInstancedMesh ) {     body = body[ index ];    }    body.setAngvel( ZERO );   body.setLinvel( ZERO );   body.setTranslation( position );   }   function setMeshVelocity( mesh, velocity, index = 0 ) {    let body = meshMap.get( mesh );    if ( mesh.isInstancedMesh ) {     body = body[ index ];    }    body.setLinvel( velocity );   }   //   const clock = new Clock();   function step() {    world.timestep = clock.getDelta();   world.step();    //    for ( let i = 0, l = meshes.length; i < l; i ++ ) {     const mesh = meshes[ i ];     if ( mesh.isInstancedMesh ) {      const array = mesh.instanceMatrix.array;     const bodies = meshMap.get( mesh );      for ( let j = 0; j < bodies.length; j ++ ) {       const body = bodies[ j ];       const position = body.translation();      _quaternion.copy( body.rotation() );       _matrix.compose( position, _quaternion, _scale ).toArray( array, j * 16 );      }      mesh.instanceMatrix.needsUpdate = true;     mesh.computeBoundingSphere();     } else {      const body = meshMap.get( mesh );      mesh.position.copy( body.translation() );     mesh.quaternion.copy( body.rotation() );     }    }   }   // animate   setInterval( step, 1000 / frameRate );   return {   addScene: addScene,   addMesh: addMesh,   setMeshPosition: setMeshPosition,   setMeshVelocity: setMeshVelocity  };  }  export { RapierPhysics }; 
^..^ FILENAME ^..^
addons|postprocessing|AfterimagePass.js
^..^ CONTENTS ^..^
import {  HalfFloatType,  MeshBasicMaterial,  NearestFilter,  ShaderMaterial,  UniformsUtils,  WebGLRenderTarget } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { AfterimageShader } from '../shaders/AfterimageShader.js';  class AfterimagePass extends Pass {   constructor( damp = 0.96 ) {    super();    this.shader = AfterimageShader;    this.uniforms = UniformsUtils.clone( this.shader.uniforms );    this.uniforms[ 'damp' ].value = damp;    this.textureComp = new WebGLRenderTarget( window.innerWidth, window.innerHeight, {    magFilter: NearestFilter,    type: HalfFloatType   } );    this.textureOld = new WebGLRenderTarget( window.innerWidth, window.innerHeight, {    magFilter: NearestFilter,    type: HalfFloatType   } );    this.compFsMaterial = new ShaderMaterial( {     uniforms: this.uniforms,    vertexShader: this.shader.vertexShader,    fragmentShader: this.shader.fragmentShader    } );    this.compFsQuad = new FullScreenQuad( this.compFsMaterial );    this.copyFsMaterial = new MeshBasicMaterial();   this.copyFsQuad = new FullScreenQuad( this.copyFsMaterial );   }   render( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {    this.uniforms[ 'tOld' ].value = this.textureOld.texture;   this.uniforms[ 'tNew' ].value = readBuffer.texture;    renderer.setRenderTarget( this.textureComp );   this.compFsQuad.render( renderer );    this.copyFsQuad.material.map = this.textureComp.texture;    if ( this.renderToScreen ) {     renderer.setRenderTarget( null );    this.copyFsQuad.render( renderer );    } else {     renderer.setRenderTarget( writeBuffer );     if ( this.clear ) renderer.clear();     this.copyFsQuad.render( renderer );    }    // Swap buffers.   const temp = this.textureOld;   this.textureOld = this.textureComp;   this.textureComp = temp;   // Now textureOld contains the latest image, ready for the next frame.   }   setSize( width, height ) {    this.textureComp.setSize( width, height );   this.textureOld.setSize( width, height );   }   dispose() {    this.textureComp.dispose();   this.textureOld.dispose();    this.compFsMaterial.dispose();   this.copyFsMaterial.dispose();    this.compFsQuad.dispose();   this.copyFsQuad.dispose();   }  }  export { AfterimagePass }; 
^..^ FILENAME ^..^
addons|postprocessing|BloomPass.js
^..^ CONTENTS ^..^
import {  AdditiveBlending,  HalfFloatType,  ShaderMaterial,  UniformsUtils,  Vector2,  WebGLRenderTarget } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { ConvolutionShader } from '../shaders/ConvolutionShader.js';  class BloomPass extends Pass {   constructor( strength = 1, kernelSize = 25, sigma = 4 ) {    super();    // render targets    this.renderTargetX = new WebGLRenderTarget( 1, 1, { type: HalfFloatType } ); // will be resized later   this.renderTargetX.texture.name = 'BloomPass.x';   this.renderTargetY = new WebGLRenderTarget( 1, 1, { type: HalfFloatType } ); // will be resized later   this.renderTargetY.texture.name = 'BloomPass.y';    // combine material    this.combineUniforms = UniformsUtils.clone( CombineShader.uniforms );    this.combineUniforms[ 'strength' ].value = strength;    this.materialCombine = new ShaderMaterial( {     name: CombineShader.name,    uniforms: this.combineUniforms,    vertexShader: CombineShader.vertexShader,    fragmentShader: CombineShader.fragmentShader,    blending: AdditiveBlending,    transparent: true    } );    // convolution material    const convolutionShader = ConvolutionShader;    this.convolutionUniforms = UniformsUtils.clone( convolutionShader.uniforms );    this.convolutionUniforms[ 'uImageIncrement' ].value = BloomPass.blurX;   this.convolutionUniforms[ 'cKernel' ].value = ConvolutionShader.buildKernel( sigma );    this.materialConvolution = new ShaderMaterial( {     name: convolutionShader.name,    uniforms: this.convolutionUniforms,    vertexShader: convolutionShader.vertexShader,    fragmentShader: convolutionShader.fragmentShader,    defines: {     'KERNEL_SIZE_FLOAT': kernelSize.toFixed( 1 ),     'KERNEL_SIZE_INT': kernelSize.toFixed( 0 )    }    } );    this.needsSwap = false;    this.fsQuad = new FullScreenQuad( null );   }   render( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {    if ( maskActive ) renderer.state.buffers.stencil.setTest( false );    // Render quad with blured scene into texture (convolution pass 1)    this.fsQuad.material = this.materialConvolution;    this.convolutionUniforms[ 'tDiffuse' ].value = readBuffer.texture;   this.convolutionUniforms[ 'uImageIncrement' ].value = BloomPass.blurX;    renderer.setRenderTarget( this.renderTargetX );   renderer.clear();   this.fsQuad.render( renderer );     // Render quad with blured scene into texture (convolution pass 2)    this.convolutionUniforms[ 'tDiffuse' ].value = this.renderTargetX.texture;   this.convolutionUniforms[ 'uImageIncrement' ].value = BloomPass.blurY;    renderer.setRenderTarget( this.renderTargetY );   renderer.clear();   this.fsQuad.render( renderer );    // Render original scene with superimposed blur to texture    this.fsQuad.material = this.materialCombine;    this.combineUniforms[ 'tDiffuse' ].value = this.renderTargetY.texture;    if ( maskActive ) renderer.state.buffers.stencil.setTest( true );    renderer.setRenderTarget( readBuffer );   if ( this.clear ) renderer.clear();   this.fsQuad.render( renderer );   }   setSize( width, height ) {    this.renderTargetX.setSize( width, height );   this.renderTargetY.setSize( width, height );   }   dispose() {    this.renderTargetX.dispose();   this.renderTargetY.dispose();    this.materialCombine.dispose();   this.materialConvolution.dispose();    this.fsQuad.dispose();   }  }  const CombineShader = {   name: 'CombineShader',   uniforms: {    'tDiffuse': { value: null },   'strength': { value: 1.0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform float strength;    uniform sampler2D tDiffuse;    varying vec2 vUv;    void main() {     vec4 texel = texture2D( tDiffuse, vUv );    gl_FragColor = strength * texel;    }|  };  BloomPass.blurX = new Vector2( 0.001953125, 0.0 ); BloomPass.blurY = new Vector2( 0.0, 0.001953125 );  export { BloomPass }; 
^..^ FILENAME ^..^
addons|postprocessing|BokehPass.js
^..^ CONTENTS ^..^
import {  Color,  HalfFloatType,  MeshDepthMaterial,  NearestFilter,  NoBlending,  RGBADepthPacking,  ShaderMaterial,  UniformsUtils,  WebGLRenderTarget } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { BokehShader } from '../shaders/BokehShader.js';  /**  * Depth-of-field post-process with bokeh shader  */  class BokehPass extends Pass {   constructor( scene, camera, params ) {    super();    this.scene = scene;   this.camera = camera;    const focus = ( params.focus !== undefined ) ? params.focus : 1.0;   const aperture = ( params.aperture !== undefined ) ? params.aperture : 0.025;   const maxblur = ( params.maxblur !== undefined ) ? params.maxblur : 1.0;    // render targets    this.renderTargetDepth = new WebGLRenderTarget( 1, 1, { // will be resized later    minFilter: NearestFilter,    magFilter: NearestFilter,    type: HalfFloatType   } );    this.renderTargetDepth.texture.name = 'BokehPass.depth';    // depth material    this.materialDepth = new MeshDepthMaterial();   this.materialDepth.depthPacking = RGBADepthPacking;   this.materialDepth.blending = NoBlending;    // bokeh material    const bokehShader = BokehShader;   const bokehUniforms = UniformsUtils.clone( bokehShader.uniforms );    bokehUniforms[ 'tDepth' ].value = this.renderTargetDepth.texture;    bokehUniforms[ 'focus' ].value = focus;   bokehUniforms[ 'aspect' ].value = camera.aspect;   bokehUniforms[ 'aperture' ].value = aperture;   bokehUniforms[ 'maxblur' ].value = maxblur;   bokehUniforms[ 'nearClip' ].value = camera.near;   bokehUniforms[ 'farClip' ].value = camera.far;    this.materialBokeh = new ShaderMaterial( {    defines: Object.assign( {}, bokehShader.defines ),    uniforms: bokehUniforms,    vertexShader: bokehShader.vertexShader,    fragmentShader: bokehShader.fragmentShader   } );    this.uniforms = bokehUniforms;    this.fsQuad = new FullScreenQuad( this.materialBokeh );    this._oldClearColor = new Color();   }   render( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {    // Render depth into texture    this.scene.overrideMaterial = this.materialDepth;    renderer.getClearColor( this._oldClearColor );   const oldClearAlpha = renderer.getClearAlpha();   const oldAutoClear = renderer.autoClear;   renderer.autoClear = false;    renderer.setClearColor( 0xffffff );   renderer.setClearAlpha( 1.0 );   renderer.setRenderTarget( this.renderTargetDepth );   renderer.clear();   renderer.render( this.scene, this.camera );    // Render bokeh composite    this.uniforms[ 'tColor' ].value = readBuffer.texture;   this.uniforms[ 'nearClip' ].value = this.camera.near;   this.uniforms[ 'farClip' ].value = this.camera.far;    if ( this.renderToScreen ) {     renderer.setRenderTarget( null );    this.fsQuad.render( renderer );    } else {     renderer.setRenderTarget( writeBuffer );    renderer.clear();    this.fsQuad.render( renderer );    }    this.scene.overrideMaterial = null;   renderer.setClearColor( this._oldClearColor );   renderer.setClearAlpha( oldClearAlpha );   renderer.autoClear = oldAutoClear;   }   setSize( width, height ) {    this.materialBokeh.uniforms[ 'aspect' ].value = width / height;    this.renderTargetDepth.setSize( width, height );   }   dispose() {    this.renderTargetDepth.dispose();    this.materialDepth.dispose();   this.materialBokeh.dispose();    this.fsQuad.dispose();   }  }  export { BokehPass }; 
^..^ FILENAME ^..^
addons|postprocessing|ClearPass.js
^..^ CONTENTS ^..^
import {  Color } from 'three'; import { Pass } from './Pass.js';  class ClearPass extends Pass {   constructor( clearColor, clearAlpha ) {    super();    this.needsSwap = false;    this.clearColor = ( clearColor !== undefined ) ? clearColor : 0x000000;   this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;   this._oldClearColor = new Color();   }   render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {    let oldClearAlpha;    if ( this.clearColor ) {     renderer.getClearColor( this._oldClearColor );    oldClearAlpha = renderer.getClearAlpha();     renderer.setClearColor( this.clearColor, this.clearAlpha );    }    renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );   renderer.clear();    if ( this.clearColor ) {     renderer.setClearColor( this._oldClearColor, oldClearAlpha );    }   }  }  export { ClearPass }; 
^..^ FILENAME ^..^
addons|postprocessing|CubeTexturePass.js
^..^ CONTENTS ^..^
import {  BackSide,  BoxGeometry,  Mesh,  PerspectiveCamera,  Scene,  ShaderLib,  ShaderMaterial,  UniformsUtils } from 'three'; import { Pass } from './Pass.js';  class CubeTexturePass extends Pass {   constructor( camera, tCube, opacity = 1 ) {    super();    this.camera = camera;    this.needsSwap = false;    this.cubeShader = ShaderLib[ 'cube' ];   this.cubeMesh = new Mesh(    new BoxGeometry( 10, 10, 10 ),    new ShaderMaterial( {     uniforms: UniformsUtils.clone( this.cubeShader.uniforms ),     vertexShader: this.cubeShader.vertexShader,     fragmentShader: this.cubeShader.fragmentShader,     depthTest: false,     depthWrite: false,     side: BackSide    } )   );    Object.defineProperty( this.cubeMesh.material, 'envMap', {     get: function () {      return this.uniforms.tCube.value;     }    } );    this.tCube = tCube;   this.opacity = opacity;    this.cubeScene = new Scene();   this.cubeCamera = new PerspectiveCamera();   this.cubeScene.add( this.cubeMesh );   }   render( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {    const oldAutoClear = renderer.autoClear;   renderer.autoClear = false;    this.cubeCamera.projectionMatrix.copy( this.camera.projectionMatrix );   this.cubeCamera.quaternion.setFromRotationMatrix( this.camera.matrixWorld );    this.cubeMesh.material.uniforms.tCube.value = this.tCube;   this.cubeMesh.material.uniforms.tFlip.value = ( this.tCube.isCubeTexture && this.tCube.isRenderTargetTexture === false ) ? - 1 : 1;   this.cubeMesh.material.uniforms.opacity.value = this.opacity;   this.cubeMesh.material.transparent = ( this.opacity < 1.0 );    renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );   if ( this.clear ) renderer.clear();   renderer.render( this.cubeScene, this.cubeCamera );    renderer.autoClear = oldAutoClear;   }   dispose() {    this.cubeMesh.geometry.dispose();   this.cubeMesh.material.dispose();   }  }  export { CubeTexturePass }; 
^..^ FILENAME ^..^
addons|postprocessing|DotScreenPass.js
^..^ CONTENTS ^..^
import {  ShaderMaterial,  UniformsUtils } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { DotScreenShader } from '../shaders/DotScreenShader.js';  class DotScreenPass extends Pass {   constructor( center, angle, scale ) {    super();    const shader = DotScreenShader;    this.uniforms = UniformsUtils.clone( shader.uniforms );    if ( center !== undefined ) this.uniforms[ 'center' ].value.copy( center );   if ( angle !== undefined ) this.uniforms[ 'angle' ].value = angle;   if ( scale !== undefined ) this.uniforms[ 'scale' ].value = scale;    this.material = new ShaderMaterial( {     name: shader.name,    uniforms: this.uniforms,    vertexShader: shader.vertexShader,    fragmentShader: shader.fragmentShader    } );    this.fsQuad = new FullScreenQuad( this.material );   }   render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {    this.uniforms[ 'tDiffuse' ].value = readBuffer.texture;   this.uniforms[ 'tSize' ].value.set( readBuffer.width, readBuffer.height );    if ( this.renderToScreen ) {     renderer.setRenderTarget( null );    this.fsQuad.render( renderer );    } else {     renderer.setRenderTarget( writeBuffer );    if ( this.clear ) renderer.clear();    this.fsQuad.render( renderer );    }   }   dispose() {    this.material.dispose();    this.fsQuad.dispose();   }  }  export { DotScreenPass }; 
^..^ FILENAME ^..^
addons|postprocessing|EffectComposer.js
^..^ CONTENTS ^..^
import {  Clock,  HalfFloatType,  NoBlending,  Vector2,  WebGLRenderTarget } from 'three'; import { CopyShader } from '../shaders/CopyShader.js'; import { ShaderPass } from './ShaderPass.js'; import { MaskPass } from './MaskPass.js'; import { ClearMaskPass } from './MaskPass.js';  class EffectComposer {   constructor( renderer, renderTarget ) {    this.renderer = renderer;    this._pixelRatio = renderer.getPixelRatio();    if ( renderTarget === undefined ) {     const size = renderer.getSize( new Vector2() );    this._width = size.width;    this._height = size.height;     renderTarget = new WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType } );    renderTarget.texture.name = 'EffectComposer.rt1';    } else {     this._width = renderTarget.width;    this._height = renderTarget.height;    }    this.renderTarget1 = renderTarget;   this.renderTarget2 = renderTarget.clone();   this.renderTarget2.texture.name = 'EffectComposer.rt2';    this.writeBuffer = this.renderTarget1;   this.readBuffer = this.renderTarget2;    this.renderToScreen = true;    this.passes = [];    this.copyPass = new ShaderPass( CopyShader );   this.copyPass.material.blending = NoBlending;    this.clock = new Clock();   }   swapBuffers() {    const tmp = this.readBuffer;   this.readBuffer = this.writeBuffer;   this.writeBuffer = tmp;   }   addPass( pass ) {    this.passes.push( pass );   pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );   }   insertPass( pass, index ) {    this.passes.splice( index, 0, pass );   pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );   }   removePass( pass ) {    const index = this.passes.indexOf( pass );    if ( index !== - 1 ) {     this.passes.splice( index, 1 );    }   }   isLastEnabledPass( passIndex ) {    for ( let i = passIndex + 1; i < this.passes.length; i ++ ) {     if ( this.passes[ i ].enabled ) {      return false;     }    }    return true;   }   render( deltaTime ) {    // deltaTime value is in seconds    if ( deltaTime === undefined ) {     deltaTime = this.clock.getDelta();    }    const currentRenderTarget = this.renderer.getRenderTarget();    let maskActive = false;    for ( let i = 0, il = this.passes.length; i < il; i ++ ) {     const pass = this.passes[ i ];     if ( pass.enabled === false ) continue;     pass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );    pass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );     if ( pass.needsSwap ) {      if ( maskActive ) {       const context = this.renderer.getContext();      const stencil = this.renderer.state.buffers.stencil;       //context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );      stencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );       this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );       //context.stencilFunc( context.EQUAL, 1, 0xffffffff );      stencil.setFunc( context.EQUAL, 1, 0xffffffff );      }      this.swapBuffers();     }     if ( MaskPass !== undefined ) {      if ( pass instanceof MaskPass ) {       maskActive = true;      } else if ( pass instanceof ClearMaskPass ) {       maskActive = false;      }     }    }    this.renderer.setRenderTarget( currentRenderTarget );   }   reset( renderTarget ) {    if ( renderTarget === undefined ) {     const size = this.renderer.getSize( new Vector2() );    this._pixelRatio = this.renderer.getPixelRatio();    this._width = size.width;    this._height = size.height;     renderTarget = this.renderTarget1.clone();    renderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );    }    this.renderTarget1.dispose();   this.renderTarget2.dispose();   this.renderTarget1 = renderTarget;   this.renderTarget2 = renderTarget.clone();    this.writeBuffer = this.renderTarget1;   this.readBuffer = this.renderTarget2;   }   setSize( width, height ) {    this._width = width;   this._height = height;    const effectiveWidth = this._width * this._pixelRatio;   const effectiveHeight = this._height * this._pixelRatio;    this.renderTarget1.setSize( effectiveWidth, effectiveHeight );   this.renderTarget2.setSize( effectiveWidth, effectiveHeight );    for ( let i = 0; i < this.passes.length; i ++ ) {     this.passes[ i ].setSize( effectiveWidth, effectiveHeight );    }   }   setPixelRatio( pixelRatio ) {    this._pixelRatio = pixelRatio;    this.setSize( this._width, this._height );   }   dispose() {    this.renderTarget1.dispose();   this.renderTarget2.dispose();    this.copyPass.dispose();   }  }  export { EffectComposer }; 
^..^ FILENAME ^..^
addons|postprocessing|FilmPass.js
^..^ CONTENTS ^..^
import {  ShaderMaterial,  UniformsUtils } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { FilmShader } from '../shaders/FilmShader.js';  class FilmPass extends Pass {   constructor( intensity = 0.5, grayscale = false ) {    super();    const shader = FilmShader;    this.uniforms = UniformsUtils.clone( shader.uniforms );    this.material = new ShaderMaterial( {     name: shader.name,    uniforms: this.uniforms,    vertexShader: shader.vertexShader,    fragmentShader: shader.fragmentShader    } );    this.uniforms.intensity.value = intensity; // (0 = no effect, 1 = full effect)   this.uniforms.grayscale.value = grayscale;    this.fsQuad = new FullScreenQuad( this.material );   }   render( renderer, writeBuffer, readBuffer, deltaTime /*, maskActive */ ) {    this.uniforms[ 'tDiffuse' ].value = readBuffer.texture;   this.uniforms[ 'time' ].value += deltaTime;    if ( this.renderToScreen ) {     renderer.setRenderTarget( null );    this.fsQuad.render( renderer );    } else {     renderer.setRenderTarget( writeBuffer );    if ( this.clear ) renderer.clear();    this.fsQuad.render( renderer );    }   }   dispose() {    this.material.dispose();    this.fsQuad.dispose();   }  }  export { FilmPass }; 
^..^ FILENAME ^..^
addons|postprocessing|GlitchPass.js
^..^ CONTENTS ^..^
import {  DataTexture,  FloatType,  MathUtils,  RedFormat,  ShaderMaterial,  UniformsUtils } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { DigitalGlitch } from '../shaders/DigitalGlitch.js';  class GlitchPass extends Pass {   constructor( dt_size = 64 ) {    super();    const shader = DigitalGlitch;    this.uniforms = UniformsUtils.clone( shader.uniforms );    this.heightMap = this.generateHeightmap( dt_size );    this.uniforms[ 'tDisp' ].value = this.heightMap;    this.material = new ShaderMaterial( {    uniforms: this.uniforms,    vertexShader: shader.vertexShader,    fragmentShader: shader.fragmentShader   } );    this.fsQuad = new FullScreenQuad( this.material );    this.goWild = false;   this.curF = 0;   this.generateTrigger();   }   render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {    this.uniforms[ 'tDiffuse' ].value = readBuffer.texture;   this.uniforms[ 'seed' ].value = Math.random();//default seeding   this.uniforms[ 'byp' ].value = 0;    if ( this.curF % this.randX == 0 || this.goWild == true ) {     this.uniforms[ 'amount' ].value = Math.random() / 30;    this.uniforms[ 'angle' ].value = MathUtils.randFloat( - Math.PI, Math.PI );    this.uniforms[ 'seed_x' ].value = MathUtils.randFloat( - 1, 1 );    this.uniforms[ 'seed_y' ].value = MathUtils.randFloat( - 1, 1 );    this.uniforms[ 'distortion_x' ].value = MathUtils.randFloat( 0, 1 );    this.uniforms[ 'distortion_y' ].value = MathUtils.randFloat( 0, 1 );    this.curF = 0;    this.generateTrigger();    } else if ( this.curF % this.randX < this.randX / 5 ) {     this.uniforms[ 'amount' ].value = Math.random() / 90;    this.uniforms[ 'angle' ].value = MathUtils.randFloat( - Math.PI, Math.PI );    this.uniforms[ 'distortion_x' ].value = MathUtils.randFloat( 0, 1 );    this.uniforms[ 'distortion_y' ].value = MathUtils.randFloat( 0, 1 );    this.uniforms[ 'seed_x' ].value = MathUtils.randFloat( - 0.3, 0.3 );    this.uniforms[ 'seed_y' ].value = MathUtils.randFloat( - 0.3, 0.3 );    } else if ( this.goWild == false ) {     this.uniforms[ 'byp' ].value = 1;    }    this.curF ++;    if ( this.renderToScreen ) {     renderer.setRenderTarget( null );    this.fsQuad.render( renderer );    } else {     renderer.setRenderTarget( writeBuffer );    if ( this.clear ) renderer.clear();    this.fsQuad.render( renderer );    }   }   generateTrigger() {    this.randX = MathUtils.randInt( 120, 240 );   }   generateHeightmap( dt_size ) {    const data_arr = new Float32Array( dt_size * dt_size );   const length = dt_size * dt_size;    for ( let i = 0; i < length; i ++ ) {     const val = MathUtils.randFloat( 0, 1 );    data_arr[ i ] = val;    }    const texture = new DataTexture( data_arr, dt_size, dt_size, RedFormat, FloatType );   texture.needsUpdate = true;   return texture;   }   dispose() {    this.material.dispose();    this.heightMap.dispose();    this.fsQuad.dispose();   }  }  export { GlitchPass }; 
^..^ FILENAME ^..^
addons|postprocessing|GTAOPass.js
^..^ CONTENTS ^..^
import {  AddEquation,  Color,  CustomBlending,  DataTexture,  DepthTexture,  DepthStencilFormat,  DstAlphaFactor,  DstColorFactor,  HalfFloatType,  MeshNormalMaterial,  NearestFilter,  NoBlending,  RepeatWrapping,  RGBAFormat,  ShaderMaterial,  UniformsUtils,  UnsignedByteType,  UnsignedInt248Type,  WebGLRenderTarget,  ZeroFactor } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { generateMagicSquareNoise, GTAOShader, GTAODepthShader, GTAOBlendShader } from '../shaders/GTAOShader.js'; import { generatePdSamplePointInitializer, PoissonDenoiseShader } from '../shaders/PoissonDenoiseShader.js'; import { CopyShader } from '../shaders/CopyShader.js'; import { SimplexNoise } from '../math/SimplexNoise.js';  class GTAOPass extends Pass {   constructor( scene, camera, width, height, parameters, aoParameters, pdParameters ) {    super();    this.width = ( width !== undefined ) ? width : 512;   this.height = ( height !== undefined ) ? height : 512;   this.clear = true;   this.camera = camera;   this.scene = scene;   this.output = 0;   this._renderGBuffer = true;   this._visibilityCache = new Map();   this.blendIntensity = 1.;    this.pdRings = 2.;   this.pdRadiusExponent = 2.;   this.pdSamples = 16;    this.gtaoNoiseTexture = generateMagicSquareNoise();   this.pdNoiseTexture = this.generateNoise();    this.gtaoRenderTarget = new WebGLRenderTarget( this.width, this.height, { type: HalfFloatType } );   this.pdRenderTarget = this.gtaoRenderTarget.clone();    this.gtaoMaterial = new ShaderMaterial( {    defines: Object.assign( {}, GTAOShader.defines ),    uniforms: UniformsUtils.clone( GTAOShader.uniforms ),    vertexShader: GTAOShader.vertexShader,    fragmentShader: GTAOShader.fragmentShader,    blending: NoBlending,    depthTest: false,    depthWrite: false,   } );   this.gtaoMaterial.defines.PERSPECTIVE_CAMERA = this.camera.isPerspectiveCamera ? 1 : 0;   this.gtaoMaterial.uniforms.tNoise.value = this.gtaoNoiseTexture;   this.gtaoMaterial.uniforms.resolution.value.set( this.width, this.height );   this.gtaoMaterial.uniforms.cameraNear.value = this.camera.near;   this.gtaoMaterial.uniforms.cameraFar.value = this.camera.far;    this.normalMaterial = new MeshNormalMaterial();   this.normalMaterial.blending = NoBlending;    this.pdMaterial = new ShaderMaterial( {    defines: Object.assign( {}, PoissonDenoiseShader.defines ),    uniforms: UniformsUtils.clone( PoissonDenoiseShader.uniforms ),    vertexShader: PoissonDenoiseShader.vertexShader,    fragmentShader: PoissonDenoiseShader.fragmentShader,    depthTest: false,    depthWrite: false,   } );   this.pdMaterial.uniforms.tDiffuse.value = this.gtaoRenderTarget.texture;   this.pdMaterial.uniforms.tNoise.value = this.pdNoiseTexture;   this.pdMaterial.uniforms.resolution.value.set( this.width, this.height );   this.pdMaterial.uniforms.lumaPhi.value = 10;   this.pdMaterial.uniforms.depthPhi.value = 2;   this.pdMaterial.uniforms.normalPhi.value = 3;   this.pdMaterial.uniforms.radius.value = 8;    this.depthRenderMaterial = new ShaderMaterial( {    defines: Object.assign( {}, GTAODepthShader.defines ),    uniforms: UniformsUtils.clone( GTAODepthShader.uniforms ),    vertexShader: GTAODepthShader.vertexShader,    fragmentShader: GTAODepthShader.fragmentShader,    blending: NoBlending   } );   this.depthRenderMaterial.uniforms.cameraNear.value = this.camera.near;   this.depthRenderMaterial.uniforms.cameraFar.value = this.camera.far;    this.copyMaterial = new ShaderMaterial( {    uniforms: UniformsUtils.clone( CopyShader.uniforms ),    vertexShader: CopyShader.vertexShader,    fragmentShader: CopyShader.fragmentShader,    transparent: true,    depthTest: false,    depthWrite: false,    blendSrc: DstColorFactor,    blendDst: ZeroFactor,    blendEquation: AddEquation,    blendSrcAlpha: DstAlphaFactor,    blendDstAlpha: ZeroFactor,    blendEquationAlpha: AddEquation   } );    this.blendMaterial = new ShaderMaterial( {    uniforms: UniformsUtils.clone( GTAOBlendShader.uniforms ),    vertexShader: GTAOBlendShader.vertexShader,    fragmentShader: GTAOBlendShader.fragmentShader,    transparent: true,    depthTest: false,    depthWrite: false,    blending: CustomBlending,    blendSrc: DstColorFactor,    blendDst: ZeroFactor,    blendEquation: AddEquation,    blendSrcAlpha: DstAlphaFactor,    blendDstAlpha: ZeroFactor,    blendEquationAlpha: AddEquation   } );    this.fsQuad = new FullScreenQuad( null );    this.originalClearColor = new Color();    this.setGBuffer( parameters ? parameters.depthTexture : undefined, parameters ? parameters.normalTexture : undefined );    if ( aoParameters !== undefined ) {     this.updateGtaoMaterial( aoParameters );    }    if ( pdParameters !== undefined ) {     this.updatePdMaterial( pdParameters );    }   }   dispose() {    this.gtaoNoiseTexture.dispose();   this.pdNoiseTexture.dispose();   this.normalRenderTarget.dispose();   this.gtaoRenderTarget.dispose();   this.pdRenderTarget.dispose();   this.normalMaterial.dispose();   this.pdMaterial.dispose();   this.copyMaterial.dispose();   this.depthRenderMaterial.dispose();   this.fsQuad.dispose();   }   get gtaoMap() {    return this.pdRenderTarget.texture;   }   setGBuffer( depthTexture, normalTexture ) {    if ( depthTexture !== undefined ) {     this.depthTexture = depthTexture;    this.normalTexture = normalTexture;    this._renderGBuffer = false;    } else {     this.depthTexture = new DepthTexture();    this.depthTexture.format = DepthStencilFormat;    this.depthTexture.type = UnsignedInt248Type;    this.normalRenderTarget = new WebGLRenderTarget( this.width, this.height, {     minFilter: NearestFilter,     magFilter: NearestFilter,     type: HalfFloatType,     depthTexture: this.depthTexture    } );    this.normalTexture = this.normalRenderTarget.texture;    this._renderGBuffer = true;    }    const normalVectorType = ( this.normalTexture ) ? 1 : 0;   const depthValueSource = ( this.depthTexture === this.normalTexture ) ? 'w' : 'x';    this.gtaoMaterial.defines.NORMAL_VECTOR_TYPE = normalVectorType;   this.gtaoMaterial.defines.DEPTH_SWIZZLING = depthValueSource;   this.gtaoMaterial.uniforms.tNormal.value = this.normalTexture;   this.gtaoMaterial.uniforms.tDepth.value = this.depthTexture;    this.pdMaterial.defines.NORMAL_VECTOR_TYPE = normalVectorType;   this.pdMaterial.defines.DEPTH_SWIZZLING = depthValueSource;   this.pdMaterial.uniforms.tNormal.value = this.normalTexture;   this.pdMaterial.uniforms.tDepth.value = this.depthTexture;    this.depthRenderMaterial.uniforms.tDepth.value = this.normalRenderTarget.depthTexture;   }   setSceneClipBox( box ) {    if ( box ) {     this.gtaoMaterial.needsUpdate = this.gtaoMaterial.defines.SCENE_CLIP_BOX !== 1;    this.gtaoMaterial.defines.SCENE_CLIP_BOX = 1;    this.gtaoMaterial.uniforms.sceneBoxMin.value.copy( box.min );    this.gtaoMaterial.uniforms.sceneBoxMax.value.copy( box.max );    } else {     this.gtaoMaterial.needsUpdate = this.gtaoMaterial.defines.SCENE_CLIP_BOX === 0;    this.gtaoMaterial.defines.SCENE_CLIP_BOX = 0;    }   }   updateGtaoMaterial( parameters ) {    if ( parameters.radius !== undefined ) {     this.gtaoMaterial.uniforms.radius.value = parameters.radius;    }    if ( parameters.distanceExponent !== undefined ) {     this.gtaoMaterial.uniforms.distanceExponent.value = parameters.distanceExponent;    }    if ( parameters.thickness !== undefined ) {     this.gtaoMaterial.uniforms.thickness.value = parameters.thickness;    }    if ( parameters.distanceFallOff !== undefined ) {     this.gtaoMaterial.uniforms.distanceFallOff.value = parameters.distanceFallOff;    this.gtaoMaterial.needsUpdate = true;    }    if ( parameters.scale !== undefined ) {     this.gtaoMaterial.uniforms.scale.value = parameters.scale;    }    if ( parameters.samples !== undefined && parameters.samples !== this.gtaoMaterial.defines.SAMPLES ) {     this.gtaoMaterial.defines.SAMPLES = parameters.samples;    this.gtaoMaterial.needsUpdate = true;    }    if ( parameters.screenSpaceRadius !== undefined && ( parameters.screenSpaceRadius ? 1 : 0 ) !== this.gtaoMaterial.defines.SCREEN_SPACE_RADIUS ) {     this.gtaoMaterial.defines.SCREEN_SPACE_RADIUS = parameters.screenSpaceRadius ? 1 : 0;    this.gtaoMaterial.needsUpdate = true;    }   }   updatePdMaterial( parameters ) {    let updateShader = false;    if ( parameters.lumaPhi !== undefined ) {     this.pdMaterial.uniforms.lumaPhi.value = parameters.lumaPhi;    }    if ( parameters.depthPhi !== undefined ) {     this.pdMaterial.uniforms.depthPhi.value = parameters.depthPhi;    }    if ( parameters.normalPhi !== undefined ) {     this.pdMaterial.uniforms.normalPhi.value = parameters.normalPhi;    }    if ( parameters.radius !== undefined && parameters.radius !== this.radius ) {     this.pdMaterial.uniforms.radius.value = parameters.radius;    }    if ( parameters.radiusExponent !== undefined && parameters.radiusExponent !== this.pdRadiusExponent ) {     this.pdRadiusExponent = parameters.radiusExponent;    updateShader = true;    }    if ( parameters.rings !== undefined && parameters.rings !== this.pdRings ) {     this.pdRings = parameters.rings;    updateShader = true;    }    if ( parameters.samples !== undefined && parameters.samples !== this.pdSamples ) {     this.pdSamples = parameters.samples;    updateShader = true;    }    if ( updateShader ) {     this.pdMaterial.defines.SAMPLES = this.pdSamples;    this.pdMaterial.defines.SAMPLE_VECTORS = generatePdSamplePointInitializer( this.pdSamples, this.pdRings, this.pdRadiusExponent );    this.pdMaterial.needsUpdate = true;    }   }   render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {    // render normals and depth (honor only meshes, points and lines do not contribute to AO)    if ( this._renderGBuffer ) {     this.overrideVisibility();    this.renderOverride( renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0 );    this.restoreVisibility();    }    // render AO    this.gtaoMaterial.uniforms.cameraNear.value = this.camera.near;   this.gtaoMaterial.uniforms.cameraFar.value = this.camera.far;   this.gtaoMaterial.uniforms.cameraProjectionMatrix.value.copy( this.camera.projectionMatrix );   this.gtaoMaterial.uniforms.cameraProjectionMatrixInverse.value.copy( this.camera.projectionMatrixInverse );   this.gtaoMaterial.uniforms.cameraWorldMatrix.value.copy( this.camera.matrixWorld );   this.renderPass( renderer, this.gtaoMaterial, this.gtaoRenderTarget, 0xffffff, 1.0 );    // render poisson denoise    this.pdMaterial.uniforms.cameraProjectionMatrixInverse.value.copy( this.camera.projectionMatrixInverse );   this.renderPass( renderer, this.pdMaterial, this.pdRenderTarget, 0xffffff, 1.0 );    // output result to screen    switch ( this.output ) {     case GTAOPass.OUTPUT.Off:     break;     case GTAOPass.OUTPUT.Diffuse:      this.copyMaterial.uniforms.tDiffuse.value = readBuffer.texture;     this.copyMaterial.blending = NoBlending;     this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );      break;     case GTAOPass.OUTPUT.AO:      this.copyMaterial.uniforms.tDiffuse.value = this.gtaoRenderTarget.texture;     this.copyMaterial.blending = NoBlending;     this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );      break;     case GTAOPass.OUTPUT.Denoise:      this.copyMaterial.uniforms.tDiffuse.value = this.pdRenderTarget.texture;     this.copyMaterial.blending = NoBlending;     this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );      break;     case GTAOPass.OUTPUT.Depth:      this.depthRenderMaterial.uniforms.cameraNear.value = this.camera.near;     this.depthRenderMaterial.uniforms.cameraFar.value = this.camera.far;     this.renderPass( renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer );      break;     case GTAOPass.OUTPUT.Normal:      this.copyMaterial.uniforms.tDiffuse.value = this.normalRenderTarget.texture;     this.copyMaterial.blending = NoBlending;     this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );      break;     case GTAOPass.OUTPUT.Default:      this.copyMaterial.uniforms.tDiffuse.value = readBuffer.texture;     this.copyMaterial.blending = NoBlending;     this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );      this.blendMaterial.uniforms.intensity.value = this.blendIntensity;     this.blendMaterial.uniforms.tDiffuse.value = this.pdRenderTarget.texture;     this.renderPass( renderer, this.blendMaterial, this.renderToScreen ? null : writeBuffer );      break;     default:     console.warn( 'THREE.GTAOPass: Unknown output type.' );    }   }   renderPass( renderer, passMaterial, renderTarget, clearColor, clearAlpha ) {    // save original state   renderer.getClearColor( this.originalClearColor );   const originalClearAlpha = renderer.getClearAlpha();   const originalAutoClear = renderer.autoClear;    renderer.setRenderTarget( renderTarget );    // setup pass state   renderer.autoClear = false;   if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {     renderer.setClearColor( clearColor );    renderer.setClearAlpha( clearAlpha || 0.0 );    renderer.clear();    }    this.fsQuad.material = passMaterial;   this.fsQuad.render( renderer );    // restore original state   renderer.autoClear = originalAutoClear;   renderer.setClearColor( this.originalClearColor );   renderer.setClearAlpha( originalClearAlpha );   }   renderOverride( renderer, overrideMaterial, renderTarget, clearColor, clearAlpha ) {    renderer.getClearColor( this.originalClearColor );   const originalClearAlpha = renderer.getClearAlpha();   const originalAutoClear = renderer.autoClear;    renderer.setRenderTarget( renderTarget );   renderer.autoClear = false;    clearColor = overrideMaterial.clearColor || clearColor;   clearAlpha = overrideMaterial.clearAlpha || clearAlpha;    if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {     renderer.setClearColor( clearColor );    renderer.setClearAlpha( clearAlpha || 0.0 );    renderer.clear();    }    this.scene.overrideMaterial = overrideMaterial;   renderer.render( this.scene, this.camera );   this.scene.overrideMaterial = null;    renderer.autoClear = originalAutoClear;   renderer.setClearColor( this.originalClearColor );   renderer.setClearAlpha( originalClearAlpha );   }   setSize( width, height ) {    this.width = width;   this.height = height;    this.gtaoRenderTarget.setSize( width, height );   this.normalRenderTarget.setSize( width, height );   this.pdRenderTarget.setSize( width, height );    this.gtaoMaterial.uniforms.resolution.value.set( width, height );   this.gtaoMaterial.uniforms.cameraProjectionMatrix.value.copy( this.camera.projectionMatrix );   this.gtaoMaterial.uniforms.cameraProjectionMatrixInverse.value.copy( this.camera.projectionMatrixInverse );    this.pdMaterial.uniforms.resolution.value.set( width, height );   this.pdMaterial.uniforms.cameraProjectionMatrixInverse.value.copy( this.camera.projectionMatrixInverse );   }   overrideVisibility() {    const scene = this.scene;   const cache = this._visibilityCache;    scene.traverse( function ( object ) {     cache.set( object, object.visible );     if ( object.isPoints || object.isLine ) object.visible = false;    } );   }   restoreVisibility() {    const scene = this.scene;   const cache = this._visibilityCache;    scene.traverse( function ( object ) {     const visible = cache.get( object );    object.visible = visible;    } );    cache.clear();   }   generateNoise( size = 64 ) {    const simplex = new SimplexNoise();    const arraySize = size * size * 4;   const data = new Uint8Array( arraySize );    for ( let i = 0; i < size; i ++ ) {     for ( let j = 0; j < size; j ++ ) {      const x = i;     const y = j;      data[ ( i * size + j ) * 4 ] = ( simplex.noise( x, y ) * 0.5 + 0.5 ) * 255;     data[ ( i * size + j ) * 4 + 1 ] = ( simplex.noise( x + size, y ) * 0.5 + 0.5 ) * 255;     data[ ( i * size + j ) * 4 + 2 ] = ( simplex.noise( x, y + size ) * 0.5 + 0.5 ) * 255;     data[ ( i * size + j ) * 4 + 3 ] = ( simplex.noise( x + size, y + size ) * 0.5 + 0.5 ) * 255;     }    }    const noiseTexture = new DataTexture( data, size, size, RGBAFormat, UnsignedByteType );   noiseTexture.wrapS = RepeatWrapping;   noiseTexture.wrapT = RepeatWrapping;   noiseTexture.needsUpdate = true;    return noiseTexture;   }  }  GTAOPass.OUTPUT = {  'Off': - 1,  'Default': 0,  'Diffuse': 1,  'Depth': 2,  'Normal': 3,  'AO': 4,  'Denoise': 5, };  export { GTAOPass }; 
^..^ FILENAME ^..^
addons|postprocessing|HalftonePass.js
^..^ CONTENTS ^..^
import {  ShaderMaterial,  UniformsUtils } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { HalftoneShader } from '../shaders/HalftoneShader.js';  /**  * RGB Halftone pass for three.js effects composer. Requires HalftoneShader.  */  class HalftonePass extends Pass {   constructor( width, height, params ) {    super();     this.uniforms = UniformsUtils.clone( HalftoneShader.uniforms );    this.material = new ShaderMaterial( {     uniforms: this.uniforms,     fragmentShader: HalftoneShader.fragmentShader,     vertexShader: HalftoneShader.vertexShader    } );    // set params   this.uniforms.width.value = width;   this.uniforms.height.value = height;    for ( const key in params ) {     if ( params.hasOwnProperty( key ) && this.uniforms.hasOwnProperty( key ) ) {      this.uniforms[ key ].value = params[ key ];     }    }    this.fsQuad = new FullScreenQuad( this.material );   }   render( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {     this.material.uniforms[ 'tDiffuse' ].value = readBuffer.texture;     if ( this.renderToScreen ) {      renderer.setRenderTarget( null );     this.fsQuad.render( renderer );    } else {      renderer.setRenderTarget( writeBuffer );     if ( this.clear ) renderer.clear();    this.fsQuad.render( renderer );    }    }    setSize( width, height ) {     this.uniforms.width.value = width;    this.uniforms.height.value = height;    }   dispose() {    this.material.dispose();    this.fsQuad.dispose();   }  }  export { HalftonePass }; 
^..^ FILENAME ^..^
addons|postprocessing|LUTPass.js
^..^ CONTENTS ^..^
import { ShaderPass } from './ShaderPass.js';  const LUTShader = {   name: 'LUTShader',   uniforms: {    lut: { value: null },   lutSize: { value: 0 },    tDiffuse: { value: null },   intensity: { value: 1.0 },  },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }   |,   fragmentShader: /* glsl */|    uniform float lutSize;   uniform sampler3D lut;    varying vec2 vUv;   uniform float intensity;   uniform sampler2D tDiffuse;   void main() {     vec4 val = texture2D( tDiffuse, vUv );    vec4 lutVal;     // pull the sample in by half a pixel so the sample begins    // at the center of the edge pixels.    float pixelWidth = 1.0 / lutSize;    float halfPixelWidth = 0.5 / lutSize;    vec3 uvw = vec3( halfPixelWidth ) + val.rgb * ( 1.0 - pixelWidth );      lutVal = vec4( texture( lut, uvw ).rgb, val.a );     gl_FragColor = vec4( mix( val, lutVal, intensity ) );    }   |,  };  class LUTPass extends ShaderPass {   set lut( v ) {    const material = this.material;    if ( v !== this.lut ) {     material.uniforms.lut.value = null;     if ( v ) {      material.uniforms.lutSize.value = v.image.width;     material.uniforms.lut.value = v;     }    }   }   get lut() {    return this.material.uniforms.lut.value;   }   set intensity( v ) {    this.material.uniforms.intensity.value = v;   }   get intensity() {    return this.material.uniforms.intensity.value;   }   constructor( options = {} ) {    super( LUTShader );   this.lut = options.lut || null;   this.intensity = 'intensity' in options ? options.intensity : 1;   }  }  export { LUTPass }; 
^..^ FILENAME ^..^
addons|postprocessing|MaskPass.js
^..^ CONTENTS ^..^
import { Pass } from './Pass.js';  class MaskPass extends Pass {   constructor( scene, camera ) {    super();    this.scene = scene;   this.camera = camera;    this.clear = true;   this.needsSwap = false;    this.inverse = false;   }   render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {    const context = renderer.getContext();   const state = renderer.state;    // don't update color or depth    state.buffers.color.setMask( false );   state.buffers.depth.setMask( false );    // lock buffers    state.buffers.color.setLocked( true );   state.buffers.depth.setLocked( true );    // set up stencil    let writeValue, clearValue;    if ( this.inverse ) {     writeValue = 0;    clearValue = 1;    } else {     writeValue = 1;    clearValue = 0;    }    state.buffers.stencil.setTest( true );   state.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );   state.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );   state.buffers.stencil.setClear( clearValue );   state.buffers.stencil.setLocked( true );    // draw into the stencil buffer    renderer.setRenderTarget( readBuffer );   if ( this.clear ) renderer.clear();   renderer.render( this.scene, this.camera );    renderer.setRenderTarget( writeBuffer );   if ( this.clear ) renderer.clear();   renderer.render( this.scene, this.camera );    // unlock color and depth buffer and make them writable for subsequent rendering/clearing    state.buffers.color.setLocked( false );   state.buffers.depth.setLocked( false );    state.buffers.color.setMask( true );   state.buffers.depth.setMask( true );    // only render where stencil is set to 1    state.buffers.stencil.setLocked( false );   state.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1   state.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );   state.buffers.stencil.setLocked( true );   }  }  class ClearMaskPass extends Pass {   constructor() {    super();    this.needsSwap = false;   }   render( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {    renderer.state.buffers.stencil.setLocked( false );   renderer.state.buffers.stencil.setTest( false );   }  }  export { MaskPass, ClearMaskPass }; 
^..^ FILENAME ^..^
addons|postprocessing|OutlinePass.js
^..^ CONTENTS ^..^
import {  AdditiveBlending,  Color,  DoubleSide,  HalfFloatType,  Matrix4,  MeshDepthMaterial,  NoBlending,  RGBADepthPacking,  ShaderMaterial,  UniformsUtils,  Vector2,  Vector3,  WebGLRenderTarget } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { CopyShader } from '../shaders/CopyShader.js';  class OutlinePass extends Pass {   constructor( resolution, scene, camera, selectedObjects ) {    super();    this.renderScene = scene;   this.renderCamera = camera;   this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];   this.visibleEdgeColor = new Color( 1, 1, 1 );   this.hiddenEdgeColor = new Color( 0.1, 0.04, 0.02 );   this.edgeGlow = 0.0;   this.usePatternTexture = false;   this.edgeThickness = 1.0;   this.edgeStrength = 3.0;   this.downSampleRatio = 2;   this.pulsePeriod = 0;    this._visibilityCache = new Map();   this._selectionCache = new Set();    this.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );    const resx = Math.round( this.resolution.x / this.downSampleRatio );   const resy = Math.round( this.resolution.y / this.downSampleRatio );    this.renderTargetMaskBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y );   this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';   this.renderTargetMaskBuffer.texture.generateMipmaps = false;    this.depthMaterial = new MeshDepthMaterial();   this.depthMaterial.side = DoubleSide;   this.depthMaterial.depthPacking = RGBADepthPacking;   this.depthMaterial.blending = NoBlending;    this.prepareMaskMaterial = this.getPrepareMaskMaterial();   this.prepareMaskMaterial.side = DoubleSide;   this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ( this.prepareMaskMaterial.fragmentShader, this.renderCamera );    this.renderTargetDepthBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y, { type: HalfFloatType } );   this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';   this.renderTargetDepthBuffer.texture.generateMipmaps = false;    this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );   this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';   this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;    this.renderTargetBlurBuffer1 = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );   this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';   this.renderTargetBlurBuffer1.texture.generateMipmaps = false;   this.renderTargetBlurBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), { type: HalfFloatType } );   this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';   this.renderTargetBlurBuffer2.texture.generateMipmaps = false;    this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();   this.renderTargetEdgeBuffer1 = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );   this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';   this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;   this.renderTargetEdgeBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), { type: HalfFloatType } );   this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';   this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;    const MAX_EDGE_THICKNESS = 4;   const MAX_EDGE_GLOW = 4;    this.separableBlurMaterial1 = this.getSeperableBlurMaterial( MAX_EDGE_THICKNESS );   this.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );   this.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = 1;   this.separableBlurMaterial2 = this.getSeperableBlurMaterial( MAX_EDGE_GLOW );   this.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( Math.round( resx / 2 ), Math.round( resy / 2 ) );   this.separableBlurMaterial2.uniforms[ 'kernelRadius' ].value = MAX_EDGE_GLOW;    // Overlay material   this.overlayMaterial = this.getOverlayMaterial();    // copy material    const copyShader = CopyShader;    this.copyUniforms = UniformsUtils.clone( copyShader.uniforms );    this.materialCopy = new ShaderMaterial( {    uniforms: this.copyUniforms,    vertexShader: copyShader.vertexShader,    fragmentShader: copyShader.fragmentShader,    blending: NoBlending,    depthTest: false,    depthWrite: false   } );    this.enabled = true;   this.needsSwap = false;    this._oldClearColor = new Color();   this.oldClearAlpha = 1;    this.fsQuad = new FullScreenQuad( null );    this.tempPulseColor1 = new Color();   this.tempPulseColor2 = new Color();   this.textureMatrix = new Matrix4();    function replaceDepthToViewZ( string, camera ) {     const type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';     return string.replace( /DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ' );    }   }   dispose() {    this.renderTargetMaskBuffer.dispose();   this.renderTargetDepthBuffer.dispose();   this.renderTargetMaskDownSampleBuffer.dispose();   this.renderTargetBlurBuffer1.dispose();   this.renderTargetBlurBuffer2.dispose();   this.renderTargetEdgeBuffer1.dispose();   this.renderTargetEdgeBuffer2.dispose();    this.depthMaterial.dispose();   this.prepareMaskMaterial.dispose();   this.edgeDetectionMaterial.dispose();   this.separableBlurMaterial1.dispose();   this.separableBlurMaterial2.dispose();   this.overlayMaterial.dispose();   this.materialCopy.dispose();    this.fsQuad.dispose();   }   setSize( width, height ) {    this.renderTargetMaskBuffer.setSize( width, height );   this.renderTargetDepthBuffer.setSize( width, height );    let resx = Math.round( width / this.downSampleRatio );   let resy = Math.round( height / this.downSampleRatio );   this.renderTargetMaskDownSampleBuffer.setSize( resx, resy );   this.renderTargetBlurBuffer1.setSize( resx, resy );   this.renderTargetEdgeBuffer1.setSize( resx, resy );   this.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );    resx = Math.round( resx / 2 );   resy = Math.round( resy / 2 );    this.renderTargetBlurBuffer2.setSize( resx, resy );   this.renderTargetEdgeBuffer2.setSize( resx, resy );    this.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( resx, resy );   }   updateSelectionCache() {    const cache = this._selectionCache;    function gatherSelectedMeshesCallBack( object ) {     if ( object.isMesh ) cache.add( object );    }    cache.clear();    for ( let i = 0; i < this.selectedObjects.length; i ++ ) {     const selectedObject = this.selectedObjects[ i ];    selectedObject.traverse( gatherSelectedMeshesCallBack );    }   }   changeVisibilityOfSelectedObjects( bVisible ) {    const cache = this._visibilityCache;    for ( const mesh of this._selectionCache ) {     if ( bVisible === true ) {      mesh.visible = cache.get( mesh );     } else {      cache.set( mesh, mesh.visible );     mesh.visible = bVisible;     }    }   }   changeVisibilityOfNonSelectedObjects( bVisible ) {    const visibilityCache = this._visibilityCache;   const selectionCache = this._selectionCache;    function VisibilityChangeCallBack( object ) {     if ( object.isMesh || object.isSprite ) {      // only meshes and sprites are supported by OutlinePass      if ( ! selectionCache.has( object ) ) {       const visibility = object.visible;       if ( bVisible === false || visibilityCache.get( object ) === true ) {        object.visible = bVisible;       }       visibilityCache.set( object, visibility );      }     } else if ( object.isPoints || object.isLine ) {      // the visibilty of points and lines is always set to false in order to     // not affect the outline computation      if ( bVisible === true ) {       object.visible = visibilityCache.get( object ); // restore      } else {       visibilityCache.set( object, object.visible );      object.visible = bVisible;      }     }    }    this.renderScene.traverse( VisibilityChangeCallBack );   }   updateTextureMatrix() {    this.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,    0.0, 0.5, 0.0, 0.5,    0.0, 0.0, 0.5, 0.5,    0.0, 0.0, 0.0, 1.0 );   this.textureMatrix.multiply( this.renderCamera.projectionMatrix );   this.textureMatrix.multiply( this.renderCamera.matrixWorldInverse );   }   render( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {    if ( this.selectedObjects.length > 0 ) {     renderer.getClearColor( this._oldClearColor );    this.oldClearAlpha = renderer.getClearAlpha();    const oldAutoClear = renderer.autoClear;     renderer.autoClear = false;     if ( maskActive ) renderer.state.buffers.stencil.setTest( false );     renderer.setClearColor( 0xffffff, 1 );     this.updateSelectionCache();     // Make selected objects invisible    this.changeVisibilityOfSelectedObjects( false );     const currentBackground = this.renderScene.background;    this.renderScene.background = null;     // 1. Draw Non Selected objects in the depth buffer    this.renderScene.overrideMaterial = this.depthMaterial;    renderer.setRenderTarget( this.renderTargetDepthBuffer );    renderer.clear();    renderer.render( this.renderScene, this.renderCamera );     // Make selected objects visible    this.changeVisibilityOfSelectedObjects( true );    this._visibilityCache.clear();     // Update Texture Matrix for Depth compare    this.updateTextureMatrix();     // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects    this.changeVisibilityOfNonSelectedObjects( false );    this.renderScene.overrideMaterial = this.prepareMaskMaterial;    this.prepareMaskMaterial.uniforms[ 'cameraNearFar' ].value.set( this.renderCamera.near, this.renderCamera.far );    this.prepareMaskMaterial.uniforms[ 'depthTexture' ].value = this.renderTargetDepthBuffer.texture;    this.prepareMaskMaterial.uniforms[ 'textureMatrix' ].value = this.textureMatrix;    renderer.setRenderTarget( this.renderTargetMaskBuffer );    renderer.clear();    renderer.render( this.renderScene, this.renderCamera );    this.renderScene.overrideMaterial = null;    this.changeVisibilityOfNonSelectedObjects( true );    this._visibilityCache.clear();    this._selectionCache.clear();     this.renderScene.background = currentBackground;     // 2. Downsample to Half resolution    this.fsQuad.material = this.materialCopy;    this.copyUniforms[ 'tDiffuse' ].value = this.renderTargetMaskBuffer.texture;    renderer.setRenderTarget( this.renderTargetMaskDownSampleBuffer );    renderer.clear();    this.fsQuad.render( renderer );     this.tempPulseColor1.copy( this.visibleEdgeColor );    this.tempPulseColor2.copy( this.hiddenEdgeColor );     if ( this.pulsePeriod > 0 ) {      const scalar = ( 1 + 0.25 ) / 2 + Math.cos( performance.now() * 0.01 / this.pulsePeriod ) * ( 1.0 - 0.25 ) / 2;     this.tempPulseColor1.multiplyScalar( scalar );     this.tempPulseColor2.multiplyScalar( scalar );     }     // 3. Apply Edge Detection Pass    this.fsQuad.material = this.edgeDetectionMaterial;    this.edgeDetectionMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskDownSampleBuffer.texture;    this.edgeDetectionMaterial.uniforms[ 'texSize' ].value.set( this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height );    this.edgeDetectionMaterial.uniforms[ 'visibleEdgeColor' ].value = this.tempPulseColor1;    this.edgeDetectionMaterial.uniforms[ 'hiddenEdgeColor' ].value = this.tempPulseColor2;    renderer.setRenderTarget( this.renderTargetEdgeBuffer1 );    renderer.clear();    this.fsQuad.render( renderer );     // 4. Apply Blur on Half res    this.fsQuad.material = this.separableBlurMaterial1;    this.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;    this.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;    this.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = this.edgeThickness;    renderer.setRenderTarget( this.renderTargetBlurBuffer1 );    renderer.clear();    this.fsQuad.render( renderer );    this.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer1.texture;    this.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;    renderer.setRenderTarget( this.renderTargetEdgeBuffer1 );    renderer.clear();    this.fsQuad.render( renderer );     // Apply Blur on quarter res    this.fsQuad.material = this.separableBlurMaterial2;    this.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;    this.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;    renderer.setRenderTarget( this.renderTargetBlurBuffer2 );    renderer.clear();    this.fsQuad.render( renderer );    this.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer2.texture;    this.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;    renderer.setRenderTarget( this.renderTargetEdgeBuffer2 );    renderer.clear();    this.fsQuad.render( renderer );     // Blend it additively over the input texture    this.fsQuad.material = this.overlayMaterial;    this.overlayMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskBuffer.texture;    this.overlayMaterial.uniforms[ 'edgeTexture1' ].value = this.renderTargetEdgeBuffer1.texture;    this.overlayMaterial.uniforms[ 'edgeTexture2' ].value = this.renderTargetEdgeBuffer2.texture;    this.overlayMaterial.uniforms[ 'patternTexture' ].value = this.patternTexture;    this.overlayMaterial.uniforms[ 'edgeStrength' ].value = this.edgeStrength;    this.overlayMaterial.uniforms[ 'edgeGlow' ].value = this.edgeGlow;    this.overlayMaterial.uniforms[ 'usePatternTexture' ].value = this.usePatternTexture;      if ( maskActive ) renderer.state.buffers.stencil.setTest( true );     renderer.setRenderTarget( readBuffer );    this.fsQuad.render( renderer );     renderer.setClearColor( this._oldClearColor, this.oldClearAlpha );    renderer.autoClear = oldAutoClear;    }    if ( this.renderToScreen ) {     this.fsQuad.material = this.materialCopy;    this.copyUniforms[ 'tDiffuse' ].value = readBuffer.texture;    renderer.setRenderTarget( null );    this.fsQuad.render( renderer );    }   }   getPrepareMaskMaterial() {    return new ShaderMaterial( {     uniforms: {     'depthTexture': { value: null },     'cameraNearFar': { value: new Vector2( 0.5, 0.5 ) },     'textureMatrix': { value: null }    },     vertexShader:     |#include <morphtarget_pars_vertex>     #include <skinning_pars_vertex>      varying vec4 projTexCoord;     varying vec4 vPosition;     uniform mat4 textureMatrix;      void main() {       #include <skinbase_vertex>      #include <begin_vertex>      #include <morphtarget_vertex>      #include <skinning_vertex>      #include <project_vertex>       vPosition = mvPosition;       vec4 worldPosition = vec4( transformed, 1.0 );       #ifdef USE_INSTANCING        worldPosition = instanceMatrix * worldPosition;       #endif       worldPosition = modelMatrix * worldPosition;       projTexCoord = textureMatrix * worldPosition;      }|,     fragmentShader:     |#include <packing>     varying vec4 vPosition;     varying vec4 projTexCoord;     uniform sampler2D depthTexture;     uniform vec2 cameraNearFar;      void main() {       float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));      float viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );      float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;      gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);      }|    } );   }   getEdgeDetectionMaterial() {    return new ShaderMaterial( {     uniforms: {     'maskTexture': { value: null },     'texSize': { value: new Vector2( 0.5, 0.5 ) },     'visibleEdgeColor': { value: new Vector3( 1.0, 1.0, 1.0 ) },     'hiddenEdgeColor': { value: new Vector3( 1.0, 1.0, 1.0 ) },    },     vertexShader:     |varying vec2 vUv;      void main() {      vUv = uv;      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );     }|,     fragmentShader:     |varying vec2 vUv;      uniform sampler2D maskTexture;     uniform vec2 texSize;     uniform vec3 visibleEdgeColor;     uniform vec3 hiddenEdgeColor;      void main() {      vec2 invSize = 1.0 / texSize;      vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);      vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);      vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);      vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);      vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);      float diff1 = (c1.r - c2.r)*0.5;      float diff2 = (c3.r - c4.r)*0.5;      float d = length( vec2(diff1, diff2) );      float a1 = min(c1.g, c2.g);      float a2 = min(c3.g, c4.g);      float visibilityFactor = min(a1, a2);      vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;      gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);     }|   } );   }   getSeperableBlurMaterial( maxRadius ) {    return new ShaderMaterial( {     defines: {     'MAX_RADIUS': maxRadius,    },     uniforms: {     'colorTexture': { value: null },     'texSize': { value: new Vector2( 0.5, 0.5 ) },     'direction': { value: new Vector2( 0.5, 0.5 ) },     'kernelRadius': { value: 1.0 }    },     vertexShader:     |varying vec2 vUv;      void main() {      vUv = uv;      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );     }|,     fragmentShader:     |#include <common>     varying vec2 vUv;     uniform sampler2D colorTexture;     uniform vec2 texSize;     uniform vec2 direction;     uniform float kernelRadius;      float gaussianPdf(in float x, in float sigma) {      return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;     }      void main() {      vec2 invSize = 1.0 / texSize;      float sigma = kernelRadius/2.0;      float weightSum = gaussianPdf(0.0, sigma);      vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;      vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);      vec2 uvOffset = delta;      for( int i = 1; i <= MAX_RADIUS; i ++ ) {       float x = kernelRadius * float(i) / float(MAX_RADIUS);       float w = gaussianPdf(x, sigma);       vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);       vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);       diffuseSum += ((sample1 + sample2) * w);       weightSum += (2.0 * w);       uvOffset += delta;      }      gl_FragColor = diffuseSum/weightSum;     }|   } );   }   getOverlayMaterial() {    return new ShaderMaterial( {     uniforms: {     'maskTexture': { value: null },     'edgeTexture1': { value: null },     'edgeTexture2': { value: null },     'patternTexture': { value: null },     'edgeStrength': { value: 1.0 },     'edgeGlow': { value: 1.0 },     'usePatternTexture': { value: 0.0 }    },     vertexShader:     |varying vec2 vUv;      void main() {      vUv = uv;      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );     }|,     fragmentShader:     |varying vec2 vUv;      uniform sampler2D maskTexture;     uniform sampler2D edgeTexture1;     uniform sampler2D edgeTexture2;     uniform sampler2D patternTexture;     uniform float edgeStrength;     uniform float edgeGlow;     uniform bool usePatternTexture;      void main() {      vec4 edgeValue1 = texture2D(edgeTexture1, vUv);      vec4 edgeValue2 = texture2D(edgeTexture2, vUv);      vec4 maskColor = texture2D(maskTexture, vUv);      vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);      float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;      vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;      vec4 finalColor = edgeStrength * maskColor.r * edgeValue;      if(usePatternTexture)       finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);      gl_FragColor = finalColor;     }|,    blending: AdditiveBlending,    depthTest: false,    depthWrite: false,    transparent: true   } );   }  }  OutlinePass.BlurDirectionX = new Vector2( 1.0, 0.0 ); OutlinePass.BlurDirectionY = new Vector2( 0.0, 1.0 );  export { OutlinePass }; 
^..^ FILENAME ^..^
addons|postprocessing|OutputPass.js
^..^ CONTENTS ^..^
import {  ColorManagement,  RawShaderMaterial,  UniformsUtils,  LinearToneMapping,  ReinhardToneMapping,  CineonToneMapping,  AgXToneMapping,  ACESFilmicToneMapping,  NeutralToneMapping,  SRGBTransfer } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { OutputShader } from '../shaders/OutputShader.js';  class OutputPass extends Pass {   constructor() {    super();    //    const shader = OutputShader;    this.uniforms = UniformsUtils.clone( shader.uniforms );    this.material = new RawShaderMaterial( {    name: shader.name,    uniforms: this.uniforms,    vertexShader: shader.vertexShader,    fragmentShader: shader.fragmentShader   } );    this.fsQuad = new FullScreenQuad( this.material );    // internal cache    this._outputColorSpace = null;   this._toneMapping = null;   }   render( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive */ ) {    this.uniforms[ 'tDiffuse' ].value = readBuffer.texture;   this.uniforms[ 'toneMappingExposure' ].value = renderer.toneMappingExposure;    // rebuild defines if required    if ( this._outputColorSpace !== renderer.outputColorSpace || this._toneMapping !== renderer.toneMapping ) {     this._outputColorSpace = renderer.outputColorSpace;    this._toneMapping = renderer.toneMapping;     this.material.defines = {};     if ( ColorManagement.getTransfer( this._outputColorSpace ) === SRGBTransfer ) this.material.defines.SRGB_TRANSFER = '';     if ( this._toneMapping === LinearToneMapping ) this.material.defines.LINEAR_TONE_MAPPING = '';    else if ( this._toneMapping === ReinhardToneMapping ) this.material.defines.REINHARD_TONE_MAPPING = '';    else if ( this._toneMapping === CineonToneMapping ) this.material.defines.CINEON_TONE_MAPPING = '';    else if ( this._toneMapping === ACESFilmicToneMapping ) this.material.defines.ACES_FILMIC_TONE_MAPPING = '';    else if ( this._toneMapping === AgXToneMapping ) this.material.defines.AGX_TONE_MAPPING = '';    else if ( this._toneMapping === NeutralToneMapping ) this.material.defines.NEUTRAL_TONE_MAPPING = '';     this.material.needsUpdate = true;    }    //    if ( this.renderToScreen === true ) {     renderer.setRenderTarget( null );    this.fsQuad.render( renderer );    } else {     renderer.setRenderTarget( writeBuffer );    if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );    this.fsQuad.render( renderer );    }   }   dispose() {    this.material.dispose();   this.fsQuad.dispose();   }  }  export { OutputPass }; 
^..^ FILENAME ^..^
addons|postprocessing|Pass.js
^..^ CONTENTS ^..^
import {  BufferGeometry,  Float32BufferAttribute,  OrthographicCamera,  Mesh } from 'three';  class Pass {   constructor() {    this.isPass = true;    // if set to true, the pass is processed by the composer   this.enabled = true;    // if set to true, the pass indicates to swap read and write buffer after rendering   this.needsSwap = true;    // if set to true, the pass clears its buffer before rendering   this.clear = false;    // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.   this.renderToScreen = false;   }   setSize( /* width, height */ ) {}   render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {    console.error( 'THREE.Pass: .render() must be implemented in derived pass.' );   }   dispose() {}  }  // Helper for passes that need to fill the viewport with a single quad.  const _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );  // https://github.com/mrdoob/three.js/pull/21358  class FullscreenTriangleGeometry extends BufferGeometry {   constructor() {    super();    this.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );   this.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );   }  }  const _geometry = new FullscreenTriangleGeometry();  class FullScreenQuad {   constructor( material ) {    this._mesh = new Mesh( _geometry, material );   }   dispose() {    this._mesh.geometry.dispose();   }   render( renderer ) {    renderer.render( this._mesh, _camera );   }   get material() {    return this._mesh.material;   }   set material( value ) {    this._mesh.material = value;   }  }  export { Pass, FullScreenQuad }; 
^..^ FILENAME ^..^
addons|postprocessing|RenderPass.js
^..^ CONTENTS ^..^
import {  Color } from 'three'; import { Pass } from './Pass.js';  class RenderPass extends Pass {   constructor( scene, camera, overrideMaterial = null, clearColor = null, clearAlpha = null ) {    super();    this.scene = scene;   this.camera = camera;    this.overrideMaterial = overrideMaterial;    this.clearColor = clearColor;   this.clearAlpha = clearAlpha;    this.clear = true;   this.clearDepth = false;   this.needsSwap = false;   this._oldClearColor = new Color();   }   render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {    const oldAutoClear = renderer.autoClear;   renderer.autoClear = false;    let oldClearAlpha, oldOverrideMaterial;    if ( this.overrideMaterial !== null ) {     oldOverrideMaterial = this.scene.overrideMaterial;     this.scene.overrideMaterial = this.overrideMaterial;    }    if ( this.clearColor !== null ) {     renderer.getClearColor( this._oldClearColor );    renderer.setClearColor( this.clearColor, renderer.getClearAlpha() );    }    if ( this.clearAlpha !== null ) {     oldClearAlpha = renderer.getClearAlpha();    renderer.setClearAlpha( this.clearAlpha );    }    if ( this.clearDepth == true ) {     renderer.clearDepth();    }    renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );    if ( this.clear === true ) {     // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600    renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );    }    renderer.render( this.scene, this.camera );    // restore    if ( this.clearColor !== null ) {     renderer.setClearColor( this._oldClearColor );    }    if ( this.clearAlpha !== null ) {     renderer.setClearAlpha( oldClearAlpha );    }    if ( this.overrideMaterial !== null ) {     this.scene.overrideMaterial = oldOverrideMaterial;    }    renderer.autoClear = oldAutoClear;   }  }  export { RenderPass }; 
^..^ FILENAME ^..^
addons|postprocessing|RenderPixelatedPass.js
^..^ CONTENTS ^..^
import {  WebGLRenderTarget,  MeshNormalMaterial,  ShaderMaterial,  Vector2,  Vector4,  DepthTexture,  NearestFilter,  HalfFloatType } from 'three'; import { Pass, FullScreenQuad } from './Pass.js';  class RenderPixelatedPass extends Pass {   constructor( pixelSize, scene, camera, options = {} ) {    super();    this.pixelSize = pixelSize;   this.resolution = new Vector2();   this.renderResolution = new Vector2();    this.pixelatedMaterial = this.createPixelatedMaterial();   this.normalMaterial = new MeshNormalMaterial();    this.fsQuad = new FullScreenQuad( this.pixelatedMaterial );   this.scene = scene;   this.camera = camera;    this.normalEdgeStrength = options.normalEdgeStrength || 0.3;   this.depthEdgeStrength = options.depthEdgeStrength || 0.4;    this.beautyRenderTarget = new WebGLRenderTarget();   this.beautyRenderTarget.texture.minFilter = NearestFilter;   this.beautyRenderTarget.texture.magFilter = NearestFilter;   this.beautyRenderTarget.texture.type = HalfFloatType;   this.beautyRenderTarget.depthTexture = new DepthTexture();    this.normalRenderTarget = new WebGLRenderTarget();   this.normalRenderTarget.texture.minFilter = NearestFilter;   this.normalRenderTarget.texture.magFilter = NearestFilter;   this.normalRenderTarget.texture.type = HalfFloatType;   }   dispose() {    this.beautyRenderTarget.dispose();   this.normalRenderTarget.dispose();    this.pixelatedMaterial.dispose();   this.normalMaterial.dispose();    this.fsQuad.dispose();   }   setSize( width, height ) {    this.resolution.set( width, height );   this.renderResolution.set( ( width / this.pixelSize ) | 0, ( height / this.pixelSize ) | 0 );   const { x, y } = this.renderResolution;   this.beautyRenderTarget.setSize( x, y );   this.normalRenderTarget.setSize( x, y );   this.fsQuad.material.uniforms.resolution.value.set( x, y, 1 / x, 1 / y );   }   setPixelSize( pixelSize ) {    this.pixelSize = pixelSize;   this.setSize( this.resolution.x, this.resolution.y );   }   render( renderer, writeBuffer ) {    const uniforms = this.fsQuad.material.uniforms;   uniforms.normalEdgeStrength.value = this.normalEdgeStrength;   uniforms.depthEdgeStrength.value = this.depthEdgeStrength;    renderer.setRenderTarget( this.beautyRenderTarget );   renderer.render( this.scene, this.camera );    const overrideMaterial_old = this.scene.overrideMaterial;   renderer.setRenderTarget( this.normalRenderTarget );   this.scene.overrideMaterial = this.normalMaterial;   renderer.render( this.scene, this.camera );   this.scene.overrideMaterial = overrideMaterial_old;    uniforms.tDiffuse.value = this.beautyRenderTarget.texture;   uniforms.tDepth.value = this.beautyRenderTarget.depthTexture;   uniforms.tNormal.value = this.normalRenderTarget.texture;    if ( this.renderToScreen ) {     renderer.setRenderTarget( null );    } else {     renderer.setRenderTarget( writeBuffer );     if ( this.clear ) renderer.clear();    }    this.fsQuad.render( renderer );   }   createPixelatedMaterial() {    return new ShaderMaterial( {    uniforms: {     tDiffuse: { value: null },     tDepth: { value: null },     tNormal: { value: null },     resolution: {      value: new Vector4(       this.renderResolution.x,       this.renderResolution.y,       1 / this.renderResolution.x,       1 / this.renderResolution.y,      )     },     normalEdgeStrength: { value: 0 },     depthEdgeStrength: { value: 0 }    },    vertexShader: /* glsl */|     varying vec2 vUv;      void main() {       vUv = uv;      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );      }    |,    fragmentShader: /* glsl */|     uniform sampler2D tDiffuse;     uniform sampler2D tDepth;     uniform sampler2D tNormal;     uniform vec4 resolution;     uniform float normalEdgeStrength;     uniform float depthEdgeStrength;     varying vec2 vUv;      float getDepth(int x, int y) {       return texture2D( tDepth, vUv + vec2(x, y) * resolution.zw ).r;      }      vec3 getNormal(int x, int y) {       return texture2D( tNormal, vUv + vec2(x, y) * resolution.zw ).rgb * 2.0 - 1.0;      }      float depthEdgeIndicator(float depth, vec3 normal) {       float diff = 0.0;      diff += clamp(getDepth(1, 0) - depth, 0.0, 1.0);      diff += clamp(getDepth(-1, 0) - depth, 0.0, 1.0);      diff += clamp(getDepth(0, 1) - depth, 0.0, 1.0);      diff += clamp(getDepth(0, -1) - depth, 0.0, 1.0);      return floor(smoothstep(0.01, 0.02, diff) * 2.) / 2.;      }      float neighborNormalEdgeIndicator(int x, int y, float depth, vec3 normal) {       float depthDiff = getDepth(x, y) - depth;      vec3 neighborNormal = getNormal(x, y);       // Edge pixels should yield to faces who's normals are closer to the bias normal.      vec3 normalEdgeBias = vec3(1., 1., 1.); // This should probably be a parameter.      float normalDiff = dot(normal - neighborNormal, normalEdgeBias);      float normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);       // Only the shallower pixel should detect the normal edge.      float depthIndicator = clamp(sign(depthDiff * .25 + .0025), 0.0, 1.0);       return (1.0 - dot(normal, neighborNormal)) * depthIndicator * normalIndicator;      }      float normalEdgeIndicator(float depth, vec3 normal) {       float indicator = 0.0;       indicator += neighborNormalEdgeIndicator(0, -1, depth, normal);      indicator += neighborNormalEdgeIndicator(0, 1, depth, normal);      indicator += neighborNormalEdgeIndicator(-1, 0, depth, normal);      indicator += neighborNormalEdgeIndicator(1, 0, depth, normal);       return step(0.1, indicator);      }      void main() {       vec4 texel = texture2D( tDiffuse, vUv );       float depth = 0.0;      vec3 normal = vec3(0.0);       if (depthEdgeStrength > 0.0 || normalEdgeStrength > 0.0) {        depth = getDepth(0, 0);       normal = getNormal(0, 0);       }       float dei = 0.0;      if (depthEdgeStrength > 0.0)       dei = depthEdgeIndicator(depth, normal);       float nei = 0.0;      if (normalEdgeStrength > 0.0)       nei = normalEdgeIndicator(depth, normal);       float Strength = dei > 0.0 ? (1.0 - depthEdgeStrength * dei) : (1.0 + normalEdgeStrength * nei);       gl_FragColor = texel * Strength;      }    |   } );   }  }  export { RenderPixelatedPass }; 
^..^ FILENAME ^..^
addons|postprocessing|RenderTransitionPass.js
^..^ CONTENTS ^..^
import {  HalfFloatType,  ShaderMaterial,  WebGLRenderTarget } from 'three'; import { FullScreenQuad, Pass } from './Pass.js';  class RenderTransitionPass extends Pass {   constructor( sceneA, cameraA, sceneB, cameraB ) {    super();    this.material = this.createMaterial();   this.fsQuad = new FullScreenQuad( this.material );    this.sceneA = sceneA;   this.cameraA = cameraA;   this.sceneB = sceneB;   this.cameraB = cameraB;    this.renderTargetA = new WebGLRenderTarget();   this.renderTargetA.texture.type = HalfFloatType;   this.renderTargetB = new WebGLRenderTarget();   this.renderTargetB.texture.type = HalfFloatType;   }   setTransition( value ) {    this.material.uniforms.mixRatio.value = value;   }   useTexture( value ) {    this.material.uniforms.useTexture.value = value ? 1 : 0;   }   setTexture( value ) {    this.material.uniforms.tMixTexture.value = value;   }   setTextureThreshold( value ) {    this.material.uniforms.threshold.value = value;   }   setSize( width, height ) {    this.renderTargetA.setSize( width, height );   this.renderTargetB.setSize( width, height );   }   render( renderer, writeBuffer ) {    renderer.setRenderTarget( this.renderTargetA );   renderer.render( this.sceneA, this.cameraA );   renderer.setRenderTarget( this.renderTargetB );   renderer.render( this.sceneB, this.cameraB );    const uniforms = this.fsQuad.material.uniforms;   uniforms.tDiffuse1.value = this.renderTargetA.texture;   uniforms.tDiffuse2.value = this.renderTargetB.texture;    if ( this.renderToScreen ) {     renderer.setRenderTarget( null );    renderer.clear();    } else {     renderer.setRenderTarget( writeBuffer );    if ( this.clear ) renderer.clear();    }    this.fsQuad.render( renderer );   }   dispose() {    this.renderTargetA.dispose();   this.renderTargetB.dispose();   this.material.dispose();   this.fsQuad.dispose();   }   createMaterial() {    return new ShaderMaterial( {    uniforms: {     tDiffuse1: {      value: null     },     tDiffuse2: {      value: null     },     mixRatio: {      value: 0.0     },     threshold: {      value: 0.1     },     useTexture: {      value: 1     },     tMixTexture: {      value: null     }    },    vertexShader: /* glsl */|     varying vec2 vUv;      void main() {       vUv = vec2( uv.x, uv.y );      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );      }    |,    fragmentShader: /* glsl */|     uniform float mixRatio;      uniform sampler2D tDiffuse1;     uniform sampler2D tDiffuse2;     uniform sampler2D tMixTexture;      uniform int useTexture;     uniform float threshold;      varying vec2 vUv;      void main() {       vec4 texel1 = texture2D( tDiffuse1, vUv );      vec4 texel2 = texture2D( tDiffuse2, vUv );       if (useTexture == 1) {        vec4 transitionTexel = texture2D( tMixTexture, vUv );       float r = mixRatio * ( 1.0 + threshold * 2.0 ) - threshold;       float mixf = clamp( ( transitionTexel.r - r ) * ( 1.0 / threshold ), 0.0, 1.0 );        gl_FragColor = mix( texel1, texel2, mixf );       } else {        gl_FragColor = mix( texel2, texel1, mixRatio );       }      }    |   } );   }  }  export { RenderTransitionPass }; 
^..^ FILENAME ^..^
addons|postprocessing|SAOPass.js
^..^ CONTENTS ^..^
import {  AddEquation,  Color,  CustomBlending,  DepthTexture,  DstAlphaFactor,  DstColorFactor,  HalfFloatType,  MeshNormalMaterial,  NearestFilter,  NoBlending,  ShaderMaterial,  UniformsUtils,  DepthStencilFormat,  UnsignedInt248Type,  Vector2,  WebGLRenderTarget,  ZeroFactor } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { SAOShader } from '../shaders/SAOShader.js'; import { DepthLimitedBlurShader } from '../shaders/DepthLimitedBlurShader.js'; import { BlurShaderUtils } from '../shaders/DepthLimitedBlurShader.js'; import { CopyShader } from '../shaders/CopyShader.js';  /**  * SAO implementation inspired from bhouston previous SAO work  */  class SAOPass extends Pass {   constructor( scene, camera, resolution = new Vector2( 256, 256 ) ) {    super();    this.scene = scene;   this.camera = camera;    this.clear = true;   this.needsSwap = false;    this.originalClearColor = new Color();   this._oldClearColor = new Color();   this.oldClearAlpha = 1;    this.params = {    output: 0,    saoBias: 0.5,    saoIntensity: 0.18,    saoScale: 1,    saoKernelRadius: 100,    saoMinResolution: 0,    saoBlur: true,    saoBlurRadius: 8,    saoBlurStdDev: 4,    saoBlurDepthCutoff: 0.01   };    this.resolution = new Vector2( resolution.x, resolution.y );    this.saoRenderTarget = new WebGLRenderTarget( this.resolution.x, this.resolution.y, { type: HalfFloatType } );   this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();    const depthTexture = new DepthTexture();   depthTexture.format = DepthStencilFormat;   depthTexture.type = UnsignedInt248Type;    this.normalRenderTarget = new WebGLRenderTarget( this.resolution.x, this.resolution.y, {    minFilter: NearestFilter,    magFilter: NearestFilter,    type: HalfFloatType,    depthTexture: depthTexture   } );    this.normalMaterial = new MeshNormalMaterial();   this.normalMaterial.blending = NoBlending;    this.saoMaterial = new ShaderMaterial( {    defines: Object.assign( {}, SAOShader.defines ),    fragmentShader: SAOShader.fragmentShader,    vertexShader: SAOShader.vertexShader,    uniforms: UniformsUtils.clone( SAOShader.uniforms )   } );   this.saoMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;   this.saoMaterial.uniforms[ 'tDepth' ].value = depthTexture;   this.saoMaterial.uniforms[ 'tNormal' ].value = this.normalRenderTarget.texture;   this.saoMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );   this.saoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.copy( this.camera.projectionMatrixInverse );   this.saoMaterial.uniforms[ 'cameraProjectionMatrix' ].value = this.camera.projectionMatrix;   this.saoMaterial.blending = NoBlending;    this.vBlurMaterial = new ShaderMaterial( {    uniforms: UniformsUtils.clone( DepthLimitedBlurShader.uniforms ),    defines: Object.assign( {}, DepthLimitedBlurShader.defines ),    vertexShader: DepthLimitedBlurShader.vertexShader,    fragmentShader: DepthLimitedBlurShader.fragmentShader   } );   this.vBlurMaterial.defines[ 'DEPTH_PACKING' ] = 0;   this.vBlurMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;   this.vBlurMaterial.uniforms[ 'tDiffuse' ].value = this.saoRenderTarget.texture;   this.vBlurMaterial.uniforms[ 'tDepth' ].value = depthTexture;   this.vBlurMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );   this.vBlurMaterial.blending = NoBlending;    this.hBlurMaterial = new ShaderMaterial( {    uniforms: UniformsUtils.clone( DepthLimitedBlurShader.uniforms ),    defines: Object.assign( {}, DepthLimitedBlurShader.defines ),    vertexShader: DepthLimitedBlurShader.vertexShader,    fragmentShader: DepthLimitedBlurShader.fragmentShader   } );   this.hBlurMaterial.defines[ 'DEPTH_PACKING' ] = 0;   this.hBlurMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;   this.hBlurMaterial.uniforms[ 'tDiffuse' ].value = this.blurIntermediateRenderTarget.texture;   this.hBlurMaterial.uniforms[ 'tDepth' ].value = depthTexture;   this.hBlurMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );   this.hBlurMaterial.blending = NoBlending;    this.materialCopy = new ShaderMaterial( {    uniforms: UniformsUtils.clone( CopyShader.uniforms ),    vertexShader: CopyShader.vertexShader,    fragmentShader: CopyShader.fragmentShader,    blending: NoBlending   } );   this.materialCopy.transparent = true;   this.materialCopy.depthTest = false;   this.materialCopy.depthWrite = false;   this.materialCopy.blending = CustomBlending;   this.materialCopy.blendSrc = DstColorFactor;   this.materialCopy.blendDst = ZeroFactor;   this.materialCopy.blendEquation = AddEquation;   this.materialCopy.blendSrcAlpha = DstAlphaFactor;   this.materialCopy.blendDstAlpha = ZeroFactor;   this.materialCopy.blendEquationAlpha = AddEquation;    this.fsQuad = new FullScreenQuad( null );   }   render( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {    // Rendering readBuffer first when rendering to screen   if ( this.renderToScreen ) {     this.materialCopy.blending = NoBlending;    this.materialCopy.uniforms[ 'tDiffuse' ].value = readBuffer.texture;    this.materialCopy.needsUpdate = true;    this.renderPass( renderer, this.materialCopy, null );    }    renderer.getClearColor( this._oldClearColor );   this.oldClearAlpha = renderer.getClearAlpha();   const oldAutoClear = renderer.autoClear;   renderer.autoClear = false;    this.saoMaterial.uniforms[ 'bias' ].value = this.params.saoBias;   this.saoMaterial.uniforms[ 'intensity' ].value = this.params.saoIntensity;   this.saoMaterial.uniforms[ 'scale' ].value = this.params.saoScale;   this.saoMaterial.uniforms[ 'kernelRadius' ].value = this.params.saoKernelRadius;   this.saoMaterial.uniforms[ 'minResolution' ].value = this.params.saoMinResolution;   this.saoMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;   this.saoMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;   // this.saoMaterial.uniforms['randomSeed'].value = Math.random();    const depthCutoff = this.params.saoBlurDepthCutoff * ( this.camera.far - this.camera.near );   this.vBlurMaterial.uniforms[ 'depthCutoff' ].value = depthCutoff;   this.hBlurMaterial.uniforms[ 'depthCutoff' ].value = depthCutoff;    this.vBlurMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;   this.vBlurMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;   this.hBlurMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;   this.hBlurMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;    this.params.saoBlurRadius = Math.floor( this.params.saoBlurRadius );   if ( ( this.prevStdDev !== this.params.saoBlurStdDev ) || ( this.prevNumSamples !== this.params.saoBlurRadius ) ) {     BlurShaderUtils.configure( this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2( 0, 1 ) );    BlurShaderUtils.configure( this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2( 1, 0 ) );    this.prevStdDev = this.params.saoBlurStdDev;    this.prevNumSamples = this.params.saoBlurRadius;    }    // render normal and depth   this.renderOverride( renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0 );    // Rendering SAO texture   this.renderPass( renderer, this.saoMaterial, this.saoRenderTarget, 0xffffff, 1.0 );    // Blurring SAO texture   if ( this.params.saoBlur ) {     this.renderPass( renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 0xffffff, 1.0 );    this.renderPass( renderer, this.hBlurMaterial, this.saoRenderTarget, 0xffffff, 1.0 );    }    const outputMaterial = this.materialCopy;    // Setting up SAO rendering   if ( this.params.output === SAOPass.OUTPUT.Normal ) {     this.materialCopy.uniforms[ 'tDiffuse' ].value = this.normalRenderTarget.texture;    this.materialCopy.needsUpdate = true;    } else {     this.materialCopy.uniforms[ 'tDiffuse' ].value = this.saoRenderTarget.texture;    this.materialCopy.needsUpdate = true;    }    // Blending depends on output   if ( this.params.output === SAOPass.OUTPUT.Default ) {     outputMaterial.blending = CustomBlending;    } else {     outputMaterial.blending = NoBlending;    }    // Rendering SAOPass result on top of previous pass   this.renderPass( renderer, outputMaterial, this.renderToScreen ? null : readBuffer );    renderer.setClearColor( this._oldClearColor, this.oldClearAlpha );   renderer.autoClear = oldAutoClear;   }   renderPass( renderer, passMaterial, renderTarget, clearColor, clearAlpha ) {    // save original state   renderer.getClearColor( this.originalClearColor );   const originalClearAlpha = renderer.getClearAlpha();   const originalAutoClear = renderer.autoClear;    renderer.setRenderTarget( renderTarget );    // setup pass state   renderer.autoClear = false;   if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {     renderer.setClearColor( clearColor );    renderer.setClearAlpha( clearAlpha || 0.0 );    renderer.clear();    }    this.fsQuad.material = passMaterial;   this.fsQuad.render( renderer );    // restore original state   renderer.autoClear = originalAutoClear;   renderer.setClearColor( this.originalClearColor );   renderer.setClearAlpha( originalClearAlpha );   }   renderOverride( renderer, overrideMaterial, renderTarget, clearColor, clearAlpha ) {    renderer.getClearColor( this.originalClearColor );   const originalClearAlpha = renderer.getClearAlpha();   const originalAutoClear = renderer.autoClear;    renderer.setRenderTarget( renderTarget );   renderer.autoClear = false;    clearColor = overrideMaterial.clearColor || clearColor;   clearAlpha = overrideMaterial.clearAlpha || clearAlpha;   if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {     renderer.setClearColor( clearColor );    renderer.setClearAlpha( clearAlpha || 0.0 );    renderer.clear();    }    this.scene.overrideMaterial = overrideMaterial;   renderer.render( this.scene, this.camera );   this.scene.overrideMaterial = null;    // restore original state   renderer.autoClear = originalAutoClear;   renderer.setClearColor( this.originalClearColor );   renderer.setClearAlpha( originalClearAlpha );   }   setSize( width, height ) {    this.saoRenderTarget.setSize( width, height );   this.blurIntermediateRenderTarget.setSize( width, height );   this.normalRenderTarget.setSize( width, height );    this.saoMaterial.uniforms[ 'size' ].value.set( width, height );   this.saoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.copy( this.camera.projectionMatrixInverse );   this.saoMaterial.uniforms[ 'cameraProjectionMatrix' ].value = this.camera.projectionMatrix;   this.saoMaterial.needsUpdate = true;    this.vBlurMaterial.uniforms[ 'size' ].value.set( width, height );   this.vBlurMaterial.needsUpdate = true;    this.hBlurMaterial.uniforms[ 'size' ].value.set( width, height );   this.hBlurMaterial.needsUpdate = true;   }   dispose() {    this.saoRenderTarget.dispose();   this.blurIntermediateRenderTarget.dispose();   this.normalRenderTarget.dispose();    this.normalMaterial.dispose();   this.saoMaterial.dispose();   this.vBlurMaterial.dispose();   this.hBlurMaterial.dispose();   this.materialCopy.dispose();    this.fsQuad.dispose();   }  }  SAOPass.OUTPUT = {  'Default': 0,  'SAO': 1,  'Normal': 2 };  export { SAOPass }; 
^..^ FILENAME ^..^
addons|postprocessing|SavePass.js
^..^ CONTENTS ^..^
import {  HalfFloatType,  NoBlending,  ShaderMaterial,  UniformsUtils,  WebGLRenderTarget } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { CopyShader } from '../shaders/CopyShader.js';  class SavePass extends Pass {   constructor( renderTarget ) {    super();    const shader = CopyShader;    this.textureID = 'tDiffuse';    this.uniforms = UniformsUtils.clone( shader.uniforms );    this.material = new ShaderMaterial( {     uniforms: this.uniforms,    vertexShader: shader.vertexShader,    fragmentShader: shader.fragmentShader,    blending: NoBlending    } );    this.renderTarget = renderTarget;    if ( this.renderTarget === undefined ) {     this.renderTarget = new WebGLRenderTarget( 1, 1, { type: HalfFloatType } ); // will be resized later    this.renderTarget.texture.name = 'SavePass.rt';    }    this.needsSwap = false;    this.fsQuad = new FullScreenQuad( this.material );   }   render( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive */ ) {    if ( this.uniforms[ this.textureID ] ) {     this.uniforms[ this.textureID ].value = readBuffer.texture;    }    renderer.setRenderTarget( this.renderTarget );   if ( this.clear ) renderer.clear();   this.fsQuad.render( renderer );   }   setSize( width, height ) {    this.renderTarget.setSize( width, height );   }   dispose() {    this.renderTarget.dispose();    this.material.dispose();    this.fsQuad.dispose();   }  }  export { SavePass }; 
^..^ FILENAME ^..^
addons|postprocessing|ShaderPass.js
^..^ CONTENTS ^..^
import {  ShaderMaterial,  UniformsUtils } from 'three'; import { Pass, FullScreenQuad } from './Pass.js';  class ShaderPass extends Pass {   constructor( shader, textureID ) {    super();    this.textureID = ( textureID !== undefined ) ? textureID : 'tDiffuse';    if ( shader instanceof ShaderMaterial ) {     this.uniforms = shader.uniforms;     this.material = shader;    } else if ( shader ) {     this.uniforms = UniformsUtils.clone( shader.uniforms );     this.material = new ShaderMaterial( {      name: ( shader.name !== undefined ) ? shader.name : 'unspecified',     defines: Object.assign( {}, shader.defines ),     uniforms: this.uniforms,     vertexShader: shader.vertexShader,     fragmentShader: shader.fragmentShader     } );    }    this.fsQuad = new FullScreenQuad( this.material );   }   render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {    if ( this.uniforms[ this.textureID ] ) {     this.uniforms[ this.textureID ].value = readBuffer.texture;    }    this.fsQuad.material = this.material;    if ( this.renderToScreen ) {     renderer.setRenderTarget( null );    this.fsQuad.render( renderer );    } else {     renderer.setRenderTarget( writeBuffer );    // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600    if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );    this.fsQuad.render( renderer );    }   }   dispose() {    this.material.dispose();    this.fsQuad.dispose();   }  }  export { ShaderPass }; 
^..^ FILENAME ^..^
addons|postprocessing|SMAAPass.js
^..^ CONTENTS ^..^
import {  HalfFloatType,  LinearFilter,  NearestFilter,  ShaderMaterial,  Texture,  UniformsUtils,  WebGLRenderTarget } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { SMAAEdgesShader } from '../shaders/SMAAShader.js'; import { SMAAWeightsShader } from '../shaders/SMAAShader.js'; import { SMAABlendShader } from '../shaders/SMAAShader.js';  class SMAAPass extends Pass {   constructor( width, height ) {    super();    // render targets    this.edgesRT = new WebGLRenderTarget( width, height, {    depthBuffer: false,    type: HalfFloatType   } );   this.edgesRT.texture.name = 'SMAAPass.edges';    this.weightsRT = new WebGLRenderTarget( width, height, {    depthBuffer: false,    type: HalfFloatType   } );   this.weightsRT.texture.name = 'SMAAPass.weights';    // textures   const scope = this;    const areaTextureImage = new Image();   areaTextureImage.src = this.getAreaTexture();   areaTextureImage.onload = function () {     // assigning data to HTMLImageElement.src is asynchronous (see #15162)    scope.areaTexture.needsUpdate = true;    };    this.areaTexture = new Texture();   this.areaTexture.name = 'SMAAPass.area';   this.areaTexture.image = areaTextureImage;   this.areaTexture.minFilter = LinearFilter;   this.areaTexture.generateMipmaps = false;   this.areaTexture.flipY = false;    const searchTextureImage = new Image();   searchTextureImage.src = this.getSearchTexture();   searchTextureImage.onload = function () {     // assigning data to HTMLImageElement.src is asynchronous (see #15162)    scope.searchTexture.needsUpdate = true;    };    this.searchTexture = new Texture();   this.searchTexture.name = 'SMAAPass.search';   this.searchTexture.image = searchTextureImage;   this.searchTexture.magFilter = NearestFilter;   this.searchTexture.minFilter = NearestFilter;   this.searchTexture.generateMipmaps = false;   this.searchTexture.flipY = false;    // materials - pass 1    this.uniformsEdges = UniformsUtils.clone( SMAAEdgesShader.uniforms );    this.uniformsEdges[ 'resolution' ].value.set( 1 / width, 1 / height );    this.materialEdges = new ShaderMaterial( {    defines: Object.assign( {}, SMAAEdgesShader.defines ),    uniforms: this.uniformsEdges,    vertexShader: SMAAEdgesShader.vertexShader,    fragmentShader: SMAAEdgesShader.fragmentShader   } );    // materials - pass 2    this.uniformsWeights = UniformsUtils.clone( SMAAWeightsShader.uniforms );    this.uniformsWeights[ 'resolution' ].value.set( 1 / width, 1 / height );   this.uniformsWeights[ 'tDiffuse' ].value = this.edgesRT.texture;   this.uniformsWeights[ 'tArea' ].value = this.areaTexture;   this.uniformsWeights[ 'tSearch' ].value = this.searchTexture;    this.materialWeights = new ShaderMaterial( {    defines: Object.assign( {}, SMAAWeightsShader.defines ),    uniforms: this.uniformsWeights,    vertexShader: SMAAWeightsShader.vertexShader,    fragmentShader: SMAAWeightsShader.fragmentShader   } );    // materials - pass 3    this.uniformsBlend = UniformsUtils.clone( SMAABlendShader.uniforms );    this.uniformsBlend[ 'resolution' ].value.set( 1 / width, 1 / height );   this.uniformsBlend[ 'tDiffuse' ].value = this.weightsRT.texture;    this.materialBlend = new ShaderMaterial( {    uniforms: this.uniformsBlend,    vertexShader: SMAABlendShader.vertexShader,    fragmentShader: SMAABlendShader.fragmentShader   } );    this.fsQuad = new FullScreenQuad( null );   }   render( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {    // pass 1    this.uniformsEdges[ 'tDiffuse' ].value = readBuffer.texture;    this.fsQuad.material = this.materialEdges;    renderer.setRenderTarget( this.edgesRT );   if ( this.clear ) renderer.clear();   this.fsQuad.render( renderer );    // pass 2    this.fsQuad.material = this.materialWeights;    renderer.setRenderTarget( this.weightsRT );   if ( this.clear ) renderer.clear();   this.fsQuad.render( renderer );    // pass 3    this.uniformsBlend[ 'tColor' ].value = readBuffer.texture;    this.fsQuad.material = this.materialBlend;    if ( this.renderToScreen ) {     renderer.setRenderTarget( null );    this.fsQuad.render( renderer );    } else {     renderer.setRenderTarget( writeBuffer );    if ( this.clear ) renderer.clear();    this.fsQuad.render( renderer );    }   }   setSize( width, height ) {    this.edgesRT.setSize( width, height );   this.weightsRT.setSize( width, height );    this.materialEdges.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );   this.materialWeights.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );   this.materialBlend.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );   }   getAreaTexture() {    return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=';   }   getSearchTexture() {    return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=';   }   dispose() {    this.edgesRT.dispose();   this.weightsRT.dispose();    this.areaTexture.dispose();   this.searchTexture.dispose();    this.materialEdges.dispose();   this.materialWeights.dispose();   this.materialBlend.dispose();    this.fsQuad.dispose();   }  }  export { SMAAPass }; 
^..^ FILENAME ^..^
addons|postprocessing|SSAARenderPass.js
^..^ CONTENTS ^..^
import {  AdditiveBlending,  Color,  HalfFloatType,  ShaderMaterial,  UniformsUtils,  WebGLRenderTarget } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { CopyShader } from '../shaders/CopyShader.js';  /** * * Supersample Anti-Aliasing Render Pass * * This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results. * * References: https://en.wikipedia.org/wiki/Supersampling * */  class SSAARenderPass extends Pass {   constructor( scene, camera, clearColor, clearAlpha ) {    super();    this.scene = scene;   this.camera = camera;    this.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.   this.unbiased = true;    this.stencilBuffer = false;    // as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.   this.clearColor = ( clearColor !== undefined ) ? clearColor : 0x000000;   this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;   this._oldClearColor = new Color();    const copyShader = CopyShader;   this.copyUniforms = UniformsUtils.clone( copyShader.uniforms );    this.copyMaterial = new ShaderMaterial( {    uniforms: this.copyUniforms,    vertexShader: copyShader.vertexShader,    fragmentShader: copyShader.fragmentShader,    transparent: true,    depthTest: false,    depthWrite: false,    premultipliedAlpha: true,    blending: AdditiveBlending   } );    this.fsQuad = new FullScreenQuad( this.copyMaterial );   }   dispose() {    if ( this.sampleRenderTarget ) {     this.sampleRenderTarget.dispose();    this.sampleRenderTarget = null;    }    this.copyMaterial.dispose();    this.fsQuad.dispose();   }   setSize( width, height ) {    if ( this.sampleRenderTarget ) this.sampleRenderTarget.setSize( width, height );   }   render( renderer, writeBuffer, readBuffer ) {    if ( ! this.sampleRenderTarget ) {     this.sampleRenderTarget = new WebGLRenderTarget( readBuffer.width, readBuffer.height, { type: HalfFloatType, stencilBuffer: this.stencilBuffer } );    this.sampleRenderTarget.texture.name = 'SSAARenderPass.sample';    }    const jitterOffsets = _JitterVectors[ Math.max( 0, Math.min( this.sampleLevel, 5 ) ) ];    const autoClear = renderer.autoClear;   renderer.autoClear = false;    renderer.getClearColor( this._oldClearColor );   const oldClearAlpha = renderer.getClearAlpha();    const baseSampleWeight = 1.0 / jitterOffsets.length;   const roundingRange = 1 / 32;   this.copyUniforms[ 'tDiffuse' ].value = this.sampleRenderTarget.texture;    const viewOffset = {     fullWidth: readBuffer.width,    fullHeight: readBuffer.height,    offsetX: 0,    offsetY: 0,    width: readBuffer.width,    height: readBuffer.height    };    const originalViewOffset = Object.assign( {}, this.camera.view );    if ( originalViewOffset.enabled ) Object.assign( viewOffset, originalViewOffset );    // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.   for ( let i = 0; i < jitterOffsets.length; i ++ ) {     const jitterOffset = jitterOffsets[ i ];     if ( this.camera.setViewOffset ) {      this.camera.setViewOffset(       viewOffset.fullWidth, viewOffset.fullHeight,       viewOffset.offsetX + jitterOffset[ 0 ] * 0.0625, viewOffset.offsetY + jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16       viewOffset.width, viewOffset.height      );     }     let sampleWeight = baseSampleWeight;     if ( this.unbiased ) {      // the theory is that equal weights for each sample lead to an accumulation of rounding errors.     // The following equation varies the sampleWeight per sample so that it is uniformly distributed     // across a range of values whose rounding errors cancel each other out.      const uniformCenteredDistribution = ( - 0.5 + ( i + 0.5 ) / jitterOffsets.length );     sampleWeight += roundingRange * uniformCenteredDistribution;     }     this.copyUniforms[ 'opacity' ].value = sampleWeight;    renderer.setClearColor( this.clearColor, this.clearAlpha );    renderer.setRenderTarget( this.sampleRenderTarget );    renderer.clear();    renderer.render( this.scene, this.camera );     renderer.setRenderTarget( this.renderToScreen ? null : writeBuffer );     if ( i === 0 ) {      renderer.setClearColor( 0x000000, 0.0 );     renderer.clear();     }     this.fsQuad.render( renderer );    }    if ( this.camera.setViewOffset && originalViewOffset.enabled ) {     this.camera.setViewOffset(      originalViewOffset.fullWidth, originalViewOffset.fullHeight,      originalViewOffset.offsetX, originalViewOffset.offsetY,      originalViewOffset.width, originalViewOffset.height     );    } else if ( this.camera.clearViewOffset ) {     this.camera.clearViewOffset();    }    renderer.autoClear = autoClear;   renderer.setClearColor( this._oldClearColor, oldClearAlpha );   }  }   // These jitter vectors are specified in integers because it is easier. // I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5) // before being used, thus these integers need to be scaled by 1/16. // // Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396 const _JitterVectors = [  [   [ 0, 0 ]  ],  [   [ 4, 4 ], [ - 4, - 4 ]  ],  [   [ - 2, - 6 ], [ 6, - 2 ], [ - 6, 2 ], [ 2, 6 ]  ],  [   [ 1, - 3 ], [ - 1, 3 ], [ 5, 1 ], [ - 3, - 5 ],   [ - 5, 5 ], [ - 7, - 1 ], [ 3, 7 ], [ 7, - 7 ]  ],  [   [ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],   [ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],   [ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],   [ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ]  ],  [   [ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],   [ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],   [ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],   [ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],   [ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],   [ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],   [ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],   [ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]  ] ];  export { SSAARenderPass }; 
^..^ FILENAME ^..^
addons|postprocessing|SSAOPass.js
^..^ CONTENTS ^..^
import {  AddEquation,  Color,  CustomBlending,  DataTexture,  DepthTexture,  DstAlphaFactor,  DstColorFactor,  FloatType,  HalfFloatType,  MathUtils,  MeshNormalMaterial,  NearestFilter,  NoBlending,  RedFormat,  DepthStencilFormat,  UnsignedInt248Type,  RepeatWrapping,  ShaderMaterial,  UniformsUtils,  Vector3,  WebGLRenderTarget,  ZeroFactor } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { SimplexNoise } from '../math/SimplexNoise.js'; import { SSAOShader } from '../shaders/SSAOShader.js'; import { SSAOBlurShader } from '../shaders/SSAOShader.js'; import { SSAODepthShader } from '../shaders/SSAOShader.js'; import { CopyShader } from '../shaders/CopyShader.js';  class SSAOPass extends Pass {   constructor( scene, camera, width, height, kernelSize = 32 ) {    super();    this.width = ( width !== undefined ) ? width : 512;   this.height = ( height !== undefined ) ? height : 512;    this.clear = true;   this.needsSwap = false;    this.camera = camera;   this.scene = scene;    this.kernelRadius = 8;   this.kernel = [];   this.noiseTexture = null;   this.output = 0;    this.minDistance = 0.005;   this.maxDistance = 0.1;    this._visibilityCache = new Map();    //    this.generateSampleKernel( kernelSize );   this.generateRandomKernelRotations();    // depth texture    const depthTexture = new DepthTexture();   depthTexture.format = DepthStencilFormat;   depthTexture.type = UnsignedInt248Type;    // normal render target with depth buffer    this.normalRenderTarget = new WebGLRenderTarget( this.width, this.height, {    minFilter: NearestFilter,    magFilter: NearestFilter,    type: HalfFloatType,    depthTexture: depthTexture   } );    // ssao render target    this.ssaoRenderTarget = new WebGLRenderTarget( this.width, this.height, { type: HalfFloatType } );    this.blurRenderTarget = this.ssaoRenderTarget.clone();    // ssao material    this.ssaoMaterial = new ShaderMaterial( {    defines: Object.assign( {}, SSAOShader.defines ),    uniforms: UniformsUtils.clone( SSAOShader.uniforms ),    vertexShader: SSAOShader.vertexShader,    fragmentShader: SSAOShader.fragmentShader,    blending: NoBlending   } );    this.ssaoMaterial.defines[ 'KERNEL_SIZE' ] = kernelSize;    this.ssaoMaterial.uniforms[ 'tNormal' ].value = this.normalRenderTarget.texture;   this.ssaoMaterial.uniforms[ 'tDepth' ].value = this.normalRenderTarget.depthTexture;   this.ssaoMaterial.uniforms[ 'tNoise' ].value = this.noiseTexture;   this.ssaoMaterial.uniforms[ 'kernel' ].value = this.kernel;   this.ssaoMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;   this.ssaoMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;   this.ssaoMaterial.uniforms[ 'resolution' ].value.set( this.width, this.height );   this.ssaoMaterial.uniforms[ 'cameraProjectionMatrix' ].value.copy( this.camera.projectionMatrix );   this.ssaoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.copy( this.camera.projectionMatrixInverse );    // normal material    this.normalMaterial = new MeshNormalMaterial();   this.normalMaterial.blending = NoBlending;    // blur material    this.blurMaterial = new ShaderMaterial( {    defines: Object.assign( {}, SSAOBlurShader.defines ),    uniforms: UniformsUtils.clone( SSAOBlurShader.uniforms ),    vertexShader: SSAOBlurShader.vertexShader,    fragmentShader: SSAOBlurShader.fragmentShader   } );   this.blurMaterial.uniforms[ 'tDiffuse' ].value = this.ssaoRenderTarget.texture;   this.blurMaterial.uniforms[ 'resolution' ].value.set( this.width, this.height );    // material for rendering the depth    this.depthRenderMaterial = new ShaderMaterial( {    defines: Object.assign( {}, SSAODepthShader.defines ),    uniforms: UniformsUtils.clone( SSAODepthShader.uniforms ),    vertexShader: SSAODepthShader.vertexShader,    fragmentShader: SSAODepthShader.fragmentShader,    blending: NoBlending   } );   this.depthRenderMaterial.uniforms[ 'tDepth' ].value = this.normalRenderTarget.depthTexture;   this.depthRenderMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;   this.depthRenderMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;    // material for rendering the content of a render target    this.copyMaterial = new ShaderMaterial( {    uniforms: UniformsUtils.clone( CopyShader.uniforms ),    vertexShader: CopyShader.vertexShader,    fragmentShader: CopyShader.fragmentShader,    transparent: true,    depthTest: false,    depthWrite: false,    blendSrc: DstColorFactor,    blendDst: ZeroFactor,    blendEquation: AddEquation,    blendSrcAlpha: DstAlphaFactor,    blendDstAlpha: ZeroFactor,    blendEquationAlpha: AddEquation   } );    this.fsQuad = new FullScreenQuad( null );    this.originalClearColor = new Color();   }   dispose() {    // dispose render targets    this.normalRenderTarget.dispose();   this.ssaoRenderTarget.dispose();   this.blurRenderTarget.dispose();    // dispose materials    this.normalMaterial.dispose();   this.blurMaterial.dispose();   this.copyMaterial.dispose();   this.depthRenderMaterial.dispose();    // dipsose full screen quad    this.fsQuad.dispose();   }   render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {    // render normals and depth (honor only meshes, points and lines do not contribute to SSAO)    this.overrideVisibility();   this.renderOverride( renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0 );   this.restoreVisibility();    // render SSAO    this.ssaoMaterial.uniforms[ 'kernelRadius' ].value = this.kernelRadius;   this.ssaoMaterial.uniforms[ 'minDistance' ].value = this.minDistance;   this.ssaoMaterial.uniforms[ 'maxDistance' ].value = this.maxDistance;   this.renderPass( renderer, this.ssaoMaterial, this.ssaoRenderTarget );    // render blur    this.renderPass( renderer, this.blurMaterial, this.blurRenderTarget );    // output result to screen    switch ( this.output ) {     case SSAOPass.OUTPUT.SSAO:      this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.ssaoRenderTarget.texture;     this.copyMaterial.blending = NoBlending;     this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : readBuffer );      break;     case SSAOPass.OUTPUT.Blur:      this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget.texture;     this.copyMaterial.blending = NoBlending;     this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : readBuffer );      break;     case SSAOPass.OUTPUT.Depth:      this.renderPass( renderer, this.depthRenderMaterial, this.renderToScreen ? null : readBuffer );      break;     case SSAOPass.OUTPUT.Normal:      this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.normalRenderTarget.texture;     this.copyMaterial.blending = NoBlending;     this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : readBuffer );      break;     case SSAOPass.OUTPUT.Default:      this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget.texture;     this.copyMaterial.blending = CustomBlending;     this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : readBuffer );      break;     default:     console.warn( 'THREE.SSAOPass: Unknown output type.' );    }   }   renderPass( renderer, passMaterial, renderTarget, clearColor, clearAlpha ) {    // save original state   renderer.getClearColor( this.originalClearColor );   const originalClearAlpha = renderer.getClearAlpha();   const originalAutoClear = renderer.autoClear;    renderer.setRenderTarget( renderTarget );    // setup pass state   renderer.autoClear = false;   if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {     renderer.setClearColor( clearColor );    renderer.setClearAlpha( clearAlpha || 0.0 );    renderer.clear();    }    this.fsQuad.material = passMaterial;   this.fsQuad.render( renderer );    // restore original state   renderer.autoClear = originalAutoClear;   renderer.setClearColor( this.originalClearColor );   renderer.setClearAlpha( originalClearAlpha );   }   renderOverride( renderer, overrideMaterial, renderTarget, clearColor, clearAlpha ) {    renderer.getClearColor( this.originalClearColor );   const originalClearAlpha = renderer.getClearAlpha();   const originalAutoClear = renderer.autoClear;    renderer.setRenderTarget( renderTarget );   renderer.autoClear = false;    clearColor = overrideMaterial.clearColor || clearColor;   clearAlpha = overrideMaterial.clearAlpha || clearAlpha;    if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {     renderer.setClearColor( clearColor );    renderer.setClearAlpha( clearAlpha || 0.0 );    renderer.clear();    }    this.scene.overrideMaterial = overrideMaterial;   renderer.render( this.scene, this.camera );   this.scene.overrideMaterial = null;    // restore original state    renderer.autoClear = originalAutoClear;   renderer.setClearColor( this.originalClearColor );   renderer.setClearAlpha( originalClearAlpha );   }   setSize( width, height ) {    this.width = width;   this.height = height;    this.ssaoRenderTarget.setSize( width, height );   this.normalRenderTarget.setSize( width, height );   this.blurRenderTarget.setSize( width, height );    this.ssaoMaterial.uniforms[ 'resolution' ].value.set( width, height );   this.ssaoMaterial.uniforms[ 'cameraProjectionMatrix' ].value.copy( this.camera.projectionMatrix );   this.ssaoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.copy( this.camera.projectionMatrixInverse );    this.blurMaterial.uniforms[ 'resolution' ].value.set( width, height );   }   generateSampleKernel( kernelSize ) {    const kernel = this.kernel;    for ( let i = 0; i < kernelSize; i ++ ) {     const sample = new Vector3();    sample.x = ( Math.random() * 2 ) - 1;    sample.y = ( Math.random() * 2 ) - 1;    sample.z = Math.random();     sample.normalize();     let scale = i / kernelSize;    scale = MathUtils.lerp( 0.1, 1, scale * scale );    sample.multiplyScalar( scale );     kernel.push( sample );    }   }   generateRandomKernelRotations() {    const width = 4, height = 4;    const simplex = new SimplexNoise();    const size = width * height;   const data = new Float32Array( size );    for ( let i = 0; i < size; i ++ ) {     const x = ( Math.random() * 2 ) - 1;    const y = ( Math.random() * 2 ) - 1;    const z = 0;     data[ i ] = simplex.noise3d( x, y, z );    }    this.noiseTexture = new DataTexture( data, width, height, RedFormat, FloatType );   this.noiseTexture.wrapS = RepeatWrapping;   this.noiseTexture.wrapT = RepeatWrapping;   this.noiseTexture.needsUpdate = true;   }   overrideVisibility() {    const scene = this.scene;   const cache = this._visibilityCache;    scene.traverse( function ( object ) {     cache.set( object, object.visible );     if ( object.isPoints || object.isLine ) object.visible = false;    } );   }   restoreVisibility() {    const scene = this.scene;   const cache = this._visibilityCache;    scene.traverse( function ( object ) {     const visible = cache.get( object );    object.visible = visible;    } );    cache.clear();   }  }  SSAOPass.OUTPUT = {  'Default': 0,  'SSAO': 1,  'Blur': 2,  'Depth': 3,  'Normal': 4 };  export { SSAOPass }; 
^..^ FILENAME ^..^
addons|postprocessing|SSRPass.js
^..^ CONTENTS ^..^
import {  AddEquation,  Color,  NormalBlending,  DepthTexture,  SrcAlphaFactor,  OneMinusSrcAlphaFactor,  MeshNormalMaterial,  MeshBasicMaterial,  NearestFilter,  NoBlending,  ShaderMaterial,  UniformsUtils,  UnsignedShortType,  WebGLRenderTarget,  HalfFloatType, } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { SSRShader } from '../shaders/SSRShader.js'; import { SSRBlurShader } from '../shaders/SSRShader.js'; import { SSRDepthShader } from '../shaders/SSRShader.js'; import { CopyShader } from '../shaders/CopyShader.js';  class SSRPass extends Pass {   constructor( { renderer, scene, camera, width, height, selects, bouncing = false, groundReflector } ) {    super();    this.width = ( width !== undefined ) ? width : 512;   this.height = ( height !== undefined ) ? height : 512;    this.clear = true;    this.renderer = renderer;   this.scene = scene;   this.camera = camera;   this.groundReflector = groundReflector;    this.opacity = SSRShader.uniforms.opacity.value;   this.output = 0;    this.maxDistance = SSRShader.uniforms.maxDistance.value;   this.thickness = SSRShader.uniforms.thickness.value;    this.tempColor = new Color();    this._selects = selects;   this.selective = Array.isArray( this._selects );   Object.defineProperty( this, 'selects', {    get() {      return this._selects;     },    set( val ) {      if ( this._selects === val ) return;     this._selects = val;     if ( Array.isArray( val ) ) {       this.selective = true;      this.ssrMaterial.defines.SELECTIVE = true;      this.ssrMaterial.needsUpdate = true;      } else {       this.selective = false;      this.ssrMaterial.defines.SELECTIVE = false;      this.ssrMaterial.needsUpdate = true;      }     }   } );    this._bouncing = bouncing;   Object.defineProperty( this, 'bouncing', {    get() {      return this._bouncing;     },    set( val ) {      if ( this._bouncing === val ) return;     this._bouncing = val;     if ( val ) {       this.ssrMaterial.uniforms[ 'tDiffuse' ].value = this.prevRenderTarget.texture;      } else {       this.ssrMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;      }     }   } );    this.blur = true;    this._distanceAttenuation = SSRShader.defines.DISTANCE_ATTENUATION;   Object.defineProperty( this, 'distanceAttenuation', {    get() {      return this._distanceAttenuation;     },    set( val ) {      if ( this._distanceAttenuation === val ) return;     this._distanceAttenuation = val;     this.ssrMaterial.defines.DISTANCE_ATTENUATION = val;     this.ssrMaterial.needsUpdate = true;     }   } );     this._fresnel = SSRShader.defines.FRESNEL;   Object.defineProperty( this, 'fresnel', {    get() {      return this._fresnel;     },    set( val ) {      if ( this._fresnel === val ) return;     this._fresnel = val;     this.ssrMaterial.defines.FRESNEL = val;     this.ssrMaterial.needsUpdate = true;     }   } );    this._infiniteThick = SSRShader.defines.INFINITE_THICK;   Object.defineProperty( this, 'infiniteThick', {    get() {      return this._infiniteThick;     },    set( val ) {      if ( this._infiniteThick === val ) return;     this._infiniteThick = val;     this.ssrMaterial.defines.INFINITE_THICK = val;     this.ssrMaterial.needsUpdate = true;     }   } );    // beauty render target with depth buffer    const depthTexture = new DepthTexture();   depthTexture.type = UnsignedShortType;   depthTexture.minFilter = NearestFilter;   depthTexture.magFilter = NearestFilter;    this.beautyRenderTarget = new WebGLRenderTarget( this.width, this.height, {    minFilter: NearestFilter,    magFilter: NearestFilter,    type: HalfFloatType,    depthTexture: depthTexture,    depthBuffer: true   } );    //for bouncing   this.prevRenderTarget = new WebGLRenderTarget( this.width, this.height, {    minFilter: NearestFilter,    magFilter: NearestFilter   } );    // normal render target    this.normalRenderTarget = new WebGLRenderTarget( this.width, this.height, {    minFilter: NearestFilter,    magFilter: NearestFilter,    type: HalfFloatType,   } );    // metalness render target    this.metalnessRenderTarget = new WebGLRenderTarget( this.width, this.height, {    minFilter: NearestFilter,    magFilter: NearestFilter,    type: HalfFloatType,   } );      // ssr render target    this.ssrRenderTarget = new WebGLRenderTarget( this.width, this.height, {    minFilter: NearestFilter,    magFilter: NearestFilter   } );    this.blurRenderTarget = this.ssrRenderTarget.clone();   this.blurRenderTarget2 = this.ssrRenderTarget.clone();   // this.blurRenderTarget3 = this.ssrRenderTarget.clone();    // ssr material    this.ssrMaterial = new ShaderMaterial( {    defines: Object.assign( {}, SSRShader.defines, {     MAX_STEP: Math.sqrt( this.width * this.width + this.height * this.height )    } ),    uniforms: UniformsUtils.clone( SSRShader.uniforms ),    vertexShader: SSRShader.vertexShader,    fragmentShader: SSRShader.fragmentShader,    blending: NoBlending   } );    this.ssrMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;   this.ssrMaterial.uniforms[ 'tNormal' ].value = this.normalRenderTarget.texture;   this.ssrMaterial.defines.SELECTIVE = this.selective;   this.ssrMaterial.needsUpdate = true;   this.ssrMaterial.uniforms[ 'tMetalness' ].value = this.metalnessRenderTarget.texture;   this.ssrMaterial.uniforms[ 'tDepth' ].value = this.beautyRenderTarget.depthTexture;   this.ssrMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;   this.ssrMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;   this.ssrMaterial.uniforms[ 'thickness' ].value = this.thickness;   this.ssrMaterial.uniforms[ 'resolution' ].value.set( this.width, this.height );   this.ssrMaterial.uniforms[ 'cameraProjectionMatrix' ].value.copy( this.camera.projectionMatrix );   this.ssrMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.copy( this.camera.projectionMatrixInverse );    // normal material    this.normalMaterial = new MeshNormalMaterial();   this.normalMaterial.blending = NoBlending;    // metalnessOn material    this.metalnessOnMaterial = new MeshBasicMaterial( {    color: 'white'   } );    // metalnessOff material    this.metalnessOffMaterial = new MeshBasicMaterial( {    color: 'black'   } );    // blur material    this.blurMaterial = new ShaderMaterial( {    defines: Object.assign( {}, SSRBlurShader.defines ),    uniforms: UniformsUtils.clone( SSRBlurShader.uniforms ),    vertexShader: SSRBlurShader.vertexShader,    fragmentShader: SSRBlurShader.fragmentShader   } );   this.blurMaterial.uniforms[ 'tDiffuse' ].value = this.ssrRenderTarget.texture;   this.blurMaterial.uniforms[ 'resolution' ].value.set( this.width, this.height );    // blur material 2    this.blurMaterial2 = new ShaderMaterial( {    defines: Object.assign( {}, SSRBlurShader.defines ),    uniforms: UniformsUtils.clone( SSRBlurShader.uniforms ),    vertexShader: SSRBlurShader.vertexShader,    fragmentShader: SSRBlurShader.fragmentShader   } );   this.blurMaterial2.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget.texture;   this.blurMaterial2.uniforms[ 'resolution' ].value.set( this.width, this.height );    // // blur material 3    // this.blurMaterial3 = new ShaderMaterial({   //   defines: Object.assign({}, SSRBlurShader.defines),   //   uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),   //   vertexShader: SSRBlurShader.vertexShader,   //   fragmentShader: SSRBlurShader.fragmentShader   // });   // this.blurMaterial3.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;   // this.blurMaterial3.uniforms['resolution'].value.set(this.width, this.height);    // material for rendering the depth    this.depthRenderMaterial = new ShaderMaterial( {    defines: Object.assign( {}, SSRDepthShader.defines ),    uniforms: UniformsUtils.clone( SSRDepthShader.uniforms ),    vertexShader: SSRDepthShader.vertexShader,    fragmentShader: SSRDepthShader.fragmentShader,    blending: NoBlending   } );   this.depthRenderMaterial.uniforms[ 'tDepth' ].value = this.beautyRenderTarget.depthTexture;   this.depthRenderMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;   this.depthRenderMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;    // material for rendering the content of a render target    this.copyMaterial = new ShaderMaterial( {    uniforms: UniformsUtils.clone( CopyShader.uniforms ),    vertexShader: CopyShader.vertexShader,    fragmentShader: CopyShader.fragmentShader,    transparent: true,    depthTest: false,    depthWrite: false,    blendSrc: SrcAlphaFactor,    blendDst: OneMinusSrcAlphaFactor,    blendEquation: AddEquation,    blendSrcAlpha: SrcAlphaFactor,    blendDstAlpha: OneMinusSrcAlphaFactor,    blendEquationAlpha: AddEquation,    // premultipliedAlpha:true,   } );    this.fsQuad = new FullScreenQuad( null );    this.originalClearColor = new Color();   }   dispose() {    // dispose render targets    this.beautyRenderTarget.dispose();   this.prevRenderTarget.dispose();   this.normalRenderTarget.dispose();   this.metalnessRenderTarget.dispose();   this.ssrRenderTarget.dispose();   this.blurRenderTarget.dispose();   this.blurRenderTarget2.dispose();   // this.blurRenderTarget3.dispose();    // dispose materials    this.normalMaterial.dispose();   this.metalnessOnMaterial.dispose();   this.metalnessOffMaterial.dispose();   this.blurMaterial.dispose();   this.blurMaterial2.dispose();   this.copyMaterial.dispose();   this.depthRenderMaterial.dispose();    // dipsose full screen quad    this.fsQuad.dispose();   }   render( renderer, writeBuffer /*, readBuffer, deltaTime, maskActive */ ) {    // render beauty and depth    renderer.setRenderTarget( this.beautyRenderTarget );   renderer.clear();   if ( this.groundReflector ) {     this.groundReflector.visible = false;    this.groundReflector.doRender( this.renderer, this.scene, this.camera );    this.groundReflector.visible = true;    }    renderer.render( this.scene, this.camera );   if ( this.groundReflector ) this.groundReflector.visible = false;    // render normals    this.renderOverride( renderer, this.normalMaterial, this.normalRenderTarget, 0, 0 );    // render metalnesses    if ( this.selective ) {     this.renderMetalness( renderer, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0 );    }    // render SSR    this.ssrMaterial.uniforms[ 'opacity' ].value = this.opacity;   this.ssrMaterial.uniforms[ 'maxDistance' ].value = this.maxDistance;   this.ssrMaterial.uniforms[ 'thickness' ].value = this.thickness;   this.renderPass( renderer, this.ssrMaterial, this.ssrRenderTarget );     // render blur    if ( this.blur ) {     this.renderPass( renderer, this.blurMaterial, this.blurRenderTarget );    this.renderPass( renderer, this.blurMaterial2, this.blurRenderTarget2 );    // this.renderPass(renderer, this.blurMaterial3, this.blurRenderTarget3);    }    // output result to screen    switch ( this.output ) {     case SSRPass.OUTPUT.Default:      if ( this.bouncing ) {       this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;      this.copyMaterial.blending = NoBlending;      this.renderPass( renderer, this.copyMaterial, this.prevRenderTarget );       if ( this.blur )       this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget2.texture;      else       this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.ssrRenderTarget.texture;      this.copyMaterial.blending = NormalBlending;      this.renderPass( renderer, this.copyMaterial, this.prevRenderTarget );       this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.prevRenderTarget.texture;      this.copyMaterial.blending = NoBlending;      this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );      } else {       this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;      this.copyMaterial.blending = NoBlending;      this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );       if ( this.blur )       this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget2.texture;      else       this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.ssrRenderTarget.texture;      this.copyMaterial.blending = NormalBlending;      this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );      }      break;    case SSRPass.OUTPUT.SSR:      if ( this.blur )      this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget2.texture;     else      this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.ssrRenderTarget.texture;     this.copyMaterial.blending = NoBlending;     this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );      if ( this.bouncing ) {       if ( this.blur )       this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget2.texture;      else       this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;      this.copyMaterial.blending = NoBlending;      this.renderPass( renderer, this.copyMaterial, this.prevRenderTarget );       this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.ssrRenderTarget.texture;      this.copyMaterial.blending = NormalBlending;      this.renderPass( renderer, this.copyMaterial, this.prevRenderTarget );      }      break;     case SSRPass.OUTPUT.Beauty:      this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;     this.copyMaterial.blending = NoBlending;     this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );      break;     case SSRPass.OUTPUT.Depth:      this.renderPass( renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer );      break;     case SSRPass.OUTPUT.Normal:      this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.normalRenderTarget.texture;     this.copyMaterial.blending = NoBlending;     this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );      break;     case SSRPass.OUTPUT.Metalness:      this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.metalnessRenderTarget.texture;     this.copyMaterial.blending = NoBlending;     this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );      break;     default:     console.warn( 'THREE.SSRPass: Unknown output type.' );    }   }   renderPass( renderer, passMaterial, renderTarget, clearColor, clearAlpha ) {    // save original state   this.originalClearColor.copy( renderer.getClearColor( this.tempColor ) );   const originalClearAlpha = renderer.getClearAlpha( this.tempColor );   const originalAutoClear = renderer.autoClear;    renderer.setRenderTarget( renderTarget );    // setup pass state   renderer.autoClear = false;   if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {     renderer.setClearColor( clearColor );    renderer.setClearAlpha( clearAlpha || 0.0 );    renderer.clear();    }    this.fsQuad.material = passMaterial;   this.fsQuad.render( renderer );    // restore original state   renderer.autoClear = originalAutoClear;   renderer.setClearColor( this.originalClearColor );   renderer.setClearAlpha( originalClearAlpha );   }   renderOverride( renderer, overrideMaterial, renderTarget, clearColor, clearAlpha ) {    this.originalClearColor.copy( renderer.getClearColor( this.tempColor ) );   const originalClearAlpha = renderer.getClearAlpha( this.tempColor );   const originalAutoClear = renderer.autoClear;    renderer.setRenderTarget( renderTarget );   renderer.autoClear = false;    clearColor = overrideMaterial.clearColor || clearColor;   clearAlpha = overrideMaterial.clearAlpha || clearAlpha;    if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {     renderer.setClearColor( clearColor );    renderer.setClearAlpha( clearAlpha || 0.0 );    renderer.clear();    }    this.scene.overrideMaterial = overrideMaterial;   renderer.render( this.scene, this.camera );   this.scene.overrideMaterial = null;    // restore original state    renderer.autoClear = originalAutoClear;   renderer.setClearColor( this.originalClearColor );   renderer.setClearAlpha( originalClearAlpha );   }   renderMetalness( renderer, overrideMaterial, renderTarget, clearColor, clearAlpha ) {    this.originalClearColor.copy( renderer.getClearColor( this.tempColor ) );   const originalClearAlpha = renderer.getClearAlpha( this.tempColor );   const originalAutoClear = renderer.autoClear;    renderer.setRenderTarget( renderTarget );   renderer.autoClear = false;    clearColor = overrideMaterial.clearColor || clearColor;   clearAlpha = overrideMaterial.clearAlpha || clearAlpha;    if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {     renderer.setClearColor( clearColor );    renderer.setClearAlpha( clearAlpha || 0.0 );    renderer.clear();    }    this.scene.traverseVisible( child => {     child._SSRPassBackupMaterial = child.material;    if ( this._selects.includes( child ) ) {      child.material = this.metalnessOnMaterial;     } else {      child.material = this.metalnessOffMaterial;     }    } );   renderer.render( this.scene, this.camera );   this.scene.traverseVisible( child => {     child.material = child._SSRPassBackupMaterial;    } );    // restore original state    renderer.autoClear = originalAutoClear;   renderer.setClearColor( this.originalClearColor );   renderer.setClearAlpha( originalClearAlpha );   }   setSize( width, height ) {    this.width = width;   this.height = height;    this.ssrMaterial.defines.MAX_STEP = Math.sqrt( width * width + height * height );   this.ssrMaterial.needsUpdate = true;   this.beautyRenderTarget.setSize( width, height );   this.prevRenderTarget.setSize( width, height );   this.ssrRenderTarget.setSize( width, height );   this.normalRenderTarget.setSize( width, height );   this.metalnessRenderTarget.setSize( width, height );   this.blurRenderTarget.setSize( width, height );   this.blurRenderTarget2.setSize( width, height );   // this.blurRenderTarget3.setSize(width, height);    this.ssrMaterial.uniforms[ 'resolution' ].value.set( width, height );   this.ssrMaterial.uniforms[ 'cameraProjectionMatrix' ].value.copy( this.camera.projectionMatrix );   this.ssrMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.copy( this.camera.projectionMatrixInverse );    this.blurMaterial.uniforms[ 'resolution' ].value.set( width, height );   this.blurMaterial2.uniforms[ 'resolution' ].value.set( width, height );   }  }  SSRPass.OUTPUT = {  'Default': 0,  'SSR': 1,  'Beauty': 3,  'Depth': 4,  'Normal': 5,  'Metalness': 7, };  export { SSRPass }; 
^..^ FILENAME ^..^
addons|postprocessing|TAARenderPass.js
^..^ CONTENTS ^..^
import {  HalfFloatType,  WebGLRenderTarget } from 'three'; import { SSAARenderPass } from './SSAARenderPass.js';  /**  *  * Temporal Anti-Aliasing Render Pass  *  * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.  *  * References:  *  * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.  *  */  class TAARenderPass extends SSAARenderPass {   constructor( scene, camera, clearColor, clearAlpha ) {    super( scene, camera, clearColor, clearAlpha );    this.sampleLevel = 0;   this.accumulate = false;   this.accumulateIndex = - 1;   }   render( renderer, writeBuffer, readBuffer, deltaTime ) {    if ( this.accumulate === false ) {     super.render( renderer, writeBuffer, readBuffer, deltaTime );     this.accumulateIndex = - 1;    return;    }    const jitterOffsets = _JitterVectors[ 5 ];    if ( this.sampleRenderTarget === undefined ) {     this.sampleRenderTarget = new WebGLRenderTarget( readBuffer.width, readBuffer.height, { type: HalfFloatType } );    this.sampleRenderTarget.texture.name = 'TAARenderPass.sample';    }    if ( this.holdRenderTarget === undefined ) {     this.holdRenderTarget = new WebGLRenderTarget( readBuffer.width, readBuffer.height, { type: HalfFloatType } );    this.holdRenderTarget.texture.name = 'TAARenderPass.hold';    }    if ( this.accumulateIndex === - 1 ) {     super.render( renderer, this.holdRenderTarget, readBuffer, deltaTime );     this.accumulateIndex = 0;    }    const autoClear = renderer.autoClear;   renderer.autoClear = false;    renderer.getClearColor( this._oldClearColor );   const oldClearAlpha = renderer.getClearAlpha();    const sampleWeight = 1.0 / ( jitterOffsets.length );    if ( this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length ) {     this.copyUniforms[ 'opacity' ].value = sampleWeight;    this.copyUniforms[ 'tDiffuse' ].value = writeBuffer.texture;     // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.    const numSamplesPerFrame = Math.pow( 2, this.sampleLevel );    for ( let i = 0; i < numSamplesPerFrame; i ++ ) {      const j = this.accumulateIndex;     const jitterOffset = jitterOffsets[ j ];      if ( this.camera.setViewOffset ) {       this.camera.setViewOffset( readBuffer.width, readBuffer.height,       jitterOffset[ 0 ] * 0.0625, jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16       readBuffer.width, readBuffer.height );      }      renderer.setRenderTarget( writeBuffer );     renderer.setClearColor( this.clearColor, this.clearAlpha );     renderer.clear();     renderer.render( this.scene, this.camera );      renderer.setRenderTarget( this.sampleRenderTarget );     if ( this.accumulateIndex === 0 ) {       renderer.setClearColor( 0x000000, 0.0 );      renderer.clear();      }      this.fsQuad.render( renderer );      this.accumulateIndex ++;      if ( this.accumulateIndex >= jitterOffsets.length ) break;     }     if ( this.camera.clearViewOffset ) this.camera.clearViewOffset();    }    renderer.setClearColor( this.clearColor, this.clearAlpha );   const accumulationWeight = this.accumulateIndex * sampleWeight;    if ( accumulationWeight > 0 ) {     this.copyUniforms[ 'opacity' ].value = 1.0;    this.copyUniforms[ 'tDiffuse' ].value = this.sampleRenderTarget.texture;    renderer.setRenderTarget( writeBuffer );    renderer.clear();    this.fsQuad.render( renderer );    }    if ( accumulationWeight < 1.0 ) {     this.copyUniforms[ 'opacity' ].value = 1.0 - accumulationWeight;    this.copyUniforms[ 'tDiffuse' ].value = this.holdRenderTarget.texture;    renderer.setRenderTarget( writeBuffer );    this.fsQuad.render( renderer );    }    renderer.autoClear = autoClear;   renderer.setClearColor( this._oldClearColor, oldClearAlpha );   }   dispose() {    super.dispose();    if ( this.holdRenderTarget ) this.holdRenderTarget.dispose();   }  }  const _JitterVectors = [  [   [ 0, 0 ]  ],  [   [ 4, 4 ], [ - 4, - 4 ]  ],  [   [ - 2, - 6 ], [ 6, - 2 ], [ - 6, 2 ], [ 2, 6 ]  ],  [   [ 1, - 3 ], [ - 1, 3 ], [ 5, 1 ], [ - 3, - 5 ],   [ - 5, 5 ], [ - 7, - 1 ], [ 3, 7 ], [ 7, - 7 ]  ],  [   [ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],   [ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],   [ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],   [ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ]  ],  [   [ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],   [ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],   [ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],   [ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],   [ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],   [ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],   [ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],   [ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]  ] ];  export { TAARenderPass }; 
^..^ FILENAME ^..^
addons|postprocessing|TexturePass.js
^..^ CONTENTS ^..^
import {  ShaderMaterial,  UniformsUtils } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { CopyShader } from '../shaders/CopyShader.js';  class TexturePass extends Pass {   constructor( map, opacity ) {    super();    const shader = CopyShader;    this.map = map;   this.opacity = ( opacity !== undefined ) ? opacity : 1.0;    this.uniforms = UniformsUtils.clone( shader.uniforms );    this.material = new ShaderMaterial( {     uniforms: this.uniforms,    vertexShader: shader.vertexShader,    fragmentShader: shader.fragmentShader,    depthTest: false,    depthWrite: false,    premultipliedAlpha: true    } );    this.needsSwap = false;    this.fsQuad = new FullScreenQuad( null );   }   render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {    const oldAutoClear = renderer.autoClear;   renderer.autoClear = false;    this.fsQuad.material = this.material;    this.uniforms[ 'opacity' ].value = this.opacity;   this.uniforms[ 'tDiffuse' ].value = this.map;   this.material.transparent = ( this.opacity < 1.0 );    renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );   if ( this.clear ) renderer.clear();   this.fsQuad.render( renderer );    renderer.autoClear = oldAutoClear;   }   dispose() {    this.material.dispose();    this.fsQuad.dispose();   }  }  export { TexturePass }; 
^..^ FILENAME ^..^
addons|postprocessing|UnrealBloomPass.js
^..^ CONTENTS ^..^
import {  AdditiveBlending,  Color,  HalfFloatType,  MeshBasicMaterial,  ShaderMaterial,  UniformsUtils,  Vector2,  Vector3,  WebGLRenderTarget } from 'three'; import { Pass, FullScreenQuad } from './Pass.js'; import { CopyShader } from '../shaders/CopyShader.js'; import { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';  /**  * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a  * mip map chain of bloom textures and blurs them with different radii. Because  * of the weighted combination of mips, and because larger blurs are done on  * higher mips, this effect provides good quality and performance.  *  * Reference:  * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/  */ class UnrealBloomPass extends Pass {   constructor( resolution, strength, radius, threshold ) {    super();    this.strength = ( strength !== undefined ) ? strength : 1;   this.radius = radius;   this.threshold = threshold;   this.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );    // create color only once here, reuse it later inside the render function   this.clearColor = new Color( 0, 0, 0 );    // render targets   this.renderTargetsHorizontal = [];   this.renderTargetsVertical = [];   this.nMips = 5;   let resx = Math.round( this.resolution.x / 2 );   let resy = Math.round( this.resolution.y / 2 );    this.renderTargetBright = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );   this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';   this.renderTargetBright.texture.generateMipmaps = false;    for ( let i = 0; i < this.nMips; i ++ ) {     const renderTargetHorizontal = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );     renderTargetHorizontal.texture.name = 'UnrealBloomPass.h' + i;    renderTargetHorizontal.texture.generateMipmaps = false;     this.renderTargetsHorizontal.push( renderTargetHorizontal );     const renderTargetVertical = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );     renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;    renderTargetVertical.texture.generateMipmaps = false;     this.renderTargetsVertical.push( renderTargetVertical );     resx = Math.round( resx / 2 );     resy = Math.round( resy / 2 );    }    // luminosity high pass material    const highPassShader = LuminosityHighPassShader;   this.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );    this.highPassUniforms[ 'luminosityThreshold' ].value = threshold;   this.highPassUniforms[ 'smoothWidth' ].value = 0.01;    this.materialHighPassFilter = new ShaderMaterial( {    uniforms: this.highPassUniforms,    vertexShader: highPassShader.vertexShader,    fragmentShader: highPassShader.fragmentShader   } );    // gaussian blur materials    this.separableBlurMaterials = [];   const kernelSizeArray = [ 3, 5, 7, 9, 11 ];   resx = Math.round( this.resolution.x / 2 );   resy = Math.round( this.resolution.y / 2 );    for ( let i = 0; i < this.nMips; i ++ ) {     this.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );     this.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );     resx = Math.round( resx / 2 );     resy = Math.round( resy / 2 );    }    // composite material    this.compositeMaterial = this.getCompositeMaterial( this.nMips );   this.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;   this.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;   this.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;   this.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;   this.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;   this.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;   this.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;    const bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];   this.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;   this.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];   this.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;    // blend material    const copyShader = CopyShader;    this.copyUniforms = UniformsUtils.clone( copyShader.uniforms );    this.blendMaterial = new ShaderMaterial( {    uniforms: this.copyUniforms,    vertexShader: copyShader.vertexShader,    fragmentShader: copyShader.fragmentShader,    blending: AdditiveBlending,    depthTest: false,    depthWrite: false,    transparent: true   } );    this.enabled = true;   this.needsSwap = false;    this._oldClearColor = new Color();   this.oldClearAlpha = 1;    this.basic = new MeshBasicMaterial();    this.fsQuad = new FullScreenQuad( null );   }   dispose() {    for ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {     this.renderTargetsHorizontal[ i ].dispose();    }    for ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {     this.renderTargetsVertical[ i ].dispose();    }    this.renderTargetBright.dispose();    //    for ( let i = 0; i < this.separableBlurMaterials.length; i ++ ) {     this.separableBlurMaterials[ i ].dispose();    }    this.compositeMaterial.dispose();   this.blendMaterial.dispose();   this.basic.dispose();    //    this.fsQuad.dispose();   }   setSize( width, height ) {    let resx = Math.round( width / 2 );   let resy = Math.round( height / 2 );    this.renderTargetBright.setSize( resx, resy );    for ( let i = 0; i < this.nMips; i ++ ) {     this.renderTargetsHorizontal[ i ].setSize( resx, resy );    this.renderTargetsVertical[ i ].setSize( resx, resy );     this.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );     resx = Math.round( resx / 2 );    resy = Math.round( resy / 2 );    }   }   render( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {    renderer.getClearColor( this._oldClearColor );   this.oldClearAlpha = renderer.getClearAlpha();   const oldAutoClear = renderer.autoClear;   renderer.autoClear = false;    renderer.setClearColor( this.clearColor, 0 );    if ( maskActive ) renderer.state.buffers.stencil.setTest( false );    // Render input to screen    if ( this.renderToScreen ) {     this.fsQuad.material = this.basic;    this.basic.map = readBuffer.texture;     renderer.setRenderTarget( null );    renderer.clear();    this.fsQuad.render( renderer );    }    // 1. Extract Bright Areas    this.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;   this.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;   this.fsQuad.material = this.materialHighPassFilter;    renderer.setRenderTarget( this.renderTargetBright );   renderer.clear();   this.fsQuad.render( renderer );    // 2. Blur All the mips progressively    let inputRenderTarget = this.renderTargetBright;    for ( let i = 0; i < this.nMips; i ++ ) {     this.fsQuad.material = this.separableBlurMaterials[ i ];     this.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;    this.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;    renderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );    renderer.clear();    this.fsQuad.render( renderer );     this.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;    this.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;    renderer.setRenderTarget( this.renderTargetsVertical[ i ] );    renderer.clear();    this.fsQuad.render( renderer );     inputRenderTarget = this.renderTargetsVertical[ i ];    }    // Composite All the mips    this.fsQuad.material = this.compositeMaterial;   this.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;   this.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;   this.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;    renderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );   renderer.clear();   this.fsQuad.render( renderer );    // Blend it additively over the input texture    this.fsQuad.material = this.blendMaterial;   this.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;    if ( maskActive ) renderer.state.buffers.stencil.setTest( true );    if ( this.renderToScreen ) {     renderer.setRenderTarget( null );    this.fsQuad.render( renderer );    } else {     renderer.setRenderTarget( readBuffer );    this.fsQuad.render( renderer );    }    // Restore renderer settings    renderer.setClearColor( this._oldClearColor, this.oldClearAlpha );   renderer.autoClear = oldAutoClear;   }   getSeperableBlurMaterial( kernelRadius ) {    const coefficients = [];    for ( let i = 0; i < kernelRadius; i ++ ) {     coefficients.push( 0.39894 * Math.exp( - 0.5 * i * i / ( kernelRadius * kernelRadius ) ) / kernelRadius );    }    return new ShaderMaterial( {     defines: {     'KERNEL_RADIUS': kernelRadius    },     uniforms: {     'colorTexture': { value: null },     'invSize': { value: new Vector2( 0.5, 0.5 ) }, // inverse texture size     'direction': { value: new Vector2( 0.5, 0.5 ) },     'gaussianCoefficients': { value: coefficients } // precomputed Gaussian coefficients    },     vertexShader:     |varying vec2 vUv;     void main() {      vUv = uv;      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );     }|,     fragmentShader:     |#include <common>     varying vec2 vUv;     uniform sampler2D colorTexture;     uniform vec2 invSize;     uniform vec2 direction;     uniform float gaussianCoefficients[KERNEL_RADIUS];      void main() {      float weightSum = gaussianCoefficients[0];      vec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;      for( int i = 1; i < KERNEL_RADIUS; i ++ ) {       float x = float(i);       float w = gaussianCoefficients[i];       vec2 uvOffset = direction * invSize * x;       vec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;       vec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;       diffuseSum += (sample1 + sample2) * w;       weightSum += 2.0 * w;      }      gl_FragColor = vec4(diffuseSum/weightSum, 1.0);     }|   } );   }   getCompositeMaterial( nMips ) {    return new ShaderMaterial( {     defines: {     'NUM_MIPS': nMips    },     uniforms: {     'blurTexture1': { value: null },     'blurTexture2': { value: null },     'blurTexture3': { value: null },     'blurTexture4': { value: null },     'blurTexture5': { value: null },     'bloomStrength': { value: 1.0 },     'bloomFactors': { value: null },     'bloomTintColors': { value: null },     'bloomRadius': { value: 0.0 }    },     vertexShader:     |varying vec2 vUv;     void main() {      vUv = uv;      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );     }|,     fragmentShader:     |varying vec2 vUv;     uniform sampler2D blurTexture1;     uniform sampler2D blurTexture2;     uniform sampler2D blurTexture3;     uniform sampler2D blurTexture4;     uniform sampler2D blurTexture5;     uniform float bloomStrength;     uniform float bloomRadius;     uniform float bloomFactors[NUM_MIPS];     uniform vec3 bloomTintColors[NUM_MIPS];      float lerpBloomFactor(const in float factor) {      float mirrorFactor = 1.2 - factor;      return mix(factor, mirrorFactor, bloomRadius);     }      void main() {      gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +       lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +       lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +       lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +       lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );     }|   } );   }  }  UnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 ); UnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );  export { UnrealBloomPass }; 
^..^ FILENAME ^..^
addons|renderers|CSS2DRenderer.js
^..^ CONTENTS ^..^
import {  Matrix4,  Object3D,  Vector2,  Vector3 } from 'three';  class CSS2DObject extends Object3D {   constructor( element = document.createElement( 'div' ) ) {    super();    this.isCSS2DObject = true;    this.element = element;    this.element.style.position = 'absolute';   this.element.style.userSelect = 'none';    this.element.setAttribute( 'draggable', false );    this.center = new Vector2( 0.5, 0.5 ); // ( 0, 0 ) is the lower left; ( 1, 1 ) is the top right    this.addEventListener( 'removed', function () {     this.traverse( function ( object ) {      if ( object.element instanceof Element && object.element.parentNode !== null ) {       object.element.parentNode.removeChild( object.element );      }     } );    } );   }   copy( source, recursive ) {    super.copy( source, recursive );    this.element = source.element.cloneNode( true );    this.center = source.center;    return this;   }  }  //  const _vector = new Vector3(); const _viewMatrix = new Matrix4(); const _viewProjectionMatrix = new Matrix4(); const _a = new Vector3(); const _b = new Vector3();  class CSS2DRenderer {   constructor( parameters = {} ) {    const _this = this;    let _width, _height;   let _widthHalf, _heightHalf;    const cache = {    objects: new WeakMap()   };    const domElement = parameters.element !== undefined ? parameters.element : document.createElement( 'div' );    domElement.style.overflow = 'hidden';    this.domElement = domElement;    this.getSize = function () {     return {     width: _width,     height: _height    };    };    this.render = function ( scene, camera ) {     if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();    if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();     _viewMatrix.copy( camera.matrixWorldInverse );    _viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );     renderObject( scene, scene, camera );    zOrder( scene );    };    this.setSize = function ( width, height ) {     _width = width;    _height = height;     _widthHalf = _width / 2;    _heightHalf = _height / 2;     domElement.style.width = width + 'px';    domElement.style.height = height + 'px';    };    function hideObject( object ) {     if ( object.isCSS2DObject ) object.element.style.display = 'none';     for ( let i = 0, l = object.children.length; i < l; i ++ ) {      hideObject( object.children[ i ] );     }    }    function renderObject( object, scene, camera ) {     if ( object.visible === false ) {      hideObject( object );      return;     }        if ( object.isCSS2DObject ) {      _vector.setFromMatrixPosition( object.matrixWorld );     _vector.applyMatrix4( _viewProjectionMatrix );      const visible = ( _vector.z >= - 1 && _vector.z <= 1 ) && ( object.layers.test( camera.layers ) === true );      const element = object.element;     element.style.display = visible === true ? '' : 'none';      if ( visible === true ) {       object.onBeforeRender( _this, scene, camera );       element.style.transform = 'translate(' + ( - 100 * object.center.x ) + '%,' + ( - 100 * object.center.y ) + '%)' + 'translate(' + ( _vector.x * _widthHalf + _widthHalf ) + 'px,' + ( - _vector.y * _heightHalf + _heightHalf ) + 'px)';       if ( element.parentNode !== domElement ) {        domElement.appendChild( element );       }       object.onAfterRender( _this, scene, camera );      }      const objectData = {      distanceToCameraSquared: getDistanceToSquared( camera, object )     };      cache.objects.set( object, objectData );     }     for ( let i = 0, l = object.children.length; i < l; i ++ ) {      renderObject( object.children[ i ], scene, camera );     }    }    function getDistanceToSquared( object1, object2 ) {     _a.setFromMatrixPosition( object1.matrixWorld );    _b.setFromMatrixPosition( object2.matrixWorld );     return _a.distanceToSquared( _b );    }    function filterAndFlatten( scene ) {     const result = [];     scene.traverseVisible( function ( object ) {      if ( object.isCSS2DObject ) result.push( object );     } );     return result;    }    function zOrder( scene ) {     const sorted = filterAndFlatten( scene ).sort( function ( a, b ) {      if ( a.renderOrder !== b.renderOrder ) {       return b.renderOrder - a.renderOrder;      }      const distanceA = cache.objects.get( a ).distanceToCameraSquared;     const distanceB = cache.objects.get( b ).distanceToCameraSquared;      return distanceA - distanceB;     } );     const zMax = sorted.length;     for ( let i = 0, l = sorted.length; i < l; i ++ ) {      sorted[ i ].element.style.zIndex = zMax - i;     }    }   }  }  export { CSS2DObject, CSS2DRenderer }; 
^..^ FILENAME ^..^
addons|renderers|CSS3DRenderer.js
^..^ CONTENTS ^..^
import {  Matrix4,  Object3D,  Quaternion,  Vector3 } from 'three';  /**  * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs  */  const _position = new Vector3(); const _quaternion = new Quaternion(); const _scale = new Vector3();  class CSS3DObject extends Object3D {   constructor( element = document.createElement( 'div' ) ) {    super();    this.isCSS3DObject = true;    this.element = element;   this.element.style.position = 'absolute';   this.element.style.pointerEvents = 'auto';   this.element.style.userSelect = 'none';    this.element.setAttribute( 'draggable', false );    this.addEventListener( 'removed', function () {     this.traverse( function ( object ) {      if ( object.element instanceof Element && object.element.parentNode !== null ) {       object.element.parentNode.removeChild( object.element );      }     } );    } );   }   copy( source, recursive ) {    super.copy( source, recursive );    this.element = source.element.cloneNode( true );    return this;   }  }  class CSS3DSprite extends CSS3DObject {   constructor( element ) {    super( element );    this.isCSS3DSprite = true;    this.rotation2D = 0;   }   copy( source, recursive ) {    super.copy( source, recursive );    this.rotation2D = source.rotation2D;    return this;   }  }  //  const _matrix = new Matrix4(); const _matrix2 = new Matrix4();  class CSS3DRenderer {   constructor( parameters = {} ) {    const _this = this;    let _width, _height;   let _widthHalf, _heightHalf;    const cache = {    camera: { style: '' },    objects: new WeakMap()   };    const domElement = parameters.element !== undefined ? parameters.element : document.createElement( 'div' );    domElement.style.overflow = 'hidden';    this.domElement = domElement;    const viewElement = document.createElement( 'div' );   viewElement.style.transformOrigin = '0 0';   viewElement.style.pointerEvents = 'none';   domElement.appendChild( viewElement );    const cameraElement = document.createElement( 'div' );    cameraElement.style.transformStyle = 'preserve-3d';    viewElement.appendChild( cameraElement );    this.getSize = function () {     return {     width: _width,     height: _height    };    };    this.render = function ( scene, camera ) {     const fov = camera.projectionMatrix.elements[ 5 ] * _heightHalf;     if ( camera.view && camera.view.enabled ) {      // view offset     viewElement.style.transform = |translate( | - camera.view.offsetX * ( _width / camera.view.width ) }px, | - camera.view.offsetY * ( _height / camera.view.height ) }px )|;      // view fullWidth and fullHeight, view width and height     viewElement.style.transform += |scale( | camera.view.fullWidth / camera.view.width }, | camera.view.fullHeight / camera.view.height } )|;     } else {      viewElement.style.transform = '';     }     if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();    if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();     let tx, ty;     if ( camera.isOrthographicCamera ) {      tx = - ( camera.right + camera.left ) / 2;     ty = ( camera.top + camera.bottom ) / 2;     }     const scaleByViewOffset = camera.view && camera.view.enabled ? camera.view.height / camera.view.fullHeight : 1;    const cameraCSSMatrix = camera.isOrthographicCamera ?     |scale( | scaleByViewOffset } )| + 'scale(' + fov + ')' + 'translate(' + epsilon( tx ) + 'px,' + epsilon( ty ) + 'px)' + getCameraCSSMatrix( camera.matrixWorldInverse ) :     |scale( | scaleByViewOffset } )| + 'translateZ(' + fov + 'px)' + getCameraCSSMatrix( camera.matrixWorldInverse );    const perspective = camera.isPerspectiveCamera ? 'perspective(' + fov + 'px) ' : '';     const style = perspective + cameraCSSMatrix +     'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)';     if ( cache.camera.style !== style ) {      cameraElement.style.transform = style;      cache.camera.style = style;     }     renderObject( scene, scene, camera, cameraCSSMatrix );    };    this.setSize = function ( width, height ) {     _width = width;    _height = height;    _widthHalf = _width / 2;    _heightHalf = _height / 2;     domElement.style.width = width + 'px';    domElement.style.height = height + 'px';     viewElement.style.width = width + 'px';    viewElement.style.height = height + 'px';     cameraElement.style.width = width + 'px';    cameraElement.style.height = height + 'px';    };    function epsilon( value ) {     return Math.abs( value ) < 1e-10 ? 0 : value;    }    function getCameraCSSMatrix( matrix ) {     const elements = matrix.elements;     return 'matrix3d(' +     epsilon( elements[ 0 ] ) + ',' +     epsilon( - elements[ 1 ] ) + ',' +     epsilon( elements[ 2 ] ) + ',' +     epsilon( elements[ 3 ] ) + ',' +     epsilon( elements[ 4 ] ) + ',' +     epsilon( - elements[ 5 ] ) + ',' +     epsilon( elements[ 6 ] ) + ',' +     epsilon( elements[ 7 ] ) + ',' +     epsilon( elements[ 8 ] ) + ',' +     epsilon( - elements[ 9 ] ) + ',' +     epsilon( elements[ 10 ] ) + ',' +     epsilon( elements[ 11 ] ) + ',' +     epsilon( elements[ 12 ] ) + ',' +     epsilon( - elements[ 13 ] ) + ',' +     epsilon( elements[ 14 ] ) + ',' +     epsilon( elements[ 15 ] ) +    ')';    }    function getObjectCSSMatrix( matrix ) {     const elements = matrix.elements;    const matrix3d = 'matrix3d(' +     epsilon( elements[ 0 ] ) + ',' +     epsilon( elements[ 1 ] ) + ',' +     epsilon( elements[ 2 ] ) + ',' +     epsilon( elements[ 3 ] ) + ',' +     epsilon( - elements[ 4 ] ) + ',' +     epsilon( - elements[ 5 ] ) + ',' +     epsilon( - elements[ 6 ] ) + ',' +     epsilon( - elements[ 7 ] ) + ',' +     epsilon( elements[ 8 ] ) + ',' +     epsilon( elements[ 9 ] ) + ',' +     epsilon( elements[ 10 ] ) + ',' +     epsilon( elements[ 11 ] ) + ',' +     epsilon( elements[ 12 ] ) + ',' +     epsilon( elements[ 13 ] ) + ',' +     epsilon( elements[ 14 ] ) + ',' +     epsilon( elements[ 15 ] ) +    ')';     return 'translate(-50%,-50%)' + matrix3d;    }    function hideObject( object ) {     if ( object.isCSS3DObject ) object.element.style.display = 'none';        for ( let i = 0, l = object.children.length; i < l; i ++ ) {       hideObject( object.children[ i ] );     }    }    function renderObject( object, scene, camera, cameraCSSMatrix ) {     if ( object.visible === false ) {      hideObject( object );      return;     }     if ( object.isCSS3DObject ) {      const visible = ( object.layers.test( camera.layers ) === true );      const element = object.element;     element.style.display = visible === true ? '' : 'none';      if ( visible === true ) {       object.onBeforeRender( _this, scene, camera );       let style;       if ( object.isCSS3DSprite ) {        // http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/        _matrix.copy( camera.matrixWorldInverse );       _matrix.transpose();        if ( object.rotation2D !== 0 ) _matrix.multiply( _matrix2.makeRotationZ( object.rotation2D ) );        object.matrixWorld.decompose( _position, _quaternion, _scale );       _matrix.setPosition( _position );       _matrix.scale( _scale );        _matrix.elements[ 3 ] = 0;       _matrix.elements[ 7 ] = 0;       _matrix.elements[ 11 ] = 0;       _matrix.elements[ 15 ] = 1;        style = getObjectCSSMatrix( _matrix );       } else {        style = getObjectCSSMatrix( object.matrixWorld );       }       const cachedObject = cache.objects.get( object );       if ( cachedObject === undefined || cachedObject.style !== style ) {        element.style.transform = style;        const objectData = { style: style };       cache.objects.set( object, objectData );       }       if ( element.parentNode !== cameraElement ) {        cameraElement.appendChild( element );       }       object.onAfterRender( _this, scene, camera );      }     }     for ( let i = 0, l = object.children.length; i < l; i ++ ) {      renderObject( object.children[ i ], scene, camera, cameraCSSMatrix );     }    }   }  }  export { CSS3DObject, CSS3DSprite, CSS3DRenderer }; 
^..^ FILENAME ^..^
addons|renderers|Projector.js
^..^ CONTENTS ^..^
import {  Box3,  Color,  DoubleSide,  Frustum,  Matrix3,  Matrix4,  Vector2,  Vector3,  Vector4 } from 'three';  class RenderableObject {   constructor() {    this.id = 0;    this.object = null;   this.z = 0;   this.renderOrder = 0;   }  }  //  class RenderableFace {   constructor() {    this.id = 0;    this.v1 = new RenderableVertex();   this.v2 = new RenderableVertex();   this.v3 = new RenderableVertex();    this.normalModel = new Vector3();    this.vertexNormalsModel = [ new Vector3(), new Vector3(), new Vector3() ];   this.vertexNormalsLength = 0;    this.color = new Color();   this.material = null;   this.uvs = [ new Vector2(), new Vector2(), new Vector2() ];    this.z = 0;   this.renderOrder = 0;   }  }  //  class RenderableVertex {   constructor() {    this.position = new Vector3();   this.positionWorld = new Vector3();   this.positionScreen = new Vector4();    this.visible = true;   }   copy( vertex ) {    this.positionWorld.copy( vertex.positionWorld );   this.positionScreen.copy( vertex.positionScreen );   }  }  //  class RenderableLine {   constructor() {    this.id = 0;    this.v1 = new RenderableVertex();   this.v2 = new RenderableVertex();    this.vertexColors = [ new Color(), new Color() ];   this.material = null;    this.z = 0;   this.renderOrder = 0;   }  }  //  class RenderableSprite {   constructor() {    this.id = 0;    this.object = null;    this.x = 0;   this.y = 0;   this.z = 0;    this.rotation = 0;   this.scale = new Vector2();    this.material = null;   this.renderOrder = 0;   }  }  //  class Projector {   constructor() {    let _object, _objectCount, _objectPoolLength = 0,    _vertex, _vertexCount, _vertexPoolLength = 0,    _face, _faceCount, _facePoolLength = 0,    _line, _lineCount, _linePoolLength = 0,    _sprite, _spriteCount, _spritePoolLength = 0,    _modelMatrix;    const     _renderData = { objects: [], lights: [], elements: [] },     _vector3 = new Vector3(),    _vector4 = new Vector4(),     _clipBox = new Box3( new Vector3( - 1, - 1, - 1 ), new Vector3( 1, 1, 1 ) ),    _boundingBox = new Box3(),    _points3 = new Array( 3 ),     _viewMatrix = new Matrix4(),    _viewProjectionMatrix = new Matrix4(),     _modelViewProjectionMatrix = new Matrix4(),     _frustum = new Frustum(),     _objectPool = [], _vertexPool = [], _facePool = [], _linePool = [], _spritePool = [];    //    function RenderList() {     const normals = [];    const colors = [];    const uvs = [];     let object = null;     const normalMatrix = new Matrix3();     function setObject( value ) {      object = value;      normalMatrix.getNormalMatrix( object.matrixWorld );      normals.length = 0;     colors.length = 0;     uvs.length = 0;     }     function projectVertex( vertex ) {      const position = vertex.position;     const positionWorld = vertex.positionWorld;     const positionScreen = vertex.positionScreen;      positionWorld.copy( position ).applyMatrix4( _modelMatrix );     positionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );      const invW = 1 / positionScreen.w;      positionScreen.x *= invW;     positionScreen.y *= invW;     positionScreen.z *= invW;      vertex.visible = positionScreen.x >= - 1 && positionScreen.x <= 1 &&        positionScreen.y >= - 1 && positionScreen.y <= 1 &&        positionScreen.z >= - 1 && positionScreen.z <= 1;     }     function pushVertex( x, y, z ) {      _vertex = getNextVertexInPool();     _vertex.position.set( x, y, z );      projectVertex( _vertex );     }     function pushNormal( x, y, z ) {      normals.push( x, y, z );     }     function pushColor( r, g, b ) {      colors.push( r, g, b );     }     function pushUv( x, y ) {      uvs.push( x, y );     }     function checkTriangleVisibility( v1, v2, v3 ) {      if ( v1.visible === true || v2.visible === true || v3.visible === true ) return true;      _points3[ 0 ] = v1.positionScreen;     _points3[ 1 ] = v2.positionScreen;     _points3[ 2 ] = v3.positionScreen;      return _clipBox.intersectsBox( _boundingBox.setFromPoints( _points3 ) );     }     function checkBackfaceCulling( v1, v2, v3 ) {      return ( ( v3.positionScreen.x - v1.positionScreen.x ) *          ( v2.positionScreen.y - v1.positionScreen.y ) -          ( v3.positionScreen.y - v1.positionScreen.y ) *          ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;     }     function pushLine( a, b ) {      const v1 = _vertexPool[ a ];     const v2 = _vertexPool[ b ];      // Clip      v1.positionScreen.copy( v1.position ).applyMatrix4( _modelViewProjectionMatrix );     v2.positionScreen.copy( v2.position ).applyMatrix4( _modelViewProjectionMatrix );      if ( clipLine( v1.positionScreen, v2.positionScreen ) === true ) {       // Perform the perspective divide      v1.positionScreen.multiplyScalar( 1 / v1.positionScreen.w );      v2.positionScreen.multiplyScalar( 1 / v2.positionScreen.w );       _line = getNextLineInPool();      _line.id = object.id;      _line.v1.copy( v1 );      _line.v2.copy( v2 );      _line.z = Math.max( v1.positionScreen.z, v2.positionScreen.z );      _line.renderOrder = object.renderOrder;       _line.material = object.material;       if ( object.material.vertexColors ) {        _line.vertexColors[ 0 ].fromArray( colors, a * 3 );       _line.vertexColors[ 1 ].fromArray( colors, b * 3 );       }       _renderData.elements.push( _line );      }     }     function pushTriangle( a, b, c, material ) {      const v1 = _vertexPool[ a ];     const v2 = _vertexPool[ b ];     const v3 = _vertexPool[ c ];      if ( checkTriangleVisibility( v1, v2, v3 ) === false ) return;      if ( material.side === DoubleSide || checkBackfaceCulling( v1, v2, v3 ) === true ) {       _face = getNextFaceInPool();       _face.id = object.id;      _face.v1.copy( v1 );      _face.v2.copy( v2 );      _face.v3.copy( v3 );      _face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;      _face.renderOrder = object.renderOrder;       // face normal      _vector3.subVectors( v3.position, v2.position );      _vector4.subVectors( v1.position, v2.position );      _vector3.cross( _vector4 );      _face.normalModel.copy( _vector3 );      _face.normalModel.applyMatrix3( normalMatrix ).normalize();       for ( let i = 0; i < 3; i ++ ) {        const normal = _face.vertexNormalsModel[ i ];       normal.fromArray( normals, arguments[ i ] * 3 );       normal.applyMatrix3( normalMatrix ).normalize();        const uv = _face.uvs[ i ];       uv.fromArray( uvs, arguments[ i ] * 2 );       }       _face.vertexNormalsLength = 3;       _face.material = material;       if ( material.vertexColors ) {        _face.color.fromArray( colors, a * 3 );       }       _renderData.elements.push( _face );      }     }     return {     setObject: setObject,     projectVertex: projectVertex,     checkTriangleVisibility: checkTriangleVisibility,     checkBackfaceCulling: checkBackfaceCulling,     pushVertex: pushVertex,     pushNormal: pushNormal,     pushColor: pushColor,     pushUv: pushUv,     pushLine: pushLine,     pushTriangle: pushTriangle    };    }    const renderList = new RenderList();    function projectObject( object ) {     if ( object.visible === false ) return;     if ( object.isLight ) {      _renderData.lights.push( object );     } else if ( object.isMesh || object.isLine || object.isPoints ) {      if ( object.material.visible === false ) return;     if ( object.frustumCulled === true && _frustum.intersectsObject( object ) === false ) return;      addObject( object );     } else if ( object.isSprite ) {      if ( object.material.visible === false ) return;     if ( object.frustumCulled === true && _frustum.intersectsSprite( object ) === false ) return;      addObject( object );     }     const children = object.children;     for ( let i = 0, l = children.length; i < l; i ++ ) {      projectObject( children[ i ] );     }    }    function addObject( object ) {     _object = getNextObjectInPool();    _object.id = object.id;    _object.object = object;     _vector3.setFromMatrixPosition( object.matrixWorld );    _vector3.applyMatrix4( _viewProjectionMatrix );    _object.z = _vector3.z;    _object.renderOrder = object.renderOrder;     _renderData.objects.push( _object );    }    this.projectScene = function ( scene, camera, sortObjects, sortElements ) {     _faceCount = 0;    _lineCount = 0;    _spriteCount = 0;     _renderData.elements.length = 0;     if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();    if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();     _viewMatrix.copy( camera.matrixWorldInverse );    _viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );     _frustum.setFromProjectionMatrix( _viewProjectionMatrix );     //     _objectCount = 0;     _renderData.objects.length = 0;    _renderData.lights.length = 0;     projectObject( scene );     if ( sortObjects === true ) {      _renderData.objects.sort( painterSort );     }     //     const objects = _renderData.objects;     for ( let o = 0, ol = objects.length; o < ol; o ++ ) {      const object = objects[ o ].object;     const geometry = object.geometry;      renderList.setObject( object );      _modelMatrix = object.matrixWorld;      _vertexCount = 0;      if ( object.isMesh ) {       let material = object.material;       const isMultiMaterial = Array.isArray( material );       const attributes = geometry.attributes;      const groups = geometry.groups;       if ( attributes.position === undefined ) continue;       const positions = attributes.position.array;       for ( let i = 0, l = positions.length; i < l; i += 3 ) {        let x = positions[ i ];       let y = positions[ i + 1 ];       let z = positions[ i + 2 ];        const morphTargets = geometry.morphAttributes.position;        if ( morphTargets !== undefined ) {         const morphTargetsRelative = geometry.morphTargetsRelative;        const morphInfluences = object.morphTargetInfluences;         for ( let t = 0, tl = morphTargets.length; t < tl; t ++ ) {          const influence = morphInfluences[ t ];          if ( influence === 0 ) continue;          const target = morphTargets[ t ];          if ( morphTargetsRelative ) {           x += target.getX( i / 3 ) * influence;          y += target.getY( i / 3 ) * influence;          z += target.getZ( i / 3 ) * influence;          } else {           x += ( target.getX( i / 3 ) - positions[ i ] ) * influence;          y += ( target.getY( i / 3 ) - positions[ i + 1 ] ) * influence;          z += ( target.getZ( i / 3 ) - positions[ i + 2 ] ) * influence;          }         }        }        renderList.pushVertex( x, y, z );       }       if ( attributes.normal !== undefined ) {        const normals = attributes.normal.array;        for ( let i = 0, l = normals.length; i < l; i += 3 ) {         renderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );        }       }       if ( attributes.color !== undefined ) {        const colors = attributes.color.array;        for ( let i = 0, l = colors.length; i < l; i += 3 ) {         renderList.pushColor( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] );        }       }       if ( attributes.uv !== undefined ) {        const uvs = attributes.uv.array;        for ( let i = 0, l = uvs.length; i < l; i += 2 ) {         renderList.pushUv( uvs[ i ], uvs[ i + 1 ] );        }       }       if ( geometry.index !== null ) {        const indices = geometry.index.array;        if ( groups.length > 0 ) {         for ( let g = 0; g < groups.length; g ++ ) {          const group = groups[ g ];          material = isMultiMaterial === true           ? object.material[ group.materialIndex ]           : object.material;          if ( material === undefined ) continue;          for ( let i = group.start, l = group.start + group.count; i < l; i += 3 ) {           renderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ], material );          }         }        } else {         for ( let i = 0, l = indices.length; i < l; i += 3 ) {          renderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ], material );         }        }       } else {        if ( groups.length > 0 ) {         for ( let g = 0; g < groups.length; g ++ ) {          const group = groups[ g ];          material = isMultiMaterial === true           ? object.material[ group.materialIndex ]           : object.material;          if ( material === undefined ) continue;          for ( let i = group.start, l = group.start + group.count; i < l; i += 3 ) {           renderList.pushTriangle( i, i + 1, i + 2, material );          }         }        } else {         for ( let i = 0, l = positions.length / 3; i < l; i += 3 ) {          renderList.pushTriangle( i, i + 1, i + 2, material );         }        }       }      } else if ( object.isLine ) {       _modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );       const attributes = geometry.attributes;       if ( attributes.position !== undefined ) {        const positions = attributes.position.array;        for ( let i = 0, l = positions.length; i < l; i += 3 ) {         renderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );        }        if ( attributes.color !== undefined ) {         const colors = attributes.color.array;         for ( let i = 0, l = colors.length; i < l; i += 3 ) {          renderList.pushColor( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] );         }        }        if ( geometry.index !== null ) {         const indices = geometry.index.array;         for ( let i = 0, l = indices.length; i < l; i += 2 ) {          renderList.pushLine( indices[ i ], indices[ i + 1 ] );         }        } else {         const step = object.isLineSegments ? 2 : 1;         for ( let i = 0, l = ( positions.length / 3 ) - 1; i < l; i += step ) {          renderList.pushLine( i, i + 1 );         }        }       }      } else if ( object.isPoints ) {       _modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );       const attributes = geometry.attributes;       if ( attributes.position !== undefined ) {        const positions = attributes.position.array;        for ( let i = 0, l = positions.length; i < l; i += 3 ) {         _vector4.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ], 1 );        _vector4.applyMatrix4( _modelViewProjectionMatrix );         pushPoint( _vector4, object, camera );        }       }      } else if ( object.isSprite ) {       object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );      _vector4.set( _modelMatrix.elements[ 12 ], _modelMatrix.elements[ 13 ], _modelMatrix.elements[ 14 ], 1 );      _vector4.applyMatrix4( _viewProjectionMatrix );       pushPoint( _vector4, object, camera );      }     }     if ( sortElements === true ) {      _renderData.elements.sort( painterSort );     }     return _renderData;    };    function pushPoint( _vector4, object, camera ) {     const invW = 1 / _vector4.w;     _vector4.z *= invW;     if ( _vector4.z >= - 1 && _vector4.z <= 1 ) {      _sprite = getNextSpriteInPool();     _sprite.id = object.id;     _sprite.x = _vector4.x * invW;     _sprite.y = _vector4.y * invW;     _sprite.z = _vector4.z;     _sprite.renderOrder = object.renderOrder;     _sprite.object = object;      _sprite.rotation = object.rotation;      _sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[ 0 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 12 ] ) );     _sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[ 5 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 13 ] ) );      _sprite.material = object.material;      _renderData.elements.push( _sprite );     }    }    // Pools    function getNextObjectInPool() {     if ( _objectCount === _objectPoolLength ) {      const object = new RenderableObject();     _objectPool.push( object );     _objectPoolLength ++;     _objectCount ++;     return object;     }     return _objectPool[ _objectCount ++ ];    }    function getNextVertexInPool() {     if ( _vertexCount === _vertexPoolLength ) {      const vertex = new RenderableVertex();     _vertexPool.push( vertex );     _vertexPoolLength ++;     _vertexCount ++;     return vertex;     }     return _vertexPool[ _vertexCount ++ ];    }    function getNextFaceInPool() {     if ( _faceCount === _facePoolLength ) {      const face = new RenderableFace();     _facePool.push( face );     _facePoolLength ++;     _faceCount ++;     return face;     }     return _facePool[ _faceCount ++ ];     }    function getNextLineInPool() {     if ( _lineCount === _linePoolLength ) {      const line = new RenderableLine();     _linePool.push( line );     _linePoolLength ++;     _lineCount ++;     return line;     }     return _linePool[ _lineCount ++ ];    }    function getNextSpriteInPool() {     if ( _spriteCount === _spritePoolLength ) {      const sprite = new RenderableSprite();     _spritePool.push( sprite );     _spritePoolLength ++;     _spriteCount ++;     return sprite;     }     return _spritePool[ _spriteCount ++ ];    }    //    function painterSort( a, b ) {     if ( a.renderOrder !== b.renderOrder ) {      return a.renderOrder - b.renderOrder;     } else if ( a.z !== b.z ) {      return b.z - a.z;     } else if ( a.id !== b.id ) {      return a.id - b.id;     } else {      return 0;     }    }    function clipLine( s1, s2 ) {     let alpha1 = 0, alpha2 = 1;     // Calculate the boundary coordinate of each vertex for the near and far clip planes,    // Z = -1 and Z = +1, respectively.     const bc1near = s1.z + s1.w,     bc2near = s2.z + s2.w,     bc1far = - s1.z + s1.w,     bc2far = - s2.z + s2.w;     if ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {      // Both vertices lie entirely within all clip planes.     return true;     } else if ( ( bc1near < 0 && bc2near < 0 ) || ( bc1far < 0 && bc2far < 0 ) ) {      // Both vertices lie entirely outside one of the clip planes.     return false;     } else {      // The line segment spans at least one clip plane.      if ( bc1near < 0 ) {       // v1 lies outside the near plane, v2 inside      alpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );      } else if ( bc2near < 0 ) {       // v2 lies outside the near plane, v1 inside      alpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );      }      if ( bc1far < 0 ) {       // v1 lies outside the far plane, v2 inside      alpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );      } else if ( bc2far < 0 ) {       // v2 lies outside the far plane, v2 inside      alpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );      }      if ( alpha2 < alpha1 ) {       // The line segment spans two boundaries, but is outside both of them.      // (This can't happen when we're only clipping against just near/far but good      //  to leave the check here for future usage if other clip planes are added.)      return false;      } else {       // Update the s1 and s2 vertices to match the clipped line segment.      s1.lerp( s2, alpha1 );      s2.lerp( s1, 1 - alpha2 );       return true;      }     }    }   }  }  export { RenderableObject, RenderableFace, RenderableVertex, RenderableLine, RenderableSprite, Projector }; 
^..^ FILENAME ^..^
addons|renderers|SVGRenderer.js
^..^ CONTENTS ^..^
import {  Box2,  Camera,  Color,  Matrix3,  Matrix4,  Object3D,  SRGBColorSpace,  Vector3 } from 'three'; import { Projector } from '../renderers/Projector.js'; import { RenderableFace } from '../renderers/Projector.js'; import { RenderableLine } from '../renderers/Projector.js'; import { RenderableSprite } from '../renderers/Projector.js';  class SVGObject extends Object3D {   constructor( node ) {    super();    this.isSVGObject = true;    this.node = node;   }  }  class SVGRenderer {   constructor() {    let _renderData, _elements, _lights,    _svgWidth, _svgHeight, _svgWidthHalf, _svgHeightHalf,     _v1, _v2, _v3,     _svgNode,    _pathCount = 0,     _precision = null,    _quality = 1,     _currentPath, _currentStyle;    const _this = this,    _clipBox = new Box2(),    _elemBox = new Box2(),     _color = new Color(),    _diffuseColor = new Color(),    _ambientLight = new Color(),    _directionalLights = new Color(),    _pointLights = new Color(),    _clearColor = new Color(),     _vector3 = new Vector3(), // Needed for PointLight    _centroid = new Vector3(),    _normal = new Vector3(),    _normalViewMatrix = new Matrix3(),     _viewMatrix = new Matrix4(),    _viewProjectionMatrix = new Matrix4(),     _svgPathPool = [],     _projector = new Projector(),    _svg = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' );    this.domElement = _svg;    this.autoClear = true;   this.sortObjects = true;   this.sortElements = true;    this.overdraw = 0.5;    this.outputColorSpace = SRGBColorSpace;    this.info = {     render: {      vertices: 0,     faces: 0     }    };    this.setQuality = function ( quality ) {     switch ( quality ) {      case 'high': _quality = 1; break;     case 'low': _quality = 0; break;     }    };    this.setClearColor = function ( color ) {     _clearColor.set( color );    };    this.setPixelRatio = function () {};    this.setSize = function ( width, height ) {     _svgWidth = width; _svgHeight = height;    _svgWidthHalf = _svgWidth / 2; _svgHeightHalf = _svgHeight / 2;     _svg.setAttribute( 'viewBox', ( - _svgWidthHalf ) + ' ' + ( - _svgHeightHalf ) + ' ' + _svgWidth + ' ' + _svgHeight );    _svg.setAttribute( 'width', _svgWidth );    _svg.setAttribute( 'height', _svgHeight );     _clipBox.min.set( - _svgWidthHalf, - _svgHeightHalf );    _clipBox.max.set( _svgWidthHalf, _svgHeightHalf );    };    this.getSize = function () {     return {     width: _svgWidth,     height: _svgHeight    };    };    this.setPrecision = function ( precision ) {     _precision = precision;    };    function removeChildNodes() {     _pathCount = 0;     while ( _svg.childNodes.length > 0 ) {      _svg.removeChild( _svg.childNodes[ 0 ] );     }    }    function convert( c ) {     return _precision !== null ? c.toFixed( _precision ) : c;    }    this.clear = function () {     removeChildNodes();    _svg.style.backgroundColor = _clearColor.getStyle( _this.outputColorSpace );    };    this.render = function ( scene, camera ) {     if ( camera instanceof Camera === false ) {      console.error( 'THREE.SVGRenderer.render: camera is not an instance of Camera.' );     return;     }     const background = scene.background;     if ( background && background.isColor ) {      removeChildNodes();     _svg.style.backgroundColor = background.getStyle( _this.outputColorSpace );     } else if ( this.autoClear === true ) {      this.clear();     }     _this.info.render.vertices = 0;    _this.info.render.faces = 0;     _viewMatrix.copy( camera.matrixWorldInverse );    _viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );     _renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );    _elements = _renderData.elements;    _lights = _renderData.lights;     _normalViewMatrix.getNormalMatrix( camera.matrixWorldInverse );     calculateLights( _lights );      // reset accumulated path     _currentPath = '';    _currentStyle = '';     for ( let e = 0, el = _elements.length; e < el; e ++ ) {      const element = _elements[ e ];     const material = element.material;      if ( material === undefined || material.opacity === 0 ) continue;      _elemBox.makeEmpty();      if ( element instanceof RenderableSprite ) {       _v1 = element;      _v1.x *= _svgWidthHalf; _v1.y *= - _svgHeightHalf;       renderSprite( _v1, element, material );      } else if ( element instanceof RenderableLine ) {       _v1 = element.v1; _v2 = element.v2;       _v1.positionScreen.x *= _svgWidthHalf; _v1.positionScreen.y *= - _svgHeightHalf;      _v2.positionScreen.x *= _svgWidthHalf; _v2.positionScreen.y *= - _svgHeightHalf;       _elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen ] );       if ( _clipBox.intersectsBox( _elemBox ) === true ) {        renderLine( _v1, _v2, material );       }      } else if ( element instanceof RenderableFace ) {       _v1 = element.v1; _v2 = element.v2; _v3 = element.v3;       if ( _v1.positionScreen.z < - 1 || _v1.positionScreen.z > 1 ) continue;      if ( _v2.positionScreen.z < - 1 || _v2.positionScreen.z > 1 ) continue;      if ( _v3.positionScreen.z < - 1 || _v3.positionScreen.z > 1 ) continue;       _v1.positionScreen.x *= _svgWidthHalf; _v1.positionScreen.y *= - _svgHeightHalf;      _v2.positionScreen.x *= _svgWidthHalf; _v2.positionScreen.y *= - _svgHeightHalf;      _v3.positionScreen.x *= _svgWidthHalf; _v3.positionScreen.y *= - _svgHeightHalf;       if ( this.overdraw > 0 ) {        expand( _v1.positionScreen, _v2.positionScreen, this.overdraw );       expand( _v2.positionScreen, _v3.positionScreen, this.overdraw );       expand( _v3.positionScreen, _v1.positionScreen, this.overdraw );       }       _elemBox.setFromPoints( [       _v1.positionScreen,       _v2.positionScreen,       _v3.positionScreen      ] );       if ( _clipBox.intersectsBox( _elemBox ) === true ) {        renderFace3( _v1, _v2, _v3, element, material );       }      }     }     flushPath(); // just to flush last svg:path     scene.traverseVisible( function ( object ) {       if ( object.isSVGObject ) {       _vector3.setFromMatrixPosition( object.matrixWorld );      _vector3.applyMatrix4( _viewProjectionMatrix );       if ( _vector3.z < - 1 || _vector3.z > 1 ) return;       const x = _vector3.x * _svgWidthHalf;      const y = - _vector3.y * _svgHeightHalf;       const node = object.node;      node.setAttribute( 'transform', 'translate(' + x + ',' + y + ')' );       _svg.appendChild( node );      }     } );    };    function calculateLights( lights ) {     _ambientLight.setRGB( 0, 0, 0 );    _directionalLights.setRGB( 0, 0, 0 );    _pointLights.setRGB( 0, 0, 0 );     for ( let l = 0, ll = lights.length; l < ll; l ++ ) {      const light = lights[ l ];     const lightColor = light.color;      if ( light.isAmbientLight ) {       _ambientLight.r += lightColor.r;      _ambientLight.g += lightColor.g;      _ambientLight.b += lightColor.b;      } else if ( light.isDirectionalLight ) {       _directionalLights.r += lightColor.r;      _directionalLights.g += lightColor.g;      _directionalLights.b += lightColor.b;      } else if ( light.isPointLight ) {       _pointLights.r += lightColor.r;      _pointLights.g += lightColor.g;      _pointLights.b += lightColor.b;      }     }    }    function calculateLight( lights, position, normal, color ) {     for ( let l = 0, ll = lights.length; l < ll; l ++ ) {      const light = lights[ l ];     const lightColor = light.color;      if ( light.isDirectionalLight ) {       const lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld ).normalize();       let amount = normal.dot( lightPosition );       if ( amount <= 0 ) continue;       amount *= light.intensity;       color.r += lightColor.r * amount;      color.g += lightColor.g * amount;      color.b += lightColor.b * amount;      } else if ( light.isPointLight ) {       const lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld );       let amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );       if ( amount <= 0 ) continue;       amount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );       if ( amount == 0 ) continue;       amount *= light.intensity;       color.r += lightColor.r * amount;      color.g += lightColor.g * amount;      color.b += lightColor.b * amount;      }     }    }    function renderSprite( v1, element, material ) {     let scaleX = element.scale.x * _svgWidthHalf;    let scaleY = element.scale.y * _svgHeightHalf;     if ( material.isPointsMaterial ) {      scaleX *= material.size;     scaleY *= material.size;     }     const path = 'M' + convert( v1.x - scaleX * 0.5 ) + ',' + convert( v1.y - scaleY * 0.5 ) + 'h' + convert( scaleX ) + 'v' + convert( scaleY ) + 'h' + convert( - scaleX ) + 'z';    let style = '';     if ( material.isSpriteMaterial || material.isPointsMaterial ) {      style = 'fill:' + material.color.getStyle( _this.outputColorSpace ) + ';fill-opacity:' + material.opacity;     }     addPath( style, path );    }    function renderLine( v1, v2, material ) {     const path = 'M' + convert( v1.positionScreen.x ) + ',' + convert( v1.positionScreen.y ) + 'L' + convert( v2.positionScreen.x ) + ',' + convert( v2.positionScreen.y );     if ( material.isLineBasicMaterial ) {      let style = 'fill:none;stroke:' + material.color.getStyle( _this.outputColorSpace ) + ';stroke-opacity:' + material.opacity + ';stroke-width:' + material.linewidth + ';stroke-linecap:' + material.linecap;      if ( material.isLineDashedMaterial ) {       style = style + ';stroke-dasharray:' + material.dashSize + ',' + material.gapSize;      }      addPath( style, path );     }    }    function renderFace3( v1, v2, v3, element, material ) {     _this.info.render.vertices += 3;    _this.info.render.faces ++;     const path = 'M' + convert( v1.positionScreen.x ) + ',' + convert( v1.positionScreen.y ) + 'L' + convert( v2.positionScreen.x ) + ',' + convert( v2.positionScreen.y ) + 'L' + convert( v3.positionScreen.x ) + ',' + convert( v3.positionScreen.y ) + 'z';    let style = '';     if ( material.isMeshBasicMaterial ) {      _color.copy( material.color );      if ( material.vertexColors ) {       _color.multiply( element.color );      }     } else if ( material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial ) {      _diffuseColor.copy( material.color );      if ( material.vertexColors ) {       _diffuseColor.multiply( element.color );      }      _color.copy( _ambientLight );      _centroid.copy( v1.positionWorld ).add( v2.positionWorld ).add( v3.positionWorld ).divideScalar( 3 );      calculateLight( _lights, _centroid, element.normalModel, _color );      _color.multiply( _diffuseColor ).add( material.emissive );     } else if ( material.isMeshNormalMaterial ) {      _normal.copy( element.normalModel ).applyMatrix3( _normalViewMatrix ).normalize();      _color.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );     }     if ( material.wireframe ) {      style = 'fill:none;stroke:' + _color.getStyle( _this.outputColorSpace ) + ';stroke-opacity:' + material.opacity + ';stroke-width:' + material.wireframeLinewidth + ';stroke-linecap:' + material.wireframeLinecap + ';stroke-linejoin:' + material.wireframeLinejoin;     } else {      style = 'fill:' + _color.getStyle( _this.outputColorSpace ) + ';fill-opacity:' + material.opacity;     }     addPath( style, path );    }    // Hide anti-alias gaps    function expand( v1, v2, pixels ) {     let x = v2.x - v1.x, y = v2.y - v1.y;    const det = x * x + y * y;     if ( det === 0 ) return;     const idet = pixels / Math.sqrt( det );     x *= idet; y *= idet;     v2.x += x; v2.y += y;    v1.x -= x; v1.y -= y;    }    function addPath( style, path ) {     if ( _currentStyle === style ) {      _currentPath += path;     } else {      flushPath();      _currentStyle = style;     _currentPath = path;     }    }    function flushPath() {     if ( _currentPath ) {      _svgNode = getPathNode( _pathCount ++ );     _svgNode.setAttribute( 'd', _currentPath );     _svgNode.setAttribute( 'style', _currentStyle );     _svg.appendChild( _svgNode );     }     _currentPath = '';    _currentStyle = '';    }    function getPathNode( id ) {     if ( _svgPathPool[ id ] == null ) {      _svgPathPool[ id ] = document.createElementNS( 'http://www.w3.org/2000/svg', 'path' );      if ( _quality == 0 ) {       _svgPathPool[ id ].setAttribute( 'shape-rendering', 'crispEdges' ); //optimizeSpeed      }      return _svgPathPool[ id ];     }     return _svgPathPool[ id ];    }   }  }  export { SVGObject, SVGRenderer }; 
^..^ FILENAME ^..^
addons|shaders|ACESFilmicToneMappingShader.js
^..^ CONTENTS ^..^
/**  * ACES Filmic Tone Mapping Shader by Stephen Hill  * source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs  *  * this implementation of ACES is modified to accommodate a brighter viewing environment.  * the scale factor of 1/0.6 is subjective. see discussion in #19621.  */  const ACESFilmicToneMappingShader = {   name: 'ACESFilmicToneMappingShader',   uniforms: {    'tDiffuse': { value: null },   'exposure': { value: 1.0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    #define saturate(a) clamp( a, 0.0, 1.0 )    uniform sampler2D tDiffuse;    uniform float exposure;    varying vec2 vUv;    vec3 RRTAndODTFit( vec3 v ) {     vec3 a = v * ( v + 0.0245786 ) - 0.000090537;    vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;    return a / b;    }    vec3 ACESFilmicToneMapping( vec3 color ) {    // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT    const mat3 ACESInputMat = mat3(     vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source     vec3( 0.35458, 0.90834, 0.13383 ),     vec3( 0.04823, 0.01566, 0.83777 )    );    // ODT_SAT => XYZ => D60_2_D65 => sRGB    const mat3 ACESOutputMat = mat3(     vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source     vec3( -0.53108,  1.10813, -0.07276 ),     vec3( -0.07367, -0.00605,  1.07602 )    );     color = ACESInputMat * color;    // Apply RRT and ODT    color = RRTAndODTFit( color );     color = ACESOutputMat * color;    // Clamp to [0, 1]    return saturate( color );    }    void main() {     vec4 tex = texture2D( tDiffuse, vUv );     tex.rgb *= exposure / 0.6; // pre-exposed, outside of the tone mapping function     gl_FragColor = vec4( ACESFilmicToneMapping( tex.rgb ), tex.a );    }|  };  export { ACESFilmicToneMappingShader }; 
^..^ FILENAME ^..^
addons|shaders|AfterimageShader.js
^..^ CONTENTS ^..^
/**  * Afterimage shader  * I created this effect inspired by a demo on codepen:  * https://codepen.io/brunoimbrizi/pen/MoRJaN?page=1&  */  const AfterimageShader = {   name: 'AfterimageShader',   uniforms: {    'damp': { value: 0.96 },   'tOld': { value: null },   'tNew': { value: null }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform float damp;    uniform sampler2D tOld;   uniform sampler2D tNew;    varying vec2 vUv;    vec4 when_gt( vec4 x, float y ) {     return max( sign( x - y ), 0.0 );    }    void main() {     vec4 texelOld = texture2D( tOld, vUv );    vec4 texelNew = texture2D( tNew, vUv );     texelOld *= damp * when_gt( texelOld, 0.1 );     gl_FragColor = max(texelNew, texelOld);    }|  };  export { AfterimageShader }; 
^..^ FILENAME ^..^
addons|shaders|BasicShader.js
^..^ CONTENTS ^..^
/**  * Simple test shader  */  const BasicShader = {   name: 'BasicShader',   uniforms: {},   vertexShader: /* glsl */|    void main() {     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    void main() {     gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );    }|  };  export { BasicShader }; 
^..^ FILENAME ^..^
addons|shaders|BleachBypassShader.js
^..^ CONTENTS ^..^
/**  * Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass]  * - based on Nvidia example  * http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass  */  const BleachBypassShader = {   name: 'BleachBypassShader',   uniforms: {    'tDiffuse': { value: null },   'opacity': { value: 1.0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform float opacity;    uniform sampler2D tDiffuse;    varying vec2 vUv;    void main() {     vec4 base = texture2D( tDiffuse, vUv );     float lum = luminance( base.rgb );    vec3 blend = vec3( lum );     float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );     vec3 result1 = 2.0 * base.rgb * blend;    vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );     vec3 newColor = mix( result1, result2, L );     float A2 = opacity * base.a;    vec3 mixRGB = A2 * newColor.rgb;    mixRGB += ( ( 1.0 - A2 ) * base.rgb );     gl_FragColor = vec4( mixRGB, base.a );    }|  };  export { BleachBypassShader }; 
^..^ FILENAME ^..^
addons|shaders|BlendShader.js
^..^ CONTENTS ^..^
/**  * Blend two textures  */  const BlendShader = {   name: 'BlendShader',   uniforms: {    'tDiffuse1': { value: null },   'tDiffuse2': { value: null },   'mixRatio': { value: 0.5 },   'opacity': { value: 1.0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform float opacity;   uniform float mixRatio;    uniform sampler2D tDiffuse1;   uniform sampler2D tDiffuse2;    varying vec2 vUv;    void main() {     vec4 texel1 = texture2D( tDiffuse1, vUv );    vec4 texel2 = texture2D( tDiffuse2, vUv );    gl_FragColor = opacity * mix( texel1, texel2, mixRatio );    }|  };  export { BlendShader }; 
^..^ FILENAME ^..^
addons|shaders|BokehShader.js
^..^ CONTENTS ^..^
/**  * Depth-of-field shader with bokeh  * ported from GLSL shader by Martins Upitis  * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html  */  const BokehShader = {   name: 'BokehShader',   defines: {   'DEPTH_PACKING': 1,   'PERSPECTIVE_CAMERA': 1,  },   uniforms: {    'tColor': { value: null },   'tDepth': { value: null },   'focus': { value: 1.0 },   'aspect': { value: 1.0 },   'aperture': { value: 0.025 },   'maxblur': { value: 0.01 },   'nearClip': { value: 1.0 },   'farClip': { value: 1000.0 },   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    #include <common>    varying vec2 vUv;    uniform sampler2D tColor;   uniform sampler2D tDepth;    uniform float maxblur; // max blur amount   uniform float aperture; // aperture - bigger values for shallower depth of field    uniform float nearClip;   uniform float farClip;    uniform float focus;   uniform float aspect;    #include <packing>    float getDepth( const in vec2 screenPosition ) {    #if DEPTH_PACKING == 1    return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );    #else    return texture2D( tDepth, screenPosition ).x;    #endif   }    float getViewZ( const in float depth ) {    #if PERSPECTIVE_CAMERA == 1    return perspectiveDepthToViewZ( depth, nearClip, farClip );    #else    return orthographicDepthToViewZ( depth, nearClip, farClip );    #endif   }     void main() {     vec2 aspectcorrect = vec2( 1.0, aspect );     float viewZ = getViewZ( getDepth( vUv ) );     float factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation     vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );     vec2 dofblur9 = dofblur * 0.9;    vec2 dofblur7 = dofblur * 0.7;    vec2 dofblur4 = dofblur * 0.4;     vec4 col = vec4( 0.0 );     col += texture2D( tColor, vUv.xy );    col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );    col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );    col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );    col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );    col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );    col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );    col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );    col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );    col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );    col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );    col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );    col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );    col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );    col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );    col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );    col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );     col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );    col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );    col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );    col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );    col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );    col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );    col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );    col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );     col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );    col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );    col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );    col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );    col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );    col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );    col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );    col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );     col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );    col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );    col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );    col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );    col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );    col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );    col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );    col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );     gl_FragColor = col / 41.0;    gl_FragColor.a = 1.0;    }|  };  export { BokehShader }; 
^..^ FILENAME ^..^
addons|shaders|BokehShader2.js
^..^ CONTENTS ^..^
import {  Vector2 } from 'three';  /**  * Depth-of-field shader with bokeh  * ported from GLSL shader by Martins Upitis  * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)  *  * Requires #define RINGS and SAMPLES integers  */ const BokehShader = {   name: 'BokehShader',   uniforms: {    'textureWidth': { value: 1.0 },   'textureHeight': { value: 1.0 },    'focalDepth': { value: 1.0 },   'focalLength': { value: 24.0 },   'fstop': { value: 0.9 },    'tColor': { value: null },   'tDepth': { value: null },    'maxblur': { value: 1.0 },    'showFocus': { value: 0 },   'manualdof': { value: 0 },   'vignetting': { value: 0 },   'depthblur': { value: 0 },    'threshold': { value: 0.5 },   'gain': { value: 2.0 },   'bias': { value: 0.5 },   'fringe': { value: 0.7 },    'znear': { value: 0.1 },   'zfar': { value: 100 },    'noise': { value: 1 },   'dithering': { value: 0.0001 },   'pentagon': { value: 0 },    'shaderFocus': { value: 1 },   'focusCoords': { value: new Vector2() }    },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    #include <common>    varying vec2 vUv;    uniform sampler2D tColor;   uniform sampler2D tDepth;   uniform float textureWidth;   uniform float textureHeight;    uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below   uniform float focalLength; //focal length in mm   uniform float fstop; //f-stop value   uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)    /*   make sure that these two values are the same for your camera, otherwise distances will be wrong.   */    uniform float znear; // camera clipping start   uniform float zfar; // camera clipping end    //------------------------------------------   //user variables    const int samples = SAMPLES; //samples on the first ring   const int rings = RINGS; //ring count    const int maxringsamples = rings * samples;    uniform bool manualdof; // manual dof calculation   float ndofstart = 1.0; // near dof blur start   float ndofdist = 2.0; // near dof blur falloff distance   float fdofstart = 1.0; // far dof blur start   float fdofdist = 3.0; // far dof blur falloff distance    float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)    uniform bool vignetting; // use optical lens vignetting    float vignout = 1.3; // vignetting outer border   float vignin = 0.0; // vignetting inner border   float vignfade = 22.0; // f-stops till vignete fades    uniform bool shaderFocus;   // disable if you use external focalDepth value    uniform vec2 focusCoords;   // autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)   // if center of screen use vec2(0.5, 0.5);    uniform float maxblur;   //clamp value of max blur (0.0 = no blur, 1.0 default)    uniform float threshold; // highlight threshold;   uniform float gain; // highlight gain;    uniform float bias; // bokeh edge bias   uniform float fringe; // bokeh chromatic aberration / fringing    uniform bool noise; //use noise instead of pattern for sample dithering    uniform float dithering;    uniform bool depthblur; // blur the depth buffer   float dbsize = 1.25; // depth blur size    /*   next part is experimental   not looking good with small sample and ring count   looks okay starting from samples = 4, rings = 4   */    uniform bool pentagon; //use pentagon as bokeh shape?   float feather = 0.4; //pentagon shape feather    //------------------------------------------    float penta(vec2 coords) {    //pentagonal shape    float scale = float(rings) - 1.3;    vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);    vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);    vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);    vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);    vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);    vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);     vec4  one = vec4( 1.0 );     vec4 P = vec4((coords),vec2(scale, scale));     vec4 dist = vec4(0.0);    float inorout = -4.0;     dist.x = dot( P, HS0 );    dist.y = dot( P, HS1 );    dist.z = dot( P, HS2 );    dist.w = dot( P, HS3 );     dist = smoothstep( -feather, feather, dist );     inorout += dot( dist, one );     dist.x = dot( P, HS4 );    dist.y = HS5.w - abs( P.z );     dist = smoothstep( -feather, feather, dist );    inorout += dist.x;     return clamp( inorout, 0.0, 1.0 );   }    float bdepth(vec2 coords) {    // Depth buffer blur    float d = 0.0;    float kernel[9];    vec2 offset[9];     vec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;     offset[0] = vec2(-wh.x,-wh.y);    offset[1] = vec2( 0.0, -wh.y);    offset[2] = vec2( wh.x -wh.y);     offset[3] = vec2(-wh.x,  0.0);    offset[4] = vec2( 0.0,   0.0);    offset[5] = vec2( wh.x,  0.0);     offset[6] = vec2(-wh.x, wh.y);    offset[7] = vec2( 0.0,  wh.y);    offset[8] = vec2( wh.x, wh.y);     kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;    kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;    kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;      for( int i=0; i<9; i++ ) {     float tmp = texture2D(tDepth, coords + offset[i]).r;     d += tmp * kernel[i];    }     return d;   }     vec3 color(vec2 coords,float blur) {    //processing the sample     vec3 col = vec3(0.0);    vec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);     col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;    col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;    col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;     vec3 lumcoeff = vec3(0.299,0.587,0.114);    float lum = dot(col.rgb, lumcoeff);    float thresh = max((lum-threshold)*gain, 0.0);    return col+mix(vec3(0.0),col,thresh*blur);   }    vec3 debugFocus(vec3 col, float blur, float depth) {    float edge = 0.002*depth; //distance based edge smoothing    float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);    float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);     col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);    col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);     return col;   }    float linearize(float depth) {    return -zfar * znear / (depth * (zfar - znear) - zfar);   }    float vignette() {    float dist = distance(vUv.xy, vec2(0.5,0.5));    dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);    return clamp(dist,0.0,1.0);   }    float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {    float rings2 = float(rings);    float step = PI*2.0 / float(ringsamples);    float pw = cos(j*step)*i;    float ph = sin(j*step)*i;    float p = 1.0;    if (pentagon) {     p = penta(vec2(pw,ph));    }    col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;    return 1.0 * mix(1.0, i /rings2, bias) * p;   }    void main() {    //scene depth calculation     float depth = linearize(texture2D(tDepth,vUv.xy).x);     // Blur depth?    if ( depthblur ) {     depth = linearize(bdepth(vUv.xy));    }     //focal plane calculation     float fDepth = focalDepth;     if (shaderFocus) {      fDepth = linearize(texture2D(tDepth,focusCoords).x);     }     // dof blur factor calculation     float blur = 0.0;     if (manualdof) {     float a = depth-fDepth; // Focal plane     float b = (a-fdofstart)/fdofdist; // Far DoF     float c = (-a-ndofstart)/ndofdist; // Near Dof     blur = (a>0.0) ? b : c;    } else {     float f = focalLength; // focal length in mm     float d = fDepth*1000.0; // focal plane in mm     float o = depth*1000.0; // depth in mm      float a = (o*f)/(o-f);     float b = (d*f)/(d-f);     float c = (d-f)/(d*fstop*CoC);      blur = abs(a-b)*c;    }     blur = clamp(blur,0.0,1.0);     // calculation of pattern for dithering     vec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;     // getting blur x and y step factor     float w = (1.0/textureWidth)*blur*maxblur+noise.x;    float h = (1.0/textureHeight)*blur*maxblur+noise.y;     // calculation of final color     vec3 col = vec3(0.0);     if(blur < 0.05) {     //some optimization thingy     col = texture2D(tColor, vUv.xy).rgb;    } else {     col = texture2D(tColor, vUv.xy).rgb;     float s = 1.0;     int ringsamples;      for (int i = 1; i <= rings; i++) {      /*unboxstart*/      ringsamples = i * samples;       for (int j = 0 ; j < maxringsamples ; j++) {       if (j >= ringsamples) break;       s += gather(float(i), float(j), ringsamples, col, w, h, blur);      }      /*unboxend*/     }      col /= s; //divide by sample count    }     if (showFocus) {     col = debugFocus(col, blur, depth);    }     if (vignetting) {     col *= vignette();    }     gl_FragColor.rgb = col;    gl_FragColor.a = 1.0;     #include <tonemapping_fragment>    #include <colorspace_fragment>   }|  };  const BokehDepthShader = {   name: 'BokehDepthShader',   uniforms: {    'mNear': { value: 1.0 },   'mFar': { value: 1000.0 },   },   vertexShader: /* glsl */|    varying float vViewZDepth;    void main() {     #include <begin_vertex>    #include <project_vertex>     vViewZDepth = - mvPosition.z;    }|,   fragmentShader: /* glsl */|    uniform float mNear;   uniform float mFar;    varying float vViewZDepth;    void main() {     float color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );    gl_FragColor = vec4( vec3( color ), 1.0 );    }|  };  export { BokehShader, BokehDepthShader }; 
^..^ FILENAME ^..^
addons|shaders|BrightnessContrastShader.js
^..^ CONTENTS ^..^
/**  * Brightness and contrast adjustment  * https://github.com/evanw/glfx.js  * brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)  * contrast: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)  */  const BrightnessContrastShader = {   name: 'BrightnessContrastShader',   uniforms: {    'tDiffuse': { value: null },   'brightness': { value: 0 },   'contrast': { value: 0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;   uniform float brightness;   uniform float contrast;    varying vec2 vUv;    void main() {     gl_FragColor = texture2D( tDiffuse, vUv );     gl_FragColor.rgb += brightness;     if (contrast > 0.0) {     gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;    } else {     gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;    }    }|  };  export { BrightnessContrastShader }; 
^..^ FILENAME ^..^
addons|shaders|ColorCorrectionShader.js
^..^ CONTENTS ^..^
import {  Vector3 } from 'three';  /**  * Color correction  */  const ColorCorrectionShader = {   name: 'ColorCorrectionShader',   uniforms: {    'tDiffuse': { value: null },   'powRGB': { value: new Vector3( 2, 2, 2 ) },   'mulRGB': { value: new Vector3( 1, 1, 1 ) },   'addRGB': { value: new Vector3( 0, 0, 0 ) }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;   uniform vec3 powRGB;   uniform vec3 mulRGB;   uniform vec3 addRGB;    varying vec2 vUv;    void main() {     gl_FragColor = texture2D( tDiffuse, vUv );    gl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );    }|  };  export { ColorCorrectionShader }; 
^..^ FILENAME ^..^
addons|shaders|ColorifyShader.js
^..^ CONTENTS ^..^
import {  Color } from 'three';  /**  * Colorify shader  */  const ColorifyShader = {   name: 'ColorifyShader',   uniforms: {    'tDiffuse': { value: null },   'color': { value: new Color( 0xffffff ) }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform vec3 color;   uniform sampler2D tDiffuse;    varying vec2 vUv;    void main() {     vec4 texel = texture2D( tDiffuse, vUv );     float v = luminance( texel.xyz );     gl_FragColor = vec4( v * color, texel.w );    }|  };  export { ColorifyShader }; 
^..^ FILENAME ^..^
addons|shaders|ConvolutionShader.js
^..^ CONTENTS ^..^
import {  Vector2 } from 'three';  /**  * Convolution shader  * ported from o3d sample to WebGL / GLSL  */  const ConvolutionShader = {   name: 'ConvolutionShader',   defines: {    'KERNEL_SIZE_FLOAT': '25.0',   'KERNEL_SIZE_INT': '25'   },   uniforms: {    'tDiffuse': { value: null },   'uImageIncrement': { value: new Vector2( 0.001953125, 0.0 ) },   'cKernel': { value: [] }   },   vertexShader: /* glsl */|    uniform vec2 uImageIncrement;    varying vec2 vUv;    void main() {     vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform float cKernel[ KERNEL_SIZE_INT ];    uniform sampler2D tDiffuse;   uniform vec2 uImageIncrement;    varying vec2 vUv;    void main() {     vec2 imageCoord = vUv;    vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );     for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {      sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];     imageCoord += uImageIncrement;     }     gl_FragColor = sum;    }|,   buildKernel: function ( sigma ) {    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.    const kMaxKernelSize = 25;   let kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;    if ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;    const halfWidth = ( kernelSize - 1 ) * 0.5;    const values = new Array( kernelSize );   let sum = 0.0;   for ( let i = 0; i < kernelSize; ++ i ) {     values[ i ] = gauss( i - halfWidth, sigma );    sum += values[ i ];    }    // normalize the kernel    for ( let i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;    return values;   }  };  function gauss( x, sigma ) {   return Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );  }  export { ConvolutionShader }; 
^..^ FILENAME ^..^
addons|shaders|CopyShader.js
^..^ CONTENTS ^..^
/**  * Full-screen textured quad shader  */  const CopyShader = {   name: 'CopyShader',   uniforms: {    'tDiffuse': { value: null },   'opacity': { value: 1.0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform float opacity;    uniform sampler2D tDiffuse;    varying vec2 vUv;    void main() {     vec4 texel = texture2D( tDiffuse, vUv );    gl_FragColor = opacity * texel;     }|  };  export { CopyShader }; 
^..^ FILENAME ^..^
addons|shaders|DepthLimitedBlurShader.js
^..^ CONTENTS ^..^
import {  Vector2 } from 'three';  /**  * TODO  */  const DepthLimitedBlurShader = {   name: 'DepthLimitedBlurShader',   defines: {   'KERNEL_RADIUS': 4,   'DEPTH_PACKING': 1,   'PERSPECTIVE_CAMERA': 1  },   uniforms: {   'tDiffuse': { value: null },   'size': { value: new Vector2( 512, 512 ) },   'sampleUvOffsets': { value: [ new Vector2( 0, 0 ) ] },   'sampleWeights': { value: [ 1.0 ] },   'tDepth': { value: null },   'cameraNear': { value: 10 },   'cameraFar': { value: 1000 },   'depthCutoff': { value: 10 },  },   vertexShader: /* glsl */|    #include <common>    uniform vec2 size;    varying vec2 vUv;   varying vec2 vInvSize;    void main() {    vUv = uv;    vInvSize = 1.0 / size;     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );   }|,   fragmentShader: /* glsl */|    #include <common>   #include <packing>    uniform sampler2D tDiffuse;   uniform sampler2D tDepth;    uniform float cameraNear;   uniform float cameraFar;   uniform float depthCutoff;    uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];   uniform float sampleWeights[ KERNEL_RADIUS + 1 ];    varying vec2 vUv;   varying vec2 vInvSize;    float getDepth( const in vec2 screenPosition ) {    #if DEPTH_PACKING == 1    return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );    #else    return texture2D( tDepth, screenPosition ).x;    #endif   }    float getViewZ( const in float depth ) {    #if PERSPECTIVE_CAMERA == 1    return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );    #else    return orthographicDepthToViewZ( depth, cameraNear, cameraFar );    #endif   }    void main() {    float depth = getDepth( vUv );    if( depth >= ( 1.0 - EPSILON ) ) {     discard;    }     float centerViewZ = -getViewZ( depth );    bool rBreak = false, lBreak = false;     float weightSum = sampleWeights[0];    vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;     for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {      float sampleWeight = sampleWeights[i];     vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;      vec2 sampleUv = vUv + sampleUvOffset;     float viewZ = -getViewZ( getDepth( sampleUv ) );      if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;      if( ! rBreak ) {      diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;      weightSum += sampleWeight;     }      sampleUv = vUv - sampleUvOffset;     viewZ = -getViewZ( getDepth( sampleUv ) );      if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;      if( ! lBreak ) {      diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;      weightSum += sampleWeight;     }     }     gl_FragColor = diffuseSum / weightSum;   }|  };  const BlurShaderUtils = {   createSampleWeights: function ( kernelRadius, stdDev ) {    const weights = [];    for ( let i = 0; i <= kernelRadius; i ++ ) {     weights.push( gaussian( i, stdDev ) );    }    return weights;   },   createSampleOffsets: function ( kernelRadius, uvIncrement ) {    const offsets = [];    for ( let i = 0; i <= kernelRadius; i ++ ) {     offsets.push( uvIncrement.clone().multiplyScalar( i ) );    }    return offsets;   },   configure: function ( material, kernelRadius, stdDev, uvIncrement ) {    material.defines[ 'KERNEL_RADIUS' ] = kernelRadius;   material.uniforms[ 'sampleUvOffsets' ].value = BlurShaderUtils.createSampleOffsets( kernelRadius, uvIncrement );   material.uniforms[ 'sampleWeights' ].value = BlurShaderUtils.createSampleWeights( kernelRadius, stdDev );   material.needsUpdate = true;   }  };  function gaussian( x, stdDev ) {   return Math.exp( - ( x * x ) / ( 2.0 * ( stdDev * stdDev ) ) ) / ( Math.sqrt( 2.0 * Math.PI ) * stdDev );  }  export { DepthLimitedBlurShader, BlurShaderUtils }; 
^..^ FILENAME ^..^
addons|shaders|DigitalGlitch.js
^..^ CONTENTS ^..^
/**  * RGB Shift Shader  * Shifts red and blue channels from center in opposite directions  * Ported from http://kriss.cx/tom/2009/05/rgb-shift/  * by Tom Butterworth / http://kriss.cx/tom/  *  * amount: shift distance (1 is width of input)  * angle: shift angle in radians  */  const DigitalGlitch = {   uniforms: {    'tDiffuse': { value: null }, //diffuse texture   'tDisp': { value: null }, //displacement texture for digital glitch squares   'byp': { value: 0 }, //apply the glitch ?   'amount': { value: 0.08 },   'angle': { value: 0.02 },   'seed': { value: 0.02 },   'seed_x': { value: 0.02 }, //-1,1   'seed_y': { value: 0.02 }, //-1,1   'distortion_x': { value: 0.5 },   'distortion_y': { value: 0.6 },   'col_s': { value: 0.05 }  },   vertexShader: /* glsl */|    varying vec2 vUv;   void main() {    vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );   }|,   fragmentShader: /* glsl */|    uniform int byp; //should we apply the glitch ?    uniform sampler2D tDiffuse;   uniform sampler2D tDisp;    uniform float amount;   uniform float angle;   uniform float seed;   uniform float seed_x;   uniform float seed_y;   uniform float distortion_x;   uniform float distortion_y;   uniform float col_s;    varying vec2 vUv;     float rand(vec2 co){    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);   }    void main() {    if(byp<1) {     vec2 p = vUv;     float xs = floor(gl_FragCoord.x / 0.5);     float ys = floor(gl_FragCoord.y / 0.5);     //based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch     float disp = texture2D(tDisp, p*seed*seed).r;     if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {      if(seed_x>0.){       p.y = 1. - (p.y + distortion_y);      }      else {       p.y = distortion_y;      }     }     if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {      if(seed_y>0.){       p.x=distortion_x;      }      else {       p.x = 1. - (p.x + distortion_x);      }     }     p.x+=disp*seed_x*(seed/5.);     p.y+=disp*seed_y*(seed/5.);     //base from RGB shift shader     vec2 offset = amount * vec2( cos(angle), sin(angle));     vec4 cr = texture2D(tDiffuse, p + offset);     vec4 cga = texture2D(tDiffuse, p);     vec4 cb = texture2D(tDiffuse, p - offset);     gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);     //add noise     vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);     gl_FragColor = gl_FragColor+ snow;    }    else {     gl_FragColor=texture2D (tDiffuse, vUv);    }   }|  };  export { DigitalGlitch }; 
^..^ FILENAME ^..^
addons|shaders|DOFMipMapShader.js
^..^ CONTENTS ^..^
/**  * Depth-of-field shader using mipmaps  * - from Matt Handley @applmak  * - requires power-of-2 sized render target with enabled mipmaps  */  const DOFMipMapShader = {   name: 'DOFMipMapShader',   uniforms: {    'tColor': { value: null },   'tDepth': { value: null },   'focus': { value: 1.0 },   'maxblur': { value: 1.0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform float focus;   uniform float maxblur;    uniform sampler2D tColor;   uniform sampler2D tDepth;    varying vec2 vUv;    void main() {     vec4 depth = texture2D( tDepth, vUv );     float factor = depth.x - focus;     vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );     gl_FragColor = col;    gl_FragColor.a = 1.0;    }|  };  export { DOFMipMapShader }; 
^..^ FILENAME ^..^
addons|shaders|DotScreenShader.js
^..^ CONTENTS ^..^
import {  Vector2 } from 'three';  /**  * Dot screen shader  * based on glfx.js sepia shader  * https://github.com/evanw/glfx.js  */  const DotScreenShader = {   name: 'DotScreenShader',   uniforms: {    'tDiffuse': { value: null },   'tSize': { value: new Vector2( 256, 256 ) },   'center': { value: new Vector2( 0.5, 0.5 ) },   'angle': { value: 1.57 },   'scale': { value: 1.0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform vec2 center;   uniform float angle;   uniform float scale;   uniform vec2 tSize;    uniform sampler2D tDiffuse;    varying vec2 vUv;    float pattern() {     float s = sin( angle ), c = cos( angle );     vec2 tex = vUv * tSize - center;    vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;     return ( sin( point.x ) * sin( point.y ) ) * 4.0;    }    void main() {     vec4 color = texture2D( tDiffuse, vUv );     float average = ( color.r + color.g + color.b ) / 3.0;     gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );    }|  };  export { DotScreenShader }; 
^..^ FILENAME ^..^
addons|shaders|ExposureShader.js
^..^ CONTENTS ^..^
/**  * Exposure shader  */  const ExposureShader = {   name: 'ExposureShader',   uniforms: {    'tDiffuse': { value: null },   'exposure': { value: 1.0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform float exposure;    uniform sampler2D tDiffuse;    varying vec2 vUv;    void main() {     gl_FragColor = texture2D( tDiffuse, vUv );    gl_FragColor.rgb *= exposure;    }|  };  export { ExposureShader }; 
^..^ FILENAME ^..^
addons|shaders|FilmShader.js
^..^ CONTENTS ^..^
const FilmShader = {   name: 'FilmShader',   uniforms: {    'tDiffuse': { value: null },   'time': { value: 0.0 },   'intensity': { value: 0.5 },   'grayscale': { value: false }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    #include <common>    uniform float intensity;   uniform bool grayscale;   uniform float time;    uniform sampler2D tDiffuse;    varying vec2 vUv;    void main() {     vec4 base = texture2D( tDiffuse, vUv );     float noise = rand( fract( vUv + time ) );     vec3 color = base.rgb + base.rgb * clamp( 0.1 + noise, 0.0, 1.0 );     color = mix( base.rgb, color, intensity );     if ( grayscale ) {      color = vec3( luminance( color ) ); // assuming linear-srgb     }     gl_FragColor = vec4( color, base.a );    }|,  };  export { FilmShader }; 
^..^ FILENAME ^..^
addons|shaders|FocusShader.js
^..^ CONTENTS ^..^
/**  * Focus shader  * based on PaintEffect postprocess from ro.me  * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js  */  const FocusShader = {   name: 'FocusShader',   uniforms: {    'tDiffuse': { value: null },   'screenWidth': { value: 1024 },   'screenHeight': { value: 1024 },   'sampleDistance': { value: 0.94 },   'waveFactor': { value: 0.00125 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform float screenWidth;   uniform float screenHeight;   uniform float sampleDistance;   uniform float waveFactor;    uniform sampler2D tDiffuse;    varying vec2 vUv;    void main() {     vec4 color, org, tmp, add;    float sample_dist, f;    vec2 vin;    vec2 uv = vUv;     add = color = org = texture2D( tDiffuse, uv );     vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );    sample_dist = dot( vin, vin ) * 2.0;     f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;     vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );     add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );    if( tmp.b < color.b ) color = tmp;     add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );    if( tmp.b < color.b ) color = tmp;     add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );    if( tmp.b < color.b ) color = tmp;     add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );    if( tmp.b < color.b ) color = tmp;     add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );    if( tmp.b < color.b ) color = tmp;     add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );    if( tmp.b < color.b ) color = tmp;     add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );    if( tmp.b < color.b ) color = tmp;     color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );    color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );     gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );    }|  };  export { FocusShader }; 
^..^ FILENAME ^..^
addons|shaders|FreiChenShader.js
^..^ CONTENTS ^..^
import {  Vector2 } from 'three';  /**  * Edge Detection Shader using Frei-Chen filter  * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector  *  * aspect: vec2 of (1/width, 1/height)  */  const FreiChenShader = {   name: 'FreiChenShader',   uniforms: {    'tDiffuse': { value: null },   'aspect': { value: new Vector2( 512, 512 ) }  },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;   varying vec2 vUv;    uniform vec2 aspect;    vec2 texel = vec2( 1.0 / aspect.x, 1.0 / aspect.y );     mat3 G[9];    // hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45    const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );   const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );   const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );   const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );   const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );   const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );   const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );   const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );   const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );    void main(void)   {     G[0] = g0,    G[1] = g1,    G[2] = g2,    G[3] = g3,    G[4] = g4,    G[5] = g5,    G[6] = g6,    G[7] = g7,    G[8] = g8;     mat3 I;    float cnv[9];    vec3 sample;    /* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */    for (float i=0.0; i<3.0; i++) {     for (float j=0.0; j<3.0; j++) {      sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;      I[int(i)][int(j)] = length(sample);     }    }    /* calculate the convolution values for all the masks */    for (int i=0; i<9; i++) {     float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);     cnv[i] = dp3 * dp3;    }     float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);    float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);     gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);   }|  };  export { FreiChenShader }; 
^..^ FILENAME ^..^
addons|shaders|FXAAShader.js
^..^ CONTENTS ^..^
import {  Vector2 } from 'three';  /**  * NVIDIA FXAA by Timothy Lottes  * https://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf  * - WebGL port by @supereggbert  * http://www.glge.org/demos/fxaa/  * Further improved by Daniel Sturk  */  const FXAAShader = {   name: 'FXAAShader',   uniforms: {    'tDiffuse': { value: null },   'resolution': { value: new Vector2( 1 / 1024, 1 / 512 ) }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|   precision highp float;    uniform sampler2D tDiffuse;    uniform vec2 resolution;    varying vec2 vUv;    // FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)    //----------------------------------------------------------------------------------   // File:        es3-kepler|FXAA|assets|shaders/FXAA_DefaultES.frag   // SDK Version: v3.00   // Email:       gameworks@nvidia.com   // Site:        http://developer.nvidia.com/   //   // Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.   //   // Redistribution and use in source and binary forms, with or without   // modification, are permitted provided that the following conditions   // are met:   //  * Redistributions of source code must retain the above copyright   //    notice, this list of conditions and the following disclaimer.   //  * Redistributions in binary form must reproduce the above copyright   //    notice, this list of conditions and the following disclaimer in the   //    documentation and/or other materials provided with the distribution.   //  * Neither the name of NVIDIA CORPORATION nor the names of its   //    contributors may be used to endorse or promote products derived   //    from this software without specific prior written permission.   //   // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY   // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR   // PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR   // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,   // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,   // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR   // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY   // OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE   // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   //   //----------------------------------------------------------------------------------    #ifndef FXAA_DISCARD    //    // Only valid for PC OpenGL currently.    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.    //    // 1 = Use discard on pixels which don't need AA.    //     For APIs which enable concurrent TEX+ROP from same surface.    // 0 = Return unchanged color on pixels which don't need AA.    //    #define FXAA_DISCARD 0   #endif    /*--------------------------------------------------------------------------*/   #define FxaaTexTop(t, p) texture2D(t, p, -100.0)   #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)   /*--------------------------------------------------------------------------*/    #define NUM_SAMPLES 5    // assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha   float contrast( vec4 a, vec4 b ) {    vec4 diff = abs( a - b );    return max( max( max( diff.r, diff.g ), diff.b ), diff.a );   }    /*============================================================================           FXAA3 QUALITY - PC    ============================================================================*/    /*--------------------------------------------------------------------------*/   vec4 FxaaPixelShader(    vec2 posM,    sampler2D tex,    vec2 fxaaQualityRcpFrame,    float fxaaQualityEdgeThreshold,    float fxaaQualityinvEdgeThreshold   ) {    vec4 rgbaM = FxaaTexTop(tex, posM);    vec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);    vec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);    vec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);    vec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);    // . S .    // W M E    // . N .     bool earlyExit = max( max( max(      contrast( rgbaM, rgbaN ),      contrast( rgbaM, rgbaS ) ),      contrast( rgbaM, rgbaE ) ),      contrast( rgbaM, rgbaW ) )      < fxaaQualityEdgeThreshold;    // . 0 .    // 0 0 0    // . 0 .     #if (FXAA_DISCARD == 1)     if(earlyExit) FxaaDiscard;    #else     if(earlyExit) return rgbaM;    #endif     float contrastN = contrast( rgbaM, rgbaN );    float contrastS = contrast( rgbaM, rgbaS );    float contrastE = contrast( rgbaM, rgbaE );    float contrastW = contrast( rgbaM, rgbaW );     float relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );    relativeVContrast *= fxaaQualityinvEdgeThreshold;     bool horzSpan = relativeVContrast > 0.;    // . 1 .    // 0 0 0    // . 1 .     // 45 deg edge detection and corners of objects, aka V/H contrast is too similar    if( abs( relativeVContrast ) < .3 ) {     // locate the edge     vec2 dirToEdge;     dirToEdge.x = contrastE > contrastW ? 1. : -1.;     dirToEdge.y = contrastS > contrastN ? 1. : -1.;     // . 2 .      . 1 .     // 1 0 2  ~=  0 0 1     // . 1 .      . 0 .      // tap 2 pixels and see which ones are "outside" the edge, to     // determine if the edge is vertical or horizontal      vec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);     float matchAlongH = contrast( rgbaM, rgbaAlongH );     // . 1 .     // 0 0 1     // . 0 H      vec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);     float matchAlongV = contrast( rgbaM, rgbaAlongV );     // V 1 .     // 0 0 1     // . 0 .      relativeVContrast = matchAlongV - matchAlongH;     relativeVContrast *= fxaaQualityinvEdgeThreshold;      if( abs( relativeVContrast ) < .3 ) { // 45 deg edge      // 1 1 .      // 0 0 1      // . 0 1       // do a simple blur      return mix(       rgbaM,       (rgbaN + rgbaS + rgbaE + rgbaW) * .25,       .4      );     }      horzSpan = relativeVContrast > 0.;    }     if(!horzSpan) rgbaN = rgbaW;    if(!horzSpan) rgbaS = rgbaE;    // . 0 .      1    // 1 0 1  ->  0    // . 0 .      1     bool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );    if(!pairN) rgbaN = rgbaS;     vec2 offNP;    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;     bool doneN = false;    bool doneP = false;     float nDist = 0.;    float pDist = 0.;     vec2 posN = posM;    vec2 posP = posM;     int iterationsUsedN = 0;    int iterationsUsedP = 0;    for( int i = 0; i < NUM_SAMPLES; i++ ) {      float increment = float(i + 1);      if(!doneN) {      nDist += increment;      posN = posM + offNP * nDist;      vec4 rgbaEndN = FxaaTexTop(tex, posN.xy);      doneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );      iterationsUsedN = i;     }      if(!doneP) {      pDist += increment;      posP = posM - offNP * pDist;      vec4 rgbaEndP = FxaaTexTop(tex, posP.xy);      doneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );      iterationsUsedP = i;     }      if(doneN || doneP) break;    }      if ( !doneP && !doneN ) return rgbaM; // failed to find end of edge     float dist = min(     doneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,     doneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.    );     // hacky way of reduces blurriness of mostly diagonal edges    // but reduces AA quality    dist = pow(dist, .5);     dist = 1. - dist;     return mix(     rgbaM,     rgbaN,     dist * .5    );   }    void main() {    const float edgeDetectionQuality = .2;    const float invEdgeDetectionQuality = 1. / edgeDetectionQuality;     gl_FragColor = FxaaPixelShader(     vUv,     tDiffuse,     resolution,     edgeDetectionQuality, // [0,1] contrast needed, otherwise early discard     invEdgeDetectionQuality    );    }  |  };  export { FXAAShader }; 
^..^ FILENAME ^..^
addons|shaders|GammaCorrectionShader.js
^..^ CONTENTS ^..^
/**  * Gamma Correction Shader  * http://en.wikipedia.org/wiki/gamma_correction  */  const GammaCorrectionShader = {   name: 'GammaCorrectionShader',   uniforms: {    'tDiffuse': { value: null }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;    varying vec2 vUv;    void main() {     vec4 tex = texture2D( tDiffuse, vUv );     gl_FragColor = sRGBTransferOETF( tex );    }|  };  export { GammaCorrectionShader }; 
^..^ FILENAME ^..^
addons|shaders|GodRaysShader.js
^..^ CONTENTS ^..^
import {  Color,  Vector3 } from 'three';  /**  * God-rays (crepuscular rays)  *  * Similar implementation to the one used by Crytek for CryEngine 2 [Sousa2008].  * Blurs a mask generated from the depth map along radial lines emanating from the light  * source. The blur repeatedly applies a blur filter of increasing support but constant  * sample count to produce a blur filter with large support.  *  * My implementation performs 3 passes, similar to the implementation from Sousa. I found  * just 6 samples per pass produced acceptible results. The blur is applied three times,  * with decreasing filter support. The result is equivalent to a single pass with  * 6*6*6 = 216 samples.  *  * References:  *  * Sousa2008 - Crysis Next Gen Effects, GDC2008, http://www.crytek.com/sites/default/files/GDC08_SousaT_CrysisEffects.ppt  */  const GodRaysDepthMaskShader = {   name: 'GodRaysDepthMaskShader',   uniforms: {    tInput: {    value: null   }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    varying vec2 vUv;    uniform sampler2D tInput;    void main() {     gl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );    }|  };   /**  * The god-ray generation shader.  *  * First pass:  *  * The depth map is blurred along radial lines towards the "sun". The  * output is written to a temporary render target (I used a 1/4 sized  * target).  *  * Pass two & three:  *  * The results of the previous pass are re-blurred, each time with a  * decreased distance between samples.  */  const GodRaysGenerateShader = {   name: 'GodRaysGenerateShader',   uniforms: {    tInput: {    value: null   },   fStepSize: {    value: 1.0   },   vSunPositionScreenSpace: {    value: new Vector3()   }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    #define TAPS_PER_PASS 6.0    varying vec2 vUv;    uniform sampler2D tInput;    uniform vec3 vSunPositionScreenSpace;   uniform float fStepSize; // filter step size    void main() {    // delta from current pixel to "sun" position     vec2 delta = vSunPositionScreenSpace.xy - vUv;    float dist = length( delta );    // Step vector (uv space)     vec2 stepv = fStepSize * delta / dist;    // Number of iterations between pixel and sun     float iters = dist/fStepSize;     vec2 uv = vUv.xy;    float col = 0.0;    // This breaks ANGLE in Chrome 22   // - see http://code.google.com/p/chromium/issues/detail?id=153105    /*   // Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),   // so i've just left the loop    "for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {",    // Accumulate samples, making sure we dont walk past the light source.    // The check for uv.y < 1 would not be necessary with "border" UV wrap   // mode, with a black border color. I don't think this is currently   // exposed by three.js. As a result there might be artifacts when the   // sun is to the left, right or bottom of screen as these cases are   // not specifically handled.    " col += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );",   " uv += stepv;",    "}",   */    // Unrolling loop manually makes it work in ANGLE     float f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) ); // used to fade out godrays     if ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;    uv += stepv;     if ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;    uv += stepv;     if ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;    uv += stepv;     if ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;    uv += stepv;     if ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;    uv += stepv;     if ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;    uv += stepv;    // Should technically be dividing by 'iters but 'TAPS_PER_PASS' smooths out   // objectionable artifacts, in particular near the sun position. The side   // effect is that the result is darker than it should be around the sun, as   // TAPS_PER_PASS is greater than the number of samples actually accumulated.   // When the result is inverted (in the shader 'godrays_combine this produces   // a slight bright spot at the position of the sun, even when it is occluded.     gl_FragColor = vec4( col/TAPS_PER_PASS );    gl_FragColor.a = 1.0;    }|  };  /**  * Additively applies god rays from texture tGodRays to a background (tColors).  * fGodRayIntensity attenuates the god rays.  */  const GodRaysCombineShader = {   name: 'GodRaysCombineShader',   uniforms: {    tColors: {    value: null   },    tGodRays: {    value: null   },    fGodRayIntensity: {    value: 0.69   }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    varying vec2 vUv;    uniform sampler2D tColors;   uniform sampler2D tGodRays;    uniform float fGodRayIntensity;    void main() {    // Since THREE.MeshDepthMaterial renders foreground objects white and background   // objects black, the god-rays will be white streaks. Therefore value is inverted   // before being combined with tColors     gl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );    gl_FragColor.a = 1.0;    }|  };   /**  * A dodgy sun/sky shader. Makes a bright spot at the sun location. Would be  * cheaper/faster/simpler to implement this as a simple sun sprite.  */  const GodRaysFakeSunShader = {   name: 'GodRaysFakeSunShader',   uniforms: {    vSunPositionScreenSpace: {    value: new Vector3()   },    fAspect: {    value: 1.0   },    sunColor: {    value: new Color( 0xffee00 )   },    bgColor: {    value: new Color( 0x000000 )   }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    varying vec2 vUv;    uniform vec3 vSunPositionScreenSpace;   uniform float fAspect;    uniform vec3 sunColor;   uniform vec3 bgColor;    void main() {     vec2 diff = vUv - vSunPositionScreenSpace.xy;    // Correct for aspect ratio     diff.x *= fAspect;     float prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );    prop = 0.35 * pow( 1.0 - prop, 3.0 );     gl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;    gl_FragColor.w = 1.0;    }|  };  export { GodRaysDepthMaskShader, GodRaysGenerateShader, GodRaysCombineShader, GodRaysFakeSunShader }; 
^..^ FILENAME ^..^
addons|shaders|GTAOShader.js
^..^ CONTENTS ^..^
import {  DataTexture,  Matrix4,  RepeatWrapping,  Vector2,  Vector3, } from 'three';  /**  * References:  * - implemented algorithm - GTAO  *   - https://iryoku.com/downloads/Practical-Realtime-Strategies-for-Accurate-Indirect-Occlusion.pdf  *   - https://github.com/Patapom/GodComplex/blob/master/Tests/TestHBIL/2018%20Mayaux%20-%20Horizon-Based%20Indirect%20Lighting%20(HBIL).pdf  *  * - other AO algorithms that are not implemented here:  *   - Screen Space Ambient Occlusion (SSAO), see also SSAOShader.js  *  - http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html  *  - https://learnopengl.com/Advanced-Lighting/SSAO  *  - https://creativecoding.soe.ucsc.edu/courses/cmpm164/_schedule/AmbientOcclusion.pdf  *  - https://drive.google.com/file/d/1SyagcEVplIm2KkRD3WQYSO9O0Iyi1hfy/edit  *   - Scalable Ambient Occlusion (SAO), see also SAOShader.js  *  - https://casual-effects.com/research/McGuire2012SAO/index.html  *    - https://research.nvidia.com/sites/default/files/pubs/2012-06_Scalable-Ambient-Obscurance/McGuire12SAO.pdf  *   - N8HO  *  - https://github.com/N8python/n8ao  *   - Horizon Based Ambient Occlusion (HBAO)  *  - http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.577.2286&rep=rep1&type=pdf  *  - https://www.derschmale.com/2013/12/20/an-alternative-implementation-for-hbao-2/  *  * - further reading  *   - https://ceur-ws.org/Vol-3027/paper5.pdf  *   - https://www.comp.nus.edu.sg/~lowkl/publications/mssao_visual_computer_2012.pdf  *   - https://web.ics.purdue.edu/~tmcgraw/papers/mcgraw-ao-2008.pdf  *   - https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf  *   - https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.390.2463&rep=rep1&type=pdf  *   - https://www.intel.com/content/www/us/en/developer/articles/technical/adaptive-screen-space-ambient-occlusion.html  */  const GTAOShader = {   name: 'GTAOShader',   defines: {   PERSPECTIVE_CAMERA: 1,   SAMPLES: 16,   NORMAL_VECTOR_TYPE: 1,   DEPTH_SWIZZLING: 'x',   SCREEN_SPACE_RADIUS: 0,   SCREEN_SPACE_RADIUS_SCALE: 100.0,   SCENE_CLIP_BOX: 0,  },   uniforms: {   tNormal: { value: null },   tDepth: { value: null },   tNoise: { value: null },   resolution: { value: new Vector2() },   cameraNear: { value: null },   cameraFar: { value: null },   cameraProjectionMatrix: { value: new Matrix4() },   cameraProjectionMatrixInverse: { value: new Matrix4() },   cameraWorldMatrix: { value: new Matrix4() },   radius: { value: 0.25 },   distanceExponent: { value: 1. },   thickness: { value: 1. },   distanceFallOff: { value: 1. },   scale: { value: 1. },   sceneBoxMin: { value: new Vector3( - 1, - 1, - 1 ) },   sceneBoxMax: { value: new Vector3( 1, 1, 1 ) },  },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {    vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );   }|,   fragmentShader: /* glsl */|   varying vec2 vUv;   uniform highp sampler2D tNormal;   uniform highp sampler2D tDepth;   uniform sampler2D tNoise;   uniform vec2 resolution;   uniform float cameraNear;   uniform float cameraFar;   uniform mat4 cameraProjectionMatrix;   uniform mat4 cameraProjectionMatrixInverse;     uniform mat4 cameraWorldMatrix;   uniform float radius;   uniform float distanceExponent;   uniform float thickness;   uniform float distanceFallOff;   uniform float scale;   #if SCENE_CLIP_BOX == 1    uniform vec3 sceneBoxMin;    uniform vec3 sceneBoxMax;   #endif      #include <common>   #include <packing>    #ifndef FRAGMENT_OUTPUT   #define FRAGMENT_OUTPUT vec4(vec3(ao), 1.)   #endif    vec3 getViewPosition(const in vec2 screenPosition, const in float depth) {    vec4 clipSpacePosition = vec4(vec3(screenPosition, depth) * 2.0 - 1.0, 1.0);    vec4 viewSpacePosition = cameraProjectionMatrixInverse * clipSpacePosition;    return viewSpacePosition.xyz / viewSpacePosition.w;   }    float getDepth(const vec2 uv) {      return textureLod(tDepth, uv.xy, 0.0).DEPTH_SWIZZLING;   }    float fetchDepth(const ivec2 uv) {       return texelFetch(tDepth, uv.xy, 0).DEPTH_SWIZZLING;   }    float getViewZ(const in float depth) {    #if PERSPECTIVE_CAMERA == 1     return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);    #else     return orthographicDepthToViewZ(depth, cameraNear, cameraFar);    #endif   }    vec3 computeNormalFromDepth(const vec2 uv) {    vec2 size = vec2(textureSize(tDepth, 0));    ivec2 p = ivec2(uv * size);    float c0 = fetchDepth(p);    float l2 = fetchDepth(p - ivec2(2, 0));    float l1 = fetchDepth(p - ivec2(1, 0));    float r1 = fetchDepth(p + ivec2(1, 0));    float r2 = fetchDepth(p + ivec2(2, 0));    float b2 = fetchDepth(p - ivec2(0, 2));    float b1 = fetchDepth(p - ivec2(0, 1));    float t1 = fetchDepth(p + ivec2(0, 1));    float t2 = fetchDepth(p + ivec2(0, 2));    float dl = abs((2.0 * l1 - l2) - c0);    float dr = abs((2.0 * r1 - r2) - c0);    float db = abs((2.0 * b1 - b2) - c0);    float dt = abs((2.0 * t1 - t2) - c0);    vec3 ce = getViewPosition(uv, c0).xyz;    vec3 dpdx = (dl < dr) ? ce - getViewPosition((uv - vec2(1.0 / size.x, 0.0)), l1).xyz : -ce + getViewPosition((uv + vec2(1.0 / size.x, 0.0)), r1).xyz;    vec3 dpdy = (db < dt) ? ce - getViewPosition((uv - vec2(0.0, 1.0 / size.y)), b1).xyz : -ce + getViewPosition((uv + vec2(0.0, 1.0 / size.y)), t1).xyz;    return normalize(cross(dpdx, dpdy));   }    vec3 getViewNormal(const vec2 uv) {    #if NORMAL_VECTOR_TYPE == 2     return normalize(textureLod(tNormal, uv, 0.).rgb);    #elif NORMAL_VECTOR_TYPE == 1     return unpackRGBToNormal(textureLod(tNormal, uv, 0.).rgb);    #else     return computeNormalFromDepth(uv);    #endif   }    vec3 getSceneUvAndDepth(vec3 sampleViewPos) {    vec4 sampleClipPos = cameraProjectionMatrix * vec4(sampleViewPos, 1.);    vec2 sampleUv = sampleClipPos.xy / sampleClipPos.w * 0.5 + 0.5;    float sampleSceneDepth = getDepth(sampleUv);    return vec3(sampleUv, sampleSceneDepth);   }      void main() {    float depth = getDepth(vUv.xy);    if (depth >= 1.0) {     discard;     return;    }    vec3 viewPos = getViewPosition(vUv, depth);    vec3 viewNormal = getViewNormal(vUv);     float radiusToUse = radius;    float distanceFalloffToUse = thickness;    #if SCREEN_SPACE_RADIUS == 1     float radiusScale = getViewPosition(vec2(0.5 + float(SCREEN_SPACE_RADIUS_SCALE) / resolution.x, 0.0), depth).x;     radiusToUse *= radiusScale;     distanceFalloffToUse *= radiusScale;    #endif     #if SCENE_CLIP_BOX == 1     vec3 worldPos = (cameraWorldMatrix * vec4(viewPos, 1.0)).xyz;     float boxDistance = length(max(vec3(0.0), max(sceneBoxMin - worldPos, worldPos - sceneBoxMax)));     if (boxDistance > radiusToUse) {      discard;      return;     }    #endif        vec2 noiseResolution = vec2(textureSize(tNoise, 0));    vec2 noiseUv = vUv * resolution / noiseResolution;    vec4 noiseTexel = textureLod(tNoise, noiseUv, 0.0);    vec3 randomVec = noiseTexel.xyz * 2.0 - 1.0;    vec3 tangent = normalize(vec3(randomVec.xy, 0.));    vec3 bitangent = vec3(-tangent.y, tangent.x, 0.);    mat3 kernelMatrix = mat3(tangent, bitangent, vec3(0., 0., 1.));     const int DIRECTIONS = SAMPLES < 30 ? 3 : 5;    const int STEPS = (SAMPLES + DIRECTIONS - 1) / DIRECTIONS;    float ao = 0.0;    for (int i = 0; i < DIRECTIONS; ++i) {          float angle = float(i) / float(DIRECTIONS) * PI;     vec4 sampleDir = vec4(cos(angle), sin(angle), 0., 0.5 + 0.5 * noiseTexel.w);      sampleDir.xyz = normalize(kernelMatrix * sampleDir.xyz);      vec3 viewDir = normalize(-viewPos.xyz);     vec3 sliceBitangent = normalize(cross(sampleDir.xyz, viewDir));     vec3 sliceTangent = cross(sliceBitangent, viewDir);     vec3 normalInSlice = normalize(viewNormal - sliceBitangent * dot(viewNormal, sliceBitangent));          vec3 tangentToNormalInSlice = cross(normalInSlice, sliceBitangent);     vec2 cosHorizons = vec2(dot(viewDir, tangentToNormalInSlice), dot(viewDir, -tangentToNormalInSlice));          for (int j = 0; j < STEPS; ++j) {      vec3 sampleViewOffset = sampleDir.xyz * radiusToUse * sampleDir.w * pow(float(j + 1) / float(STEPS), distanceExponent);        vec3 sampleSceneUvDepth = getSceneUvAndDepth(viewPos + sampleViewOffset);      vec3 sampleSceneViewPos = getViewPosition(sampleSceneUvDepth.xy, sampleSceneUvDepth.z);      vec3 viewDelta = sampleSceneViewPos - viewPos;      if (abs(viewDelta.z) < thickness) {       float sampleCosHorizon = dot(viewDir, normalize(viewDelta));       cosHorizons.x += max(0., (sampleCosHorizon - cosHorizons.x) * mix(1., 2. / float(j + 2), distanceFallOff));      }         sampleSceneUvDepth = getSceneUvAndDepth(viewPos - sampleViewOffset);      sampleSceneViewPos = getViewPosition(sampleSceneUvDepth.xy, sampleSceneUvDepth.z);      viewDelta = sampleSceneViewPos - viewPos;      if (abs(viewDelta.z) < thickness) {       float sampleCosHorizon = dot(viewDir, normalize(viewDelta));       cosHorizons.y += max(0., (sampleCosHorizon - cosHorizons.y) * mix(1., 2. / float(j + 2), distanceFallOff));      }     }      vec2 sinHorizons = sqrt(1. - cosHorizons * cosHorizons);     float nx = dot(normalInSlice, sliceTangent);     float ny = dot(normalInSlice, viewDir);     float nxb = 1. / 2. * (acos(cosHorizons.y) - acos(cosHorizons.x) + sinHorizons.x * cosHorizons.x - sinHorizons.y * cosHorizons.y);     float nyb = 1. / 2. * (2. - cosHorizons.x * cosHorizons.x - cosHorizons.y * cosHorizons.y);     float occlusion = nx * nxb + ny * nyb;     ao += occlusion;    }     ao = clamp(ao / float(DIRECTIONS), 0., 1.);     #if SCENE_CLIP_BOX == 1    ao = mix(ao, 1., smoothstep(0., radiusToUse, boxDistance));   #endif    ao = pow(ao, scale);     gl_FragColor = FRAGMENT_OUTPUT;   }|  };  const GTAODepthShader = {   name: 'GTAODepthShader',   defines: {   PERSPECTIVE_CAMERA: 1  },   uniforms: {   tDepth: { value: null },   cameraNear: { value: null },   cameraFar: { value: null },  },   vertexShader: /* glsl */|   varying vec2 vUv;    void main() {    vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );   }|,   fragmentShader: /* glsl */|   uniform sampler2D tDepth;   uniform float cameraNear;   uniform float cameraFar;   varying vec2 vUv;    #include <packing>    float getLinearDepth( const in vec2 screenPosition ) {    #if PERSPECTIVE_CAMERA == 1     float fragCoordZ = texture2D( tDepth, screenPosition ).x;     float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );     return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );    #else     return texture2D( tDepth, screenPosition ).x;    #endif   }    void main() {    float depth = getLinearDepth( vUv );    gl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );    }|  };  const GTAOBlendShader = {   name: 'GTAOBlendShader',   uniforms: {   tDiffuse: { value: null },   intensity: { value: 1.0 }  },   vertexShader: /* glsl */|   varying vec2 vUv;    void main() {    vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );   }|,   fragmentShader: /* glsl */|   uniform float intensity;   uniform sampler2D tDiffuse;   varying vec2 vUv;    void main() {    vec4 texel = texture2D( tDiffuse, vUv );    gl_FragColor = vec4(mix(vec3(1.), texel.rgb, intensity), texel.a);   }|  };   function generateMagicSquareNoise( size = 5 ) {   const noiseSize = Math.floor( size ) % 2 === 0 ? Math.floor( size ) + 1 : Math.floor( size );  const magicSquare = generateMagicSquare( noiseSize );  const noiseSquareSize = magicSquare.length;  const data = new Uint8Array( noiseSquareSize * 4 );   for ( let inx = 0; inx < noiseSquareSize; ++ inx ) {    const iAng = magicSquare[ inx ];   const angle = ( 2 * Math.PI * iAng ) / noiseSquareSize;   const randomVec = new Vector3(    Math.cos( angle ),    Math.sin( angle ),    0   ).normalize();   data[ inx * 4 ] = ( randomVec.x * 0.5 + 0.5 ) * 255;   data[ inx * 4 + 1 ] = ( randomVec.y * 0.5 + 0.5 ) * 255;   data[ inx * 4 + 2 ] = 127;   data[ inx * 4 + 3 ] = 255;   }   const noiseTexture = new DataTexture( data, noiseSize, noiseSize );  noiseTexture.wrapS = RepeatWrapping;  noiseTexture.wrapT = RepeatWrapping;  noiseTexture.needsUpdate = true;   return noiseTexture;  }  function generateMagicSquare( size ) {   const noiseSize = Math.floor( size ) % 2 === 0 ? Math.floor( size ) + 1 : Math.floor( size );  const noiseSquareSize = noiseSize * noiseSize;  const magicSquare = Array( noiseSquareSize ).fill( 0 );  let i = Math.floor( noiseSize / 2 );  let j = noiseSize - 1;   for ( let num = 1; num <= noiseSquareSize; ) {    if ( i === - 1 && j === noiseSize ) {     j = noiseSize - 2;    i = 0;    } else {     if ( j === noiseSize ) {      j = 0;     }     if ( i < 0 ) {      i = noiseSize - 1;     }    }    if ( magicSquare[ i * noiseSize + j ] !== 0 ) {     j -= 2;    i ++;    continue;    } else {     magicSquare[ i * noiseSize + j ] = num ++;    }    j ++;   i --;   }   return magicSquare;  }   export { generateMagicSquareNoise, GTAOShader, GTAODepthShader, GTAOBlendShader }; 
^..^ FILENAME ^..^
addons|shaders|HalftoneShader.js
^..^ CONTENTS ^..^
/**  * RGB Halftone shader for three.js.  * NOTE:  *   Shape (1 = Dot, 2 = Ellipse, 3 = Line, 4 = Square)  *  Blending Mode (1 = Linear, 2 = Multiply, 3 = Add, 4 = Lighter, 5 = Darker)  */  const HalftoneShader = {   name: 'HalftoneShader',   uniforms: {   'tDiffuse': { value: null },   'shape': { value: 1 },   'radius': { value: 4 },   'rotateR': { value: Math.PI / 12 * 1 },   'rotateG': { value: Math.PI / 12 * 2 },   'rotateB': { value: Math.PI / 12 * 3 },   'scatter': { value: 0 },   'width': { value: 1 },   'height': { value: 1 },   'blending': { value: 1 },   'blendingMode': { value: 1 },   'greyscale': { value: false },   'disable': { value: false }  },   vertexShader: /* glsl */|    varying vec2 vUV;    void main() {     vUV = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    }|,   fragmentShader: /* glsl */|    #define SQRT2_MINUS_ONE 0.41421356   #define SQRT2_HALF_MINUS_ONE 0.20710678   #define PI2 6.28318531   #define SHAPE_DOT 1   #define SHAPE_ELLIPSE 2   #define SHAPE_LINE 3   #define SHAPE_SQUARE 4   #define BLENDING_LINEAR 1   #define BLENDING_MULTIPLY 2   #define BLENDING_ADD 3   #define BLENDING_LIGHTER 4   #define BLENDING_DARKER 5   uniform sampler2D tDiffuse;   uniform float radius;   uniform float rotateR;   uniform float rotateG;   uniform float rotateB;   uniform float scatter;   uniform float width;   uniform float height;   uniform int shape;   uniform bool disable;   uniform float blending;   uniform int blendingMode;   varying vec2 vUV;   uniform bool greyscale;   const int samples = 8;    float blend( float a, float b, float t ) {    // linear blend    return a * ( 1.0 - t ) + b * t;    }    float hypot( float x, float y ) {    // vector magnitude    return sqrt( x * x + y * y );    }    float rand( vec2 seed ){    // get pseudo-random number    return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );    }    float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {    // apply shape-specific transforms    float dist = hypot( coord.x - p.x, coord.y - p.y );    float rad = channel;     if ( shape == SHAPE_DOT ) {      rad = pow( abs( rad ), 1.125 ) * rad_max;     } else if ( shape == SHAPE_ELLIPSE ) {      rad = pow( abs( rad ), 1.125 ) * rad_max;      if ( dist != 0.0 ) {      float dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );      dist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;     }     } else if ( shape == SHAPE_LINE ) {      rad = pow( abs( rad ), 1.5) * rad_max;     float dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;     dist = hypot( normal.x * dot_p, normal.y * dot_p );     } else if ( shape == SHAPE_SQUARE ) {      float theta = atan( p.y - coord.y, p.x - coord.x ) - angle;     float sin_t = abs( sin( theta ) );     float cos_t = abs( cos( theta ) );     rad = pow( abs( rad ), 1.4 );     rad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );     }     return rad - dist;    }    struct Cell {    // grid sample positions    vec2 normal;    vec2 p1;    vec2 p2;    vec2 p3;    vec2 p4;    float samp2;    float samp1;    float samp3;    float samp4;    };    vec4 getSample( vec2 point ) {    // multi-sampled point    vec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );    float base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;    float step = PI2 / float( samples );    float dist = radius * 0.66;     for ( int i = 0; i < samples; ++i ) {      float r = base + step * float( i );     vec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );     tex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );     }     tex /= float( samples ) + 1.0;    return tex;    }    float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {    // get colour for given point    float dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;     if ( channel == 0 ) {      c.samp1 = getSample( c.p1 ).r;     c.samp2 = getSample( c.p2 ).r;     c.samp3 = getSample( c.p3 ).r;     c.samp4 = getSample( c.p4 ).r;     } else if (channel == 1) {      c.samp1 = getSample( c.p1 ).g;     c.samp2 = getSample( c.p2 ).g;     c.samp3 = getSample( c.p3 ).g;     c.samp4 = getSample( c.p4 ).g;     } else {      c.samp1 = getSample( c.p1 ).b;     c.samp3 = getSample( c.p3 ).b;     c.samp2 = getSample( c.p2 ).b;     c.samp4 = getSample( c.p4 ).b;     }     dist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );    dist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );    dist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );    dist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );    res = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;    res += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;    res += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;    res += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;    res = clamp( res, 0.0, 1.0 );     return res;    }    Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {    // get containing cell    Cell c;    // calc grid    vec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );    float threshold = step * 0.5;    float dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );    float dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );    vec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );    float offset_normal = mod( hypot( offset.x, offset.y ), step );    float normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;    float normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;    float offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );    float line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;    float line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;    // get closest corner    c.normal = n;    c.p1.x = p.x - n.x * normal_scale + n.y * line_scale;    c.p1.y = p.y - n.y * normal_scale - n.x * line_scale;    // scatter    if ( scatter != 0.0 ) {      float off_mag = scatter * threshold * 0.5;     float off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;     c.p1.x += cos( off_angle ) * off_mag;     c.p1.y += sin( off_angle ) * off_mag;     }    // find corners    float normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );    float line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );    c.p2.x = c.p1.x - n.x * normal_step;    c.p2.y = c.p1.y - n.y * normal_step;    c.p3.x = c.p1.x + n.y * line_step;    c.p3.y = c.p1.y - n.x * line_step;    c.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;    c.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;     return c;    }    float blendColour( float a, float b, float t ) {    // blend colours    if ( blendingMode == BLENDING_LINEAR ) {     return blend( a, b, 1.0 - t );    } else if ( blendingMode == BLENDING_ADD ) {     return blend( a, min( 1.0, a + b ), t );    } else if ( blendingMode == BLENDING_MULTIPLY ) {     return blend( a, max( 0.0, a * b ), t );    } else if ( blendingMode == BLENDING_LIGHTER ) {     return blend( a, max( a, b ), t );    } else if ( blendingMode == BLENDING_DARKER ) {     return blend( a, min( a, b ), t );    } else {     return blend( a, b, 1.0 - t );    }    }    void main() {     if ( ! disable ) {    // setup     vec2 p = vec2( vUV.x * width, vUV.y * height );     vec2 origin = vec2( 0, 0 );     float aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;    // get channel samples     Cell cell_r = getReferenceCell( p, origin, rotateR, radius );     Cell cell_g = getReferenceCell( p, origin, rotateG, radius );     Cell cell_b = getReferenceCell( p, origin, rotateB, radius );     float r = getDotColour( cell_r, p, 0, rotateR, aa );     float g = getDotColour( cell_g, p, 1, rotateG, aa );     float b = getDotColour( cell_b, p, 2, rotateB, aa );    // blend with original     vec4 colour = texture2D( tDiffuse, vUV );     r = blendColour( r, colour.r, blending );     g = blendColour( g, colour.g, blending );     b = blendColour( b, colour.b, blending );      if ( greyscale ) {      r = g = b = (r + b + g) / 3.0;     }      gl_FragColor = vec4( r, g, b, 1.0 );     } else {      gl_FragColor = texture2D( tDiffuse, vUV );     }    }|  };  export { HalftoneShader }; 
^..^ FILENAME ^..^
addons|shaders|HorizontalBlurShader.js
^..^ CONTENTS ^..^
/**  * Two pass Gaussian blur filter (horizontal and vertical blur shaders)  * - see http://www.cake23.de/traveling-wavefronts-lit-up.html  *  * - 9 samples per pass  * - standard deviation 2.7  * - "h" and "v" parameters should be set to "1 / width" and "1 / height"  */  const HorizontalBlurShader = {   name: 'HorizontalBlurShader',   uniforms: {    'tDiffuse': { value: null },   'h': { value: 1.0 / 512.0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;   uniform float h;    varying vec2 vUv;    void main() {     vec4 sum = vec4( 0.0 );     sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;    sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;    sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;    sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;    sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;    sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;    sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;    sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;     gl_FragColor = sum;    }|  };  export { HorizontalBlurShader }; 
^..^ FILENAME ^..^
addons|shaders|HorizontalTiltShiftShader.js
^..^ CONTENTS ^..^
/**  * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position  *  * - 9 samples per pass  * - standard deviation 2.7  * - "h" and "v" parameters should be set to "1 / width" and "1 / height"  * - "r" parameter control where "focused" horizontal line lies  */  const HorizontalTiltShiftShader = {   name: 'HorizontalTiltShiftShader',   uniforms: {    'tDiffuse': { value: null },   'h': { value: 1.0 / 512.0 },   'r': { value: 0.35 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;   uniform float h;   uniform float r;    varying vec2 vUv;    void main() {     vec4 sum = vec4( 0.0 );     float hh = h * abs( r - vUv.y );     sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;    sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;    sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;    sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;    sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;    sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;    sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;    sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;     gl_FragColor = sum;    }|  };  export { HorizontalTiltShiftShader }; 
^..^ FILENAME ^..^
addons|shaders|HueSaturationShader.js
^..^ CONTENTS ^..^
/**  * Hue and saturation adjustment  * https://github.com/evanw/glfx.js  * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.  * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)  */  const HueSaturationShader = {   name: 'HueSaturationShader',   uniforms: {    'tDiffuse': { value: null },   'hue': { value: 0 },   'saturation': { value: 0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;   uniform float hue;   uniform float saturation;    varying vec2 vUv;    void main() {     gl_FragColor = texture2D( tDiffuse, vUv );     // hue    float angle = hue * 3.14159265;    float s = sin(angle), c = cos(angle);    vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;    float len = length(gl_FragColor.rgb);    gl_FragColor.rgb = vec3(     dot(gl_FragColor.rgb, weights.xyz),     dot(gl_FragColor.rgb, weights.zxy),     dot(gl_FragColor.rgb, weights.yzx)    );     // saturation    float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;    if (saturation > 0.0) {     gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));    } else {     gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);    }    }|  };  export { HueSaturationShader }; 
^..^ FILENAME ^..^
addons|shaders|KaleidoShader.js
^..^ CONTENTS ^..^
/**  * Kaleidoscope Shader  * Radial reflection around center point  * Ported from: http://pixelshaders.com/editor/  * by Toby Schachman / http://tobyschachman.com/  *  * sides: number of reflections  * angle: initial angle in radians  */  const KaleidoShader = {   name: 'KaleidoShader',   uniforms: {    'tDiffuse': { value: null },   'sides': { value: 6.0 },   'angle': { value: 0.0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;   uniform float sides;   uniform float angle;    varying vec2 vUv;    void main() {     vec2 p = vUv - 0.5;    float r = length(p);    float a = atan(p.y, p.x) + angle;    float tau = 2. * 3.1416 ;    a = mod(a, tau/sides);    a = abs(a - tau/sides/2.) ;    p = r * vec2(cos(a), sin(a));    vec4 color = texture2D(tDiffuse, p + 0.5);    gl_FragColor = color;    }|  };  export { KaleidoShader }; 
^..^ FILENAME ^..^
addons|shaders|LuminosityHighPassShader.js
^..^ CONTENTS ^..^
import {  Color } from 'three';  /**  * Luminosity  * http://en.wikipedia.org/wiki/Luminosity  */  const LuminosityHighPassShader = {   name: 'LuminosityHighPassShader',   shaderID: 'luminosityHighPass',   uniforms: {    'tDiffuse': { value: null },   'luminosityThreshold': { value: 1.0 },   'smoothWidth': { value: 1.0 },   'defaultColor': { value: new Color( 0x000000 ) },   'defaultOpacity': { value: 0.0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;   uniform vec3 defaultColor;   uniform float defaultOpacity;   uniform float luminosityThreshold;   uniform float smoothWidth;    varying vec2 vUv;    void main() {     vec4 texel = texture2D( tDiffuse, vUv );     float v = luminance( texel.xyz );     vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );     float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );     gl_FragColor = mix( outputColor, texel, alpha );    }|  };  export { LuminosityHighPassShader }; 
^..^ FILENAME ^..^
addons|shaders|LuminosityShader.js
^..^ CONTENTS ^..^
/**  * Luminosity  * http://en.wikipedia.org/wiki/Luminosity  */  const LuminosityShader = {   name: 'LuminosityShader',   uniforms: {    'tDiffuse': { value: null }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    #include <common>    uniform sampler2D tDiffuse;    varying vec2 vUv;    void main() {     vec4 texel = texture2D( tDiffuse, vUv );     float l = luminance( texel.rgb );     gl_FragColor = vec4( l, l, l, texel.w );    }|  };  export { LuminosityShader }; 
^..^ FILENAME ^..^
addons|shaders|MirrorShader.js
^..^ CONTENTS ^..^
/**  * Mirror Shader  * Copies half the input to the other half  *  * side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom)  */  const MirrorShader = {   name: 'MirrorShader',   uniforms: {    'tDiffuse': { value: null },   'side': { value: 1 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;   uniform int side;    varying vec2 vUv;    void main() {     vec2 p = vUv;    if (side == 0){     if (p.x > 0.5) p.x = 1.0 - p.x;    }else if (side == 1){     if (p.x < 0.5) p.x = 1.0 - p.x;    }else if (side == 2){     if (p.y < 0.5) p.y = 1.0 - p.y;    }else if (side == 3){     if (p.y > 0.5) p.y = 1.0 - p.y;    }    vec4 color = texture2D(tDiffuse, p);    gl_FragColor = color;    }|  };  export { MirrorShader }; 
^..^ FILENAME ^..^
addons|shaders|MMDToonShader.js
^..^ CONTENTS ^..^
/**  * MMD Toon Shader  *  * This shader is extended from MeshPhongMaterial, and merged algorithms with  * MeshToonMaterial and MeshMetcapMaterial.  * Ideas came from https://github.com/mrdoob/three.js/issues/19609  *  * Combining steps:  *  * Declare matcap uniform.  *  * Add gradientmap_pars_fragment.  *  * Use gradient irradiances instead of dotNL irradiance from MeshPhongMaterial.  *    (Replace lights_phong_pars_fragment with lights_mmd_toon_pars_fragment)  *  * Add mmd_toon_matcap_fragment.  */  import { UniformsUtils, ShaderLib } from 'three';  const lights_mmd_toon_pars_fragment = /* glsl */| varying vec3 vViewPosition;  struct BlinnPhongMaterial {   vec3 diffuseColor;  vec3 specularColor;  float specularShininess;  float specularStrength;  };  void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {   vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;   reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );   reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;  }  void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {   reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );  }  #define RE_Direct    RE_Direct_BlinnPhong #define RE_IndirectDiffuse  RE_IndirectDiffuse_BlinnPhong |;  const mmd_toon_matcap_fragment = /* glsl */| #ifdef USE_MATCAP   vec3 viewDir = normalize( vViewPosition );  vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );  vec3 y = cross( viewDir, x );  vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks  vec4 matcapColor = texture2D( matcap, uv );   #ifdef MATCAP_BLENDING_MULTIPLY    outgoingLight *= matcapColor.rgb;   #elif defined( MATCAP_BLENDING_ADD )    outgoingLight += matcapColor.rgb;   #endif  #endif |;  const MMDToonShader = {   name: 'MMDToonShader',   defines: {   TOON: true,   MATCAP: true,   MATCAP_BLENDING_ADD: true,  },   uniforms: UniformsUtils.merge( [   ShaderLib.toon.uniforms,   ShaderLib.phong.uniforms,   ShaderLib.matcap.uniforms,  ] ),   vertexShader:   ShaderLib.phong.vertexShader    .replace(     '#include <envmap_pars_vertex>',     ''    )    .replace(     '#include <envmap_vertex>',     ''    ),   fragmentShader:   ShaderLib.phong.fragmentShader    .replace(     '#include <common>',     |      #ifdef USE_MATCAP       uniform sampler2D matcap;      #endif       #include <common>     |    )    .replace(     '#include <envmap_common_pars_fragment>',     |      #include <gradientmap_pars_fragment>     |    )    .replace(     '#include <envmap_pars_fragment>',     ''    )    .replace(     '#include <lights_phong_pars_fragment>',     lights_mmd_toon_pars_fragment    )    .replace(     '#include <envmap_fragment>',     |      |mmd_toon_matcap_fragment}     |    )  };  export { MMDToonShader }; 
^..^ FILENAME ^..^
addons|shaders|NormalMapShader.js
^..^ CONTENTS ^..^
import {  Vector2 } from 'three';  /**  * Normal map shader  * - compute normals from heightmap  */  const NormalMapShader = {   name: 'NormalMapShader',   uniforms: {    'heightMap': { value: null },   'resolution': { value: new Vector2( 512, 512 ) },   'scale': { value: new Vector2( 1, 1 ) },   'height': { value: 0.05 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform float height;   uniform vec2 resolution;   uniform sampler2D heightMap;    varying vec2 vUv;    void main() {     float val = texture2D( heightMap, vUv ).x;     float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;    float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;     gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );    }|  };  export { NormalMapShader }; 
^..^ FILENAME ^..^
addons|shaders|OutputShader.js
^..^ CONTENTS ^..^
const OutputShader = {   name: 'OutputShader',   uniforms: {    'tDiffuse': { value: null },   'toneMappingExposure': { value: 1 }   },   vertexShader: /* glsl */|   precision highp float;    uniform mat4 modelViewMatrix;   uniform mat4 projectionMatrix;    attribute vec3 position;   attribute vec2 uv;    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|     precision highp float;    uniform sampler2D tDiffuse;    #include <tonemapping_pars_fragment>   #include <colorspace_pars_fragment>    varying vec2 vUv;    void main() {     gl_FragColor = texture2D( tDiffuse, vUv );     // tone mapping     #ifdef LINEAR_TONE_MAPPING      gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );     #elif defined( REINHARD_TONE_MAPPING )      gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );     #elif defined( CINEON_TONE_MAPPING )      gl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );     #elif defined( ACES_FILMIC_TONE_MAPPING )      gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );     #elif defined( AGX_TONE_MAPPING )      gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );     #elif defined( NEUTRAL_TONE_MAPPING )      gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );     #endif     // color space     #ifdef SRGB_TRANSFER      gl_FragColor = sRGBTransferOETF( gl_FragColor );     #endif    }|  };  export { OutputShader }; 
^..^ FILENAME ^..^
addons|shaders|PoissonDenoiseShader.js
^..^ CONTENTS ^..^
import {  Matrix4,  Vector2,  Vector3, } from 'three';  /**  * References:  * https://openaccess.thecvf.com/content/WACV2021/papers/Khademi_Self-Supervised_Poisson-Gaussian_Denoising_WACV_2021_paper.pdf  * https://arxiv.org/pdf/2206.01856.pdf  */  const PoissonDenoiseShader = {   name: 'PoissonDenoiseShader',   defines: {   'SAMPLES': 16,   'SAMPLE_VECTORS': generatePdSamplePointInitializer( 16, 2, 1 ),   'NORMAL_VECTOR_TYPE': 1,   'DEPTH_VALUE_SOURCE': 0,  },   uniforms: {   'tDiffuse': { value: null },   'tNormal': { value: null },   'tDepth': { value: null },   'tNoise': { value: null },   'resolution': { value: new Vector2() },   'cameraProjectionMatrixInverse': { value: new Matrix4() },   'lumaPhi': { value: 5. },   'depthPhi': { value: 5. },   'normalPhi': { value: 5. },   'radius': { value: 4. },   'index': { value: 0 }  },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {    vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );   }|,   fragmentShader: /* glsl */|    varying vec2 vUv;    uniform sampler2D tDiffuse;   uniform sampler2D tNormal;   uniform sampler2D tDepth;   uniform sampler2D tNoise;   uniform vec2 resolution;   uniform mat4 cameraProjectionMatrixInverse;   uniform float lumaPhi;   uniform float depthPhi;   uniform float normalPhi;   uniform float radius;   uniform int index;      #include <common>   #include <packing>    #ifndef SAMPLE_LUMINANCE   #define SAMPLE_LUMINANCE dot(vec3(0.2125, 0.7154, 0.0721), a)   #endif    #ifndef FRAGMENT_OUTPUT   #define FRAGMENT_OUTPUT vec4(denoised, 1.)   #endif    float getLuminance(const in vec3 a) {    return SAMPLE_LUMINANCE;   }    const vec3 poissonDisk[SAMPLES] = SAMPLE_VECTORS;    vec3 getViewPosition(const in vec2 screenPosition, const in float depth) {    vec4 clipSpacePosition = vec4(vec3(screenPosition, depth) * 2.0 - 1.0, 1.0);    vec4 viewSpacePosition = cameraProjectionMatrixInverse * clipSpacePosition;    return viewSpacePosition.xyz / viewSpacePosition.w;   }      float getDepth(const vec2 uv) {   #if DEPTH_VALUE_SOURCE == 1        return textureLod(tDepth, uv.xy, 0.0).a;   #else    return textureLod(tDepth, uv.xy, 0.0).r;   #endif   }    float fetchDepth(const ivec2 uv) {    #if DEPTH_VALUE_SOURCE == 1         return texelFetch(tDepth, uv.xy, 0).a;    #else     return texelFetch(tDepth, uv.xy, 0).r;    #endif   }    vec3 computeNormalFromDepth(const vec2 uv) {    vec2 size = vec2(textureSize(tDepth, 0));    ivec2 p = ivec2(uv * size);    float c0 = fetchDepth(p);    float l2 = fetchDepth(p - ivec2(2, 0));    float l1 = fetchDepth(p - ivec2(1, 0));    float r1 = fetchDepth(p + ivec2(1, 0));    float r2 = fetchDepth(p + ivec2(2, 0));    float b2 = fetchDepth(p - ivec2(0, 2));    float b1 = fetchDepth(p - ivec2(0, 1));    float t1 = fetchDepth(p + ivec2(0, 1));    float t2 = fetchDepth(p + ivec2(0, 2));    float dl = abs((2.0 * l1 - l2) - c0);    float dr = abs((2.0 * r1 - r2) - c0);    float db = abs((2.0 * b1 - b2) - c0);    float dt = abs((2.0 * t1 - t2) - c0);    vec3 ce = getViewPosition(uv, c0).xyz;    vec3 dpdx = (dl < dr) ?  ce - getViewPosition((uv - vec2(1.0 / size.x, 0.0)), l1).xyz          : -ce + getViewPosition((uv + vec2(1.0 / size.x, 0.0)), r1).xyz;    vec3 dpdy = (db < dt) ?  ce - getViewPosition((uv - vec2(0.0, 1.0 / size.y)), b1).xyz          : -ce + getViewPosition((uv + vec2(0.0, 1.0 / size.y)), t1).xyz;    return normalize(cross(dpdx, dpdy));   }    vec3 getViewNormal(const vec2 uv) {   #if NORMAL_VECTOR_TYPE == 2    return normalize(textureLod(tNormal, uv, 0.).rgb);   #elif NORMAL_VECTOR_TYPE == 1    return unpackRGBToNormal(textureLod(tNormal, uv, 0.).rgb);   #else    return computeNormalFromDepth(uv);   #endif   }    void denoiseSample(in vec3 center, in vec3 viewNormal, in vec3 viewPos, in vec2 sampleUv, inout vec3 denoised, inout float totalWeight) {    vec4 sampleTexel = textureLod(tDiffuse, sampleUv, 0.0);    float sampleDepth = getDepth(sampleUv);    vec3 sampleNormal = getViewNormal(sampleUv);    vec3 neighborColor = sampleTexel.rgb;    vec3 viewPosSample = getViewPosition(sampleUv, sampleDepth);        float normalDiff = dot(viewNormal, sampleNormal);    float normalSimilarity = pow(max(normalDiff, 0.), normalPhi);    float lumaDiff = abs(getLuminance(neighborColor) - getLuminance(center));    float lumaSimilarity = max(1.0 - lumaDiff / lumaPhi, 0.0);    float depthDiff = abs(dot(viewPos - viewPosSample, viewNormal));    float depthSimilarity = max(1. - depthDiff / depthPhi, 0.);    float w = lumaSimilarity * depthSimilarity * normalSimilarity;       denoised += w * neighborColor;    totalWeight += w;   }      void main() {    float depth = getDepth(vUv.xy);     vec3 viewNormal = getViewNormal(vUv);     if (depth == 1. || dot(viewNormal, viewNormal) == 0.) {     discard;     return;    }    vec4 texel = textureLod(tDiffuse, vUv, 0.0);    vec3 center = texel.rgb;    vec3 viewPos = getViewPosition(vUv, depth);     vec2 noiseResolution = vec2(textureSize(tNoise, 0));    vec2 noiseUv = vUv * resolution / noiseResolution;    vec4 noiseTexel = textureLod(tNoise, noiseUv, 0.0);         vec2 noiseVec = vec2(sin(noiseTexel[index % 4] * 2. * PI), cos(noiseTexel[index % 4] * 2. * PI));       mat2 rotationMatrix = mat2(noiseVec.x, -noiseVec.y, noiseVec.x, noiseVec.y);       float totalWeight = 1.0;    vec3 denoised = texel.rgb;    for (int i = 0; i < SAMPLES; i++) {     vec3 sampleDir = poissonDisk[i];     vec2 offset = rotationMatrix * (sampleDir.xy * (1. + sampleDir.z * (radius - 1.)) / resolution);     vec2 sampleUv = vUv + offset;     denoiseSample(center, viewNormal, viewPos, sampleUv, denoised, totalWeight);    }       if (totalWeight > 0.) {      denoised /= totalWeight;    }    gl_FragColor = FRAGMENT_OUTPUT;   }|  };  function generatePdSamplePointInitializer( samples, rings, radiusExponent ) {   const poissonDisk = generateDenoiseSamples(   samples,   rings,   radiusExponent,  );   let glslCode = 'vec3[SAMPLES](';   for ( let i = 0; i < samples; i ++ ) {    const sample = poissonDisk[ i ];   glslCode += |vec3(|sample.x}, |sample.y}, |sample.z})|( i < samples - 1 ) ? ',' : ')'}|;   }   return glslCode;  }  function generateDenoiseSamples( numSamples, numRings, radiusExponent ) {   const samples = [];   for ( let i = 0; i < numSamples; i ++ ) {    const angle = 2 * Math.PI * numRings * i / numSamples;   const radius = Math.pow( i / ( numSamples - 1 ), radiusExponent );   samples.push( new Vector3( Math.cos( angle ), Math.sin( angle ), radius ) );   }   return samples;  }  export { generatePdSamplePointInitializer, PoissonDenoiseShader }; 
^..^ FILENAME ^..^
addons|shaders|RGBShiftShader.js
^..^ CONTENTS ^..^
/**  * RGB Shift Shader  * Shifts red and blue channels from center in opposite directions  * Ported from https://web.archive.org/web/20090820185047/http://kriss.cx/tom/2009/05/rgb-shift/  * by Tom Butterworth / https://web.archive.org/web/20090810054752/http://kriss.cx/tom/  *  * amount: shift distance (1 is width of input)  * angle: shift angle in radians  */  const RGBShiftShader = {   name: 'RGBShiftShader',   uniforms: {    'tDiffuse': { value: null },   'amount': { value: 0.005 },   'angle': { value: 0.0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;   uniform float amount;   uniform float angle;    varying vec2 vUv;    void main() {     vec2 offset = amount * vec2( cos(angle), sin(angle));    vec4 cr = texture2D(tDiffuse, vUv + offset);    vec4 cga = texture2D(tDiffuse, vUv);    vec4 cb = texture2D(tDiffuse, vUv - offset);    gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);    }|  };  export { RGBShiftShader }; 
^..^ FILENAME ^..^
addons|shaders|SAOShader.js
^..^ CONTENTS ^..^
import {  Matrix4,  Vector2 } from 'three';  /**  * TODO  */  const SAOShader = {   name: 'SAOShader',   defines: {   'NUM_SAMPLES': 7,   'NUM_RINGS': 4,   'DIFFUSE_TEXTURE': 0,   'PERSPECTIVE_CAMERA': 1  },   uniforms: {    'tDepth': { value: null },   'tDiffuse': { value: null },   'tNormal': { value: null },   'size': { value: new Vector2( 512, 512 ) },    'cameraNear': { value: 1 },   'cameraFar': { value: 100 },   'cameraProjectionMatrix': { value: new Matrix4() },   'cameraInverseProjectionMatrix': { value: new Matrix4() },    'scale': { value: 1.0 },   'intensity': { value: 0.1 },   'bias': { value: 0.5 },    'minResolution': { value: 0.0 },   'kernelRadius': { value: 100.0 },   'randomSeed': { value: 0.0 }  },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {    vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );   }|,   fragmentShader: /* glsl */|   #include <common>    varying vec2 vUv;    #if DIFFUSE_TEXTURE == 1   uniform sampler2D tDiffuse;   #endif    uniform highp sampler2D tDepth;   uniform highp sampler2D tNormal;    uniform float cameraNear;   uniform float cameraFar;   uniform mat4 cameraProjectionMatrix;   uniform mat4 cameraInverseProjectionMatrix;    uniform float scale;   uniform float intensity;   uniform float bias;   uniform float kernelRadius;   uniform float minResolution;   uniform vec2 size;   uniform float randomSeed;    // RGBA depth    #include <packing>    vec4 getDefaultColor( const in vec2 screenPosition ) {    #if DIFFUSE_TEXTURE == 1    return texture2D( tDiffuse, vUv );    #else    return vec4( 1.0 );    #endif   }    float getDepth( const in vec2 screenPosition ) {    return texture2D( tDepth, screenPosition ).x;   }    float getViewZ( const in float depth ) {    #if PERSPECTIVE_CAMERA == 1    return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );    #else    return orthographicDepthToViewZ( depth, cameraNear, cameraFar );    #endif   }    vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {    float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];    vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );    clipPosition *= clipW; // unprojection.     return ( cameraInverseProjectionMatrix * clipPosition ).xyz;   }    vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {    return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );   }    float scaleDividedByCameraFar;   float minResolutionMultipliedByCameraFar;    float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {    vec3 viewDelta = sampleViewPosition - centerViewPosition;    float viewDistance = length( viewDelta );    float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;     return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );   }    // moving costly divides into consts   const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );   const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );    float getAmbientOcclusion( const in vec3 centerViewPosition ) {    // precompute some variables require in getOcclusion.    scaleDividedByCameraFar = scale / cameraFar;    minResolutionMultipliedByCameraFar = minResolution * cameraFar;    vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );     // jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/    float angle = rand( vUv + randomSeed ) * PI2;    vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;    vec2 radiusStep = radius;     float occlusionSum = 0.0;    float weightSum = 0.0;     for( int i = 0; i < NUM_SAMPLES; i ++ ) {     vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;     radius += radiusStep;     angle += ANGLE_STEP;      float sampleDepth = getDepth( sampleUv );     if( sampleDepth >= ( 1.0 - EPSILON ) ) {      continue;     }      float sampleViewZ = getViewZ( sampleDepth );     vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );     occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );     weightSum += 1.0;    }     if( weightSum == 0.0 ) discard;     return occlusionSum * ( intensity / weightSum );   }    void main() {    float centerDepth = getDepth( vUv );    if( centerDepth >= ( 1.0 - EPSILON ) ) {     discard;    }     float centerViewZ = getViewZ( centerDepth );    vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );     float ambientOcclusion = getAmbientOcclusion( viewPosition );     gl_FragColor = getDefaultColor( vUv );    gl_FragColor.xyz *=  1.0 - ambientOcclusion;   }|  };  export { SAOShader }; 
^..^ FILENAME ^..^
addons|shaders|SepiaShader.js
^..^ CONTENTS ^..^
/**  * Sepia tone shader  * based on glfx.js sepia shader  * https://github.com/evanw/glfx.js  */  const SepiaShader = {   name: 'SepiaShader',   uniforms: {    'tDiffuse': { value: null },   'amount': { value: 1.0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform float amount;    uniform sampler2D tDiffuse;    varying vec2 vUv;    void main() {     vec4 color = texture2D( tDiffuse, vUv );    vec3 c = color.rgb;     color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );    color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );    color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );     gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );    }|  };  export { SepiaShader }; 
^..^ FILENAME ^..^
addons|shaders|SMAAShader.js
^..^ CONTENTS ^..^
import {  Vector2 } from 'three';  /**  * WebGL port of Subpixel Morphological Antialiasing (SMAA) v2.8  * Preset: SMAA 1x Medium (with color edge detection)  * https://github.com/iryoku/smaa/releases/tag/v2.8  */  const SMAAEdgesShader = {   name: 'SMAAEdgesShader',   defines: {    'SMAA_THRESHOLD': '0.1'   },   uniforms: {    'tDiffuse': { value: null },   'resolution': { value: new Vector2( 1 / 1024, 1 / 512 ) }   },   vertexShader: /* glsl */|    uniform vec2 resolution;    varying vec2 vUv;   varying vec4 vOffset[ 3 ];    void SMAAEdgeDetectionVS( vec2 texcoord ) {    vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component    vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component    vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component   }    void main() {     vUv = uv;     SMAAEdgeDetectionVS( vUv );     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;    varying vec2 vUv;   varying vec4 vOffset[ 3 ];    vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {    vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );     // Calculate color deltas:    vec4 delta;    vec3 C = texture2D( colorTex, texcoord ).rgb;     vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;    vec3 t = abs( C - Cleft );    delta.x = max( max( t.r, t.g ), t.b );     vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;    t = abs( C - Ctop );    delta.y = max( max( t.r, t.g ), t.b );     // We do the usual threshold:    vec2 edges = step( threshold, delta.xy );     // Then discard if there is no edge:    if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )     discard;     // Calculate right and bottom deltas:    vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;    t = abs( C - Cright );    delta.z = max( max( t.r, t.g ), t.b );     vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;    t = abs( C - Cbottom );    delta.w = max( max( t.r, t.g ), t.b );     // Calculate the maximum delta in the direct neighborhood:    float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );     // Calculate left-left and top-top deltas:    vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;    t = abs( C - Cleftleft );    delta.z = max( max( t.r, t.g ), t.b );     vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;    t = abs( C - Ctoptop );    delta.w = max( max( t.r, t.g ), t.b );     // Calculate the final maximum delta:    maxDelta = max( max( maxDelta, delta.z ), delta.w );     // Local contrast adaptation in action:    edges.xy *= step( 0.5 * maxDelta, delta.xy );     return vec4( edges, 0.0, 0.0 );   }    void main() {     gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );    }|  };  const SMAAWeightsShader = {   name: 'SMAAWeightsShader',   defines: {    'SMAA_MAX_SEARCH_STEPS': '8',   'SMAA_AREATEX_MAX_DISTANCE': '16',   'SMAA_AREATEX_PIXEL_SIZE': '( 1.0 / vec2( 160.0, 560.0 ) )',   'SMAA_AREATEX_SUBTEX_SIZE': '( 1.0 / 7.0 )'   },   uniforms: {    'tDiffuse': { value: null },   'tArea': { value: null },   'tSearch': { value: null },   'resolution': { value: new Vector2( 1 / 1024, 1 / 512 ) }   },   vertexShader: /* glsl */|    uniform vec2 resolution;    varying vec2 vUv;   varying vec4 vOffset[ 3 ];   varying vec2 vPixcoord;    void SMAABlendingWeightCalculationVS( vec2 texcoord ) {    vPixcoord = texcoord / resolution;     // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):    vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components    vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components     // And these for the searches, they indicate the ends of the loops:    vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );    }    void main() {     vUv = uv;     SMAABlendingWeightCalculationVS( vUv );     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    #define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )    uniform sampler2D tDiffuse;   uniform sampler2D tArea;   uniform sampler2D tSearch;   uniform vec2 resolution;    varying vec2 vUv;   varying vec4 vOffset[3];   varying vec2 vPixcoord;    #if __VERSION__ == 100   vec2 round( vec2 x ) {    return sign( x ) * floor( abs( x ) + 0.5 );   }   #endif    float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {    // Not required if searchTex accesses are set to point:    // float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);    // e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +    //     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;    e.r = bias + e.r * scale;    return 255.0 * texture2D( searchTex, e, 0.0 ).r;   }    float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {    /**     * @PSEUDO_GATHER4     * This texcoord has been offset by (-0.25, -0.125) in the vertex shader to     * sample between edge, thus fetching four edges in a row.     * Sampling with different offsets in each direction allows to disambiguate     * which edges are active from the four fetched ones.     */    vec2 e = vec2( 0.0, 1.0 );     for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for     e = texture2D( edgesTex, texcoord, 0.0 ).rg;     texcoord -= vec2( 2.0, 0.0 ) * resolution;     if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;    }     // We correct the previous (-0.25, -0.125) offset we applied:    texcoord.x += 0.25 * resolution.x;     // The searches are bias by 1, so adjust the coords accordingly:    texcoord.x += resolution.x;     // Disambiguate the length added by the last step:    texcoord.x += 2.0 * resolution.x; // Undo last step    texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);     return texcoord.x;   }    float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {    vec2 e = vec2( 0.0, 1.0 );     for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for     e = texture2D( edgesTex, texcoord, 0.0 ).rg;     texcoord += vec2( 2.0, 0.0 ) * resolution;     if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;    }     texcoord.x -= 0.25 * resolution.x;    texcoord.x -= resolution.x;    texcoord.x -= 2.0 * resolution.x;    texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );     return texcoord.x;   }    float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {    vec2 e = vec2( 1.0, 0.0 );     for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for     e = texture2D( edgesTex, texcoord, 0.0 ).rg;     texcoord += vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign     if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;    }     texcoord.y -= 0.25 * resolution.y; // WebGL port note: Changed sign    texcoord.y -= resolution.y; // WebGL port note: Changed sign    texcoord.y -= 2.0 * resolution.y; // WebGL port note: Changed sign    texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign     return texcoord.y;   }    float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {    vec2 e = vec2( 1.0, 0.0 );     for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for     e = texture2D( edgesTex, texcoord, 0.0 ).rg;     texcoord -= vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign     if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;    }     texcoord.y += 0.25 * resolution.y; // WebGL port note: Changed sign    texcoord.y += resolution.y; // WebGL port note: Changed sign    texcoord.y += 2.0 * resolution.y; // WebGL port note: Changed sign    texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign     return texcoord.y;   }    vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {    // Rounding prevents precision errors of bilinear filtering:    vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;     // We do a scale and bias for mapping to texel space:    texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );     // Move to proper place, according to the subpixel offset:    texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;     return texture2D( areaTex, texcoord, 0.0 ).rg;   }    vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {    vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );     vec2 e = texture2D( edgesTex, texcoord ).rg;     if ( e.g > 0.0 ) { // Edge at north     vec2 d;      // Find the distance to the left:     vec2 coords;     coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );     coords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)     d.x = coords.x;      // Now fetch the left crossing edges, two at a time using bilinear     // filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to     // discern what value each edge has:     float e1 = texture2D( edgesTex, coords, 0.0 ).r;      // Find the distance to the right:     coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );     d.y = coords.x;      // We want the distances to be in pixel units (doing this here allow to     // better interleave arithmetic and memory accesses):     d = d / resolution.x - pixcoord.x;      // SMAAArea below needs a sqrt, as the areas texture is compressed     // quadratically:     vec2 sqrt_d = sqrt( abs( d ) );      // Fetch the right crossing edges:     coords.y -= 1.0 * resolution.y; // WebGL port note: Added     float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;      // Ok, we know how this pattern looks like, now it is time for getting     // the actual area:     weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );    }     if ( e.r > 0.0 ) { // Edge at west     vec2 d;      // Find the distance to the top:     vec2 coords;      coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );     coords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * resolution.x;     d.x = coords.y;      // Fetch the top crossing edges:     float e1 = texture2D( edgesTex, coords, 0.0 ).g;      // Find the distance to the bottom:     coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );     d.y = coords.y;      // We want the distances to be in pixel units:     d = d / resolution.y - pixcoord.y;      // SMAAArea below needs a sqrt, as the areas texture is compressed     // quadratically:     vec2 sqrt_d = sqrt( abs( d ) );      // Fetch the bottom crossing edges:     coords.y -= 1.0 * resolution.y; // WebGL port note: Added     float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;      // Get the area for this direction:     weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );    }     return weights;   }    void main() {     gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );    }|  };  const SMAABlendShader = {   name: 'SMAABlendShader',   uniforms: {    'tDiffuse': { value: null },   'tColor': { value: null },   'resolution': { value: new Vector2( 1 / 1024, 1 / 512 ) }   },   vertexShader: /* glsl */|    uniform vec2 resolution;    varying vec2 vUv;   varying vec4 vOffset[ 2 ];    void SMAANeighborhoodBlendingVS( vec2 texcoord ) {    vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component    vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component   }    void main() {     vUv = uv;     SMAANeighborhoodBlendingVS( vUv );     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;   uniform sampler2D tColor;   uniform vec2 resolution;    varying vec2 vUv;   varying vec4 vOffset[ 2 ];    vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {    // Fetch the blending weights for current pixel:    vec4 a;    a.xz = texture2D( blendTex, texcoord ).xz;    a.y = texture2D( blendTex, offset[ 1 ].zw ).g;    a.w = texture2D( blendTex, offset[ 1 ].xy ).a;     // Is there any blending weight with a value greater than 0.0?    if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {     return texture2D( colorTex, texcoord, 0.0 );    } else {     // Up to 4 lines can be crossing a pixel (one through each edge). We     // favor blending by choosing the line with the maximum weight for each     // direction:     vec2 offset;     offset.x = a.a > a.b ? a.a : -a.b; // left vs. right     offset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs      // Then we go in the direction that has the maximum weight:     if ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical      offset.y = 0.0;     } else {      offset.x = 0.0;     }      // Fetch the opposite color and lerp by hand:     vec4 C = texture2D( colorTex, texcoord, 0.0 );     texcoord += sign( offset ) * resolution;     vec4 Cop = texture2D( colorTex, texcoord, 0.0 );     float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );      // WebGL port note: Added gamma correction     C.xyz = pow(C.xyz, vec3(2.2));     Cop.xyz = pow(Cop.xyz, vec3(2.2));     vec4 mixed = mix(C, Cop, s);     mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));      return mixed;    }   }    void main() {     gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );    }|  };  export { SMAAEdgesShader, SMAAWeightsShader, SMAABlendShader }; 
^..^ FILENAME ^..^
addons|shaders|SobelOperatorShader.js
^..^ CONTENTS ^..^
import {  Vector2 } from 'three';  /**  * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)  *  * As mentioned in the video the Sobel operator expects a grayscale image as input.  *  */  const SobelOperatorShader = {   name: 'SobelOperatorShader',   uniforms: {    'tDiffuse': { value: null },   'resolution': { value: new Vector2() }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;   uniform vec2 resolution;   varying vec2 vUv;    void main() {     vec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );    // kernel definition (in glsl matrices are filled in column-major order)     const mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 ); // x direction kernel    const mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 ); // y direction kernel    // fetch the 3x3 neighbourhood of a fragment    // first column     float tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;    float tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;    float tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;    // second column     float tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;    float tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;    float tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;    // third column     float tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;    float tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;    float tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;    // gradient value in x direction     float valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 +     Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 +     Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2;    // gradient value in y direction     float valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 +     Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 +     Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2;    // magnitute of the total gradient     float G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );     gl_FragColor = vec4( vec3( G ), 1 );    }|  };  export { SobelOperatorShader }; 
^..^ FILENAME ^..^
addons|shaders|SSAOShader.js
^..^ CONTENTS ^..^
import {  Matrix4,  Vector2 } from 'three';  /**  * References:  * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html  * https://learnopengl.com/Advanced-Lighting/SSAO  * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl  */  const SSAOShader = {   name: 'SSAOShader',   defines: {   'PERSPECTIVE_CAMERA': 1,   'KERNEL_SIZE': 32  },   uniforms: {    'tNormal': { value: null },   'tDepth': { value: null },   'tNoise': { value: null },   'kernel': { value: null },   'cameraNear': { value: null },   'cameraFar': { value: null },   'resolution': { value: new Vector2() },   'cameraProjectionMatrix': { value: new Matrix4() },   'cameraInverseProjectionMatrix': { value: new Matrix4() },   'kernelRadius': { value: 8 },   'minDistance': { value: 0.005 },   'maxDistance': { value: 0.05 },   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|   uniform highp sampler2D tNormal;   uniform highp sampler2D tDepth;   uniform sampler2D tNoise;    uniform vec3 kernel[ KERNEL_SIZE ];    uniform vec2 resolution;    uniform float cameraNear;   uniform float cameraFar;   uniform mat4 cameraProjectionMatrix;   uniform mat4 cameraInverseProjectionMatrix;    uniform float kernelRadius;   uniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference   uniform float maxDistance; // avoid the influence of fragments which are too far away    varying vec2 vUv;    #include <packing>    float getDepth( const in vec2 screenPosition ) {     return texture2D( tDepth, screenPosition ).x;    }    float getLinearDepth( const in vec2 screenPosition ) {     #if PERSPECTIVE_CAMERA == 1      float fragCoordZ = texture2D( tDepth, screenPosition ).x;     float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );     return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );     #else      return texture2D( tDepth, screenPosition ).x;     #endif    }    float getViewZ( const in float depth ) {     #if PERSPECTIVE_CAMERA == 1      return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );     #else      return orthographicDepthToViewZ( depth, cameraNear, cameraFar );     #endif    }    vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {     float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];     vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );     clipPosition *= clipW; // unprojection.     return ( cameraInverseProjectionMatrix * clipPosition ).xyz;    }    vec3 getViewNormal( const in vec2 screenPosition ) {     return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );    }    void main() {     float depth = getDepth( vUv );     if ( depth == 1.0 ) {      gl_FragColor = vec4( 1.0 ); // don't influence background         } else {      float viewZ = getViewZ( depth );      vec3 viewPosition = getViewPosition( vUv, depth, viewZ );     vec3 viewNormal = getViewNormal( vUv );      vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );     vec3 random = vec3( texture2D( tNoise, vUv * noiseScale ).r );      // compute matrix used to reorient a kernel vector      vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );     vec3 bitangent = cross( viewNormal, tangent );     mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );      float occlusion = 0.0;      for ( int i = 0; i < KERNEL_SIZE; i ++ ) {       vec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space      vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point       vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC      samplePointNDC /= samplePointNDC.w;       vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates       float realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture      float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value      float delta = sampleDepth - realDepth;       if ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion        occlusion += 1.0;       }      }      occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );      gl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );     }    }|  };  const SSAODepthShader = {   name: 'SSAODepthShader',   defines: {   'PERSPECTIVE_CAMERA': 1  },   uniforms: {    'tDepth': { value: null },   'cameraNear': { value: null },   'cameraFar': { value: null },   },   vertexShader:    |varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader:    |uniform sampler2D tDepth;    uniform float cameraNear;   uniform float cameraFar;    varying vec2 vUv;    #include <packing>    float getLinearDepth( const in vec2 screenPosition ) {     #if PERSPECTIVE_CAMERA == 1      float fragCoordZ = texture2D( tDepth, screenPosition ).x;     float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );     return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );     #else      return texture2D( tDepth, screenPosition ).x;     #endif    }    void main() {     float depth = getLinearDepth( vUv );    gl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );    }|  };  const SSAOBlurShader = {   name: 'SSAOBlurShader',   uniforms: {    'tDiffuse': { value: null },   'resolution': { value: new Vector2() }   },   vertexShader:    |varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader:    |uniform sampler2D tDiffuse;    uniform vec2 resolution;    varying vec2 vUv;    void main() {     vec2 texelSize = ( 1.0 / resolution );    float result = 0.0;     for ( int i = - 2; i <= 2; i ++ ) {      for ( int j = - 2; j <= 2; j ++ ) {       vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;      result += texture2D( tDiffuse, vUv + offset ).r;      }     }     gl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );    }|  };  export { SSAOShader, SSAODepthShader, SSAOBlurShader }; 
^..^ FILENAME ^..^
addons|shaders|SSRShader.js
^..^ CONTENTS ^..^
import {  Matrix4,  Vector2 } from 'three'; /**  * References:  * https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html  */  const SSRShader = {   name: 'SSRShader',   defines: {   MAX_STEP: 0,   PERSPECTIVE_CAMERA: true,   DISTANCE_ATTENUATION: true,   FRESNEL: true,   INFINITE_THICK: false,   SELECTIVE: false,  },   uniforms: {    'tDiffuse': { value: null },   'tNormal': { value: null },   'tMetalness': { value: null },   'tDepth': { value: null },   'cameraNear': { value: null },   'cameraFar': { value: null },   'resolution': { value: new Vector2() },   'cameraProjectionMatrix': { value: new Matrix4() },   'cameraInverseProjectionMatrix': { value: new Matrix4() },   'opacity': { value: .5 },   'maxDistance': { value: 180 },   'cameraRange': { value: 0 },   'thickness': { value: .018 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }   |,   fragmentShader: /* glsl */|   // precision highp float;   precision highp sampler2D;   varying vec2 vUv;   uniform sampler2D tDepth;   uniform sampler2D tNormal;   uniform sampler2D tMetalness;   uniform sampler2D tDiffuse;   uniform float cameraRange;   uniform vec2 resolution;   uniform float opacity;   uniform float cameraNear;   uniform float cameraFar;   uniform float maxDistance;   uniform float thickness;   uniform mat4 cameraProjectionMatrix;   uniform mat4 cameraInverseProjectionMatrix;   #include <packing>   float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {    //x0: point, x1: linePointA, x2: linePointB    //https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html    return length(cross(x0-x1,x0-x2))/length(x2-x1);   }   float pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){    // https://mathworld.wolfram.com/Point-PlaneDistance.html    //// https://en.wikipedia.org/wiki/Plane_(geometry)    //// http://paulbourke.net/geometry/pointlineplane/    float a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;    float x0=point.x,y0=point.y,z0=point.z;    float x=planePoint.x,y=planePoint.y,z=planePoint.z;    float d=-(a*x+b*y+c*z);    float distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);    return distance;   }   float getDepth( const in vec2 uv ) {    return texture2D( tDepth, uv ).x;   }   float getViewZ( const in float depth ) {    #ifdef PERSPECTIVE_CAMERA     return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );    #else     return orthographicDepthToViewZ( depth, cameraNear, cameraFar );    #endif   }   vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {    vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc    clipPosition *= clipW; //clip    return ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view   }   vec3 getViewNormal( const in vec2 uv ) {    return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );   }   vec2 viewPositionToXY(vec3 viewPosition){    vec2 xy;    vec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);    xy=clip.xy;//clip    float clipW=clip.w;    xy/=clipW;//NDC    xy=(xy+1.)/2.;//uv    xy*=resolution;//screen    return xy;   }   void main(){    #ifdef SELECTIVE     float metalness=texture2D(tMetalness,vUv).r;     if(metalness==0.) return;    #endif     float depth = getDepth( vUv );    float viewZ = getViewZ( depth );    if(-viewZ>=cameraFar) return;     float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];    vec3 viewPosition=getViewPosition( vUv, depth, clipW );     vec2 d0=gl_FragCoord.xy;    vec2 d1;     vec3 viewNormal=getViewNormal( vUv );     #ifdef PERSPECTIVE_CAMERA     vec3 viewIncidentDir=normalize(viewPosition);     vec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);    #else     vec3 viewIncidentDir=vec3(0,0,-1);     vec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);    #endif     float maxReflectRayLen=maxDistance/dot(-viewIncidentDir,viewNormal);    // dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html    // if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)    // maxDistance/maxReflectRayLen=cos(theta)    // maxDistance/maxReflectRayLen==dot(a,b)    // maxReflectRayLen==maxDistance/dot(a,b)     vec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;    #ifdef PERSPECTIVE_CAMERA     if(d1viewPosition.z>-cameraNear){      //https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx      float t=(-cameraNear-viewPosition.z)/viewReflectDir.z;      d1viewPosition=viewPosition+viewReflectDir*t;     }    #endif    d1=viewPositionToXY(d1viewPosition);     float totalLen=length(d1-d0);    float xLen=d1.x-d0.x;    float yLen=d1.y-d0.y;    float totalStep=max(abs(xLen),abs(yLen));    float xSpan=xLen/totalStep;    float ySpan=yLen/totalStep;    for(float i=0.;i<float(MAX_STEP);i++){     if(i>=totalStep) break;     vec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);     if(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;     float s=length(xy-d0)/totalLen;     vec2 uv=xy/resolution;      float d = getDepth(uv);     float vZ = getViewZ( d );     if(-vZ>=cameraFar) continue;     float cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];     vec3 vP=getViewPosition( uv, d, cW );      #ifdef PERSPECTIVE_CAMERA      // https://comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf      float recipVPZ=1./viewPosition.z;      float viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));     #else      float viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);     #endif      // if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.     // https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164     if(viewReflectRayZ<=vZ){       bool hit;      #ifdef INFINITE_THICK       hit=true;      #else       float away=pointToLineDistance(vP,viewPosition,d1viewPosition);        float minThickness;       vec2 xyNeighbor=xy;       xyNeighbor.x+=1.;       vec2 uvNeighbor=xyNeighbor/resolution;       vec3 vPNeighbor=getViewPosition(uvNeighbor,d,cW);       minThickness=vPNeighbor.x-vP.x;       minThickness*=3.;       float tk=max(minThickness,thickness);        hit=away<=tk;      #endif       if(hit){       vec3 vN=getViewNormal( uv );       if(dot(viewReflectDir,vN)>=0.) continue;       float distance=pointPlaneDistance(vP,viewPosition,viewNormal);       if(distance>maxDistance) break;       float op=opacity;       #ifdef DISTANCE_ATTENUATION        float ratio=1.-(distance/maxDistance);        float attenuation=ratio*ratio;        op=opacity*attenuation;       #endif       #ifdef FRESNEL        float fresnelCoe=(dot(viewIncidentDir,viewReflectDir)+1.)/2.;        op*=fresnelCoe;       #endif       vec4 reflectColor=texture2D(tDiffuse,uv);       gl_FragColor.xyz=reflectColor.xyz;       gl_FragColor.a=op;       break;      }     }    }   }  |  };  const SSRDepthShader = {   name: 'SSRDepthShader',   defines: {   'PERSPECTIVE_CAMERA': 1  },   uniforms: {    'tDepth': { value: null },   'cameraNear': { value: null },   'cameraFar': { value: null },   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }   |,   fragmentShader: /* glsl */|    uniform sampler2D tDepth;    uniform float cameraNear;   uniform float cameraFar;    varying vec2 vUv;    #include <packing>    float getLinearDepth( const in vec2 uv ) {     #if PERSPECTIVE_CAMERA == 1      float fragCoordZ = texture2D( tDepth, uv ).x;     float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );     return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );     #else      return texture2D( tDepth, uv ).x;     #endif    }    void main() {     float depth = getLinearDepth( vUv );    float d = 1.0 - depth;    // d=(d-.999)*1000.;    gl_FragColor = vec4( vec3( d ), 1.0 );    }   |  };  const SSRBlurShader = {   name: 'SSRBlurShader',   uniforms: {    'tDiffuse': { value: null },   'resolution': { value: new Vector2() },   'opacity': { value: .5 },   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }   |,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;   uniform vec2 resolution;   varying vec2 vUv;   void main() {    //reverse engineering from PhotoShop blur filter, then change coefficient     vec2 texelSize = ( 1.0 / resolution );     vec4 c=texture2D(tDiffuse,vUv);     vec2 offset;     offset=(vec2(-1,0))*texelSize;    vec4 cl=texture2D(tDiffuse,vUv+offset);     offset=(vec2(1,0))*texelSize;    vec4 cr=texture2D(tDiffuse,vUv+offset);     offset=(vec2(0,-1))*texelSize;    vec4 cb=texture2D(tDiffuse,vUv+offset);     offset=(vec2(0,1))*texelSize;    vec4 ct=texture2D(tDiffuse,vUv+offset);     // float coeCenter=.5;    // float coeSide=.125;    float coeCenter=.2;    float coeSide=.2;    float a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;    vec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;    gl_FragColor=vec4(rgb,a);    }  |   };  export { SSRShader, SSRDepthShader, SSRBlurShader }; 
^..^ FILENAME ^..^
addons|shaders|SubsurfaceScatteringShader.js
^..^ CONTENTS ^..^
import {  Color,  ShaderChunk,  ShaderLib,  UniformsUtils } from 'three';  /**  * ------------------------------------------------------------------------------------------  * Subsurface Scattering shader  * Based on GDC 2011 ?" Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look  * https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/  *------------------------------------------------------------------------------------------  */  function replaceAll( string, find, replace ) {   return string.split( find ).join( replace );  }  const meshphong_frag_head = ShaderChunk[ 'meshphong_frag' ].slice( 0, ShaderChunk[ 'meshphong_frag' ].indexOf( 'void main() {' ) ); const meshphong_frag_body = ShaderChunk[ 'meshphong_frag' ].slice( ShaderChunk[ 'meshphong_frag' ].indexOf( 'void main() {' ) );  const SubsurfaceScatteringShader = {   name: 'SubsurfaceScatteringShader',   uniforms: UniformsUtils.merge( [   ShaderLib[ 'phong' ].uniforms,   {    'thicknessMap': { value: null },    'thicknessColor': { value: new Color( 0xffffff ) },    'thicknessDistortion': { value: 0.1 },    'thicknessAmbient': { value: 0.0 },    'thicknessAttenuation': { value: 0.1 },    'thicknessPower': { value: 2.0 },    'thicknessScale': { value: 10.0 }   }   ] ),   vertexShader: [   '#define USE_UV',   ShaderChunk[ 'meshphong_vert' ],  ].join( '|n' ),   fragmentShader: [   '#define USE_UV',   '#define SUBSURFACE',    meshphong_frag_head,    'uniform sampler2D thicknessMap;',   'uniform float thicknessPower;',   'uniform float thicknessScale;',   'uniform float thicknessDistortion;',   'uniform float thicknessAmbient;',   'uniform float thicknessAttenuation;',   'uniform vec3 thicknessColor;',    'void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {',   ' vec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;',   ' vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));',   ' float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;',   ' vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;',   ' reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;',   '}',    meshphong_frag_body.replace( '#include <lights_fragment_begin>',     replaceAll(     ShaderChunk[ 'lights_fragment_begin' ],     'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',     [      'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',       '#if defined( SUBSURFACE ) && defined( USE_UV )',      ' RE_Direct_Scattering(directLight, vUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);',      '#endif',     ].join( '|n' )    ),    ),   ].join( '|n' ),  };  export { SubsurfaceScatteringShader }; 
^..^ FILENAME ^..^
addons|shaders|TechnicolorShader.js
^..^ CONTENTS ^..^
/**  * Technicolor Shader  * Simulates the look of the two-strip technicolor process popular in early 20th century films.  * More historical info here: http://www.widescreenmuseum.com/oldcolor/technicolor1.htm  * Demo here: http://charliehoey.com/technicolor_shader/shader_test.html  */  const TechnicolorShader = {   name: 'TechnicolorShader',   uniforms: {    'tDiffuse': { value: null }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;   varying vec2 vUv;    void main() {     vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );    vec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);     gl_FragColor = newTex;    }|  };  export { TechnicolorShader }; 
^..^ FILENAME ^..^
addons|shaders|ToonShader.js
^..^ CONTENTS ^..^
import {  Color,  Vector3 } from 'three';  /**  * Currently contains:  *  * toon1  * toon2  * hatching  * dotted  */  const ToonShader1 = {   uniforms: {    'uDirLightPos': { value: new Vector3() },   'uDirLightColor': { value: new Color( 0xeeeeee ) },    'uAmbientLightColor': { value: new Color( 0x050505 ) },    'uBaseColor': { value: new Color( 0xffffff ) }   },   vertexShader: /* glsl */|    varying vec3 vNormal;   varying vec3 vRefract;    void main() {     vec4 worldPosition = modelMatrix * vec4( position, 1.0 );    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );    vec3 worldNormal = normalize ( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );     vNormal = normalize( normalMatrix * normal );     vec3 I = worldPosition.xyz - cameraPosition;    vRefract = refract( normalize( I ), worldNormal, 1.02 );     gl_Position = projectionMatrix * mvPosition;    }|,   fragmentShader: /* glsl */|    uniform vec3 uBaseColor;    uniform vec3 uDirLightPos;   uniform vec3 uDirLightColor;    uniform vec3 uAmbientLightColor;    varying vec3 vNormal;    varying vec3 vRefract;    void main() {     float directionalLightWeighting = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);    vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;     float intensity = smoothstep( - 0.5, 1.0, pow( length(lightWeighting), 20.0 ) );    intensity += length(lightWeighting) * 0.2;     float cameraWeighting = dot( normalize( vNormal ), vRefract );    intensity += pow( 1.0 - length( cameraWeighting ), 6.0 );    intensity = intensity * 0.2 + 0.3;     if ( intensity < 0.50 ) {      gl_FragColor = vec4( 2.0 * intensity * uBaseColor, 1.0 );     } else {      gl_FragColor = vec4( 1.0 - 2.0 * ( 1.0 - intensity ) * ( 1.0 - uBaseColor ), 1.0 );     }     #include <colorspace_fragment>    }|  };  const ToonShader2 = {   uniforms: {    'uDirLightPos': { value: new Vector3() },   'uDirLightColor': { value: new Color( 0xeeeeee ) },    'uAmbientLightColor': { value: new Color( 0x050505 ) },    'uBaseColor': { value: new Color( 0xeeeeee ) },   'uLineColor1': { value: new Color( 0x808080 ) },   'uLineColor2': { value: new Color( 0x000000 ) },   'uLineColor3': { value: new Color( 0x000000 ) },   'uLineColor4': { value: new Color( 0x000000 ) }   },   vertexShader: /* glsl */|    varying vec3 vNormal;    void main() {     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    vNormal = normalize( normalMatrix * normal );    }|,   fragmentShader: /* glsl */|    uniform vec3 uBaseColor;   uniform vec3 uLineColor1;   uniform vec3 uLineColor2;   uniform vec3 uLineColor3;   uniform vec3 uLineColor4;    uniform vec3 uDirLightPos;   uniform vec3 uDirLightColor;    uniform vec3 uAmbientLightColor;    varying vec3 vNormal;    void main() {     float camera = max( dot( normalize( vNormal ), vec3( 0.0, 0.0, 1.0 ) ), 0.4);    float light = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);     gl_FragColor = vec4( uBaseColor, 1.0 );     if ( length(uAmbientLightColor + uDirLightColor * light) < 1.00 ) {      gl_FragColor *= vec4( uLineColor1, 1.0 );     }     if ( length(uAmbientLightColor + uDirLightColor * camera) < 0.50 ) {      gl_FragColor *= vec4( uLineColor2, 1.0 );     }     #include <colorspace_fragment>    }|  };  const ToonShaderHatching = {   uniforms: {    'uDirLightPos': { value: new Vector3() },   'uDirLightColor': { value: new Color( 0xeeeeee ) },    'uAmbientLightColor': { value: new Color( 0x050505 ) },    'uBaseColor': { value: new Color( 0xffffff ) },   'uLineColor1': { value: new Color( 0x000000 ) },   'uLineColor2': { value: new Color( 0x000000 ) },   'uLineColor3': { value: new Color( 0x000000 ) },   'uLineColor4': { value: new Color( 0x000000 ) }   },   vertexShader: /* glsl */|    varying vec3 vNormal;    void main() {     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    vNormal = normalize( normalMatrix * normal );    }|,   fragmentShader: /* glsl */|    uniform vec3 uBaseColor;   uniform vec3 uLineColor1;   uniform vec3 uLineColor2;   uniform vec3 uLineColor3;   uniform vec3 uLineColor4;    uniform vec3 uDirLightPos;   uniform vec3 uDirLightColor;    uniform vec3 uAmbientLightColor;    varying vec3 vNormal;    void main() {     float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);    vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;     gl_FragColor = vec4( uBaseColor, 1.0 );     if ( length(lightWeighting) < 1.00 ) {      if ( mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {       gl_FragColor = vec4( uLineColor1, 1.0 );      }     }     if ( length(lightWeighting) < 0.75 ) {      if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {       gl_FragColor = vec4( uLineColor2, 1.0 );      }     }     if ( length(lightWeighting) < 0.50 ) {      if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {       gl_FragColor = vec4( uLineColor3, 1.0 );      }     }     if ( length(lightWeighting) < 0.3465 ) {      if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {       gl_FragColor = vec4( uLineColor4, 1.0 );     }     }     #include <colorspace_fragment>    }|  };  const ToonShaderDotted = {   uniforms: {    'uDirLightPos': { value: new Vector3() },   'uDirLightColor': { value: new Color( 0xeeeeee ) },    'uAmbientLightColor': { value: new Color( 0x050505 ) },    'uBaseColor': { value: new Color( 0xffffff ) },   'uLineColor1': { value: new Color( 0x000000 ) }   },   vertexShader: /* glsl */|    varying vec3 vNormal;    void main() {     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    vNormal = normalize( normalMatrix * normal );    }|,   fragmentShader: /* glsl */|    uniform vec3 uBaseColor;   uniform vec3 uLineColor1;   uniform vec3 uLineColor2;   uniform vec3 uLineColor3;   uniform vec3 uLineColor4;    uniform vec3 uDirLightPos;   uniform vec3 uDirLightColor;    uniform vec3 uAmbientLightColor;    varying vec3 vNormal;    void main() {     float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);    vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;     gl_FragColor = vec4( uBaseColor, 1.0 );     if ( length(lightWeighting) < 1.00 ) {      if ( ( mod(gl_FragCoord.x, 4.001) + mod(gl_FragCoord.y, 4.0) ) > 6.00 ) {       gl_FragColor = vec4( uLineColor1, 1.0 );      }     }     if ( length(lightWeighting) < 0.50 ) {      if ( ( mod(gl_FragCoord.x + 2.0, 4.001) + mod(gl_FragCoord.y + 2.0, 4.0) ) > 6.00 ) {       gl_FragColor = vec4( uLineColor1, 1.0 );      }     }     #include <colorspace_fragment>    }|  };  export { ToonShader1, ToonShader2, ToonShaderHatching, ToonShaderDotted }; 
^..^ FILENAME ^..^
addons|shaders|TriangleBlurShader.js
^..^ CONTENTS ^..^
import {  Vector2 } from 'three';  /**  * Triangle blur shader  * based on glfx.js triangle blur shader  * https://github.com/evanw/glfx.js  *  * A basic blur filter, which convolves the image with a  * pyramid filter. The pyramid filter is separable and is applied as two  * perpendicular triangle filters.  */  const TriangleBlurShader = {   name: 'TriangleBlurShader',   uniforms: {    'texture': { value: null },   'delta': { value: new Vector2( 1, 1 ) }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    #include <common>    #define ITERATIONS 10.0    uniform sampler2D texture;   uniform vec2 delta;    varying vec2 vUv;    void main() {     vec4 color = vec4( 0.0 );     float total = 0.0;    // randomize the lookup values to hide the fixed number of samples     float offset = rand( vUv );     for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {      float percent = ( t + offset - 0.5 ) / ITERATIONS;     float weight = 1.0 - abs( percent );      color += texture2D( texture, vUv + delta * percent ) * weight;     total += weight;     }     gl_FragColor = color / total;    }|  };  export { TriangleBlurShader }; 
^..^ FILENAME ^..^
addons|shaders|UnpackDepthRGBAShader.js
^..^ CONTENTS ^..^
/**  * Unpack RGBA depth shader  * - show RGBA encoded depth as monochrome color  */  const UnpackDepthRGBAShader = {   name: 'UnpackDepthRGBAShader',   uniforms: {    'tDiffuse': { value: null },   'opacity': { value: 1.0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform float opacity;    uniform sampler2D tDiffuse;    varying vec2 vUv;    #include <packing>    void main() {     float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );    gl_FragColor = vec4( vec3( depth ), opacity );    }|  };  export { UnpackDepthRGBAShader }; 
^..^ FILENAME ^..^
addons|shaders|VelocityShader.js
^..^ CONTENTS ^..^
import {  UniformsLib,  UniformsUtils,  Matrix4 } from 'three';  /**  * Mesh Velocity Shader @bhouston  */  const VelocityShader = {   name: 'VelocityShader',   uniforms: UniformsUtils.merge( [   UniformsLib.common,   UniformsLib.displacementmap,   {    modelMatrixPrev: { value: new Matrix4() },    currentProjectionViewMatrix: { value: new Matrix4() },    previousProjectionViewMatrix: { value: new Matrix4() }   }  ] ),   vertexShader: /* glsl */| #define NORMAL  #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )   varying vec3 vViewPosition;  #endif  #include <common> #include <packing> #include <uv_pars_vertex> #include <displacementmap_pars_vertex> #include <normal_pars_vertex> #include <morphtarget_pars_vertex> #include <skinning_pars_vertex> #include <logdepthbuf_pars_vertex> #include <clipping_planes_pars_vertex>  uniform mat4 previousProjectionViewMatrix; uniform mat4 currentProjectionViewMatrix;  uniform mat4 modelMatrixPrev;  varying vec4 clipPositionCurrent; varying vec4 clipPositionPrevious;  void main() {    #include <uv_vertex>   #include <beginnormal_vertex>  #include <morphnormal_vertex>  #include <skinbase_vertex>  #include <skinnormal_vertex>  #include <defaultnormal_vertex>  #include <normal_vertex>   #include <begin_vertex>  #include <morphtarget_vertex>  #include <displacementmap_vertex>  #include <morphtarget_vertex>  #include <skinning_vertex>  #ifdef USE_SKINNING   vec4 mvPosition = modelViewMatrix * skinned;  clipPositionCurrent  = currentProjectionViewMatrix * modelMatrix * skinned;  clipPositionPrevious = previousProjectionViewMatrix * modelMatrixPrev * skinned;  #else   vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );  clipPositionCurrent  = currentProjectionViewMatrix * modelMatrix * vec4( transformed, 1.0 );  clipPositionPrevious = previousProjectionViewMatrix * modelMatrixPrev * vec4( transformed, 1.0 );  #endif   gl_Position = projectionMatrix * mvPosition;   #include <logdepthbuf_vertex>  #include <clipping_planes_vertex> } |,  fragmentShader: /* glsl */| #define NORMAL  uniform float opacity;  #include <packing> #include <uv_pars_fragment> #include <map_pars_fragment> #include <alphamap_pars_fragment> #include <alphatest_pars_fragment> #include <logdepthbuf_pars_fragment> #include <clipping_planes_pars_fragment>  varying vec4 clipPositionCurrent; varying vec4 clipPositionPrevious;  void main() {   vec4 diffuseColor = vec4( 1.0 );  diffuseColor.a = opacity;   #include <map_fragment>  #include <alphamap_fragment>  #include <alphatest_fragment>   vec2 ndcPositionCurrent  = clipPositionCurrent.xy/clipPositionCurrent.w;  vec2 ndcPositionPrevious = clipPositionPrevious.xy/clipPositionPrevious.w;  vec2 vel = ( ndcPositionCurrent - ndcPositionPrevious ) * 0.5;  vel = vel * 0.5 + 0.5;  vec2 v1 = packDepthToRG(vel.x);  vec2 v2 = packDepthToRG(vel.y);  gl_FragColor = vec4(v1.x, v1.y, v2.x, v2.y);   #include <logdepthbuf_fragment>  }  | };  export { VelocityShader }; 
^..^ FILENAME ^..^
addons|shaders|VerticalBlurShader.js
^..^ CONTENTS ^..^
/**  * Two pass Gaussian blur filter (horizontal and vertical blur shaders)  * - see http://www.cake23.de/traveling-wavefronts-lit-up.html  *  * - 9 samples per pass  * - standard deviation 2.7  * - "h" and "v" parameters should be set to "1 / width" and "1 / height"  */  const VerticalBlurShader = {   name: 'VerticalBlurShader',   uniforms: {    'tDiffuse': { value: null },   'v': { value: 1.0 / 512.0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;   uniform float v;    varying vec2 vUv;    void main() {     vec4 sum = vec4( 0.0 );     sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;     gl_FragColor = sum;    }|  };  export { VerticalBlurShader }; 
^..^ FILENAME ^..^
addons|shaders|VerticalTiltShiftShader.js
^..^ CONTENTS ^..^
/**  * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position  *  * - 9 samples per pass  * - standard deviation 2.7  * - "h" and "v" parameters should be set to "1 / width" and "1 / height"  * - "r" parameter control where "focused" horizontal line lies  */  const VerticalTiltShiftShader = {   name: 'VerticalTiltShiftShader',   uniforms: {    'tDiffuse': { value: null },   'v': { value: 1.0 / 512.0 },   'r': { value: 0.35 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform sampler2D tDiffuse;   uniform float v;   uniform float r;    varying vec2 vUv;    void main() {     vec4 sum = vec4( 0.0 );     float vv = v * abs( r - vUv.y );     sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;     gl_FragColor = sum;    }|  };  export { VerticalTiltShiftShader }; 
^..^ FILENAME ^..^
addons|shaders|VignetteShader.js
^..^ CONTENTS ^..^
/**  * Vignette shader  * based on PaintEffect postprocess from ro.me  * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js  */  const VignetteShader = {   name: 'VignetteShader',   uniforms: {    'tDiffuse': { value: null },   'offset': { value: 1.0 },   'darkness': { value: 1.0 }   },   vertexShader: /* glsl */|    varying vec2 vUv;    void main() {     vUv = uv;    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform float offset;   uniform float darkness;    uniform sampler2D tDiffuse;    varying vec2 vUv;    void main() {     // Eskil's vignette     vec4 texel = texture2D( tDiffuse, vUv );    vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );    gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );    }|  };  export { VignetteShader }; 
^..^ FILENAME ^..^
addons|shaders|VolumeShader.js
^..^ CONTENTS ^..^
import {  Vector2,  Vector3 } from 'three';  /**  * Shaders to render 3D volumes using raycasting.  * The applied techniques are based on similar implementations in the Visvis and Vispy projects.  * This is not the only approach, therefore it's marked 1.  */  const VolumeRenderShader1 = {   uniforms: {   'u_size': { value: new Vector3( 1, 1, 1 ) },   'u_renderstyle': { value: 0 },   'u_renderthreshold': { value: 0.5 },   'u_clim': { value: new Vector2( 1, 1 ) },   'u_data': { value: null },   'u_cmdata': { value: null }  },   vertexShader: /* glsl */|    varying vec4 v_nearpos;   varying vec4 v_farpos;   varying vec3 v_position;    void main() {     // Prepare transforms to map to "camera view". See also:     // https://threejs.org/docs/#api/renderers/webgl/WebGLProgram     mat4 viewtransformf = modelViewMatrix;     mat4 viewtransformi = inverse(modelViewMatrix);      // Project local vertex coordinate to camera position. Then do a step     // backward (in cam coords) to the near clipping plane, and project back. Do     // the same for the far clipping plane. This gives us all the information we     // need to calculate the ray and truncate it to the viewing cone.     vec4 position4 = vec4(position, 1.0);     vec4 pos_in_cam = viewtransformf * position4;      // Intersection of ray and near clipping plane (z = -1 in clip coords)     pos_in_cam.z = -pos_in_cam.w;     v_nearpos = viewtransformi * pos_in_cam;      // Intersection of ray and far clipping plane (z = +1 in clip coords)     pos_in_cam.z = pos_in_cam.w;     v_farpos = viewtransformi * pos_in_cam;      // Set varyings and output pos     v_position = position;     gl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;   }|,   fragmentShader: /* glsl */|      precision highp float;     precision mediump sampler3D;      uniform vec3 u_size;     uniform int u_renderstyle;     uniform float u_renderthreshold;     uniform vec2 u_clim;      uniform sampler3D u_data;     uniform sampler2D u_cmdata;      varying vec3 v_position;     varying vec4 v_nearpos;     varying vec4 v_farpos;      // The maximum distance through our rendering volume is sqrt(3).     const int MAX_STEPS = 887; // 887 for 512^3, 1774 for 1024^3     const int REFINEMENT_STEPS = 4;     const float relative_step_size = 1.0;     const vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);     const vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);     const vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);     const float shininess = 40.0;      void cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);     void cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);      float sample1(vec3 texcoords);     vec4 apply_colormap(float val);     vec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);       void main() {       // Normalize clipping plane info       vec3 farpos = v_farpos.xyz / v_farpos.w;       vec3 nearpos = v_nearpos.xyz / v_nearpos.w;        // Calculate unit vector pointing in the view direction through this fragment.       vec3 view_ray = normalize(nearpos.xyz - farpos.xyz);        // Compute the (negative) distance to the front surface or near clipping plane.       // v_position is the back face of the cuboid, so the initial distance calculated in the dot       // product below is the distance from near clip plane to the back of the cuboid       float distance = dot(nearpos - v_position, view_ray);       distance = max(distance, min((-0.5 - v_position.x) / view_ray.x,                     (u_size.x - 0.5 - v_position.x) / view_ray.x));       distance = max(distance, min((-0.5 - v_position.y) / view_ray.y,                     (u_size.y - 0.5 - v_position.y) / view_ray.y));       distance = max(distance, min((-0.5 - v_position.z) / view_ray.z,                     (u_size.z - 0.5 - v_position.z) / view_ray.z));        // Now we have the starting position on the front surface       vec3 front = v_position + view_ray * distance;        // Decide how many steps to take       int nsteps = int(-distance / relative_step_size + 0.5);       if ( nsteps < 1 )         discard;        // Get starting location and step vector in texture coordinates       vec3 step = ((v_position - front) / u_size) / float(nsteps);       vec3 start_loc = front / u_size;        // For testing: show the number of steps. This helps to establish       // whether the rays are correctly oriented       //'gl_FragColor = vec4(0.0, float(nsteps) / 1.0 / u_size.x, 1.0, 1.0);       //'return;        if (u_renderstyle == 0)         cast_mip(start_loc, step, nsteps, view_ray);       else if (u_renderstyle == 1)         cast_iso(start_loc, step, nsteps, view_ray);        if (gl_FragColor.a < 0.05)         discard;     }       float sample1(vec3 texcoords) {       /* Sample float value from a 3D texture. Assumes intensity data. */       return texture(u_data, texcoords.xyz).r;     }       vec4 apply_colormap(float val) {       val = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);       return texture2D(u_cmdata, vec2(val, 0.5));     }       void cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {        float max_val = -1e6;       int max_i = 100;       vec3 loc = start_loc;        // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with       // non-constant expression. So we use a hard-coded max, and an additional condition       // inside the loop.       for (int iter=0; iter<MAX_STEPS; iter++) {         if (iter >= nsteps)           break;         // Sample from the 3D texture         float val = sample1(loc);         // Apply MIP operation         if (val > max_val) {           max_val = val;           max_i = iter;         }         // Advance location deeper into the volume         loc += step;       }        // Refine location, gives crispier images       vec3 iloc = start_loc + step * (float(max_i) - 0.5);       vec3 istep = step / float(REFINEMENT_STEPS);       for (int i=0; i<REFINEMENT_STEPS; i++) {         max_val = max(max_val, sample1(iloc));         iloc += istep;       }        // Resolve final color       gl_FragColor = apply_colormap(max_val);     }       void cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {        gl_FragColor = vec4(0.0); // init transparent       vec4 color3 = vec4(0.0); // final color       vec3 dstep = 1.5 / u_size; // step to sample derivative       vec3 loc = start_loc;        float low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);        // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with       // non-constant expression. So we use a hard-coded max, and an additional condition       // inside the loop.       for (int iter=0; iter<MAX_STEPS; iter++) {         if (iter >= nsteps)           break;          // Sample from the 3D texture         float val = sample1(loc);          if (val > low_threshold) {           // Take the last interval in smaller steps           vec3 iloc = loc - 0.5 * step;           vec3 istep = step / float(REFINEMENT_STEPS);           for (int i=0; i<REFINEMENT_STEPS; i++) {             val = sample1(iloc);             if (val > u_renderthreshold) {               gl_FragColor = add_lighting(val, iloc, dstep, view_ray);               return;             }             iloc += istep;           }         }          // Advance location deeper into the volume         loc += step;       }     }       vec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)     {      // Calculate color by incorporating lighting        // View direction       vec3 V = normalize(view_ray);        // calculate normal vector from gradient       vec3 N;       float val1, val2;       val1 = sample1(loc + vec3(-step[0], 0.0, 0.0));       val2 = sample1(loc + vec3(+step[0], 0.0, 0.0));       N[0] = val1 - val2;       val = max(max(val1, val2), val);       val1 = sample1(loc + vec3(0.0, -step[1], 0.0));       val2 = sample1(loc + vec3(0.0, +step[1], 0.0));       N[1] = val1 - val2;       val = max(max(val1, val2), val);       val1 = sample1(loc + vec3(0.0, 0.0, -step[2]));       val2 = sample1(loc + vec3(0.0, 0.0, +step[2]));       N[2] = val1 - val2;       val = max(max(val1, val2), val);        float gm = length(N); // gradient magnitude       N = normalize(N);        // Flip normal so it points towards viewer       float Nselect = float(dot(N, V) > 0.0);       N = (2.0 * Nselect - 1.0) * N; // == Nselect * N - (1.0-Nselect)*N;        // Init colors       vec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);       vec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);       vec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);        // note: could allow multiple lights       for (int i=0; i<1; i++)       {          // Get light direction (make sure to prevent zero devision)         vec3 L = normalize(view_ray); //lightDirs[i];         float lightEnabled = float( length(L) > 0.0 );         L = normalize(L + (1.0 - lightEnabled));          // Calculate lighting properties         float lambertTerm = clamp(dot(N, L), 0.0, 1.0);         vec3 H = normalize(L+V); // Halfway vector         float specularTerm = pow(max(dot(H, N), 0.0), shininess);          // Calculate mask         float mask1 = lightEnabled;          // Calculate colors         ambient_color += mask1 * ambient_color; // * gl_LightSource[i].ambient;         diffuse_color += mask1 * lambertTerm;         specular_color += mask1 * specularTerm * specular_color;       }        // Calculate final color by componing different components       vec4 final_color;       vec4 color = apply_colormap(val);       final_color = color * (ambient_color + diffuse_color) + specular_color;       final_color.a = color.a;       return final_color;     }|  };  export { VolumeRenderShader1 }; 
^..^ FILENAME ^..^
addons|shaders|WaterRefractionShader.js
^..^ CONTENTS ^..^
const WaterRefractionShader = {   name: 'WaterRefractionShader',   uniforms: {    'color': {    value: null   },    'time': {    value: 0   },    'tDiffuse': {    value: null   },    'tDudv': {    value: null   },    'textureMatrix': {    value: null   }   },   vertexShader: /* glsl */|    uniform mat4 textureMatrix;    varying vec2 vUv;   varying vec4 vUvRefraction;    void main() {     vUv = uv;     vUvRefraction = textureMatrix * vec4( position, 1.0 );     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }|,   fragmentShader: /* glsl */|    uniform vec3 color;   uniform float time;   uniform sampler2D tDiffuse;   uniform sampler2D tDudv;    varying vec2 vUv;   varying vec4 vUvRefraction;    float blendOverlay( float base, float blend ) {     return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );    }    vec3 blendOverlay( vec3 base, vec3 blend ) {     return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ),blendOverlay( base.b, blend.b ) );    }    void main() {     float waveStrength = 0.5;    float waveSpeed = 0.03;     // simple distortion (ripple) via dudv map (see https://www.youtube.com/watch?v=6B7IF6GOu7s)     vec2 distortedUv = texture2D( tDudv, vec2( vUv.x + time * waveSpeed, vUv.y ) ).rg * waveStrength;    distortedUv = vUv.xy + vec2( distortedUv.x, distortedUv.y + time * waveSpeed );    vec2 distortion = ( texture2D( tDudv, distortedUv ).rg * 2.0 - 1.0 ) * waveStrength;     // new uv coords     vec4 uv = vec4( vUvRefraction );    uv.xy += distortion;     vec4 base = texture2DProj( tDiffuse, uv );     gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );     #include <tonemapping_fragment>    #include <colorspace_fragment>    }|  };  export { WaterRefractionShader }; 
^..^ FILENAME ^..^
addons|textures|FlakesTexture.js
^..^ CONTENTS ^..^
class FlakesTexture {   constructor( width = 512, height = 512 ) {    const canvas = document.createElement( 'canvas' );   canvas.width = width;   canvas.height = height;    const context = canvas.getContext( '2d' );   context.fillStyle = 'rgb(127,127,255)';   context.fillRect( 0, 0, width, height );    for ( let i = 0; i < 4000; i ++ ) {     const x = Math.random() * width;    const y = Math.random() * height;    const r = Math.random() * 3 + 3;     let nx = Math.random() * 2 - 1;    let ny = Math.random() * 2 - 1;    let nz = 1.5;     const l = Math.sqrt( nx * nx + ny * ny + nz * nz );     nx /= l; ny /= l; nz /= l;     context.fillStyle = 'rgb(' + ( nx * 127 + 127 ) + ',' + ( ny * 127 + 127 ) + ',' + ( nz * 255 ) + ')';    context.beginPath();    context.arc( x, y, r, 0, Math.PI * 2 );    context.fill();    }    return canvas;   }  }  export { FlakesTexture }; 
^..^ FILENAME ^..^
addons|transpiler|AST.js
^..^ CONTENTS ^..^
export class Program {   constructor() {    this.body = [];    this.isProgram = true;   }  }  export class VariableDeclaration {   constructor( type, name, value = null, next = null, immutable = false ) {    this.type = type;   this.name = name;   this.value = value;   this.next = next;    this.immutable = immutable;    this.isVariableDeclaration = true;   }  }  export class Uniform {   constructor( type, name ) {    this.type = type;   this.name = name;    this.isUniform = true;   }  }  export class Varying {   constructor( type, name ) {    this.type = type;   this.name = name;    this.isVarying = true;   }  }  export class FunctionParameter {   constructor( type, name, qualifier = null, immutable = true ) {    this.type = type;   this.name = name;   this.qualifier = qualifier;   this.immutable = immutable;    this.isFunctionParameter = true;   }  }  export class FunctionDeclaration {   constructor( type, name, params = [] ) {    this.type = type;   this.name = name;   this.params = params;   this.body = [];    this.isFunctionDeclaration = true;   }  }  export class Expression {   constructor( expression ) {    this.expression = expression;    this.isExpression = true;   }  }  export class Ternary {   constructor( cond, left, right ) {    this.cond = cond;   this.left = left;   this.right = right;    this.isTernary = true;   }  }  export class Operator {   constructor( type, left, right ) {    this.type = type;   this.left = left;   this.right = right;    this.isOperator = true;   }  }   export class Unary {   constructor( type, expression, after = false ) {    this.type = type;   this.expression = expression;   this.after = after;    this.isUnary = true;   }  }  export class Number {   constructor( value, type = 'float' ) {    this.type = type;   this.value = value;    this.isNumber = true;   }  }  export class String {   constructor( value ) {    this.value = value;    this.isString = true;   }  }   export class Conditional {   constructor( cond = null ) {    this.cond = cond;    this.body = [];   this.elseConditional = null;    this.isConditional = true;   }  }  export class FunctionCall {   constructor( name, params = [] ) {    this.name = name;   this.params = params;    this.isFunctionCall = true;   }  }  export class Return {   constructor( value ) {    this.value = value;    this.isReturn = true;   }  }  export class Accessor {   constructor( property ) {    this.property = property;    this.isAccessor = true;   }  }  export class StaticElement {   constructor( value ) {    this.value = value;    this.isStaticElement = true;   }  }  export class DynamicElement {   constructor( value ) {    this.value = value;    this.isDynamicElement = true;   }  }  export class AccessorElements {   constructor( property, elements = [] ) {    this.property = property;   this.elements = elements;    this.isAccessorElements = true;   }  }  export class For {   constructor( initialization, condition, afterthought ) {    this.initialization = initialization;   this.condition = condition;   this.afterthought = afterthought;    this.body = [];    this.isFor = true;   }  } 
^..^ FILENAME ^..^
addons|transpiler|GLSLDecoder.js
^..^ CONTENTS ^..^
import { Program, FunctionDeclaration, For, AccessorElements, Ternary, Varying, DynamicElement, StaticElement, FunctionParameter, Unary, Conditional, VariableDeclaration, Operator, Number, String, FunctionCall, Return, Accessor, Uniform } from './AST.js';  const unaryOperators = [  '+', '-', '~', '!', '++', '--' ];  const precedenceOperators = [  '*', '/', '%',  '-', '+',  '<<', '>>',  '<', '>', '<=', '>=',  '==', '!=',  '&',  '^',  '|',  '&&',  '^^',  '||',  '?',  '=',  '+=', '-=', '*=', '/=', '%=', '^=', '&=', '|=', '<<=', '>>=',  ',' ].reverse();  const associativityRightToLeft = [  '=',  '+=', '-=', '*=', '/=', '%=', '^=', '&=', '|=', '<<=', '>>=',  ',',  '?',  ':' ];  const spaceRegExp = /^((|t| )|n*)+/; const lineRegExp = /^|n+/; const commentRegExp = /^|/|*[|s|S]*?|*|//; const inlineCommentRegExp = /^|/|/.*?(|n|$)/;  const numberRegExp = /^((0x|w+)|(|.?|d+|.?|d*((e-?|d+)||w)?))/; const stringDoubleRegExp = /^(|"((?:[^"||]|||.)*)|")/; const stringSingleRegExp = /^(|'((?:[^'||]|||.)*)|')/; const literalRegExp = /^[A-Za-z](|w||.)*/; const operatorsRegExp = new RegExp( '^(||' + [  '<<=', '>>=', '++', '--', '<<', '>>', '+=', '-=', '*=', '/=', '%=', '&=', '^^', '^=', '|=',  '<=', '>=', '==', '!=', '&&', '||',  '(', ')', '[', ']', '{', '}',  '.', ',', ';', '!', '=', '~', '*', '/', '%', '+', '-', '<', '>', '&', '^', '|', '?', ':', '#' ].join( '$' ).split( '' ).join( '||' ).replace( /|||$/g, '|' ) + ')' );  function getGroupDelta( str ) {   if ( str === '(' || str === '[' || str === '{' ) return 1;  if ( str === ')' || str === ']' || str === '}' ) return - 1;   return 0;  }  class Token {   constructor( tokenizer, type, str, pos ) {    this.tokenizer = tokenizer;    this.type = type;    this.str = str;   this.pos = pos;    this.tag = null;   }   get endPos() {    return this.pos + this.str.length;   }   get isNumber() {    return this.type === Token.NUMBER;   }   get isString() {    return this.type === Token.STRING;   }   get isLiteral() {    return this.type === Token.LITERAL;   }   get isOperator() {    return this.type === Token.OPERATOR;   }  }  Token.LINE = 'line'; Token.COMMENT = 'comment'; Token.NUMBER = 'number'; Token.STRING = 'string'; Token.LITERAL = 'literal'; Token.OPERATOR = 'operator';  const TokenParserList = [  { type: Token.LINE, regexp: lineRegExp, isTag: true },  { type: Token.COMMENT, regexp: commentRegExp, isTag: true },  { type: Token.COMMENT, regexp: inlineCommentRegExp, isTag: true },  { type: Token.NUMBER, regexp: numberRegExp },  { type: Token.STRING, regexp: stringDoubleRegExp, group: 2 },  { type: Token.STRING, regexp: stringSingleRegExp, group: 2 },  { type: Token.LITERAL, regexp: literalRegExp },  { type: Token.OPERATOR, regexp: operatorsRegExp } ];  class Tokenizer {   constructor( source ) {    this.source = source;   this.position = 0;    this.tokens = [];   }   tokenize() {    let token = this.readToken();    while ( token ) {     this.tokens.push( token );     token = this.readToken();    }    return this;   }   skip( ...params ) {    let remainingCode = this.source.substr( this.position );   let i = params.length;    while ( i -- ) {     const skip = params[ i ].exec( remainingCode );    const skipLength = skip ? skip[ 0 ].length : 0;     if ( skipLength > 0 ) {      this.position += skipLength;      remainingCode = this.source.substr( this.position );      // re-skip, new remainingCode is generated     // maybe exist previous regexp non detected     i = params.length;     }    }    return remainingCode;   }   readToken() {    const remainingCode = this.skip( spaceRegExp );    for ( var i = 0; i < TokenParserList.length; i ++ ) {     const parser = TokenParserList[ i ];    const result = parser.regexp.exec( remainingCode );     if ( result ) {      const token = new Token( this, parser.type, result[ parser.group || 0 ], this.position );      this.position += result[ 0 ].length;      if ( parser.isTag ) {       const nextToken = this.readToken();       if ( nextToken ) {        nextToken.tag = token;       }       return nextToken;      }      return token;     }    }   }  }  const isType = ( str ) => /void|bool|float|u?int|(u|i)?vec[234]/.test( str );  class GLSLDecoder {   constructor() {    this.index = 0;   this.tokenizer = null;   this.keywords = [];    this._currentFunction = null;    this.addPolyfill( 'gl_FragCoord', 'vec3 gl_FragCoord = vec3( screenCoordinate.x, screenCoordinate.y.oneMinus(), screenCoordinate.z );' );   }   addPolyfill( name, polyfill ) {    this.keywords.push( { name, polyfill } );    return this;   }   get tokens() {    return this.tokenizer.tokens;   }   readToken() {    return this.tokens[ this.index ++ ];   }   getToken( offset = 0 ) {    return this.tokens[ this.index + offset ];   }   getTokensUntil( str, tokens, offset = 0 ) {    const output = [];    let groupIndex = 0;    for ( let i = offset; i < tokens.length; i ++ ) {     const token = tokens[ i ];     groupIndex += getGroupDelta( token.str );     output.push( token );     if ( groupIndex === 0 && token.str === str ) {      break;     }    }    return output;   }   readTokensUntil( str ) {    const tokens = this.getTokensUntil( str, this.tokens, this.index );    this.index += tokens.length;    return tokens;   }   parseExpressionFromTokens( tokens ) {    if ( tokens.length === 0 ) return null;    const firstToken = tokens[ 0 ];   const lastToken = tokens[ tokens.length - 1 ];    // precedence operators    let groupIndex = 0;    for ( const operator of precedenceOperators ) {     const parseToken = ( i, inverse = false ) => {      const token = tokens[ i ];      groupIndex += getGroupDelta( token.str );      if ( ! token.isOperator || i === 0 || i === tokens.length - 1 ) return;      if ( groupIndex === 0 && token.str === operator ) {       if ( operator === '?' ) {        const conditionTokens = tokens.slice( 0, i );       const leftTokens = this.getTokensUntil( ':', tokens, i + 1 ).slice( 0, - 1 );       const rightTokens = tokens.slice( i + leftTokens.length + 2 );        const condition = this.parseExpressionFromTokens( conditionTokens );       const left = this.parseExpressionFromTokens( leftTokens );       const right = this.parseExpressionFromTokens( rightTokens );        return new Ternary( condition, left, right );       } else {        const left = this.parseExpressionFromTokens( tokens.slice( 0, i ) );       const right = this.parseExpressionFromTokens( tokens.slice( i + 1, tokens.length ) );        return this._evalOperator( new Operator( operator, left, right ) );       }      }      if ( inverse ) {       if ( groupIndex > 0 ) {        return this.parseExpressionFromTokens( tokens.slice( i ) );       }      } else {       if ( groupIndex < 0 ) {        return this.parseExpressionFromTokens( tokens.slice( 0, i ) );       }      }     };     if ( associativityRightToLeft.includes( operator ) ) {      for ( let i = 0; i < tokens.length; i ++ ) {       const result = parseToken( i );       if ( result ) return result;      }     } else {      for ( let i = tokens.length - 1; i >= 0; i -- ) {       const result = parseToken( i, true );       if ( result ) return result;      }     }    }    // unary operators (before)    if ( firstToken.isOperator ) {     for ( const operator of unaryOperators ) {      if ( firstToken.str === operator ) {       const right = this.parseExpressionFromTokens( tokens.slice( 1 ) );       return new Unary( operator, right );      }     }    }     // unary operators (after)    if ( lastToken.isOperator ) {     for ( const operator of unaryOperators ) {      if ( lastToken.str === operator ) {       const left = this.parseExpressionFromTokens( tokens.slice( 0, tokens.length - 1 ) );       return new Unary( operator, left, true );      }     }    }    // groups    if ( firstToken.str === '(' ) {     const leftTokens = this.getTokensUntil( ')', tokens );     const left = this.parseExpressionFromTokens( leftTokens.slice( 1, leftTokens.length - 1 ) );     const operator = tokens[ leftTokens.length ];     if ( operator ) {      const rightTokens = tokens.slice( leftTokens.length + 1 );     const right = this.parseExpressionFromTokens( rightTokens );      return this._evalOperator( new Operator( operator.str, left, right ) );     }     return left;    }    // primitives and accessors    if ( firstToken.isNumber ) {     let type;     const isHex = /^(0x)/.test( firstToken.str );     if ( isHex ) type = 'int';    else if ( /u$/.test( firstToken.str ) ) type = 'uint';    else if ( /f|e||./.test( firstToken.str ) ) type = 'float';    else type = 'int';     let str = firstToken.str.replace( /u|i$/, '' );     if ( isHex === false ) {      str = str.replace( /f$/, '' );     }     return new Number( str, type );    } else if ( firstToken.isString ) {     return new String( firstToken.str );    } else if ( firstToken.isLiteral ) {     if ( firstToken.str === 'return' ) {      return new Return( this.parseExpressionFromTokens( tokens.slice( 1 ) ) );     }     const secondToken = tokens[ 1 ];     if ( secondToken ) {      if ( secondToken.str === '(' ) {       // function call       const paramsTokens = this.parseFunctionParametersFromTokens( tokens.slice( 2, tokens.length - 1 ) );       return new FunctionCall( firstToken.str, paramsTokens );      } else if ( secondToken.str === '[' ) {       // array accessor       const elements = [];       let currentTokens = tokens.slice( 1 );       while ( currentTokens.length > 0 ) {        const token = currentTokens[ 0 ];        if ( token.str === '[' ) {         const accessorTokens = this.getTokensUntil( ']', currentTokens );         const element = this.parseExpressionFromTokens( accessorTokens.slice( 1, accessorTokens.length - 1 ) );         currentTokens = currentTokens.slice( accessorTokens.length );         elements.push( new DynamicElement( element ) );        } else if ( token.str === '.' ) {         const accessorTokens = currentTokens.slice( 1, 2 );         const element = this.parseExpressionFromTokens( accessorTokens );         currentTokens = currentTokens.slice( 2 );         elements.push( new StaticElement( element ) );        } else {         console.error( 'Unknown accessor expression', token );         break;        }       }       return new AccessorElements( firstToken.str, elements );      }     }     return new Accessor( firstToken.str );    }   }   parseFunctionParametersFromTokens( tokens ) {    if ( tokens.length === 0 ) return [];    const expression = this.parseExpressionFromTokens( tokens );   const params = [];    let current = expression;    while ( current.type === ',' ) {     params.push( current.left );     current = current.right;    }    params.push( current );    return params;   }   parseExpression() {    const tokens = this.readTokensUntil( ';' );    const exp = this.parseExpressionFromTokens( tokens.slice( 0, tokens.length - 1 ) );    return exp;   }   parseFunctionParams( tokens ) {    const params = [];    for ( let i = 0; i < tokens.length; i ++ ) {     const immutable = tokens[ i ].str === 'const';    if ( immutable ) i ++;     let qualifier = tokens[ i ].str;     if ( /^(in|out|inout)$/.test( qualifier ) ) {      i ++;     } else {      qualifier = null;     }     const type = tokens[ i ++ ].str;    const name = tokens[ i ++ ].str;     params.push( new FunctionParameter( type, name, qualifier, immutable ) );     if ( tokens[ i ] && tokens[ i ].str !== ',' ) throw new Error( 'Expected ","' );    }    return params;   }   parseFunction() {    const type = this.readToken().str;   const name = this.readToken().str;    const paramsTokens = this.readTokensUntil( ')' );    const params = this.parseFunctionParams( paramsTokens.slice( 1, paramsTokens.length - 1 ) );    const func = new FunctionDeclaration( type, name, params );    this._currentFunction = func;    this.parseBlock( func );    this._currentFunction = null;    return func;   }   parseVariablesFromToken( tokens, type ) {    let index = 0;   const immutable = tokens[ 0 ].str === 'const';    if ( immutable ) index ++;    type = type || tokens[ index ++ ].str;   const name = tokens[ index ++ ].str;    const token = tokens[ index ];    let init = null;   let next = null;    if ( token ) {     const initTokens = this.getTokensUntil( ',', tokens, index );     if ( initTokens[ 0 ].str === '=' ) {      const expressionTokens = initTokens.slice( 1 );     if ( expressionTokens[ expressionTokens.length - 1 ].str === ',' ) expressionTokens.pop();      init = this.parseExpressionFromTokens( expressionTokens );     }     const nextTokens = tokens.slice( initTokens.length + ( index - 1 ) );     if ( nextTokens[ 0 ] && nextTokens[ 0 ].str === ',' ) {      next = this.parseVariablesFromToken( nextTokens.slice( 1 ), type );     }    }    const variable = new VariableDeclaration( type, name, init, next, immutable );    return variable;   }   parseVariables() {    const tokens = this.readTokensUntil( ';' );    return this.parseVariablesFromToken( tokens.slice( 0, tokens.length - 1 ) );   }   parseUniform() {    const tokens = this.readTokensUntil( ';' );    const type = tokens[ 1 ].str;   const name = tokens[ 2 ].str;    return new Uniform( type, name );   }   parseVarying() {    const tokens = this.readTokensUntil( ';' );    const type = tokens[ 1 ].str;   const name = tokens[ 2 ].str;    return new Varying( type, name );   }   parseReturn() {    this.readToken(); // skip 'return'    const expression = this.parseExpression();    return new Return( expression );   }   parseFor() {    this.readToken(); // skip 'for'    const forTokens = this.readTokensUntil( ')' ).slice( 1, - 1 );    const initializationTokens = this.getTokensUntil( ';', forTokens, 0 ).slice( 0, - 1 );   const conditionTokens = this.getTokensUntil( ';', forTokens, initializationTokens.length + 1 ).slice( 0, - 1 );   const afterthoughtTokens = forTokens.slice( initializationTokens.length + conditionTokens.length + 2 );    let initialization;    if ( initializationTokens[ 0 ] && isType( initializationTokens[ 0 ].str ) ) {     initialization = this.parseVariablesFromToken( initializationTokens );    } else {     initialization = this.parseExpressionFromTokens( initializationTokens );    }    const condition = this.parseExpressionFromTokens( conditionTokens );   const afterthought = this.parseExpressionFromTokens( afterthoughtTokens );    const statement = new For( initialization, condition, afterthought );    if ( this.getToken().str === '{' ) {     this.parseBlock( statement );    } else {     statement.body.push( this.parseExpression() );    }    return statement;   }   parseIf() {    const parseIfExpression = () => {     this.readToken(); // skip 'if'     const condTokens = this.readTokensUntil( ')' );     return this.parseExpressionFromTokens( condTokens.slice( 1, condTokens.length - 1 ) );    };    const parseIfBlock = ( cond ) => {     if ( this.getToken().str === '{' ) {      this.parseBlock( cond );     } else {      cond.body.push( this.parseExpression() );     }    };    //    const conditional = new Conditional( parseIfExpression() );    parseIfBlock( conditional );    //    let current = conditional;    while ( this.getToken() && this.getToken().str === 'else' ) {     this.readToken(); // skip 'else'     const previous = current;     if ( this.getToken().str === 'if' ) {      current = new Conditional( parseIfExpression() );     } else {      current = new Conditional();     }     previous.elseConditional = current;     parseIfBlock( current );    }    return conditional;   }   parseBlock( scope ) {    const firstToken = this.getToken();    if ( firstToken.str === '{' ) {     this.readToken(); // skip '{'    }    let groupIndex = 0;    while ( this.index < this.tokens.length ) {     const token = this.getToken();     let statement = null;     groupIndex += getGroupDelta( token.str );     if ( groupIndex < 0 ) {      this.readToken(); // skip '}'      break;     }     //     if ( token.isLiteral ) {      if ( token.str === 'const' ) {       statement = this.parseVariables();      } else if ( token.str === 'uniform' ) {       statement = this.parseUniform();      } else if ( token.str === 'varying' ) {       statement = this.parseVarying();      } else if ( isType( token.str ) ) {       if ( this.getToken( 2 ).str === '(' ) {        statement = this.parseFunction();       } else {        statement = this.parseVariables();       }      } else if ( token.str === 'return' ) {       statement = this.parseReturn();      } else if ( token.str === 'if' ) {       statement = this.parseIf();      } else if ( token.str === 'for' ) {       statement = this.parseFor();      } else {       statement = this.parseExpression();      }     }     if ( statement ) {      scope.body.push( statement );     } else {      this.index ++;     }    }   }   _evalOperator( operator ) {    if ( operator.type.includes( '=' ) ) {     const parameter = this._getFunctionParameter( operator.left.property );     if ( parameter !== undefined ) {      // Parameters are immutable in WGSL      parameter.immutable = false;     }    }    return operator;   }   _getFunctionParameter( name ) {    if ( this._currentFunction ) {     for ( const param of this._currentFunction.params ) {      if ( param.name === name ) {       return param;      }     }    }   }   parse( source ) {    let polyfill = '';    for ( const keyword of this.keywords ) {     if ( new RegExp( |(^|||b)| keyword.name }($|||b)|, 'gm' ).test( source ) ) {      polyfill += keyword.polyfill + '|n';     }    }    if ( polyfill ) {     polyfill = '// Polyfills|n|n' + polyfill + '|n';    }    this.index = 0;   this.tokenizer = new Tokenizer( polyfill + source ).tokenize();    const program = new Program();    this.parseBlock( program );    return program;    }  }  export default GLSLDecoder; 
^..^ FILENAME ^..^
addons|transpiler|ShaderToyDecoder.js
^..^ CONTENTS ^..^
import { Return, VariableDeclaration, Accessor } from './AST.js'; import GLSLDecoder from './GLSLDecoder.js';  class ShaderToyDecoder extends GLSLDecoder {   constructor() {    super();    this.addPolyfill( 'iTime', 'float iTime = timerGlobal();' );   this.addPolyfill( 'iResolution', 'vec2 iResolution = screenSize;' );   this.addPolyfill( 'fragCoord', 'vec3 fragCoord = vec3( screenCoordinate.x, screenSize.y - screenCoordinate.y, screenCoordinate.z );' );   }   parseFunction() {    const node = super.parseFunction();    if ( node.name === 'mainImage' ) {     node.params = []; // remove default parameters    node.type = 'vec4';    node.layout = false; // for now     const fragColor = new Accessor( 'fragColor' );     for ( const subNode of node.body ) {      if ( subNode.isReturn ) {       subNode.value = fragColor;      }     }     node.body.unshift( new VariableDeclaration( 'vec4', 'fragColor' ) );    node.body.push( new Return( fragColor ) );    }    return node;   }  }  export default ShaderToyDecoder; 
^..^ FILENAME ^..^
addons|transpiler|Transpiler.js
^..^ CONTENTS ^..^
class Transpiler {   constructor( decoder, encoder ) {    this.decoder = decoder;   this.encoder = encoder;   }   parse( source ) {    return this.encoder.emit( this.decoder.parse( source ) );   }  }  export default Transpiler; 
^..^ FILENAME ^..^
addons|transpiler|TSLEncoder.js
^..^ CONTENTS ^..^
import * as THREE from 'three';  import { VariableDeclaration, Accessor } from './AST.js';  const opLib = {  '=': 'assign',  '+': 'add',  '-': 'sub',  '*': 'mul',  '/': 'div',  '%': 'remainder',  '<': 'lessThan',  '>': 'greaterThan',  '<=': 'lessThanEqual',  '>=': 'greaterThanEqual',  '==': 'equal',  '&&': 'and',  '||': 'or',  '^^': 'xor',  '&': 'bitAnd',  '|': 'bitOr',  '^': 'bitXor',  '<<': 'shiftLeft',  '>>': 'shiftRight',  '+=': 'addAssign',  '-=': 'subAssign',  '*=': 'mulAssign',  '/=': 'divAssign',  '%=': 'remainderAssign',  '^=': 'bitXorAssign',  '&=': 'bitAndAssign',  '|=': 'bitOrAssign',  '<<=': 'shiftLeftAssign',  '>>=': 'shiftRightAssign' };  const unaryLib = {  '+': '', // positive  '-': 'negate',  '~': 'bitNot',  '!': 'not',  '++': 'increment', // incrementBefore  '--': 'decrement' // decrementBefore };  const isPrimitive = ( value ) => /^(true|false|-?|d)/.test( value );  class TSLEncoder {   constructor() {    this.tab = '';   this.imports = new Set();   this.global = new Set();   this.overloadings = new Map();   this.iife = false;   this.uniqueNames = false;   this.reference = false;    this._currentProperties = {};   this._lastStatement = null;   }   addImport( name ) {    // import only if it's a node    name = name.split( '.' )[ 0 ];    if ( THREE[ name ] !== undefined && this.global.has( name ) === false && this._currentProperties[ name ] === undefined ) {     this.imports.add( name );    }   }   emitUniform( node ) {    let code = |const | node.name } = |;    if ( this.reference === true ) {     this.addImport( 'reference' );     this.global.add( node.name );     //code += |reference( '| node.name }', '| node.type }', uniforms )|;     // legacy    code += |reference( 'value', '| node.type }', uniforms[ '| node.name }' ] )|;    } else {     this.addImport( 'uniform' );     this.global.add( node.name );     code += |uniform( '| node.type }' )|;    }    return code;   }   emitExpression( node ) {    let code;    /*@TODO: else if ( node.isVarying ) {     code = this.emitVarying( node );    }*/    if ( node.isAccessor ) {     this.addImport( node.property );     code = node.property;    } else if ( node.isNumber ) {     if ( node.type === 'int' || node.type === 'uint' ) {      code = node.type + '( ' + node.value + ' )';      this.addImport( node.type );     } else {      code = node.value;     }    } else if ( node.isString ) {     code = '|'' + node.value + '|'';    } else if ( node.isOperator ) {     const opFn = opLib[ node.type ] || node.type;     const left = this.emitExpression( node.left );    const right = this.emitExpression( node.right );     if ( isPrimitive( left ) && isPrimitive( right ) ) {      return left + ' ' + node.type + ' ' + right;     }     if ( isPrimitive( left ) ) {      code = opFn + '( ' + left + ', ' + right + ' )';      this.addImport( opFn );     } else {      code = left + '.' + opFn + '( ' + right + ' )';     }    } else if ( node.isFunctionCall ) {     const params = [];     for ( const parameter of node.params ) {      params.push( this.emitExpression( parameter ) );     }     this.addImport( node.name );     const paramsStr = params.length > 0 ? ' ' + params.join( ', ' ) + ' ' : '';     code = || node.name }(| paramsStr })|;    } else if ( node.isReturn ) {     code = 'return';     if ( node.value ) {      code += ' ' + this.emitExpression( node.value );     }    } else if ( node.isAccessorElements ) {     code = node.property;     for ( const element of node.elements ) {      if ( element.isStaticElement ) {       code += '.' + this.emitExpression( element.value );      } else if ( element.isDynamicElement ) {       const value = this.emitExpression( element.value );       if ( isPrimitive( value ) ) {        code += |[ | value } ]|;       } else {        code += |.element( | value } )|;       }      }     }    } else if ( node.isDynamicElement ) {     code = this.emitExpression( node.value );    } else if ( node.isStaticElement ) {     code = this.emitExpression( node.value );    } else if ( node.isFor ) {     code = this.emitFor( node );    } else if ( node.isVariableDeclaration ) {     code = this.emitVariables( node );    } else if ( node.isUniform ) {     code = this.emitUniform( node );    } else if ( node.isTernary ) {     code = this.emitTernary( node );    } else if ( node.isConditional ) {     code = this.emitConditional( node );    } else if ( node.isUnary && node.expression.isNumber ) {     code = node.type + ' ' + node.expression.value;    } else if ( node.isUnary ) {     let type = unaryLib[ node.type ];     if ( node.after === false && ( node.type === '++' || node.type === '--' ) ) {      type += 'Before';     }     const exp = this.emitExpression( node.expression );     if ( isPrimitive( exp ) ) {      this.addImport( type );      code = type + '( ' + exp + ' )';     } else {      code = exp + '.' + type + '()';     }    } else {     console.warn( 'Unknown node type', node );    }    if ( ! code ) code = '/* unknown statement */';    return code;   }   emitBody( body ) {    this.setLastStatement( null );    let code = '';    this.tab += '|t';    for ( const statement of body ) {     code += this.emitExtraLine( statement );    code += this.tab + this.emitExpression( statement );     if ( code.slice( - 1 ) !== '}' ) code += ';';     code += '|n';     this.setLastStatement( statement );    }    code = code.slice( 0, - 1 ); // remove the last extra line    this.tab = this.tab.slice( 0, - 1 );    return code;    }   emitTernary( node ) {    const condStr = this.emitExpression( node.cond );   const leftStr = this.emitExpression( node.left );   const rightStr = this.emitExpression( node.right );    this.addImport( 'select' );    return |select( | condStr }, | leftStr }, | rightStr } )|;   }   emitConditional( node ) {    const condStr = this.emitExpression( node.cond );   const bodyStr = this.emitBody( node.body );    let ifStr = |If( | condStr }, () => {  | bodyStr }  | this.tab }} )|;    let current = node;    while ( current.elseConditional ) {     const elseBodyStr = this.emitBody( current.elseConditional.body );     if ( current.elseConditional.cond ) {      const elseCondStr = this.emitExpression( current.elseConditional.cond );      ifStr += |.ElseIf( | elseCondStr }, () => {  | elseBodyStr }  | this.tab }} )|;     } else {      ifStr += |.Else( () => {  | elseBodyStr }  | this.tab }} )|;     }     current = current.elseConditional;     }    this.imports.add( 'If' );    return ifStr;   }   emitLoop( node ) {    const start = this.emitExpression( node.initialization.value );   const end = this.emitExpression( node.condition.right );    const name = node.initialization.name;   const type = node.initialization.type;   const condition = node.condition.type;   const update = node.afterthought.type;    const nameParam = name !== 'i' ? |, name: '| name }'| : '';   const typeParam = type !== 'int' ? |, type: '| type }'| : '';   const conditionParam = condition !== '<' ? |, condition: '| condition }'| : '';   const updateParam = update !== '++' ? |, update: '| update }'| : '';    let loopStr = |Loop( { start: | start }, end: | end + nameParam + typeParam + conditionParam + updateParam } }, ( { | name } } ) => {|n|n|;    loopStr += this.emitBody( node.body ) + '|n|n';    loopStr += this.tab + '} )';    this.imports.add( 'Loop' );    return loopStr;   }   emitFor( node ) {    const { initialization, condition, afterthought } = node;    if ( ( initialization && initialization.isVariableDeclaration && initialization.next === null ) &&    ( condition && condition.left.isAccessor && condition.left.property === initialization.name ) &&    ( afterthought && afterthought.isUnary ) &&    ( initialization.name === afterthought.expression.property )   ) {     return this.emitLoop( node );    }    return this.emitForWhile( node );   }   emitForWhile( node ) {    const initialization = this.emitExpression( node.initialization );   const condition = this.emitExpression( node.condition );   const afterthought = this.emitExpression( node.afterthought );    this.tab += '|t';    let forStr = '{|n|n' + this.tab + initialization + ';|n|n';   forStr += || this.tab }While( | condition }, () => {|n|n|;    forStr += this.emitBody( node.body ) + '|n|n';    forStr += this.tab + '|t' + afterthought + ';|n|n';    forStr += this.tab + '} )|n|n';    this.tab = this.tab.slice( 0, - 1 );    forStr += this.tab + '}';    this.imports.add( 'While' );    return forStr;   }   emitVariables( node, isRoot = true ) {    const { name, type, value, next } = node;    const valueStr = value ? this.emitExpression( value ) : '';    let varStr = isRoot ? 'const ' : '';   varStr += name;    if ( value ) {     if ( value.isFunctionCall && value.name === type ) {      varStr += ' = ' + valueStr;     } else {      varStr += | = | type }( | valueStr } )|;     }    } else {     varStr += | = | type }()|;    }    if ( node.immutable === false ) {     varStr += '.toVar()';    }    if ( next ) {     varStr += ', ' + this.emitVariables( next, false );    }    this.addImport( type );    return varStr;   }   /*emitVarying( node ) { }*/   emitOverloadingFunction( nodes ) {    const { name } = nodes[ 0 ];    this.addImport( 'overloadingFn' );    const prefix = this.iife === false ? 'export ' : '';    return || prefix }const | name } = /*#__PURE__*/ overloadingFn( [ | nodes.map( node => node.name + '_' + nodes.indexOf( node ) ).join( ', ' ) } ] );|n|;   }   emitFunction( node ) {    const { name, type } = node;    this._currentProperties = { name: node };    const params = [];   const inputs = [];   const mutableParams = [];    let hasPointer = false;    for ( const param of node.params ) {     let str = |{ name: '| param.name }', type: '| param.type }'|;     let name = param.name;     if ( param.immutable === false && ( param.qualifier !== 'inout' && param.qualifier !== 'out' ) ) {      name = name + '_immutable';      mutableParams.push( param );     }     if ( param.qualifier ) {      if ( param.qualifier === 'inout' || param.qualifier === 'out' ) {       hasPointer = true;      }      str += ', qualifier: |'' + param.qualifier + '|'';     }     inputs.push( str + ' }' );    params.push( name );     this._currentProperties[ name ] = param;    }    for ( const param of mutableParams ) {     node.body.unshift( new VariableDeclaration( param.type, param.name, new Accessor( param.name + '_immutable' ) ) );    }    const paramsStr = params.length > 0 ? ' [ ' + params.join( ', ' ) + ' ] ' : '';   const bodyStr = this.emitBody( node.body );    let fnName = name;   let overloadingNodes = null;    if ( this.overloadings.has( name ) ) {     const overloadings = this.overloadings.get( name );     if ( overloadings.length > 1 ) {      const index = overloadings.indexOf( node );      fnName += '_' + index;      if ( index === overloadings.length - 1 ) {       overloadingNodes = overloadings;      }     }    }    const prefix = this.iife === false ? 'export ' : '';    let funcStr = || prefix }const | fnName } = /*#__PURE__*/ Fn( (| paramsStr }) => {  | bodyStr }  | this.tab }} )|;    const layoutInput = inputs.length > 0 ? '|n|t|t' + this.tab + inputs.join( ',|n|t|t' + this.tab ) + '|n|t' + this.tab : '';    if ( node.layout !== false && hasPointer === false ) {     const uniqueName = this.uniqueNames ? fnName + '_' + Math.random().toString( 36 ).slice( 2 ) : fnName;     funcStr += |.setLayout( { | this.tab }|tname: '| uniqueName }', | this.tab }|ttype: '| type }', | this.tab }|tinputs: [| layoutInput }] | this.tab }} )|;    }    funcStr += ';|n';    this.imports.add( 'Fn' );    this.global.add( node.name );    if ( overloadingNodes !== null ) {     funcStr += '|n' + this.emitOverloadingFunction( overloadingNodes );    }    return funcStr;   }   setLastStatement( statement ) {    this._lastStatement = statement;   }   emitExtraLine( statement ) {    const last = this._lastStatement;   if ( last === null ) return '';    if ( statement.isReturn ) return '|n';    const isExpression = ( st ) => st.isFunctionDeclaration !== true && st.isFor !== true && st.isConditional !== true;   const lastExp = isExpression( last );   const currExp = isExpression( statement );    if ( lastExp !== currExp || ( ! lastExp && ! currExp ) ) return '|n';    return '';   }   emit( ast ) {    let code = '|n';    if ( this.iife ) this.tab += '|t';    const overloadings = this.overloadings;    for ( const statement of ast.body ) {     if ( statement.isFunctionDeclaration ) {      if ( overloadings.has( statement.name ) === false ) {       overloadings.set( statement.name, [] );      }      overloadings.get( statement.name ).push( statement );     }    }    for ( const statement of ast.body ) {     code += this.emitExtraLine( statement );     if ( statement.isFunctionDeclaration ) {      code += this.tab + this.emitFunction( statement );     } else {      code += this.tab + this.emitExpression( statement ) + ';|n';     }     this.setLastStatement( statement );    }    const imports = [ ...this.imports ];   const exports = [ ...this.global ];    let header = '// Three.js Transpiler r' + THREE.REVISION + '|n|n';   let footer = '';    if ( this.iife ) {     header += '( function ( TSL, uniforms ) {|n|n';     header += imports.length > 0 ? '|tconst { ' + imports.join( ', ' ) + ' } = TSL;|n' : '';    footer += exports.length > 0 ? '|treturn { ' + exports.join( ', ' ) + ' };|n' : '';     footer += '|n} );';    } else {     header += imports.length > 0 ? 'import { ' + imports.join( ', ' ) + ' } from |'three/tsl|';|n' : '';    }    return header + code + footer;   }  }  export default TSLEncoder; 
^..^ FILENAME ^..^
addons|utils|BufferGeometryUtils.js
^..^ CONTENTS ^..^
import {  BufferAttribute,  BufferGeometry,  Float32BufferAttribute,  InstancedBufferAttribute,  InterleavedBuffer,  InterleavedBufferAttribute,  TriangleFanDrawMode,  TriangleStripDrawMode,  TrianglesDrawMode,  Vector3, } from 'three';  function computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {   if ( ! MikkTSpace || ! MikkTSpace.isReady ) {    throw new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );   }   if ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {    throw new Error( 'BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.' );   }   function getAttributeArray( attribute ) {    if ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {     const dstArray = new Float32Array( attribute.count * attribute.itemSize );     for ( let i = 0, j = 0; i < attribute.count; i ++ ) {      dstArray[ j ++ ] = attribute.getX( i );     dstArray[ j ++ ] = attribute.getY( i );      if ( attribute.itemSize > 2 ) {       dstArray[ j ++ ] = attribute.getZ( i );      }     }     return dstArray;    }    if ( attribute.array instanceof Float32Array ) {     return attribute.array;    }    return new Float32Array( attribute.array );   }   // MikkTSpace algorithm requires non-indexed input.   const _geometry = geometry.index ? geometry.toNonIndexed() : geometry;   // Compute vertex tangents.   const tangents = MikkTSpace.generateTangents(    getAttributeArray( _geometry.attributes.position ),   getAttributeArray( _geometry.attributes.normal ),   getAttributeArray( _geometry.attributes.uv )   );   // Texture coordinate convention of glTF differs from the apparent  // default of the MikkTSpace library; .w component must be flipped.   if ( negateSign ) {    for ( let i = 3; i < tangents.length; i += 4 ) {     tangents[ i ] *= - 1;    }   }   //   _geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );   if ( geometry !== _geometry ) {    geometry.copy( _geometry );   }   return geometry;  }  /**  * @param  {Array<BufferGeometry>} geometries  * @param  {Boolean} useGroups  * @return {BufferGeometry}  */ function mergeGeometries( geometries, useGroups = false ) {   const isIndexed = geometries[ 0 ].index !== null;   const attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );  const morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );   const attributes = {};  const morphAttributes = {};   const morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;   const mergedGeometry = new BufferGeometry();   let offset = 0;   for ( let i = 0; i < geometries.length; ++ i ) {    const geometry = geometries[ i ];   let attributesCount = 0;    // ensure that all geometries are indexed, or none    if ( isIndexed !== ( geometry.index !== null ) ) {     console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );    return null;    }    // gather attributes, exit early if they're different    for ( const name in geometry.attributes ) {     if ( ! attributesUsed.has( name ) ) {      console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.' );     return null;     }     if ( attributes[ name ] === undefined ) attributes[ name ] = [];     attributes[ name ].push( geometry.attributes[ name ] );     attributesCount ++;    }    // ensure geometries have the same number of attributes    if ( attributesCount !== attributesUsed.size ) {     console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );    return null;    }    // gather morph attributes, exit early if they're different    if ( morphTargetsRelative !== geometry.morphTargetsRelative ) {     console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );    return null;    }    for ( const name in geometry.morphAttributes ) {     if ( ! morphAttributesUsed.has( name ) ) {      console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );     return null;     }     if ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];     morphAttributes[ name ].push( geometry.morphAttributes[ name ] );    }    if ( useGroups ) {     let count;     if ( isIndexed ) {      count = geometry.index.count;     } else if ( geometry.attributes.position !== undefined ) {      count = geometry.attributes.position.count;     } else {      console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );     return null;     }     mergedGeometry.addGroup( offset, count, i );     offset += count;    }   }   // merge indices   if ( isIndexed ) {    let indexOffset = 0;   const mergedIndex = [];    for ( let i = 0; i < geometries.length; ++ i ) {     const index = geometries[ i ].index;     for ( let j = 0; j < index.count; ++ j ) {      mergedIndex.push( index.getX( j ) + indexOffset );     }     indexOffset += geometries[ i ].attributes.position.count;    }    mergedGeometry.setIndex( mergedIndex );   }   // merge attributes   for ( const name in attributes ) {    const mergedAttribute = mergeAttributes( attributes[ name ] );    if ( ! mergedAttribute ) {     console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );    return null;    }    mergedGeometry.setAttribute( name, mergedAttribute );   }   // merge morph attributes   for ( const name in morphAttributes ) {    const numMorphTargets = morphAttributes[ name ][ 0 ].length;    if ( numMorphTargets === 0 ) break;    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};   mergedGeometry.morphAttributes[ name ] = [];    for ( let i = 0; i < numMorphTargets; ++ i ) {     const morphAttributesToMerge = [];     for ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {      morphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );     }     const mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );     if ( ! mergedMorphAttribute ) {      console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );     return null;     }     mergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );    }   }   return mergedGeometry;  }  /**  * @param {Array<BufferAttribute>} attributes  * @return {BufferAttribute}  */ function mergeAttributes( attributes ) {   let TypedArray;  let itemSize;  let normalized;  let gpuType = - 1;  let arrayLength = 0;   for ( let i = 0; i < attributes.length; ++ i ) {    const attribute = attributes[ i ];    if ( TypedArray === undefined ) TypedArray = attribute.array.constructor;   if ( TypedArray !== attribute.array.constructor ) {     console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );    return null;    }    if ( itemSize === undefined ) itemSize = attribute.itemSize;   if ( itemSize !== attribute.itemSize ) {     console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );    return null;    }    if ( normalized === undefined ) normalized = attribute.normalized;   if ( normalized !== attribute.normalized ) {     console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );    return null;    }    if ( gpuType === - 1 ) gpuType = attribute.gpuType;   if ( gpuType !== attribute.gpuType ) {     console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );    return null;    }    arrayLength += attribute.count * itemSize;   }   const array = new TypedArray( arrayLength );  const result = new BufferAttribute( array, itemSize, normalized );  let offset = 0;   for ( let i = 0; i < attributes.length; ++ i ) {    const attribute = attributes[ i ];   if ( attribute.isInterleavedBufferAttribute ) {     const tupleOffset = offset / itemSize;    for ( let j = 0, l = attribute.count; j < l; j ++ ) {      for ( let c = 0; c < itemSize; c ++ ) {       const value = attribute.getComponent( j, c );      result.setComponent( j + tupleOffset, c, value );      }     }    } else {     array.set( attribute.array, offset );    }    offset += attribute.count * itemSize;   }   if ( gpuType !== undefined ) {    result.gpuType = gpuType;   }   return result;  }  /**  * @param {BufferAttribute}  * @return {BufferAttribute}  */ export function deepCloneAttribute( attribute ) {   if ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {    return deinterleaveAttribute( attribute );   }   if ( attribute.isInstancedBufferAttribute ) {    return new InstancedBufferAttribute().copy( attribute );   }   return new BufferAttribute().copy( attribute );  }  /**  * @param {Array<BufferAttribute>} attributes  * @return {Array<InterleavedBufferAttribute>}  */ function interleaveAttributes( attributes ) {   // Interleaves the provided attributes into an InterleavedBuffer and returns  // a set of InterleavedBufferAttributes for each attribute  let TypedArray;  let arrayLength = 0;  let stride = 0;   // calculate the length and type of the interleavedBuffer  for ( let i = 0, l = attributes.length; i < l; ++ i ) {    const attribute = attributes[ i ];    if ( TypedArray === undefined ) TypedArray = attribute.array.constructor;   if ( TypedArray !== attribute.array.constructor ) {     console.error( 'AttributeBuffers of different types cannot be interleaved' );    return null;    }    arrayLength += attribute.array.length;   stride += attribute.itemSize;   }   // Create the set of buffer attributes  const interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );  let offset = 0;  const res = [];  const getters = [ 'getX', 'getY', 'getZ', 'getW' ];  const setters = [ 'setX', 'setY', 'setZ', 'setW' ];   for ( let j = 0, l = attributes.length; j < l; j ++ ) {    const attribute = attributes[ j ];   const itemSize = attribute.itemSize;   const count = attribute.count;   const iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );   res.push( iba );    offset += itemSize;    // Move the data for each attribute into the new interleavedBuffer   // at the appropriate offset   for ( let c = 0; c < count; c ++ ) {     for ( let k = 0; k < itemSize; k ++ ) {      iba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );     }    }   }   return res;  }  // returns a new, non-interleaved version of the provided attribute export function deinterleaveAttribute( attribute ) {   const cons = attribute.data.array.constructor;  const count = attribute.count;  const itemSize = attribute.itemSize;  const normalized = attribute.normalized;   const array = new cons( count * itemSize );  let newAttribute;  if ( attribute.isInstancedInterleavedBufferAttribute ) {    newAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );   } else {    newAttribute = new BufferAttribute( array, itemSize, normalized );   }   for ( let i = 0; i < count; i ++ ) {    newAttribute.setX( i, attribute.getX( i ) );    if ( itemSize >= 2 ) {     newAttribute.setY( i, attribute.getY( i ) );    }    if ( itemSize >= 3 ) {     newAttribute.setZ( i, attribute.getZ( i ) );    }    if ( itemSize >= 4 ) {     newAttribute.setW( i, attribute.getW( i ) );    }   }   return newAttribute;  }  // deinterleaves all attributes on the geometry export function deinterleaveGeometry( geometry ) {   const attributes = geometry.attributes;  const morphTargets = geometry.morphTargets;  const attrMap = new Map();   for ( const key in attributes ) {    const attr = attributes[ key ];   if ( attr.isInterleavedBufferAttribute ) {     if ( ! attrMap.has( attr ) ) {      attrMap.set( attr, deinterleaveAttribute( attr ) );     }     attributes[ key ] = attrMap.get( attr );    }   }   for ( const key in morphTargets ) {    const attr = morphTargets[ key ];   if ( attr.isInterleavedBufferAttribute ) {     if ( ! attrMap.has( attr ) ) {      attrMap.set( attr, deinterleaveAttribute( attr ) );     }     morphTargets[ key ] = attrMap.get( attr );    }   }  }  /**  * @param {BufferGeometry} geometry  * @return {number}  */ function estimateBytesUsed( geometry ) {   // Return the estimated memory used by this geometry in bytes  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account  // for InterleavedBufferAttributes.  let mem = 0;  for ( const name in geometry.attributes ) {    const attr = geometry.getAttribute( name );   mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;   }   const indices = geometry.getIndex();  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;  return mem;  }  /**  * @param {BufferGeometry} geometry  * @param {number} tolerance  * @return {BufferGeometry}  */ function mergeVertices( geometry, tolerance = 1e-4 ) {   tolerance = Math.max( tolerance, Number.EPSILON );   // Generate an index buffer if the geometry doesn't have one, or optimize it  // if it's already available.  const hashToIndex = {};  const indices = geometry.getIndex();  const positions = geometry.getAttribute( 'position' );  const vertexCount = indices ? indices.count : positions.count;   // next value for triangle indices  let nextIndex = 0;   // attributes and new attribute arrays  const attributeNames = Object.keys( geometry.attributes );  const tmpAttributes = {};  const tmpMorphAttributes = {};  const newIndices = [];  const getters = [ 'getX', 'getY', 'getZ', 'getW' ];  const setters = [ 'setX', 'setY', 'setZ', 'setW' ];   // Initialize the arrays, allocating space conservatively. Extra  // space will be trimmed in the last step.  for ( let i = 0, l = attributeNames.length; i < l; i ++ ) {    const name = attributeNames[ i ];   const attr = geometry.attributes[ name ];    tmpAttributes[ name ] = new attr.constructor(    new attr.array.constructor( attr.count * attr.itemSize ),    attr.itemSize,    attr.normalized   );    const morphAttributes = geometry.morphAttributes[ name ];   if ( morphAttributes ) {     if ( ! tmpMorphAttributes[ name ] ) tmpMorphAttributes[ name ] = [];    morphAttributes.forEach( ( morphAttr, i ) => {      const array = new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize );     tmpMorphAttributes[ name ][ i ] = new morphAttr.constructor( array, morphAttr.itemSize, morphAttr.normalized );     } );    }   }   // convert the error tolerance to an amount of decimal places to truncate to  const halfTolerance = tolerance * 0.5;  const exponent = Math.log10( 1 / tolerance );  const hashMultiplier = Math.pow( 10, exponent );  const hashAdditive = halfTolerance * hashMultiplier;  for ( let i = 0; i < vertexCount; i ++ ) {    const index = indices ? indices.getX( i ) : i;    // Generate a hash for the vertex attributes at the current index 'i'   let hash = '';   for ( let j = 0, l = attributeNames.length; j < l; j ++ ) {     const name = attributeNames[ j ];    const attribute = geometry.getAttribute( name );    const itemSize = attribute.itemSize;     for ( let k = 0; k < itemSize; k ++ ) {      // double tilde truncates the decimal value     hash += || ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },|;     }    }    // Add another reference to the vertex if it's already   // used by another index   if ( hash in hashToIndex ) {     newIndices.push( hashToIndex[ hash ] );    } else {     // copy data to the new index in the temporary attributes    for ( let j = 0, l = attributeNames.length; j < l; j ++ ) {      const name = attributeNames[ j ];     const attribute = geometry.getAttribute( name );     const morphAttributes = geometry.morphAttributes[ name ];     const itemSize = attribute.itemSize;     const newArray = tmpAttributes[ name ];     const newMorphArrays = tmpMorphAttributes[ name ];      for ( let k = 0; k < itemSize; k ++ ) {       const getterFunc = getters[ k ];      const setterFunc = setters[ k ];      newArray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );       if ( morphAttributes ) {        for ( let m = 0, ml = morphAttributes.length; m < ml; m ++ ) {         newMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttributes[ m ][ getterFunc ]( index ) );        }       }      }     }     hashToIndex[ hash ] = nextIndex;    newIndices.push( nextIndex );    nextIndex ++;    }   }   // generate result BufferGeometry  const result = geometry.clone();  for ( const name in geometry.attributes ) {    const tmpAttribute = tmpAttributes[ name ];    result.setAttribute( name, new tmpAttribute.constructor(    tmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),    tmpAttribute.itemSize,    tmpAttribute.normalized,   ) );    if ( ! ( name in tmpMorphAttributes ) ) continue;    for ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {     const tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];     result.morphAttributes[ name ][ j ] = new tmpMorphAttribute.constructor(     tmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),     tmpMorphAttribute.itemSize,     tmpMorphAttribute.normalized,    );    }   }   // indices   result.setIndex( newIndices );   return result;  }  /**  * @param {BufferGeometry} geometry  * @param {number} drawMode  * @return {BufferGeometry}  */ function toTrianglesDrawMode( geometry, drawMode ) {   if ( drawMode === TrianglesDrawMode ) {    console.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );   return geometry;   }   if ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {    let index = geometry.getIndex();    // generate index if not present    if ( index === null ) {     const indices = [];     const position = geometry.getAttribute( 'position' );     if ( position !== undefined ) {      for ( let i = 0; i < position.count; i ++ ) {       indices.push( i );      }      geometry.setIndex( indices );     index = geometry.getIndex();     } else {      console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );     return geometry;     }    }    //    const numberOfTriangles = index.count - 2;   const newIndices = [];    if ( drawMode === TriangleFanDrawMode ) {     // gl.TRIANGLE_FAN     for ( let i = 1; i <= numberOfTriangles; i ++ ) {      newIndices.push( index.getX( 0 ) );     newIndices.push( index.getX( i ) );     newIndices.push( index.getX( i + 1 ) );     }    } else {     // gl.TRIANGLE_STRIP     for ( let i = 0; i < numberOfTriangles; i ++ ) {      if ( i % 2 === 0 ) {       newIndices.push( index.getX( i ) );      newIndices.push( index.getX( i + 1 ) );      newIndices.push( index.getX( i + 2 ) );      } else {       newIndices.push( index.getX( i + 2 ) );      newIndices.push( index.getX( i + 1 ) );      newIndices.push( index.getX( i ) );      }     }    }    if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {     console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );    }    // build final geometry    const newGeometry = geometry.clone();   newGeometry.setIndex( newIndices );   newGeometry.clearGroups();    return newGeometry;   } else {    console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );   return geometry;   }  }  /**  * Calculates the morphed attributes of a morphed/skinned BufferGeometry.  * Helpful for Raytracing or Decals.  * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.  * @return {Object} An Object with original position/normal attributes and morphed ones.  */ function computeMorphedAttributes( object ) {   const _vA = new Vector3();  const _vB = new Vector3();  const _vC = new Vector3();   const _tempA = new Vector3();  const _tempB = new Vector3();  const _tempC = new Vector3();   const _morphA = new Vector3();  const _morphB = new Vector3();  const _morphC = new Vector3();   function _calculateMorphedAttributeData(   object,   attribute,   morphAttribute,   morphTargetsRelative,   a,   b,   c,   modifiedAttributeArray  ) {    _vA.fromBufferAttribute( attribute, a );   _vB.fromBufferAttribute( attribute, b );   _vC.fromBufferAttribute( attribute, c );    const morphInfluences = object.morphTargetInfluences;    if ( morphAttribute && morphInfluences ) {     _morphA.set( 0, 0, 0 );    _morphB.set( 0, 0, 0 );    _morphC.set( 0, 0, 0 );     for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {      const influence = morphInfluences[ i ];     const morph = morphAttribute[ i ];      if ( influence === 0 ) continue;      _tempA.fromBufferAttribute( morph, a );     _tempB.fromBufferAttribute( morph, b );     _tempC.fromBufferAttribute( morph, c );      if ( morphTargetsRelative ) {       _morphA.addScaledVector( _tempA, influence );      _morphB.addScaledVector( _tempB, influence );      _morphC.addScaledVector( _tempC, influence );      } else {       _morphA.addScaledVector( _tempA.sub( _vA ), influence );      _morphB.addScaledVector( _tempB.sub( _vB ), influence );      _morphC.addScaledVector( _tempC.sub( _vC ), influence );      }     }     _vA.add( _morphA );    _vB.add( _morphB );    _vC.add( _morphC );    }    if ( object.isSkinnedMesh ) {     object.applyBoneTransform( a, _vA );    object.applyBoneTransform( b, _vB );    object.applyBoneTransform( c, _vC );    }    modifiedAttributeArray[ a * 3 + 0 ] = _vA.x;   modifiedAttributeArray[ a * 3 + 1 ] = _vA.y;   modifiedAttributeArray[ a * 3 + 2 ] = _vA.z;   modifiedAttributeArray[ b * 3 + 0 ] = _vB.x;   modifiedAttributeArray[ b * 3 + 1 ] = _vB.y;   modifiedAttributeArray[ b * 3 + 2 ] = _vB.z;   modifiedAttributeArray[ c * 3 + 0 ] = _vC.x;   modifiedAttributeArray[ c * 3 + 1 ] = _vC.y;   modifiedAttributeArray[ c * 3 + 2 ] = _vC.z;   }   const geometry = object.geometry;  const material = object.material;   let a, b, c;  const index = geometry.index;  const positionAttribute = geometry.attributes.position;  const morphPosition = geometry.morphAttributes.position;  const morphTargetsRelative = geometry.morphTargetsRelative;  const normalAttribute = geometry.attributes.normal;  const morphNormal = geometry.morphAttributes.position;   const groups = geometry.groups;  const drawRange = geometry.drawRange;  let i, j, il, jl;  let group;  let start, end;   const modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );  const modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );   if ( index !== null ) {    // indexed buffer geometry    if ( Array.isArray( material ) ) {     for ( i = 0, il = groups.length; i < il; i ++ ) {      group = groups[ i ];      start = Math.max( group.start, drawRange.start );     end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );      for ( j = start, jl = end; j < jl; j += 3 ) {       a = index.getX( j );      b = index.getX( j + 1 );      c = index.getX( j + 2 );       _calculateMorphedAttributeData(       object,       positionAttribute,       morphPosition,       morphTargetsRelative,       a, b, c,       modifiedPosition      );       _calculateMorphedAttributeData(       object,       normalAttribute,       morphNormal,       morphTargetsRelative,       a, b, c,       modifiedNormal      );      }     }    } else {     start = Math.max( 0, drawRange.start );    end = Math.min( index.count, ( drawRange.start + drawRange.count ) );     for ( i = start, il = end; i < il; i += 3 ) {      a = index.getX( i );     b = index.getX( i + 1 );     c = index.getX( i + 2 );      _calculateMorphedAttributeData(      object,      positionAttribute,      morphPosition,      morphTargetsRelative,      a, b, c,      modifiedPosition     );      _calculateMorphedAttributeData(      object,      normalAttribute,      morphNormal,      morphTargetsRelative,      a, b, c,      modifiedNormal     );     }    }   } else {    // non-indexed buffer geometry    if ( Array.isArray( material ) ) {     for ( i = 0, il = groups.length; i < il; i ++ ) {      group = groups[ i ];      start = Math.max( group.start, drawRange.start );     end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );      for ( j = start, jl = end; j < jl; j += 3 ) {       a = j;      b = j + 1;      c = j + 2;       _calculateMorphedAttributeData(       object,       positionAttribute,       morphPosition,       morphTargetsRelative,       a, b, c,       modifiedPosition      );       _calculateMorphedAttributeData(       object,       normalAttribute,       morphNormal,       morphTargetsRelative,       a, b, c,       modifiedNormal      );      }     }    } else {     start = Math.max( 0, drawRange.start );    end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );     for ( i = start, il = end; i < il; i += 3 ) {      a = i;     b = i + 1;     c = i + 2;      _calculateMorphedAttributeData(      object,      positionAttribute,      morphPosition,      morphTargetsRelative,      a, b, c,      modifiedPosition     );      _calculateMorphedAttributeData(      object,      normalAttribute,      morphNormal,      morphTargetsRelative,      a, b, c,      modifiedNormal     );     }    }   }   const morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );  const morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );   return {    positionAttribute: positionAttribute,   normalAttribute: normalAttribute,   morphedPositionAttribute: morphedPositionAttribute,   morphedNormalAttribute: morphedNormalAttribute   };  }  function mergeGroups( geometry ) {   if ( geometry.groups.length === 0 ) {    console.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );   return geometry;   }   let groups = geometry.groups;   // sort groups by material index   groups = groups.sort( ( a, b ) => {    if ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;    return a.start - b.start;   } );   // create index for non-indexed geometries   if ( geometry.getIndex() === null ) {    const positionAttribute = geometry.getAttribute( 'position' );   const indices = [];    for ( let i = 0; i < positionAttribute.count; i += 3 ) {     indices.push( i, i + 1, i + 2 );    }    geometry.setIndex( indices );   }   // sort index   const index = geometry.getIndex();   const newIndices = [];   for ( let i = 0; i < groups.length; i ++ ) {    const group = groups[ i ];    const groupStart = group.start;   const groupLength = groupStart + group.count;    for ( let j = groupStart; j < groupLength; j ++ ) {     newIndices.push( index.getX( j ) );    }   }   geometry.dispose(); // Required to force buffer recreation  geometry.setIndex( newIndices );   // update groups indices   let start = 0;   for ( let i = 0; i < groups.length; i ++ ) {    const group = groups[ i ];    group.start = start;   start += group.count;   }   // merge groups   let currentGroup = groups[ 0 ];   geometry.groups = [ currentGroup ];   for ( let i = 1; i < groups.length; i ++ ) {    const group = groups[ i ];    if ( currentGroup.materialIndex === group.materialIndex ) {     currentGroup.count += group.count;    } else {     currentGroup = group;    geometry.groups.push( currentGroup );    }   }   return geometry;  }   /**  * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,  * non-indexed geometry. Returns the geometry with smooth normals everywhere except  * faces that meet at an angle greater than the crease angle.  *  * @param {BufferGeometry} geometry  * @param {number} [creaseAngle]  * @return {BufferGeometry}  */ function toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {   const creaseDot = Math.cos( creaseAngle );  const hashMultiplier = ( 1 + 1e-10 ) * 1e2;   // reusable vectors  const verts = [ new Vector3(), new Vector3(), new Vector3() ];  const tempVec1 = new Vector3();  const tempVec2 = new Vector3();  const tempNorm = new Vector3();  const tempNorm2 = new Vector3();   // hashes a vector  function hashVertex( v ) {    const x = ~ ~ ( v.x * hashMultiplier );   const y = ~ ~ ( v.y * hashMultiplier );   const z = ~ ~ ( v.z * hashMultiplier );   return ||x},|y},|z}|;   }   // BufferGeometry.toNonIndexed() warns if the geometry is non-indexed  // and returns the original geometry  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;  const posAttr = resultGeometry.attributes.position;  const vertexMap = {};   // find all the normals shared by commonly located vertices  for ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {    const i3 = 3 * i;   const a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );   const b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );   const c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );    tempVec1.subVectors( c, b );   tempVec2.subVectors( a, b );    // add the normal to the map for all vertices   const normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();   for ( let n = 0; n < 3; n ++ ) {     const vert = verts[ n ];    const hash = hashVertex( vert );    if ( ! ( hash in vertexMap ) ) {      vertexMap[ hash ] = [];     }     vertexMap[ hash ].push( normal );    }   }   // average normals from all vertices that share a common location if they are within the  // provided crease threshold  const normalArray = new Float32Array( posAttr.count * 3 );  const normAttr = new BufferAttribute( normalArray, 3, false );  for ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {    // get the face normal for this vertex   const i3 = 3 * i;   const a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );   const b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );   const c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );    tempVec1.subVectors( c, b );   tempVec2.subVectors( a, b );    tempNorm.crossVectors( tempVec1, tempVec2 ).normalize();    // average all normals that meet the threshold and set the normal value   for ( let n = 0; n < 3; n ++ ) {     const vert = verts[ n ];    const hash = hashVertex( vert );    const otherNormals = vertexMap[ hash ];    tempNorm2.set( 0, 0, 0 );     for ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {      const otherNorm = otherNormals[ k ];     if ( tempNorm.dot( otherNorm ) > creaseDot ) {       tempNorm2.add( otherNorm );      }     }     tempNorm2.normalize();    normAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );    }   }   resultGeometry.setAttribute( 'normal', normAttr );  return resultGeometry;  }  export {  computeMikkTSpaceTangents,  mergeGeometries,  mergeAttributes,  interleaveAttributes,  estimateBytesUsed,  mergeVertices,  toTrianglesDrawMode,  computeMorphedAttributes,  mergeGroups,  toCreasedNormals }; 
^..^ FILENAME ^..^
addons|utils|CameraUtils.js
^..^ CONTENTS ^..^
import {  MathUtils,  Quaternion,  Vector3 } from 'three';  const _va = /*@__PURE__*/ new Vector3(), // from pe to pa  _vb = /*@__PURE__*/ new Vector3(), // from pe to pb  _vc = /*@__PURE__*/ new Vector3(), // from pe to pc  _vr = /*@__PURE__*/ new Vector3(), // right axis of screen  _vu = /*@__PURE__*/ new Vector3(), // up axis of screen  _vn = /*@__PURE__*/ new Vector3(), // normal vector of screen  _vec = /*@__PURE__*/ new Vector3(), // temporary vector  _quat = /*@__PURE__*/ new Quaternion(); // temporary quaternion   /** Set a PerspectiveCamera's projectionMatrix and quaternion  * to exactly frame the corners of an arbitrary rectangle.  * NOTE: This function ignores the standard parameters;  * do not call updateProjectionMatrix() after this!  * @param {Vector3} bottomLeftCorner  * @param {Vector3} bottomRightCorner  * @param {Vector3} topLeftCorner  * @param {boolean} estimateViewFrustum */ function frameCorners( camera, bottomLeftCorner, bottomRightCorner, topLeftCorner, estimateViewFrustum = false ) {   const pa = bottomLeftCorner, pb = bottomRightCorner, pc = topLeftCorner;  const pe = camera.position; // eye position  const n = camera.near; // distance of near clipping plane  const f = camera.far; //distance of far clipping plane   _vr.copy( pb ).sub( pa ).normalize();  _vu.copy( pc ).sub( pa ).normalize();  _vn.crossVectors( _vr, _vu ).normalize();   _va.copy( pa ).sub( pe ); // from pe to pa  _vb.copy( pb ).sub( pe ); // from pe to pb  _vc.copy( pc ).sub( pe ); // from pe to pc   const d = - _va.dot( _vn ); // distance from eye to screen  const l = _vr.dot( _va ) * n / d; // distance to left screen edge  const r = _vr.dot( _vb ) * n / d; // distance to right screen edge  const b = _vu.dot( _va ) * n / d; // distance to bottom screen edge  const t = _vu.dot( _vc ) * n / d; // distance to top screen edge   // Set the camera rotation to match the focal plane to the corners' plane  _quat.setFromUnitVectors( _vec.set( 0, 1, 0 ), _vu );  camera.quaternion.setFromUnitVectors( _vec.set( 0, 0, 1 ).applyQuaternion( _quat ), _vn ).multiply( _quat );   // Set the off-axis projection matrix to match the corners  camera.projectionMatrix.set( 2.0 * n / ( r - l ), 0.0,   ( r + l ) / ( r - l ), 0.0, 0.0,   2.0 * n / ( t - b ),   ( t + b ) / ( t - b ), 0.0, 0.0, 0.0,   ( f + n ) / ( n - f ),   2.0 * f * n / ( n - f ), 0.0, 0.0, - 1.0, 0.0 );  camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();   // FoV estimation to fix frustum culling  if ( estimateViewFrustum ) {    // Set fieldOfView to a conservative estimate   // to make frustum tall/wide enough to encompass it   camera.fov =    MathUtils.RAD2DEG / Math.min( 1.0, camera.aspect ) *    Math.atan( ( _vec.copy( pb ).sub( pa ).length() +        ( _vec.copy( pc ).sub( pa ).length() ) ) / _va.length() );   }  }  export { frameCorners }; 
^..^ FILENAME ^..^
addons|utils|GeometryCompressionUtils.js
^..^ CONTENTS ^..^
/**  * Octahedron and Quantization encodings based on work by:  *  * @link https://github.com/tsherif/mesh-quantization-example  *  */  import {  BufferAttribute,  Matrix3,  Matrix4,  Vector3 } from 'three';    /**  * Make the input geometry's normal attribute encoded and compressed by 3 different methods.  *  * @param {THREE.BufferGeometry} geometry  * @param {String} encodeMethod  "DEFAULT" || "OCT1Byte" || "OCT2Byte" || "ANGLES"  *  */ function compressNormals( geometry, encodeMethod ) {   const normal = geometry.attributes.normal;   if ( ! normal ) {    console.error( 'Geometry must contain normal attribute. ' );   }   if ( normal.isPacked ) return;   if ( normal.itemSize != 3 ) {    console.error( 'normal.itemSize is not 3, which cannot be encoded. ' );   }   const array = normal.array;  const count = normal.count;   let result;  if ( encodeMethod == 'DEFAULT' ) {    // TODO: Add 1 byte to the result, making the encoded length to be 4 bytes.   result = new Uint8Array( count * 3 );    for ( let idx = 0; idx < array.length; idx += 3 ) {     const encoded = defaultEncode( array[ idx ], array[ idx + 1 ], array[ idx + 2 ], 1 );     result[ idx + 0 ] = encoded[ 0 ];    result[ idx + 1 ] = encoded[ 1 ];    result[ idx + 2 ] = encoded[ 2 ];    }    geometry.setAttribute( 'normal', new BufferAttribute( result, 3, true ) );   geometry.attributes.normal.bytes = result.length * 1;   } else if ( encodeMethod == 'OCT1Byte' ) {    /**   * It is not recommended to use 1-byte octahedron normals encoding unless you want to extremely reduce the memory usage   * As it makes vertex data not aligned to a 4 byte boundary which may harm some WebGL implementations and sometimes the normal distortion is visible   * Please refer to @zeux 's comments in https://github.com/mrdoob/three.js/pull/18208   */    result = new Int8Array( count * 2 );    for ( let idx = 0; idx < array.length; idx += 3 ) {     const encoded = octEncodeBest( array[ idx ], array[ idx + 1 ], array[ idx + 2 ], 1 );     result[ idx / 3 * 2 + 0 ] = encoded[ 0 ];    result[ idx / 3 * 2 + 1 ] = encoded[ 1 ];    }    geometry.setAttribute( 'normal', new BufferAttribute( result, 2, true ) );   geometry.attributes.normal.bytes = result.length * 1;   } else if ( encodeMethod == 'OCT2Byte' ) {    result = new Int16Array( count * 2 );    for ( let idx = 0; idx < array.length; idx += 3 ) {     const encoded = octEncodeBest( array[ idx ], array[ idx + 1 ], array[ idx + 2 ], 2 );     result[ idx / 3 * 2 + 0 ] = encoded[ 0 ];    result[ idx / 3 * 2 + 1 ] = encoded[ 1 ];    }    geometry.setAttribute( 'normal', new BufferAttribute( result, 2, true ) );   geometry.attributes.normal.bytes = result.length * 2;   } else if ( encodeMethod == 'ANGLES' ) {    result = new Uint16Array( count * 2 );    for ( let idx = 0; idx < array.length; idx += 3 ) {     const encoded = anglesEncode( array[ idx ], array[ idx + 1 ], array[ idx + 2 ] );     result[ idx / 3 * 2 + 0 ] = encoded[ 0 ];    result[ idx / 3 * 2 + 1 ] = encoded[ 1 ];    }    geometry.setAttribute( 'normal', new BufferAttribute( result, 2, true ) );   geometry.attributes.normal.bytes = result.length * 2;   } else {    console.error( 'Unrecognized encoding method, should be |DEFAULT| or |ANGLES| or |OCT|. ' );   }   geometry.attributes.normal.needsUpdate = true;  geometry.attributes.normal.isPacked = true;  geometry.attributes.normal.packingMethod = encodeMethod;  }   /**   * Make the input geometry's position attribute encoded and compressed.   *   * @param {THREE.BufferGeometry} geometry   *   */ function compressPositions( geometry ) {   const position = geometry.attributes.position;   if ( ! position ) {    console.error( 'Geometry must contain position attribute. ' );   }   if ( position.isPacked ) return;   if ( position.itemSize != 3 ) {    console.error( 'position.itemSize is not 3, which cannot be packed. ' );   }   const array = position.array;  const encodingBytes = 2;   const result = quantizedEncode( array, encodingBytes );   const quantized = result.quantized;   // IMPORTANT: calculate original geometry bounding info first, before updating packed positions  if ( geometry.boundingBox == null ) geometry.computeBoundingBox();  if ( geometry.boundingSphere == null ) geometry.computeBoundingSphere();   geometry.setAttribute( 'position', new BufferAttribute( quantized, 3 ) );  geometry.attributes.position.isPacked = true;  geometry.attributes.position.needsUpdate = true;  geometry.attributes.position.bytes = quantized.length * encodingBytes;  }  /**  * Make the input geometry's uv attribute encoded and compressed.  *  * @param {THREE.BufferGeometry} geometry  *  */ function compressUvs( geometry ) {   const uvs = geometry.attributes.uv;   if ( ! uvs ) {    console.error( 'Geometry must contain uv attribute. ' );   }   if ( uvs.isPacked ) return;   const range = { min: Infinity, max: - Infinity };   const array = uvs.array;   for ( let i = 0; i < array.length; i ++ ) {    range.min = Math.min( range.min, array[ i ] );   range.max = Math.max( range.max, array[ i ] );   }   let result;   if ( range.min >= - 1.0 && range.max <= 1.0 ) {    // use default encoding method   result = new Uint16Array( array.length );    for ( let i = 0; i < array.length; i += 2 ) {     const encoded = defaultEncode( array[ i ], array[ i + 1 ], 0, 2 );     result[ i ] = encoded[ 0 ];    result[ i + 1 ] = encoded[ 1 ];    }    geometry.setAttribute( 'uv', new BufferAttribute( result, 2, true ) );   geometry.attributes.uv.isPacked = true;   geometry.attributes.uv.needsUpdate = true;   geometry.attributes.uv.bytes = result.length * 2;   } else {    // use quantized encoding method   result = quantizedEncodeUV( array, 2 );    geometry.setAttribute( 'uv', new BufferAttribute( result.quantized, 2 ) );   geometry.attributes.uv.isPacked = true;   geometry.attributes.uv.needsUpdate = true;   geometry.attributes.uv.bytes = result.quantized.length * 2;   }  }   // Encoding functions  function defaultEncode( x, y, z, bytes ) {   if ( bytes == 1 ) {    const tmpx = Math.round( ( x + 1 ) * 0.5 * 255 );   const tmpy = Math.round( ( y + 1 ) * 0.5 * 255 );   const tmpz = Math.round( ( z + 1 ) * 0.5 * 255 );   return new Uint8Array( [ tmpx, tmpy, tmpz ] );   } else if ( bytes == 2 ) {    const tmpx = Math.round( ( x + 1 ) * 0.5 * 65535 );   const tmpy = Math.round( ( y + 1 ) * 0.5 * 65535 );   const tmpz = Math.round( ( z + 1 ) * 0.5 * 65535 );   return new Uint16Array( [ tmpx, tmpy, tmpz ] );   } else {    console.error( 'number of bytes must be 1 or 2' );   }  }  // for |Angles| encoding function anglesEncode( x, y, z ) {   const normal0 = parseInt( 0.5 * ( 1.0 + Math.atan2( y, x ) / Math.PI ) * 65535 );  const normal1 = parseInt( 0.5 * ( 1.0 + z ) * 65535 );  return new Uint16Array( [ normal0, normal1 ] );  }  // for |Octahedron| encoding function octEncodeBest( x, y, z, bytes ) {   let oct, dec, best, currentCos, bestCos;   // Test various combinations of ceil and floor  // to minimize rounding errors  best = oct = octEncodeVec3( x, y, z, 'floor', 'floor' );  dec = octDecodeVec2( oct );  bestCos = dot( x, y, z, dec );   oct = octEncodeVec3( x, y, z, 'ceil', 'floor' );  dec = octDecodeVec2( oct );  currentCos = dot( x, y, z, dec );   if ( currentCos > bestCos ) {    best = oct;   bestCos = currentCos;   }   oct = octEncodeVec3( x, y, z, 'floor', 'ceil' );  dec = octDecodeVec2( oct );  currentCos = dot( x, y, z, dec );   if ( currentCos > bestCos ) {    best = oct;   bestCos = currentCos;   }   oct = octEncodeVec3( x, y, z, 'ceil', 'ceil' );  dec = octDecodeVec2( oct );  currentCos = dot( x, y, z, dec );   if ( currentCos > bestCos ) {    best = oct;   }   return best;   function octEncodeVec3( x0, y0, z0, xfunc, yfunc ) {    let x = x0 / ( Math.abs( x0 ) + Math.abs( y0 ) + Math.abs( z0 ) );   let y = y0 / ( Math.abs( x0 ) + Math.abs( y0 ) + Math.abs( z0 ) );    if ( z < 0 ) {     const tempx = ( 1 - Math.abs( y ) ) * ( x >= 0 ? 1 : - 1 );    const tempy = ( 1 - Math.abs( x ) ) * ( y >= 0 ? 1 : - 1 );     x = tempx;    y = tempy;     let diff = 1 - Math.abs( x ) - Math.abs( y );    if ( diff > 0 ) {      diff += 0.001;     x += x > 0 ? diff / 2 : - diff / 2;     y += y > 0 ? diff / 2 : - diff / 2;     }    }    if ( bytes == 1 ) {     return new Int8Array( [     Math[ xfunc ]( x * 127.5 + ( x < 0 ? 1 : 0 ) ),     Math[ yfunc ]( y * 127.5 + ( y < 0 ? 1 : 0 ) )    ] );    }    if ( bytes == 2 ) {     return new Int16Array( [     Math[ xfunc ]( x * 32767.5 + ( x < 0 ? 1 : 0 ) ),     Math[ yfunc ]( y * 32767.5 + ( y < 0 ? 1 : 0 ) )    ] );    }    }   function octDecodeVec2( oct ) {    let x = oct[ 0 ];   let y = oct[ 1 ];    if ( bytes == 1 ) {     x /= x < 0 ? 127 : 128;    y /= y < 0 ? 127 : 128;    } else if ( bytes == 2 ) {     x /= x < 0 ? 32767 : 32768;    y /= y < 0 ? 32767 : 32768;    }     const z = 1 - Math.abs( x ) - Math.abs( y );    if ( z < 0 ) {     const tmpx = x;    x = ( 1 - Math.abs( y ) ) * ( x >= 0 ? 1 : - 1 );    y = ( 1 - Math.abs( tmpx ) ) * ( y >= 0 ? 1 : - 1 );    }    const length = Math.sqrt( x * x + y * y + z * z );    return [    x / length,    y / length,    z / length   ];   }   function dot( x, y, z, vec3 ) {    return x * vec3[ 0 ] + y * vec3[ 1 ] + z * vec3[ 2 ];   }  }  function quantizedEncode( array, bytes ) {   let quantized, segments;   if ( bytes == 1 ) {    quantized = new Uint8Array( array.length );   segments = 255;   } else if ( bytes == 2 ) {    quantized = new Uint16Array( array.length );   segments = 65535;   } else {    console.error( 'number of bytes error! ' );   }   const decodeMat = new Matrix4();   const min = new Float32Array( 3 );  const max = new Float32Array( 3 );   min[ 0 ] = min[ 1 ] = min[ 2 ] = Number.MAX_VALUE;  max[ 0 ] = max[ 1 ] = max[ 2 ] = - Number.MAX_VALUE;   for ( let i = 0; i < array.length; i += 3 ) {    min[ 0 ] = Math.min( min[ 0 ], array[ i + 0 ] );   min[ 1 ] = Math.min( min[ 1 ], array[ i + 1 ] );   min[ 2 ] = Math.min( min[ 2 ], array[ i + 2 ] );   max[ 0 ] = Math.max( max[ 0 ], array[ i + 0 ] );   max[ 1 ] = Math.max( max[ 1 ], array[ i + 1 ] );   max[ 2 ] = Math.max( max[ 2 ], array[ i + 2 ] );   }   decodeMat.scale( new Vector3(   ( max[ 0 ] - min[ 0 ] ) / segments,   ( max[ 1 ] - min[ 1 ] ) / segments,   ( max[ 2 ] - min[ 2 ] ) / segments  ) );   decodeMat.elements[ 12 ] = min[ 0 ];  decodeMat.elements[ 13 ] = min[ 1 ];  decodeMat.elements[ 14 ] = min[ 2 ];   decodeMat.transpose();    const multiplier = new Float32Array( [   max[ 0 ] !== min[ 0 ] ? segments / ( max[ 0 ] - min[ 0 ] ) : 0,   max[ 1 ] !== min[ 1 ] ? segments / ( max[ 1 ] - min[ 1 ] ) : 0,   max[ 2 ] !== min[ 2 ] ? segments / ( max[ 2 ] - min[ 2 ] ) : 0  ] );   for ( let i = 0; i < array.length; i += 3 ) {    quantized[ i + 0 ] = Math.floor( ( array[ i + 0 ] - min[ 0 ] ) * multiplier[ 0 ] );   quantized[ i + 1 ] = Math.floor( ( array[ i + 1 ] - min[ 1 ] ) * multiplier[ 1 ] );   quantized[ i + 2 ] = Math.floor( ( array[ i + 2 ] - min[ 2 ] ) * multiplier[ 2 ] );   }   return {   quantized: quantized,   decodeMat: decodeMat  };  }  function quantizedEncodeUV( array, bytes ) {   let quantized, segments;   if ( bytes == 1 ) {    quantized = new Uint8Array( array.length );   segments = 255;   } else if ( bytes == 2 ) {    quantized = new Uint16Array( array.length );   segments = 65535;   } else {    console.error( 'number of bytes error! ' );   }   const decodeMat = new Matrix3();   const min = new Float32Array( 2 );  const max = new Float32Array( 2 );   min[ 0 ] = min[ 1 ] = Number.MAX_VALUE;  max[ 0 ] = max[ 1 ] = - Number.MAX_VALUE;   for ( let i = 0; i < array.length; i += 2 ) {    min[ 0 ] = Math.min( min[ 0 ], array[ i + 0 ] );   min[ 1 ] = Math.min( min[ 1 ], array[ i + 1 ] );   max[ 0 ] = Math.max( max[ 0 ], array[ i + 0 ] );   max[ 1 ] = Math.max( max[ 1 ], array[ i + 1 ] );   }   decodeMat.scale(   ( max[ 0 ] - min[ 0 ] ) / segments,   ( max[ 1 ] - min[ 1 ] ) / segments  );   decodeMat.elements[ 6 ] = min[ 0 ];  decodeMat.elements[ 7 ] = min[ 1 ];   decodeMat.transpose();   const multiplier = new Float32Array( [   max[ 0 ] !== min[ 0 ] ? segments / ( max[ 0 ] - min[ 0 ] ) : 0,   max[ 1 ] !== min[ 1 ] ? segments / ( max[ 1 ] - min[ 1 ] ) : 0  ] );   for ( let i = 0; i < array.length; i += 2 ) {    quantized[ i + 0 ] = Math.floor( ( array[ i + 0 ] - min[ 0 ] ) * multiplier[ 0 ] );   quantized[ i + 1 ] = Math.floor( ( array[ i + 1 ] - min[ 1 ] ) * multiplier[ 1 ] );   }   return {   quantized: quantized,   decodeMat: decodeMat  };  }    export {  compressNormals,  compressPositions,  compressUvs, }; 
^..^ FILENAME ^..^
addons|utils|GeometryUtils.js
^..^ CONTENTS ^..^
import { Vector3 } from 'three';   /**  * Generates 2D-Coordinates in a very fast way.  *  * Based on work by:  * @link http://www.openprocessing.org/sketch/15493  *  * @param center     Center of Hilbert curve.  * @param size       Total width of Hilbert curve.  * @param iterations Number of subdivisions.  * @param v0         Corner index -X, -Z.  * @param v1         Corner index -X, +Z.  * @param v2         Corner index +X, +Z.  * @param v3         Corner index +X, -Z.  */ function hilbert2D( center = new Vector3( 0, 0, 0 ), size = 10, iterations = 1, v0 = 0, v1 = 1, v2 = 2, v3 = 3 ) {   const half = size / 2;   const vec_s = [   new Vector3( center.x - half, center.y, center.z - half ),   new Vector3( center.x - half, center.y, center.z + half ),   new Vector3( center.x + half, center.y, center.z + half ),   new Vector3( center.x + half, center.y, center.z - half )  ];   const vec = [   vec_s[ v0 ],   vec_s[ v1 ],   vec_s[ v2 ],   vec_s[ v3 ]  ];   // Recurse iterations  if ( 0 <= -- iterations ) {    return [    ...hilbert2D( vec[ 0 ], half, iterations, v0, v3, v2, v1 ),    ...hilbert2D( vec[ 1 ], half, iterations, v0, v1, v2, v3 ),    ...hilbert2D( vec[ 2 ], half, iterations, v0, v1, v2, v3 ),    ...hilbert2D( vec[ 3 ], half, iterations, v2, v1, v0, v3 )   ];   }   // Return complete Hilbert Curve.  return vec;  }  /**  * Generates 3D-Coordinates in a very fast way.  *  * Based on work by:  * @link https://openprocessing.org/user/5654  *  * @param center     Center of Hilbert curve.  * @param size       Total width of Hilbert curve.  * @param iterations Number of subdivisions.  * @param v0         Corner index -X, +Y, -Z.  * @param v1         Corner index -X, +Y, +Z.  * @param v2         Corner index -X, -Y, +Z.  * @param v3         Corner index -X, -Y, -Z.  * @param v4         Corner index +X, -Y, -Z.  * @param v5         Corner index +X, -Y, +Z.  * @param v6         Corner index +X, +Y, +Z.  * @param v7         Corner index +X, +Y, -Z.  */ function hilbert3D( center = new Vector3( 0, 0, 0 ), size = 10, iterations = 1, v0 = 0, v1 = 1, v2 = 2, v3 = 3, v4 = 4, v5 = 5, v6 = 6, v7 = 7 ) {   // Default Vars  const half = size / 2;   const vec_s = [   new Vector3( center.x - half, center.y + half, center.z - half ),   new Vector3( center.x - half, center.y + half, center.z + half ),   new Vector3( center.x - half, center.y - half, center.z + half ),   new Vector3( center.x - half, center.y - half, center.z - half ),   new Vector3( center.x + half, center.y - half, center.z - half ),   new Vector3( center.x + half, center.y - half, center.z + half ),   new Vector3( center.x + half, center.y + half, center.z + half ),   new Vector3( center.x + half, center.y + half, center.z - half )  ];   const vec = [   vec_s[ v0 ],   vec_s[ v1 ],   vec_s[ v2 ],   vec_s[ v3 ],   vec_s[ v4 ],   vec_s[ v5 ],   vec_s[ v6 ],   vec_s[ v7 ]  ];   // Recurse iterations  if ( -- iterations >= 0 ) {    return [    ...hilbert3D( vec[ 0 ], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1 ),    ...hilbert3D( vec[ 1 ], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3 ),    ...hilbert3D( vec[ 2 ], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3 ),    ...hilbert3D( vec[ 3 ], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5 ),    ...hilbert3D( vec[ 4 ], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5 ),    ...hilbert3D( vec[ 5 ], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7 ),    ...hilbert3D( vec[ 6 ], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7 ),    ...hilbert3D( vec[ 7 ], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7 )   ];   }   // Return complete Hilbert Curve.  return vec;  }  /**  * Generates a Gosper curve (lying in the XY plane)  *  * https://gist.github.com/nitaku/6521802  *  * @param size The size of a single gosper island.  */ function gosper( size = 1 ) {   function fractalize( config ) {    let output;   let input = config.axiom;    for ( let i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i ++ : i -- ) {     output = '';     for ( let j = 0, jl = input.length; j < jl; j ++ ) {      const char = input[ j ];      if ( char in config.rules ) {       output += config.rules[ char ];      } else {       output += char;      }     }     input = output;    }    return output;   }   function toPoints( config ) {    let currX = 0, currY = 0;   let angle = 0;   const path = [ 0, 0, 0 ];   const fractal = config.fractal;    for ( let i = 0, l = fractal.length; i < l; i ++ ) {     const char = fractal[ i ];     if ( char === '+' ) {      angle += config.angle;     } else if ( char === '-' ) {      angle -= config.angle;     } else if ( char === 'F' ) {      currX += config.size * Math.cos( angle );     currY += - config.size * Math.sin( angle );     path.push( currX, currY, 0 );     }    }    return path;   }   //   const gosper = fractalize( {   axiom: 'A',   steps: 4,   rules: {    A: 'A+BF++BF-FA--FAFA-BF+',    B: '-FA+BFBF++BF+FA--FA-B'   }  } );   const points = toPoints( {   fractal: gosper,   size: size,   angle: Math.PI / 3 // 60 degrees  } );   return points;  }    export {  hilbert2D,  hilbert3D,  gosper, }; 
^..^ FILENAME ^..^
addons|utils|LDrawUtils.js
^..^ CONTENTS ^..^
import {  BufferAttribute,  BufferGeometry,  Group,  LineSegments,  Matrix3,  Mesh } from 'three';  import { mergeGeometries } from './BufferGeometryUtils.js';  class LDrawUtils {   static mergeObject( object ) {    // Merges geometries in object by materials and returns new object. Use on not indexed geometries.   // The object buffers reference the old object ones.   // Special treatment is done to the conditional lines generated by LDrawLoader.    function extractGroup( geometry, group, elementSize, isConditionalLine ) {     // Extracts a group from a geometry as a new geometry (with attribute buffers referencing original buffers)     const newGeometry = new BufferGeometry();     const originalPositions = geometry.getAttribute( 'position' ).array;    const originalNormals = elementSize === 3 ? geometry.getAttribute( 'normal' ).array : null;     const numVertsGroup = Math.min( group.count, Math.floor( originalPositions.length / 3 ) - group.start );    const vertStart = group.start * 3;    const vertEnd = ( group.start + numVertsGroup ) * 3;     const positions = originalPositions.subarray( vertStart, vertEnd );    const normals = originalNormals !== null ? originalNormals.subarray( vertStart, vertEnd ) : null;     newGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );    if ( normals !== null ) newGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );     if ( isConditionalLine ) {      const controlArray0 = geometry.getAttribute( 'control0' ).array.subarray( vertStart, vertEnd );     const controlArray1 = geometry.getAttribute( 'control1' ).array.subarray( vertStart, vertEnd );     const directionArray = geometry.getAttribute( 'direction' ).array.subarray( vertStart, vertEnd );      newGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );     newGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );     newGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );     }     return newGeometry;    }    function addGeometry( mat, geometry, geometries ) {     const geoms = geometries[ mat.uuid ];    if ( ! geoms ) {      geometries[ mat.uuid ] = {      mat: mat,      arr: [ geometry ]     };     } else {      geoms.arr.push( geometry );     }    }    function permuteAttribute( attribute, elemSize ) {     // Permutes first two vertices of each attribute element     if ( ! attribute ) return;     const verts = attribute.array;    const numVerts = Math.floor( verts.length / 3 );    let offset = 0;    for ( let i = 0; i < numVerts; i ++ ) {      const x = verts[ offset ];     const y = verts[ offset + 1 ];     const z = verts[ offset + 2 ];      verts[ offset ] = verts[ offset + 3 ];     verts[ offset + 1 ] = verts[ offset + 4 ];     verts[ offset + 2 ] = verts[ offset + 5 ];      verts[ offset + 3 ] = x;     verts[ offset + 4 ] = y;     verts[ offset + 5 ] = z;      offset += elemSize * 3;     }    }    // Traverse the object hierarchy collecting geometries and transforming them to world space    const meshGeometries = {};   const linesGeometries = {};   const condLinesGeometries = {};    object.updateMatrixWorld( true );   const normalMatrix = new Matrix3();    object.traverse( c => {     if ( c.isMesh | c.isLineSegments ) {      const elemSize = c.isMesh ? 3 : 2;      const geometry = c.geometry.clone();     const matrixIsInverted = c.matrixWorld.determinant() < 0;     if ( matrixIsInverted ) {       permuteAttribute( geometry.attributes.position, elemSize );      permuteAttribute( geometry.attributes.normal, elemSize );      }      geometry.applyMatrix4( c.matrixWorld );      if ( c.isConditionalLine ) {       geometry.attributes.control0.applyMatrix4( c.matrixWorld );      geometry.attributes.control1.applyMatrix4( c.matrixWorld );      normalMatrix.getNormalMatrix( c.matrixWorld );      geometry.attributes.direction.applyNormalMatrix( normalMatrix );      }      const geometries = c.isMesh ? meshGeometries : ( c.isConditionalLine ? condLinesGeometries : linesGeometries );      if ( Array.isArray( c.material ) ) {       for ( const groupIndex in geometry.groups ) {        const group = geometry.groups[ groupIndex ];       const mat = c.material[ group.materialIndex ];       const newGeometry = extractGroup( geometry, group, elemSize, c.isConditionalLine );       addGeometry( mat, newGeometry, geometries );       }      } else {       addGeometry( c.material, geometry, geometries );      }     }    } );    // Create object with merged geometries    const mergedObject = new Group();    const meshMaterialsIds = Object.keys( meshGeometries );   for ( const meshMaterialsId of meshMaterialsIds ) {     const meshGeometry = meshGeometries[ meshMaterialsId ];    const mergedGeometry = mergeGeometries( meshGeometry.arr );    mergedObject.add( new Mesh( mergedGeometry, meshGeometry.mat ) );    }    const linesMaterialsIds = Object.keys( linesGeometries );   for ( const linesMaterialsId of linesMaterialsIds ) {     const lineGeometry = linesGeometries[ linesMaterialsId ];    const mergedGeometry = mergeGeometries( lineGeometry.arr );    mergedObject.add( new LineSegments( mergedGeometry, lineGeometry.mat ) );    }    const condLinesMaterialsIds = Object.keys( condLinesGeometries );   for ( const condLinesMaterialsId of condLinesMaterialsIds ) {     const condLineGeometry = condLinesGeometries[ condLinesMaterialsId ];    const mergedGeometry = mergeGeometries( condLineGeometry.arr );    const condLines = new LineSegments( mergedGeometry, condLineGeometry.mat );    condLines.isConditionalLine = true;    mergedObject.add( condLines );    }    mergedObject.userData.constructionStep = 0;   mergedObject.userData.numConstructionSteps = 1;    return mergedObject;   }  }  export { LDrawUtils }; 
^..^ FILENAME ^..^
addons|utils|SceneUtils.js
^..^ CONTENTS ^..^
import {  BufferAttribute,  BufferGeometry,  Color,  Group,  Matrix4,  Mesh,  Vector3 } from 'three';  import { mergeGroups, deepCloneAttribute } from './BufferGeometryUtils.js';  const _color = /*@__PURE__*/new Color(); const _matrix = /*@__PURE__*/new Matrix4();  function createMeshesFromInstancedMesh( instancedMesh ) {   const group = new Group();   const count = instancedMesh.count;  const geometry = instancedMesh.geometry;  const material = instancedMesh.material;   for ( let i = 0; i < count; i ++ ) {    const mesh = new Mesh( geometry, material );    instancedMesh.getMatrixAt( i, mesh.matrix );   mesh.matrix.decompose( mesh.position, mesh.quaternion, mesh.scale );    group.add( mesh );   }   group.copy( instancedMesh );  group.updateMatrixWorld(); // ensure correct world matrices of meshes   return group;  }  function createMeshesFromMultiMaterialMesh( mesh ) {   if ( Array.isArray( mesh.material ) === false ) {    console.warn( 'THREE.SceneUtils.createMeshesFromMultiMaterialMesh(): The given mesh has no multiple materials.' );   return mesh;   }   const object = new Group();  object.copy( mesh );   // merge groups (which automatically sorts them)   const geometry = mergeGroups( mesh.geometry );   const index = geometry.index;  const groups = geometry.groups;  const attributeNames = Object.keys( geometry.attributes );   // create a mesh for each group by extracting the buffer data into a new geometry   for ( let i = 0; i < groups.length; i ++ ) {    const group = groups[ i ];    const start = group.start;   const end = start + group.count;    const newGeometry = new BufferGeometry();   const newMaterial = mesh.material[ group.materialIndex ];    // process all buffer attributes    for ( let j = 0; j < attributeNames.length; j ++ ) {     const name = attributeNames[ j ];    const attribute = geometry.attributes[ name ];    const itemSize = attribute.itemSize;     const newLength = group.count * itemSize;    const type = attribute.array.constructor;     const newArray = new type( newLength );    const newAttribute = new BufferAttribute( newArray, itemSize );     for ( let k = start, n = 0; k < end; k ++, n ++ ) {      const ind = index.getX( k );      if ( itemSize >= 1 ) newAttribute.setX( n, attribute.getX( ind ) );     if ( itemSize >= 2 ) newAttribute.setY( n, attribute.getY( ind ) );     if ( itemSize >= 3 ) newAttribute.setZ( n, attribute.getZ( ind ) );     if ( itemSize >= 4 ) newAttribute.setW( n, attribute.getW( ind ) );     }      newGeometry.setAttribute( name, newAttribute );    }    const newMesh = new Mesh( newGeometry, newMaterial );   object.add( newMesh );   }   return object;  }  function createMultiMaterialObject( geometry, materials ) {   const group = new Group();   for ( let i = 0, l = materials.length; i < l; i ++ ) {    group.add( new Mesh( geometry, materials[ i ] ) );   }   return group;  }  function reduceVertices( object, func, initialValue ) {   let value = initialValue;  const vertex = new Vector3();   object.updateWorldMatrix( true, true );   object.traverseVisible( ( child ) => {    const { geometry } = child;    if ( geometry !== undefined ) {     const { position } = geometry.attributes;     if ( position !== undefined ) {      for ( let i = 0, l = position.count; i < l; i ++ ) {       if ( child.isMesh ) {        child.getVertexPosition( i, vertex );       } else {        vertex.fromBufferAttribute( position, i );       }       if ( ! child.isSkinnedMesh ) {        vertex.applyMatrix4( child.matrixWorld );       }       value = func( value, vertex );      }     }    }   } );   return value;  }  /**  * @param {InstancedMesh}  * @param {function(int, int):int}  */ function sortInstancedMesh( mesh, compareFn ) {   // store copy of instanced attributes for lookups   const instanceMatrixRef = deepCloneAttribute( mesh.instanceMatrix );  const instanceColorRef = mesh.instanceColor ? deepCloneAttribute( mesh.instanceColor ) : null;   const attributeRefs = new Map();   for ( const name in mesh.geometry.attributes ) {    const attribute = mesh.geometry.attributes[ name ];    if ( attribute.isInstancedBufferAttribute ) {     attributeRefs.set( attribute, deepCloneAttribute( attribute ) );    }   }    // compute sort order   const tokens = [];   for ( let i = 0; i < mesh.count; i ++ ) tokens.push( i );   tokens.sort( compareFn );    // apply sort order   for ( let i = 0; i < tokens.length; i ++ ) {    const refIndex = tokens[ i ];    _matrix.fromArray( instanceMatrixRef.array, refIndex * mesh.instanceMatrix.itemSize );   _matrix.toArray( mesh.instanceMatrix.array, i * mesh.instanceMatrix.itemSize );    if ( mesh.instanceColor ) {     _color.fromArray( instanceColorRef.array, refIndex * mesh.instanceColor.itemSize );    _color.toArray( mesh.instanceColor.array, i * mesh.instanceColor.itemSize );    }    for ( const name in mesh.geometry.attributes ) {     const attribute = mesh.geometry.attributes[ name ];     if ( attribute.isInstancedBufferAttribute ) {      const attributeRef = attributeRefs.get( attribute );      attribute.setX( i, attributeRef.getX( refIndex ) );     if ( attribute.itemSize > 1 ) attribute.setY( i, attributeRef.getY( refIndex ) );     if ( attribute.itemSize > 2 ) attribute.setZ( i, attributeRef.getZ( refIndex ) );     if ( attribute.itemSize > 3 ) attribute.setW( i, attributeRef.getW( refIndex ) );     }    }   }  }  /**  * @param {Object3D} object Object to traverse.  * @yields {Object3D} Objects that passed the filter condition.  */ function* traverseGenerator( object ) {   yield object;   const children = object.children;   for ( let i = 0, l = children.length; i < l; i ++ ) {    yield* traverseGenerator( children[ i ] );   }  }  /**  * @param {Object3D} object Object to traverse.  * @yields {Object3D} Objects that passed the filter condition.  */ function* traverseVisibleGenerator( object ) {   if ( object.visible === false ) return;   yield object;   const children = object.children;   for ( let i = 0, l = children.length; i < l; i ++ ) {    yield* traverseVisibleGenerator( children[ i ] );   }  }  /**  * @param {Object3D} object Object to traverse.  * @yields {Object3D} Objects that passed the filter condition.  */ function* traverseAncestorsGenerator( object ) {   const parent = object.parent;   if ( parent !== null ) {    yield parent;    yield* traverseAncestorsGenerator( parent );   }  }  export {  createMeshesFromInstancedMesh,  createMeshesFromMultiMaterialMesh,  createMultiMaterialObject,  reduceVertices,  sortInstancedMesh,  traverseGenerator,  traverseVisibleGenerator,  traverseAncestorsGenerator }; 
^..^ FILENAME ^..^
addons|utils|ShadowMapViewer.js
^..^ CONTENTS ^..^
import {  DoubleSide,  CanvasTexture,  Mesh,  MeshBasicMaterial,  OrthographicCamera,  PlaneGeometry,  Scene,  ShaderMaterial,  UniformsUtils } from 'three'; import { UnpackDepthRGBAShader } from '../shaders/UnpackDepthRGBAShader.js';  /**  * This is a helper for visualising a given light's shadow map.  * It works for shadow casting lights: DirectionalLight and SpotLight.  * It renders out the shadow map and displays it on a HUD.  *  * Example usage:  * 1) Import ShadowMapViewer into your app.  *  * 2) Create a shadow casting light and name it optionally:  *  let light = new DirectionalLight( 0xffffff, 1 );  *  light.castShadow = true;  *  light.name = 'Sun';  *  * 3) Create a shadow map viewer for that light and set its size and position optionally:  *  let shadowMapViewer = new ShadowMapViewer( light );  *  shadowMapViewer.size.set( 128, 128 ); //width, height  default: 256, 256  *  shadowMapViewer.position.set( 10, 10 ); //x, y in pixel  default: 0, 0 (top left corner)  *  * 4) Render the shadow map viewer in your render loop:  *  shadowMapViewer.render( renderer );  *  * 5) Optionally: Update the shadow map viewer on window resize:  *  shadowMapViewer.updateForWindowResize();  *  * 6) If you set the position or size members directly, you need to call shadowMapViewer.update();  */  class ShadowMapViewer {   constructor( light ) {    //- Internals   const scope = this;   const doRenderLabel = ( light.name !== undefined && light.name !== '' );   let userAutoClearSetting;    //Holds the initial position and dimension of the HUD   const frame = {    x: 10,    y: 10,    width: 256,    height: 256   };    const camera = new OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 10 );   camera.position.set( 0, 0, 2 );   const scene = new Scene();    //HUD for shadow map   const shader = UnpackDepthRGBAShader;    const uniforms = UniformsUtils.clone( shader.uniforms );   const material = new ShaderMaterial( {    uniforms: uniforms,    vertexShader: shader.vertexShader,    fragmentShader: shader.fragmentShader   } );   const plane = new PlaneGeometry( frame.width, frame.height );   const mesh = new Mesh( plane, material );    scene.add( mesh );     //Label for light's name   let labelCanvas, labelMesh;    if ( doRenderLabel ) {     labelCanvas = document.createElement( 'canvas' );     const context = labelCanvas.getContext( '2d' );    context.font = 'Bold 20px Arial';     const labelWidth = context.measureText( light.name ).width;    labelCanvas.width = labelWidth;    labelCanvas.height = 25; //25 to account for g, p, etc.     context.font = 'Bold 20px Arial';    context.fillStyle = 'rgba( 255, 0, 0, 1 )';    context.fillText( light.name, 0, 20 );     const labelTexture = new CanvasTexture( labelCanvas );     const labelMaterial = new MeshBasicMaterial( { map: labelTexture, side: DoubleSide, transparent: true } );     const labelPlane = new PlaneGeometry( labelCanvas.width, labelCanvas.height );    labelMesh = new Mesh( labelPlane, labelMaterial );     scene.add( labelMesh );    }     function resetPosition() {     scope.position.set( scope.position.x, scope.position.y );    }    //- API   // Set to false to disable displaying this shadow map   this.enabled = true;    // Set the size of the displayed shadow map on the HUD   this.size = {    width: frame.width,    height: frame.height,    set: function ( width, height ) {      this.width = width;     this.height = height;      mesh.scale.set( this.width / frame.width, this.height / frame.height, 1 );      //Reset the position as it is off when we scale stuff     resetPosition();     }   };    // Set the position of the displayed shadow map on the HUD   this.position = {    x: frame.x,    y: frame.y,    set: function ( x, y ) {      this.x = x;     this.y = y;      const width = scope.size.width;     const height = scope.size.height;      mesh.position.set( - window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0 );      if ( doRenderLabel ) labelMesh.position.set( mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0 );     }   };    this.render = function ( renderer ) {     if ( this.enabled ) {      //Because a light's .shadowMap is only initialised after the first render pass     //we have to make sure the correct map is sent into the shader, otherwise we     //always end up with the scene's first added shadow casting light's shadowMap     //in the shader     //See: https://github.com/mrdoob/three.js/issues/5932     uniforms.tDiffuse.value = light.shadow.map.texture;      userAutoClearSetting = renderer.autoClear;     renderer.autoClear = false; // To allow render overlay     renderer.clearDepth();     renderer.render( scene, camera );     renderer.autoClear = userAutoClearSetting; //Restore user's setting     }    };    this.updateForWindowResize = function () {     if ( this.enabled ) {       camera.left = window.innerWidth / - 2;      camera.right = window.innerWidth / 2;      camera.top = window.innerHeight / 2;      camera.bottom = window.innerHeight / - 2;      camera.updateProjectionMatrix();       this.update();     }    };    this.update = function () {     this.position.set( this.position.x, this.position.y );    this.size.set( this.size.width, this.size.height );    };    //Force an update to set position/size   this.update();   }  }   export { ShadowMapViewer }; 
^..^ FILENAME ^..^
addons|utils|ShadowMapViewerGPU.js
^..^ CONTENTS ^..^
import {  DoubleSide,  CanvasTexture,  Mesh,  MeshBasicMaterial,  NodeMaterial,  OrthographicCamera,  PlaneGeometry,  Scene,  Texture } from 'three'; import { texture } from 'three/tsl';  /**  * This is a helper for visualising a given light's shadow map.  * It works for shadow casting lights: DirectionalLight and SpotLight.  * It renders out the shadow map and displays it on a HUD.  *  * Example usage:  * 1) Import ShadowMapViewer into your app.  *  * 2) Create a shadow casting light and name it optionally:  *  let light = new DirectionalLight( 0xffffff, 1 );  *  light.castShadow = true;  *  light.name = 'Sun';  *  * 3) Create a shadow map viewer for that light and set its size and position optionally:  *  let shadowMapViewer = new ShadowMapViewer( light );  *  shadowMapViewer.size.set( 128, 128 ); //width, height  default: 256, 256  *  shadowMapViewer.position.set( 10, 10 ); //x, y in pixel  default: 0, 0 (top left corner)  *  * 4) Render the shadow map viewer in your render loop:  *  shadowMapViewer.render( renderer );  *  * 5) Optionally: Update the shadow map viewer on window resize:  *  shadowMapViewer.updateForWindowResize();  *  * 6) If you set the position or size members directly, you need to call shadowMapViewer.update();  */  class ShadowMapViewer {   constructor( light ) {    //- Internals   const scope = this;   const doRenderLabel = ( light.name !== undefined && light.name !== '' );   let currentAutoClear;    //Holds the initial position and dimension of the HUD   const frame = {    x: 10,    y: 10,    width: 256,    height: 256   };    const camera = new OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 10 );   camera.position.set( 0, 0, 2 );   const scene = new Scene();    //HUD for shadow map    const material = new NodeMaterial();    const shadowMapUniform = texture( new Texture() );   material.fragmentNode = shadowMapUniform;    const plane = new PlaneGeometry( frame.width, frame.height );   const mesh = new Mesh( plane, material );    scene.add( mesh );    //Label for light's name   let labelCanvas, labelMesh;    if ( doRenderLabel ) {     labelCanvas = document.createElement( 'canvas' );     const context = labelCanvas.getContext( '2d' );    context.font = 'Bold 20px Arial';     const labelWidth = context.measureText( light.name ).width;    labelCanvas.width = labelWidth;    labelCanvas.height = 25; //25 to account for g, p, etc.     context.font = 'Bold 20px Arial';    context.fillStyle = 'rgba( 255, 0, 0, 1 )';    context.fillText( light.name, 0, 20 );     const labelTexture = new CanvasTexture( labelCanvas );     const labelMaterial = new MeshBasicMaterial( { map: labelTexture, side: DoubleSide, transparent: true } );     const labelPlane = new PlaneGeometry( labelCanvas.width, labelCanvas.height );    labelMesh = new Mesh( labelPlane, labelMaterial );     scene.add( labelMesh );    }    function resetPosition() {     scope.position.set( scope.position.x, scope.position.y );    }    //- API   // Set to false to disable displaying this shadow map   this.enabled = true;    // Set the size of the displayed shadow map on the HUD   this.size = {    width: frame.width,    height: frame.height,    set: function ( width, height ) {      this.width = width;     this.height = height;      mesh.scale.set( this.width / frame.width, this.height / frame.height, 1 );      //Reset the position as it is off when we scale stuff     resetPosition();     }   };    // Set the position of the displayed shadow map on the HUD   this.position = {    x: frame.x,    y: frame.y,    set: function ( x, y ) {      this.x = x;     this.y = y;      const width = scope.size.width;     const height = scope.size.height;      mesh.position.set( - window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0 );      if ( doRenderLabel ) labelMesh.position.set( mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0 );     }   };    this.render = function ( renderer ) {     if ( this.enabled ) {      //Because a light's .shadowMap is only initialised after the first render pass     //we have to make sure the correct map is sent into the shader, otherwise we     //always end up with the scene's first added shadow casting light's shadowMap     //in the shader     //See: https://github.com/mrdoob/three.js/issues/5932     shadowMapUniform.value = light.shadow.map.texture;      currentAutoClear = renderer.autoClear;     renderer.autoClear = false; // To allow render overlay     renderer.clearDepth();     renderer.render( scene, camera );     renderer.autoClear = currentAutoClear;     }    };    this.updateForWindowResize = function () {     if ( this.enabled ) {       camera.left = window.innerWidth / - 2;      camera.right = window.innerWidth / 2;      camera.top = window.innerHeight / 2;      camera.bottom = window.innerHeight / - 2;      camera.updateProjectionMatrix();       this.update();     }    };    this.update = function () {     this.position.set( this.position.x, this.position.y );    this.size.set( this.size.width, this.size.height );    };    //Force an update to set position/size   this.update();   }  }   export { ShadowMapViewer }; 
^..^ FILENAME ^..^
addons|utils|SkeletonUtils.js
^..^ CONTENTS ^..^
import {  AnimationClip,  AnimationMixer,  Matrix4,  Quaternion,  QuaternionKeyframeTrack,  SkeletonHelper,  Vector3,  VectorKeyframeTrack } from 'three';  function getBoneName( bone, options ) {   if ( options.getBoneName !== undefined ) {    return options.getBoneName( bone );   }   return options.names[ bone.name ];  }  function retarget( target, source, options = {} ) {   const quat = new Quaternion(),   scale = new Vector3(),   relativeMatrix = new Matrix4(),   globalMatrix = new Matrix4();   options.preserveBoneMatrix = options.preserveBoneMatrix !== undefined ? options.preserveBoneMatrix : true;  options.preserveBonePositions = options.preserveBonePositions !== undefined ? options.preserveBonePositions : true;  options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;  options.hip = options.hip !== undefined ? options.hip : 'hip';  options.hipInfluence = options.hipInfluence !== undefined ? options.hipInfluence : new Vector3( 1, 1, 1 );  options.scale = options.scale !== undefined ? options.scale : 1;  options.names = options.names || {};   const sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),   bones = target.isObject3D ? target.skeleton.bones : getBones( target );   let bone, name, boneTo,   bonesPosition;   // reset bones   if ( target.isObject3D ) {    target.skeleton.pose();   } else {    options.useTargetMatrix = true;   options.preserveBoneMatrix = false;   }   if ( options.preserveBonePositions ) {    bonesPosition = [];    for ( let i = 0; i < bones.length; i ++ ) {     bonesPosition.push( bones[ i ].position.clone() );    }   }   if ( options.preserveBoneMatrix ) {    // reset matrix    target.updateMatrixWorld();    target.matrixWorld.identity();    // reset children matrix    for ( let i = 0; i < target.children.length; ++ i ) {     target.children[ i ].updateMatrixWorld( true );    }   }   for ( let i = 0; i < bones.length; ++ i ) {    bone = bones[ i ];   name = getBoneName( bone, options );    boneTo = getBoneByName( name, sourceBones );    globalMatrix.copy( bone.matrixWorld );    if ( boneTo ) {     boneTo.updateMatrixWorld();     if ( options.useTargetMatrix ) {      relativeMatrix.copy( boneTo.matrixWorld );     } else {      relativeMatrix.copy( target.matrixWorld ).invert();     relativeMatrix.multiply( boneTo.matrixWorld );     }     // ignore scale to extract rotation     scale.setFromMatrixScale( relativeMatrix );    relativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );     // apply to global matrix     globalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );     if ( target.isObject3D ) {      if ( options.localOffsets ) {       if ( options.localOffsets[ bone.name ] ) {        globalMatrix.multiply( options.localOffsets[ bone.name ] );       }      }     }     globalMatrix.copyPosition( relativeMatrix );    }    if ( name === options.hip ) {     globalMatrix.elements[ 12 ] *= options.scale * options.hipInfluence.x;    globalMatrix.elements[ 13 ] *= options.scale * options.hipInfluence.y;    globalMatrix.elements[ 14 ] *= options.scale * options.hipInfluence.z;     if ( options.hipPosition !== undefined ) {      globalMatrix.elements[ 12 ] += options.hipPosition.x * options.scale;     globalMatrix.elements[ 13 ] += options.hipPosition.y * options.scale;     globalMatrix.elements[ 14 ] += options.hipPosition.z * options.scale;     }    }    if ( bone.parent ) {     bone.matrix.copy( bone.parent.matrixWorld ).invert();    bone.matrix.multiply( globalMatrix );    } else {     bone.matrix.copy( globalMatrix );    }    bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );    bone.updateMatrixWorld();   }   if ( options.preserveBonePositions ) {    for ( let i = 0; i < bones.length; ++ i ) {     bone = bones[ i ];    name = getBoneName( bone, options ) || bone.name;     if ( name !== options.hip ) {      bone.position.copy( bonesPosition[ i ] );     }    }   }   if ( options.preserveBoneMatrix ) {    // restore matrix    target.updateMatrixWorld( true );   }  }  function retargetClip( target, source, clip, options = {} ) {   options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;   // Calculate the fps from the source clip based on the track with the most frames, unless fps is already provided.  options.fps = options.fps !== undefined ? options.fps : ( Math.max( ...clip.tracks.map( track => track.times.length ) ) / clip.duration );  options.names = options.names || [];   if ( ! source.isObject3D ) {    source = getHelperFromSkeleton( source );   }   const numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),   delta = clip.duration / ( numFrames - 1 ),   convertedTracks = [],   mixer = new AnimationMixer( source ),   bones = getBones( target.skeleton ),   boneDatas = [];   let positionOffset,   bone, boneTo, boneData,   name;   mixer.clipAction( clip ).play();   // trim   let start = 0, end = numFrames;   if ( options.trim !== undefined ) {    start = Math.round( options.trim[ 0 ] * options.fps );   end = Math.min( Math.round( options.trim[ 1 ] * options.fps ), numFrames ) - start;    mixer.update( options.trim[ 0 ] );   } else {    mixer.update( 0 );   }   source.updateMatrixWorld();   //   for ( let frame = 0; frame < end; ++ frame ) {    const time = frame * delta;    retarget( target, source, options );    for ( let j = 0; j < bones.length; ++ j ) {     bone = bones[ j ];    name = getBoneName( bone, options ) || bone.name;    boneTo = getBoneByName( name, source.skeleton );     if ( boneTo ) {      boneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };      if ( options.hip === name ) {       if ( ! boneData.pos ) {        boneData.pos = {        times: new Float32Array( end ),        values: new Float32Array( end * 3 )       };       }       if ( options.useFirstFramePosition ) {        if ( frame === 0 ) {         positionOffset = bone.position.clone();        }        bone.position.sub( positionOffset );       }       boneData.pos.times[ frame ] = time;       bone.position.toArray( boneData.pos.values, frame * 3 );      }      if ( ! boneData.quat ) {       boneData.quat = {       times: new Float32Array( end ),       values: new Float32Array( end * 4 )      };      }      boneData.quat.times[ frame ] = time;      bone.quaternion.toArray( boneData.quat.values, frame * 4 );     }    }    if ( frame === end - 2 ) {     // last mixer update before final loop iteration    // make sure we do not go over or equal to clip duration    mixer.update( delta - 0.0000001 );    } else {     mixer.update( delta );    }    source.updateMatrixWorld();   }   for ( let i = 0; i < boneDatas.length; ++ i ) {    boneData = boneDatas[ i ];    if ( boneData ) {     if ( boneData.pos ) {      convertedTracks.push( new VectorKeyframeTrack(      '.bones[' + boneData.bone.name + '].position',      boneData.pos.times,      boneData.pos.values     ) );     }     convertedTracks.push( new QuaternionKeyframeTrack(     '.bones[' + boneData.bone.name + '].quaternion',     boneData.quat.times,     boneData.quat.values    ) );    }   }   mixer.uncacheAction( clip );   return new AnimationClip( clip.name, - 1, convertedTracks );  }  function clone( source ) {   const sourceLookup = new Map();  const cloneLookup = new Map();   const clone = source.clone();   parallelTraverse( source, clone, function ( sourceNode, clonedNode ) {    sourceLookup.set( clonedNode, sourceNode );   cloneLookup.set( sourceNode, clonedNode );   } );   clone.traverse( function ( node ) {    if ( ! node.isSkinnedMesh ) return;    const clonedMesh = node;   const sourceMesh = sourceLookup.get( node );   const sourceBones = sourceMesh.skeleton.bones;    clonedMesh.skeleton = sourceMesh.skeleton.clone();   clonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );    clonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {     return cloneLookup.get( bone );    } );    clonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );   } );   return clone;  }  // internal helper  function getBoneByName( name, skeleton ) {   for ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {    if ( name === bones[ i ].name )     return bones[ i ];   }  }  function getBones( skeleton ) {   return Array.isArray( skeleton ) ? skeleton : skeleton.bones;  }   function getHelperFromSkeleton( skeleton ) {   const source = new SkeletonHelper( skeleton.bones[ 0 ] );  source.skeleton = skeleton;   return source;  }  function parallelTraverse( a, b, callback ) {   callback( a, b );   for ( let i = 0; i < a.children.length; i ++ ) {    parallelTraverse( a.children[ i ], b.children[ i ], callback );   }  }  export {  retarget,  retargetClip,  clone, }; 
^..^ FILENAME ^..^
addons|utils|SortUtils.js
^..^ CONTENTS ^..^
// Hybrid radix sort from // - https://gist.github.com/sciecode/93ed864dd77c5c8803c6a86698d68dab // - https://github.com/mrdoob/three.js/pull/27202#issuecomment-1817640271 // // expects unsigned 32b integer values  const POWER = 3; const BIT_MAX = 32; const BIN_BITS = 1 << POWER; const BIN_SIZE = 1 << BIN_BITS; const BIN_MAX = BIN_SIZE - 1; const ITERATIONS = BIT_MAX / BIN_BITS;  const bins = new Array( ITERATIONS ); const bins_buffer = new ArrayBuffer( ( ITERATIONS + 1 ) * BIN_SIZE * 4 );  let c = 0; for ( let i = 0; i < ( ITERATIONS + 1 ); i ++ ) {   bins[ i ] = new Uint32Array( bins_buffer, c, BIN_SIZE );  c += BIN_SIZE * 4;  }  const defaultGet = ( el ) => el;  export const radixSort = ( arr, opt ) => {   const len = arr.length;   const options = opt || {};  const aux = options.aux || new arr.constructor( len );  const get = options.get || defaultGet;   const data = [ arr, aux ];   let compare, accumulate, recurse;   if ( options.reversed ) {    compare = ( a, b ) => a < b;   accumulate = ( bin ) => {     for ( let j = BIN_SIZE - 2; j >= 0; j -- )     bin[ j ] += bin[ j + 1 ];    };    recurse = ( cache, depth, start ) => {     let prev = 0;    for ( let j = BIN_MAX; j >= 0; j -- ) {      const cur = cache[ j ], diff = cur - prev;     if ( diff != 0 ) {       if ( diff > 32 )       radixSortBlock( depth + 1, start + prev, diff );      else       insertionSortBlock( depth + 1, start + prev, diff );      prev = cur;      }     }    };   } else {    compare = ( a, b ) => a > b;   accumulate = ( bin ) => {     for ( let j = 1; j < BIN_SIZE; j ++ )     bin[ j ] += bin[ j - 1 ];    };    recurse = ( cache, depth, start ) => {     let prev = 0;    for ( let j = 0; j < BIN_SIZE; j ++ ) {      const cur = cache[ j ], diff = cur - prev;     if ( diff != 0 ) {       if ( diff > 32 )       radixSortBlock( depth + 1, start + prev, diff );      else       insertionSortBlock( depth + 1, start + prev, diff );      prev = cur;      }     }    };   }   const insertionSortBlock = ( depth, start, len ) => {    const a = data[ depth & 1 ];   const b = data[ ( depth + 1 ) & 1 ];    for ( let j = start + 1; j < start + len; j ++ ) {     const p = a[ j ], t = get( p ) >>> 0;    let i = j;    while ( i > start ) {      if ( compare( get( a[ i - 1 ] ) >>> 0, t ) )      a[ i ] = a[ -- i ];     else      break;     }     a[ i ] = p;    }    if ( ( depth & 1 ) == 1 ) {     for ( let i = start; i < start + len; i ++ )     b[ i ] = a[ i ];    }   };   const radixSortBlock = ( depth, start, len ) => {    const a = data[ depth & 1 ];   const b = data[ ( depth + 1 ) & 1 ];    const shift = ( 3 - depth ) << POWER;   const end = start + len;    const cache = bins[ depth ];   const bin = bins[ depth + 1 ];    bin.fill( 0 );    for ( let j = start; j < end; j ++ )    bin[ ( get( a[ j ] ) >>> shift ) & BIN_MAX ] ++;    accumulate( bin );    cache.set( bin );    for ( let j = end - 1; j >= start; j -- )    b[ start + -- bin[ ( get( a[ j ] ) >>> shift ) & BIN_MAX ] ] = a[ j ];    if ( depth == ITERATIONS - 1 ) return;    recurse( cache, depth, start );   };   radixSortBlock( 0, 0, len );  }; 
^..^ FILENAME ^..^
addons|utils|TextureUtils.js
^..^ CONTENTS ^..^
import {  PlaneGeometry,  ShaderMaterial,  Uniform,  Mesh,  PerspectiveCamera,  Scene,  WebGLRenderer,  CanvasTexture,  SRGBColorSpace } from 'three';  let _renderer; let fullscreenQuadGeometry; let fullscreenQuadMaterial; let fullscreenQuad;  export function decompress( texture, maxTextureSize = Infinity, renderer = null ) {   if ( ! fullscreenQuadGeometry ) fullscreenQuadGeometry = new PlaneGeometry( 2, 2, 1, 1 );  if ( ! fullscreenQuadMaterial ) fullscreenQuadMaterial = new ShaderMaterial( {   uniforms: { blitTexture: new Uniform( texture ) },   vertexShader: |    varying vec2 vUv;    void main(){     vUv = uv;     gl_Position = vec4(position.xy * 1.0,0.,.999999);    }|,   fragmentShader: |    uniform sampler2D blitTexture;     varying vec2 vUv;     void main(){      gl_FragColor = vec4(vUv.xy, 0, 1);          #ifdef IS_SRGB     gl_FragColor = sRGBTransferOETF( texture2D( blitTexture, vUv) );     #else     gl_FragColor = texture2D( blitTexture, vUv);     #endif    }|  } );   fullscreenQuadMaterial.uniforms.blitTexture.value = texture;  fullscreenQuadMaterial.defines.IS_SRGB = texture.colorSpace == SRGBColorSpace;  fullscreenQuadMaterial.needsUpdate = true;   if ( ! fullscreenQuad ) {    fullscreenQuad = new Mesh( fullscreenQuadGeometry, fullscreenQuadMaterial );   fullscreenQuad.frustumCulled = false;   }   const _camera = new PerspectiveCamera();  const _scene = new Scene();  _scene.add( fullscreenQuad );   if ( renderer === null ) {    renderer = _renderer = new WebGLRenderer( { antialias: false } );   }   const width = Math.min( texture.image.width, maxTextureSize );  const height = Math.min( texture.image.height, maxTextureSize );   renderer.setSize( width, height );  renderer.clear();  renderer.render( _scene, _camera );   const canvas = document.createElement( 'canvas' );  const context = canvas.getContext( '2d' );   canvas.width = width;  canvas.height = height;   context.drawImage( renderer.domElement, 0, 0, width, height );   const readableTexture = new CanvasTexture( canvas );   readableTexture.minFilter = texture.minFilter;  readableTexture.magFilter = texture.magFilter;  readableTexture.wrapS = texture.wrapS;  readableTexture.wrapT = texture.wrapT;  readableTexture.colorSpace = texture.colorSpace;  readableTexture.name = texture.name;   if ( _renderer ) {    _renderer.forceContextLoss();   _renderer.dispose();   _renderer = null;   }   return readableTexture;  } 
^..^ FILENAME ^..^
addons|utils|TextureUtilsGPU.js
^..^ CONTENTS ^..^
import {  QuadMesh,  NodeMaterial,  WebGPURenderer,  CanvasTexture } from 'three'; import { texture, uv } from 'three/tsl';  let _renderer; const _quadMesh = /*@__PURE__*/ new QuadMesh();  export async function decompress( blitTexture, maxTextureSize = Infinity, renderer = null ) {   if ( renderer === null ) {    renderer = _renderer = new WebGPURenderer();   await renderer.init();   }   const material = new NodeMaterial();  material.fragmentNode = texture( blitTexture ).uv( uv().flipY() );   const width = Math.min( blitTexture.image.width, maxTextureSize );  const height = Math.min( blitTexture.image.height, maxTextureSize );   const currentOutputColorSpace = renderer.outputColorSpace;   renderer.setSize( width, height );  renderer.outputColorSpace = blitTexture.colorSpace;   _quadMesh.material = material;  _quadMesh.render( renderer );   renderer.outputColorSpace = currentOutputColorSpace;   const canvas = document.createElement( 'canvas' );  const context = canvas.getContext( '2d' );   canvas.width = width;  canvas.height = height;   context.drawImage( renderer.domElement, 0, 0, width, height );   const readableTexture = new CanvasTexture( canvas );   readableTexture.minFilter = blitTexture.minFilter;  readableTexture.magFilter = blitTexture.magFilter;  readableTexture.wrapS = blitTexture.wrapS;  readableTexture.wrapT = blitTexture.wrapT;  readableTexture.colorSpace = blitTexture.colorSpace;  readableTexture.name = blitTexture.name;   if ( _renderer !== null ) {    _renderer.dispose();   _renderer = null;   }   return readableTexture;  } 
^..^ FILENAME ^..^
addons|utils|UVsDebug.js
^..^ CONTENTS ^..^
import {  Vector2 } from 'three';  /**  * tool for "unwrapping" and debugging three.js geometries UV mapping  *  * Sample usage:  * document.body.appendChild( UVsDebug( new THREE.SphereGeometry( 10, 10, 10, 10 ) );  *  */  function UVsDebug( geometry, size = 1024 ) {   // handles wrapping of uv.x > 1 only   const abc = 'abc';  const a = new Vector2();  const b = new Vector2();   const uvs = [   new Vector2(),   new Vector2(),   new Vector2()  ];   const face = [];   const canvas = document.createElement( 'canvas' );  const width = size; // power of 2 required for wrapping  const height = size;  canvas.width = width;  canvas.height = height;   const ctx = canvas.getContext( '2d' );  ctx.lineWidth = 1;  ctx.strokeStyle = 'rgb( 63, 63, 63 )';  ctx.textAlign = 'center';   // paint background white   ctx.fillStyle = 'rgb( 255, 255, 255 )';  ctx.fillRect( 0, 0, width, height );   const index = geometry.index;  const uvAttribute = geometry.attributes.uv;   if ( index ) {    // indexed geometry    for ( let i = 0, il = index.count; i < il; i += 3 ) {     face[ 0 ] = index.getX( i );    face[ 1 ] = index.getX( i + 1 );    face[ 2 ] = index.getX( i + 2 );     uvs[ 0 ].fromBufferAttribute( uvAttribute, face[ 0 ] );    uvs[ 1 ].fromBufferAttribute( uvAttribute, face[ 1 ] );    uvs[ 2 ].fromBufferAttribute( uvAttribute, face[ 2 ] );     processFace( face, uvs, i / 3 );    }   } else {    // non-indexed geometry    for ( let i = 0, il = uvAttribute.count; i < il; i += 3 ) {     face[ 0 ] = i;    face[ 1 ] = i + 1;    face[ 2 ] = i + 2;     uvs[ 0 ].fromBufferAttribute( uvAttribute, face[ 0 ] );    uvs[ 1 ].fromBufferAttribute( uvAttribute, face[ 1 ] );    uvs[ 2 ].fromBufferAttribute( uvAttribute, face[ 2 ] );     processFace( face, uvs, i / 3 );    }   }   return canvas;   function processFace( face, uvs, index ) {    // draw contour of face    ctx.beginPath();    a.set( 0, 0 );    for ( let j = 0, jl = uvs.length; j < jl; j ++ ) {     const uv = uvs[ j ];     a.x += uv.x;    a.y += uv.y;     if ( j === 0 ) {      ctx.moveTo( uv.x * ( width - 2 ) + 0.5, ( 1 - uv.y ) * ( height - 2 ) + 0.5 );     } else {      ctx.lineTo( uv.x * ( width - 2 ) + 0.5, ( 1 - uv.y ) * ( height - 2 ) + 0.5 );     }    }    ctx.closePath();   ctx.stroke();    // calculate center of face    a.divideScalar( uvs.length );    // label the face number    ctx.font = '18px Arial';   ctx.fillStyle = 'rgb( 63, 63, 63 )';   ctx.fillText( index, a.x * width, ( 1 - a.y ) * height );    if ( a.x > 0.95 ) {     // wrap x // 0.95 is arbitrary     ctx.fillText( index, ( a.x % 1 ) * width, ( 1 - a.y ) * height );    }    //    ctx.font = '12px Arial';   ctx.fillStyle = 'rgb( 191, 191, 191 )';    // label uv edge orders    for ( let j = 0, jl = uvs.length; j < jl; j ++ ) {     const uv = uvs[ j ];    b.addVectors( a, uv ).divideScalar( 2 );     const vnum = face[ j ];    ctx.fillText( abc[ j ] + vnum, b.x * width, ( 1 - b.y ) * height );     if ( b.x > 0.95 ) {      // wrap x      ctx.fillText( abc[ j ] + vnum, ( b.x % 1 ) * width, ( 1 - b.y ) * height );     }    }   }  }  export { UVsDebug }; 
^..^ FILENAME ^..^
addons|utils|WorkerPool.js
^..^ CONTENTS ^..^
/**  * @author Deepkolos / https://github.com/deepkolos  */  export class WorkerPool {   constructor( pool = 4 ) {    this.pool = pool;   this.queue = [];   this.workers = [];   this.workersResolve = [];   this.workerStatus = 0;   }   _initWorker( workerId ) {    if ( ! this.workers[ workerId ] ) {     const worker = this.workerCreator();    worker.addEventListener( 'message', this._onMessage.bind( this, workerId ) );    this.workers[ workerId ] = worker;    }   }   _getIdleWorker() {    for ( let i = 0; i < this.pool; i ++ )    if ( ! ( this.workerStatus & ( 1 << i ) ) ) return i;    return - 1;   }   _onMessage( workerId, msg ) {    const resolve = this.workersResolve[ workerId ];   resolve && resolve( msg );    if ( this.queue.length ) {     const { resolve, msg, transfer } = this.queue.shift();    this.workersResolve[ workerId ] = resolve;    this.workers[ workerId ].postMessage( msg, transfer );    } else {     this.workerStatus ^= 1 << workerId;    }   }   setWorkerCreator( workerCreator ) {    this.workerCreator = workerCreator;   }   setWorkerLimit( pool ) {    this.pool = pool;   }   postMessage( msg, transfer ) {    return new Promise( ( resolve ) => {     const workerId = this._getIdleWorker();     if ( workerId !== - 1 ) {      this._initWorker( workerId );     this.workerStatus |= 1 << workerId;     this.workersResolve[ workerId ] = resolve;     this.workers[ workerId ].postMessage( msg, transfer );     } else {      this.queue.push( { resolve, msg, transfer } );     }    } );   }   dispose() {    this.workers.forEach( ( worker ) => worker.terminate() );   this.workersResolve.length = 0;   this.workers.length = 0;   this.queue.length = 0;   this.workerStatus = 0;   }  } 
^..^ FILENAME ^..^
addons|webxr|ARButton.js
^..^ CONTENTS ^..^
class ARButton {   static createButton( renderer, sessionInit = {} ) {    const button = document.createElement( 'button' );    function showStartAR( /*device*/ ) {     if ( sessionInit.domOverlay === undefined ) {      const overlay = document.createElement( 'div' );     overlay.style.display = 'none';     document.body.appendChild( overlay );      const svg = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' );     svg.setAttribute( 'width', 38 );     svg.setAttribute( 'height', 38 );     svg.style.position = 'absolute';     svg.style.right = '20px';     svg.style.top = '20px';     svg.addEventListener( 'click', function () {       currentSession.end();      } );     overlay.appendChild( svg );      const path = document.createElementNS( 'http://www.w3.org/2000/svg', 'path' );     path.setAttribute( 'd', 'M 12,12 L 28,28 M 28,12 12,28' );     path.setAttribute( 'stroke', '#fff' );     path.setAttribute( 'stroke-width', 2 );     svg.appendChild( path );      if ( sessionInit.optionalFeatures === undefined ) {       sessionInit.optionalFeatures = [];      }      sessionInit.optionalFeatures.push( 'dom-overlay' );     sessionInit.domOverlay = { root: overlay };     }     //     let currentSession = null;     async function onSessionStarted( session ) {      session.addEventListener( 'end', onSessionEnded );      renderer.xr.setReferenceSpaceType( 'local' );      await renderer.xr.setSession( session );      button.textContent = 'STOP AR';     sessionInit.domOverlay.root.style.display = '';      currentSession = session;     }     function onSessionEnded( /*event*/ ) {      currentSession.removeEventListener( 'end', onSessionEnded );      button.textContent = 'START AR';     sessionInit.domOverlay.root.style.display = 'none';      currentSession = null;     }     //     button.style.display = '';     button.style.cursor = 'pointer';    button.style.left = 'calc(50% - 50px)';    button.style.width = '100px';     button.textContent = 'START AR';     button.onmouseenter = function () {      button.style.opacity = '1.0';     };     button.onmouseleave = function () {      button.style.opacity = '0.5';     };     button.onclick = function () {      if ( currentSession === null ) {       navigator.xr.requestSession( 'immersive-ar', sessionInit ).then( onSessionStarted );      } else {       currentSession.end();       if ( navigator.xr.offerSession !== undefined ) {        navigator.xr.offerSession( 'immersive-ar', sessionInit )        .then( onSessionStarted )        .catch( ( err ) => {          console.warn( err );         } );       }      }     };     if ( navigator.xr.offerSession !== undefined ) {      navigator.xr.offerSession( 'immersive-ar', sessionInit )      .then( onSessionStarted )      .catch( ( err ) => {        console.warn( err );       } );     }    }    function disableButton() {     button.style.display = '';     button.style.cursor = 'auto';    button.style.left = 'calc(50% - 75px)';    button.style.width = '150px';     button.onmouseenter = null;    button.onmouseleave = null;     button.onclick = null;    }    function showARNotSupported() {     disableButton();     button.textContent = 'AR NOT SUPPORTED';    }    function showARNotAllowed( exception ) {     disableButton();     console.warn( 'Exception when trying to call xr.isSessionSupported', exception );     button.textContent = 'AR NOT ALLOWED';    }    function stylizeElement( element ) {     element.style.position = 'absolute';    element.style.bottom = '20px';    element.style.padding = '12px 6px';    element.style.border = '1px solid #fff';    element.style.borderRadius = '4px';    element.style.background = 'rgba(0,0,0,0.1)';    element.style.color = '#fff';    element.style.font = 'normal 13px sans-serif';    element.style.textAlign = 'center';    element.style.opacity = '0.5';    element.style.outline = 'none';    element.style.zIndex = '999';    }    if ( 'xr' in navigator ) {     button.id = 'ARButton';    button.style.display = 'none';     stylizeElement( button );     navigator.xr.isSessionSupported( 'immersive-ar' ).then( function ( supported ) {      supported ? showStartAR() : showARNotSupported();     } ).catch( showARNotAllowed );     return button;    } else {     const message = document.createElement( 'a' );     if ( window.isSecureContext === false ) {      message.href = document.location.href.replace( /^http:/, 'https:' );     message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message     } else {      message.href = 'https://immersiveweb.dev/';     message.innerHTML = 'WEBXR NOT AVAILABLE';     }     message.style.left = 'calc(50% - 90px)';    message.style.width = '180px';    message.style.textDecoration = 'none';     stylizeElement( message );     return message;    }   }  }  export { ARButton }; 
^..^ FILENAME ^..^
addons|webxr|OculusHandModel.js
^..^ CONTENTS ^..^
import { Object3D, Sphere, Box3 } from 'three'; import { XRHandMeshModel } from './XRHandMeshModel.js';  const TOUCH_RADIUS = 0.01; const POINTING_JOINT = 'index-finger-tip';  class OculusHandModel extends Object3D {   constructor( controller, loader = null, onLoad = null ) {    super();    this.controller = controller;   this.motionController = null;   this.envMap = null;   this.loader = loader;   this.onLoad = onLoad;    this.mesh = null;    controller.addEventListener( 'connected', ( event ) => {     const xrInputSource = event.data;     if ( xrInputSource.hand && ! this.motionController ) {      this.xrInputSource = xrInputSource;      this.motionController = new XRHandMeshModel( this, controller, this.path, xrInputSource.handedness, this.loader, this.onLoad );     }    } );    controller.addEventListener( 'disconnected', () => {     this.clear();    this.motionController = null;    } );   }   updateMatrixWorld( force ) {    super.updateMatrixWorld( force );    if ( this.motionController ) {     this.motionController.updateMesh();    }   }   getPointerPosition() {    const indexFingerTip = this.controller.joints[ POINTING_JOINT ];   if ( indexFingerTip ) {     return indexFingerTip.position;    } else {     return null;    }   }   intersectBoxObject( boxObject ) {    const pointerPosition = this.getPointerPosition();   if ( pointerPosition ) {     const indexSphere = new Sphere( pointerPosition, TOUCH_RADIUS );    const box = new Box3().setFromObject( boxObject );    return indexSphere.intersectsBox( box );    } else {     return false;    }   }   checkButton( button ) {    if ( this.intersectBoxObject( button ) ) {     button.onPress();    } else {     button.onClear();    }    if ( button.isPressed() ) {     button.whilePressed();    }   }  }  export { OculusHandModel }; 
^..^ FILENAME ^..^
addons|webxr|OculusHandPointerModel.js
^..^ CONTENTS ^..^
import * as THREE from 'three';  const PINCH_MAX = 0.05; const PINCH_THRESHOLD = 0.02; const PINCH_MIN = 0.01; const POINTER_ADVANCE_MAX = 0.02; const POINTER_OPACITY_MAX = 1; const POINTER_OPACITY_MIN = 0.4; const POINTER_FRONT_RADIUS = 0.002; const POINTER_REAR_RADIUS = 0.01; const POINTER_REAR_RADIUS_MIN = 0.003; const POINTER_LENGTH = 0.035; const POINTER_SEGMENTS = 16; const POINTER_RINGS = 12; const POINTER_HEMISPHERE_ANGLE = 110; const YAXIS = /* @__PURE__ */ new THREE.Vector3( 0, 1, 0 ); const ZAXIS = /* @__PURE__ */ new THREE.Vector3( 0, 0, 1 );  const CURSOR_RADIUS = 0.02; const CURSOR_MAX_DISTANCE = 1.5;  class OculusHandPointerModel extends THREE.Object3D {   constructor( hand, controller ) {    super();    this.hand = hand;   this.controller = controller;    // Unused   this.motionController = null;   this.envMap = null;   this.mesh = null;    this.pointerGeometry = null;   this.pointerMesh = null;   this.pointerObject = null;    this.pinched = false;   this.attached = false;    this.cursorObject = null;    this.raycaster = null;    this._onConnected = this._onConnected.bind( this );   this._onDisconnected = this._onDisconnected.bind( this );   this.hand.addEventListener( 'connected', this._onConnected );   this.hand.addEventListener( 'disconnected', this._onDisconnected );   }   _onConnected( event ) {    const xrInputSource = event.data;   if ( xrInputSource.hand ) {     this.visible = true;    this.xrInputSource = xrInputSource;     this.createPointer();    }   }   _onDisconnected() {    this.visible = false;   this.xrInputSource = null;    if ( this.pointerGeometry ) this.pointerGeometry.dispose();   if ( this.pointerMesh && this.pointerMesh.material ) this.pointerMesh.material.dispose();    this.clear();   }   _drawVerticesRing( vertices, baseVector, ringIndex ) {    const segmentVector = baseVector.clone();   for ( let i = 0; i < POINTER_SEGMENTS; i ++ ) {     segmentVector.applyAxisAngle( ZAXIS, ( Math.PI * 2 ) / POINTER_SEGMENTS );    const vid = ringIndex * POINTER_SEGMENTS + i;    vertices[ 3 * vid ] = segmentVector.x;    vertices[ 3 * vid + 1 ] = segmentVector.y;    vertices[ 3 * vid + 2 ] = segmentVector.z;    }   }   _updatePointerVertices( rearRadius ) {    const vertices = this.pointerGeometry.attributes.position.array;   // first ring for front face   const frontFaceBase = new THREE.Vector3(    POINTER_FRONT_RADIUS,    0,    - 1 * ( POINTER_LENGTH - rearRadius )   );   this._drawVerticesRing( vertices, frontFaceBase, 0 );    // rings for rear hemisphere   const rearBase = new THREE.Vector3(    Math.sin( ( Math.PI * POINTER_HEMISPHERE_ANGLE ) / 180 ) * rearRadius,    Math.cos( ( Math.PI * POINTER_HEMISPHERE_ANGLE ) / 180 ) * rearRadius,    0   );   for ( let i = 0; i < POINTER_RINGS; i ++ ) {     this._drawVerticesRing( vertices, rearBase, i + 1 );    rearBase.applyAxisAngle(     YAXIS,     ( Math.PI * POINTER_HEMISPHERE_ANGLE ) / 180 / ( POINTER_RINGS * - 2 )    );    }    // front and rear face center vertices   const frontCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS );   const rearCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS ) + 1;   const frontCenter = new THREE.Vector3(    0,    0,    - 1 * ( POINTER_LENGTH - rearRadius )   );   vertices[ frontCenterIndex * 3 ] = frontCenter.x;   vertices[ frontCenterIndex * 3 + 1 ] = frontCenter.y;   vertices[ frontCenterIndex * 3 + 2 ] = frontCenter.z;   const rearCenter = new THREE.Vector3( 0, 0, rearRadius );   vertices[ rearCenterIndex * 3 ] = rearCenter.x;   vertices[ rearCenterIndex * 3 + 1 ] = rearCenter.y;   vertices[ rearCenterIndex * 3 + 2 ] = rearCenter.z;    this.pointerGeometry.setAttribute(    'position',    new THREE.Float32BufferAttribute( vertices, 3 )   );   // verticesNeedUpdate = true;   }   createPointer() {    let i, j;   const vertices = new Array(    ( ( POINTER_RINGS + 1 ) * POINTER_SEGMENTS + 2 ) * 3   ).fill( 0 );   // const vertices = [];   const indices = [];   this.pointerGeometry = new THREE.BufferGeometry();    this.pointerGeometry.setAttribute(    'position',    new THREE.Float32BufferAttribute( vertices, 3 )   );    this._updatePointerVertices( POINTER_REAR_RADIUS );    // construct faces to connect rings   for ( i = 0; i < POINTER_RINGS; i ++ ) {     for ( j = 0; j < POINTER_SEGMENTS - 1; j ++ ) {      indices.push(      i * POINTER_SEGMENTS + j,      i * POINTER_SEGMENTS + j + 1,      ( i + 1 ) * POINTER_SEGMENTS + j     );     indices.push(      i * POINTER_SEGMENTS + j + 1,      ( i + 1 ) * POINTER_SEGMENTS + j + 1,      ( i + 1 ) * POINTER_SEGMENTS + j     );     }     indices.push(     ( i + 1 ) * POINTER_SEGMENTS - 1,     i * POINTER_SEGMENTS,     ( i + 2 ) * POINTER_SEGMENTS - 1    );    indices.push(     i * POINTER_SEGMENTS,     ( i + 1 ) * POINTER_SEGMENTS,     ( i + 2 ) * POINTER_SEGMENTS - 1    );    }    // construct front and rear face   const frontCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS );   const rearCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS ) + 1;    for ( i = 0; i < POINTER_SEGMENTS - 1; i ++ ) {     indices.push( frontCenterIndex, i + 1, i );    indices.push(     rearCenterIndex,     i + POINTER_SEGMENTS * POINTER_RINGS,     i + POINTER_SEGMENTS * POINTER_RINGS + 1    );    }    indices.push( frontCenterIndex, 0, POINTER_SEGMENTS - 1 );   indices.push(    rearCenterIndex,    POINTER_SEGMENTS * ( POINTER_RINGS + 1 ) - 1,    POINTER_SEGMENTS * POINTER_RINGS   );    const material = new THREE.MeshBasicMaterial();   material.transparent = true;   material.opacity = POINTER_OPACITY_MIN;    this.pointerGeometry.setIndex( indices );    this.pointerMesh = new THREE.Mesh( this.pointerGeometry, material );    this.pointerMesh.position.set( 0, 0, - 1 * POINTER_REAR_RADIUS );   this.pointerObject = new THREE.Object3D();   this.pointerObject.add( this.pointerMesh );    this.raycaster = new THREE.Raycaster();    // create cursor   const cursorGeometry = new THREE.SphereGeometry( CURSOR_RADIUS, 10, 10 );   const cursorMaterial = new THREE.MeshBasicMaterial();   cursorMaterial.transparent = true;   cursorMaterial.opacity = POINTER_OPACITY_MIN;    this.cursorObject = new THREE.Mesh( cursorGeometry, cursorMaterial );   this.pointerObject.add( this.cursorObject );    this.add( this.pointerObject );   }   _updateRaycaster() {    if ( this.raycaster ) {     const pointerMatrix = this.pointerObject.matrixWorld;    const tempMatrix = new THREE.Matrix4();    tempMatrix.identity().extractRotation( pointerMatrix );    this.raycaster.ray.origin.setFromMatrixPosition( pointerMatrix );    this.raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );    }   }   _updatePointer() {    this.pointerObject.visible = this.controller.visible;   const indexTip = this.hand.joints[ 'index-finger-tip' ];   const thumbTip = this.hand.joints[ 'thumb-tip' ];   const distance = indexTip.position.distanceTo( thumbTip.position );   const position = indexTip.position    .clone()    .add( thumbTip.position )    .multiplyScalar( 0.5 );   this.pointerObject.position.copy( position );   this.pointerObject.quaternion.copy( this.controller.quaternion );    this.pinched = distance <= PINCH_THRESHOLD;    const pinchScale = ( distance - PINCH_MIN ) / ( PINCH_MAX - PINCH_MIN );   const focusScale = ( distance - PINCH_MIN ) / ( PINCH_THRESHOLD - PINCH_MIN );   if ( pinchScale > 1 ) {     this._updatePointerVertices( POINTER_REAR_RADIUS );    this.pointerMesh.position.set( 0, 0, - 1 * POINTER_REAR_RADIUS );    this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;    } else if ( pinchScale > 0 ) {     const rearRadius =         ( POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN ) * pinchScale +         POINTER_REAR_RADIUS_MIN;    this._updatePointerVertices( rearRadius );    if ( focusScale < 1 ) {      this.pointerMesh.position.set(      0,      0,      - 1 * rearRadius - ( 1 - focusScale ) * POINTER_ADVANCE_MAX     );     this.pointerMesh.material.opacity =           POINTER_OPACITY_MIN +           ( 1 - focusScale ) * ( POINTER_OPACITY_MAX - POINTER_OPACITY_MIN );     } else {      this.pointerMesh.position.set( 0, 0, - 1 * rearRadius );     this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;     }    } else {     this._updatePointerVertices( POINTER_REAR_RADIUS_MIN );    this.pointerMesh.position.set(     0,     0,     - 1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX    );    this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;    }    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;   }   updateMatrixWorld( force ) {    super.updateMatrixWorld( force );   if ( this.pointerGeometry ) {     this._updatePointer();    this._updateRaycaster();    }   }   isPinched() {    return this.pinched;   }   setAttached( attached ) {    this.attached = attached;   }   isAttached() {    return this.attached;   }   intersectObject( object, recursive = true ) {    if ( this.raycaster ) {     return this.raycaster.intersectObject( object, recursive );    }   }   intersectObjects( objects, recursive = true ) {    if ( this.raycaster ) {     return this.raycaster.intersectObjects( objects, recursive );    }   }   checkIntersections( objects, recursive = false ) {    if ( this.raycaster && ! this.attached ) {     const intersections = this.raycaster.intersectObjects( objects, recursive );    const direction = new THREE.Vector3( 0, 0, - 1 );    if ( intersections.length > 0 ) {      const intersection = intersections[ 0 ];     const distance = intersection.distance;     this.cursorObject.position.copy( direction.multiplyScalar( distance ) );     } else {      this.cursorObject.position.copy( direction.multiplyScalar( CURSOR_MAX_DISTANCE ) );     }    }   }   setCursor( distance ) {    const direction = new THREE.Vector3( 0, 0, - 1 );   if ( this.raycaster && ! this.attached ) {     this.cursorObject.position.copy( direction.multiplyScalar( distance ) );    }   }   dispose() {    this._onDisconnected();   this.hand.removeEventListener( 'connected', this._onConnected );   this.hand.removeEventListener( 'disconnected', this._onDisconnected );   }  }  export { OculusHandPointerModel }; 
^..^ FILENAME ^..^
addons|webxr|Text2D.js
^..^ CONTENTS ^..^
import * as THREE from 'three';  function createText( message, height ) {   const canvas = document.createElement( 'canvas' );  const context = canvas.getContext( '2d' );  let metrics = null;  const textHeight = 100;  context.font = 'normal ' + textHeight + 'px Arial';  metrics = context.measureText( message );  const textWidth = metrics.width;  canvas.width = textWidth;  canvas.height = textHeight;  context.font = 'normal ' + textHeight + 'px Arial';  context.textAlign = 'center';  context.textBaseline = 'middle';  context.fillStyle = '#ffffff';  context.fillText( message, textWidth / 2, textHeight / 2 );   const texture = new THREE.Texture( canvas );  texture.needsUpdate = true;   const material = new THREE.MeshBasicMaterial( {   color: 0xffffff,   side: THREE.DoubleSide,   map: texture,   transparent: true,  } );  const geometry = new THREE.PlaneGeometry(   ( height * textWidth ) / textHeight,   height  );  const plane = new THREE.Mesh( geometry, material );  return plane;  }  export { createText }; 
^..^ FILENAME ^..^
addons|webxr|VRButton.js
^..^ CONTENTS ^..^
class VRButton {   static createButton( renderer, sessionInit = {} ) {    const button = document.createElement( 'button' );    function showEnterVR( /*device*/ ) {     let currentSession = null;     async function onSessionStarted( session ) {      session.addEventListener( 'end', onSessionEnded );      await renderer.xr.setSession( session );     button.textContent = 'EXIT VR';      currentSession = session;     }     function onSessionEnded( /*event*/ ) {      currentSession.removeEventListener( 'end', onSessionEnded );      button.textContent = 'ENTER VR';      currentSession = null;     }     //     button.style.display = '';     button.style.cursor = 'pointer';    button.style.left = 'calc(50% - 50px)';    button.style.width = '100px';     button.textContent = 'ENTER VR';     // WebXR's requestReferenceSpace only works if the corresponding feature    // was requested at session creation time. For simplicity, just ask for    // the interesting ones as optional features, but be aware that the    // requestReferenceSpace call will fail if it turns out to be unavailable.    // ('local' is always available for immersive sessions and doesn't need to    // be requested separately.)     const sessionOptions = {     ...sessionInit,     optionalFeatures: [      'local-floor',      'bounded-floor',      'layers',      ...( sessionInit.optionalFeatures || [] )     ],    };     button.onmouseenter = function () {      button.style.opacity = '1.0';     };     button.onmouseleave = function () {      button.style.opacity = '0.5';     };     button.onclick = function () {      if ( currentSession === null ) {       navigator.xr.requestSession( 'immersive-vr', sessionOptions ).then( onSessionStarted );      } else {       currentSession.end();       if ( navigator.xr.offerSession !== undefined ) {        navigator.xr.offerSession( 'immersive-vr', sessionOptions )        .then( onSessionStarted )        .catch( ( err ) => {          console.warn( err );         } );       }      }     };     if ( navigator.xr.offerSession !== undefined ) {      navigator.xr.offerSession( 'immersive-vr', sessionOptions )      .then( onSessionStarted )      .catch( ( err ) => {        console.warn( err );       } );     }    }    function disableButton() {     button.style.display = '';     button.style.cursor = 'auto';    button.style.left = 'calc(50% - 75px)';    button.style.width = '150px';     button.onmouseenter = null;    button.onmouseleave = null;     button.onclick = null;    }    function showWebXRNotFound() {     disableButton();     button.textContent = 'VR NOT SUPPORTED';    }    function showVRNotAllowed( exception ) {     disableButton();     console.warn( 'Exception when trying to call xr.isSessionSupported', exception );     button.textContent = 'VR NOT ALLOWED';    }    function stylizeElement( element ) {     element.style.position = 'absolute';    element.style.bottom = '20px';    element.style.padding = '12px 6px';    element.style.border = '1px solid #fff';    element.style.borderRadius = '4px';    element.style.background = 'rgba(0,0,0,0.1)';    element.style.color = '#fff';    element.style.font = 'normal 13px sans-serif';    element.style.textAlign = 'center';    element.style.opacity = '0.5';    element.style.outline = 'none';    element.style.zIndex = '999';    }    if ( 'xr' in navigator ) {     button.id = 'VRButton';    button.style.display = 'none';     stylizeElement( button );     navigator.xr.isSessionSupported( 'immersive-vr' ).then( function ( supported ) {      supported ? showEnterVR() : showWebXRNotFound();      if ( supported && VRButton.xrSessionIsGranted ) {       button.click();      }     } ).catch( showVRNotAllowed );     return button;    } else {     const message = document.createElement( 'a' );     if ( window.isSecureContext === false ) {      message.href = document.location.href.replace( /^http:/, 'https:' );     message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message     } else {      message.href = 'https://immersiveweb.dev/';     message.innerHTML = 'WEBXR NOT AVAILABLE';     }     message.style.left = 'calc(50% - 90px)';    message.style.width = '180px';    message.style.textDecoration = 'none';     stylizeElement( message );     return message;    }   }   static registerSessionGrantedListener() {    if ( typeof navigator !== 'undefined' && 'xr' in navigator ) {     // WebXRViewer (based on Firefox) has a bug where addEventListener    // throws a silent exception and aborts execution entirely.    if ( /WebXRViewer|//i.test( navigator.userAgent ) ) return;     navigator.xr.addEventListener( 'sessiongranted', () => {      VRButton.xrSessionIsGranted = true;     } );    }   }  }  VRButton.xrSessionIsGranted = false; VRButton.registerSessionGrantedListener();  export { VRButton }; 
^..^ FILENAME ^..^
addons|webxr|XRButton.js
^..^ CONTENTS ^..^
class XRButton {   static createButton( renderer, sessionInit = {} ) {    const button = document.createElement( 'button' );    function showStartXR( mode ) {     let currentSession = null;     async function onSessionStarted( session ) {      session.addEventListener( 'end', onSessionEnded );      await renderer.xr.setSession( session );      button.textContent = 'STOP XR';      currentSession = session;     }     function onSessionEnded( /*event*/ ) {      currentSession.removeEventListener( 'end', onSessionEnded );      button.textContent = 'START XR';      currentSession = null;     }     //     button.style.display = '';     button.style.cursor = 'pointer';    button.style.left = 'calc(50% - 50px)';    button.style.width = '100px';     button.textContent = 'START XR';     const sessionOptions = {     ...sessionInit,     optionalFeatures: [      'local-floor',      'bounded-floor',      'layers',      ...( sessionInit.optionalFeatures || [] )     ],    };     button.onmouseenter = function () {      button.style.opacity = '1.0';     };     button.onmouseleave = function () {      button.style.opacity = '0.5';     };     button.onclick = function () {      if ( currentSession === null ) {       navigator.xr.requestSession( mode, sessionOptions )       .then( onSessionStarted );      } else {       currentSession.end();       if ( navigator.xr.offerSession !== undefined ) {        navigator.xr.offerSession( mode, sessionOptions )        .then( onSessionStarted )        .catch( ( err ) => {          console.warn( err );         } );       }      }     };     if ( navigator.xr.offerSession !== undefined ) {      navigator.xr.offerSession( mode, sessionOptions )      .then( onSessionStarted )      .catch( ( err ) => {        console.warn( err );       } );     }    }    function disableButton() {     button.style.display = '';     button.style.cursor = 'auto';    button.style.left = 'calc(50% - 75px)';    button.style.width = '150px';     button.onmouseenter = null;    button.onmouseleave = null;     button.onclick = null;    }    function showXRNotSupported() {     disableButton();     button.textContent = 'XR NOT SUPPORTED';    }    function showXRNotAllowed( exception ) {     disableButton();     console.warn( 'Exception when trying to call xr.isSessionSupported', exception );     button.textContent = 'XR NOT ALLOWED';    }    function stylizeElement( element ) {     element.style.position = 'absolute';    element.style.bottom = '20px';    element.style.padding = '12px 6px';    element.style.border = '1px solid #fff';    element.style.borderRadius = '4px';    element.style.background = 'rgba(0,0,0,0.1)';    element.style.color = '#fff';    element.style.font = 'normal 13px sans-serif';    element.style.textAlign = 'center';    element.style.opacity = '0.5';    element.style.outline = 'none';    element.style.zIndex = '999';    }    if ( 'xr' in navigator ) {     button.id = 'XRButton';    button.style.display = 'none';     stylizeElement( button );     navigator.xr.isSessionSupported( 'immersive-ar' )     .then( function ( supported ) {       if ( supported ) {        showStartXR( 'immersive-ar' );       } else {        navigator.xr.isSessionSupported( 'immersive-vr' )        .then( function ( supported ) {          if ( supported ) {           showStartXR( 'immersive-vr' );          } else {           showXRNotSupported();          }         } ).catch( showXRNotAllowed );       }      } ).catch( showXRNotAllowed );     return button;    } else {     const message = document.createElement( 'a' );     if ( window.isSecureContext === false ) {      message.href = document.location.href.replace( /^http:/, 'https:' );     message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message     } else {      message.href = 'https://immersiveweb.dev/';     message.innerHTML = 'WEBXR NOT AVAILABLE';     }     message.style.left = 'calc(50% - 90px)';    message.style.width = '180px';    message.style.textDecoration = 'none';     stylizeElement( message );     return message;    }   }  }  export { XRButton }; 
^..^ FILENAME ^..^
addons|webxr|XRControllerModelFactory.js
^..^ CONTENTS ^..^
import {  Mesh,  MeshBasicMaterial,  Object3D,  SphereGeometry, } from 'three';  import { GLTFLoader } from '../loaders/GLTFLoader.js';  import {  Constants as MotionControllerConstants,  fetchProfile,  MotionController } from '../libs/motion-controllers.module.js';  const DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles'; const DEFAULT_PROFILE = 'generic-trigger';  class XRControllerModel extends Object3D {   constructor() {    super();    this.motionController = null;   this.envMap = null;   }   setEnvironmentMap( envMap ) {    if ( this.envMap == envMap ) {     return this;    }    this.envMap = envMap;   this.traverse( ( child ) => {     if ( child.isMesh ) {      child.material.envMap = this.envMap;     child.material.needsUpdate = true;     }    } );    return this;   }   /**   * Polls data from the XRInputSource and updates the model's components to match   * the real world data   */  updateMatrixWorld( force ) {    super.updateMatrixWorld( force );    if ( ! this.motionController ) return;    // Cause the MotionController to poll the Gamepad for data   this.motionController.updateFromGamepad();    // Update the 3D model to reflect the button, thumbstick, and touchpad state   Object.values( this.motionController.components ).forEach( ( component ) => {     // Update node data based on the visual responses' current states    Object.values( component.visualResponses ).forEach( ( visualResponse ) => {      const { valueNode, minNode, maxNode, value, valueNodeProperty } = visualResponse;      // Skip if the visual response node is not found. No error is needed,     // because it will have been reported at load time.     if ( ! valueNode ) return;      // Calculate the new properties based on the weight supplied     if ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY ) {       valueNode.visible = value;      } else if ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM ) {       valueNode.quaternion.slerpQuaternions(       minNode.quaternion,       maxNode.quaternion,       value      );       valueNode.position.lerpVectors(       minNode.position,       maxNode.position,       value      );      }     } );    } );   }  }  /**  * Walks the model's tree to find the nodes needed to animate the components and  * saves them to the motionContoller components for use in the frame loop. When  * touchpads are found, attaches a touch dot to them.  */ function findNodes( motionController, scene ) {   // Loop through the components and find the nodes needed for each components' visual responses  Object.values( motionController.components ).forEach( ( component ) => {    const { type, touchPointNodeName, visualResponses } = component;    if ( type === MotionControllerConstants.ComponentType.TOUCHPAD ) {     component.touchPointNode = scene.getObjectByName( touchPointNodeName );    if ( component.touchPointNode ) {      // Attach a touch dot to the touchpad.     const sphereGeometry = new SphereGeometry( 0.001 );     const material = new MeshBasicMaterial( { color: 0x0000FF } );     const sphere = new Mesh( sphereGeometry, material );     component.touchPointNode.add( sphere );     } else {      console.warn( |Could not find touch dot, |component.touchPointNodeName}, in touchpad component |component.id}| );     }    }    // Loop through all the visual responses to be applied to this component   Object.values( visualResponses ).forEach( ( visualResponse ) => {     const { valueNodeName, minNodeName, maxNodeName, valueNodeProperty } = visualResponse;     // If animating a transform, find the two nodes to be interpolated between.    if ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM ) {      visualResponse.minNode = scene.getObjectByName( minNodeName );     visualResponse.maxNode = scene.getObjectByName( maxNodeName );      // If the extents cannot be found, skip this animation     if ( ! visualResponse.minNode ) {       console.warn( |Could not find |minNodeName} in the model| );      return;      }      if ( ! visualResponse.maxNode ) {       console.warn( |Could not find |maxNodeName} in the model| );      return;      }     }     // If the target node cannot be found, skip this animation    visualResponse.valueNode = scene.getObjectByName( valueNodeName );    if ( ! visualResponse.valueNode ) {      console.warn( |Could not find |valueNodeName} in the model| );     }    } );   } );  }  function addAssetSceneToControllerModel( controllerModel, scene ) {   // Find the nodes needed for animation and cache them on the motionController.  findNodes( controllerModel.motionController, scene );   // Apply any environment map that the mesh already has set.  if ( controllerModel.envMap ) {    scene.traverse( ( child ) => {     if ( child.isMesh ) {      child.material.envMap = controllerModel.envMap;     child.material.needsUpdate = true;     }    } );   }   // Add the glTF scene to the controllerModel.  controllerModel.add( scene );  }  class XRControllerModelFactory {   constructor( gltfLoader = null, onLoad = null ) {    this.gltfLoader = gltfLoader;   this.path = DEFAULT_PROFILES_PATH;   this._assetCache = {};   this.onLoad = onLoad;    // If a GLTFLoader wasn't supplied to the constructor create a new one.   if ( ! this.gltfLoader ) {     this.gltfLoader = new GLTFLoader();    }   }   setPath( path ) {    this.path = path;    return this;   }   createControllerModel( controller ) {    const controllerModel = new XRControllerModel();   let scene = null;    controller.addEventListener( 'connected', ( event ) => {     const xrInputSource = event.data;     if ( xrInputSource.targetRayMode !== 'tracked-pointer' || ! xrInputSource.gamepad || xrInputSource.hand ) return;     fetchProfile( xrInputSource, this.path, DEFAULT_PROFILE ).then( ( { profile, assetPath } ) => {      controllerModel.motionController = new MotionController(      xrInputSource,      profile,      assetPath     );      const cachedAsset = this._assetCache[ controllerModel.motionController.assetUrl ];     if ( cachedAsset ) {       scene = cachedAsset.scene.clone();       addAssetSceneToControllerModel( controllerModel, scene );       if ( this.onLoad ) this.onLoad( scene );      } else {       if ( ! this.gltfLoader ) {        throw new Error( 'GLTFLoader not set.' );       }       this.gltfLoader.setPath( '' );      this.gltfLoader.load( controllerModel.motionController.assetUrl, ( asset ) => {        this._assetCache[ controllerModel.motionController.assetUrl ] = asset;        scene = asset.scene.clone();        addAssetSceneToControllerModel( controllerModel, scene );        if ( this.onLoad ) this.onLoad( scene );       },      null,      () => {        throw new Error( |Asset |controllerModel.motionController.assetUrl} missing or malformed.| );       } );      }     } ).catch( ( err ) => {      console.warn( err );     } );    } );    controller.addEventListener( 'disconnected', () => {     controllerModel.motionController = null;    controllerModel.remove( scene );    scene = null;    } );    return controllerModel;   }  }  export { XRControllerModelFactory }; 
^..^ FILENAME ^..^
addons|webxr|XREstimatedLight.js
^..^ CONTENTS ^..^
import {  DirectionalLight,  Group,  LightProbe,  WebGLCubeRenderTarget } from 'three';  class SessionLightProbe {   constructor( xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback ) {    this.xrLight = xrLight;   this.renderer = renderer;   this.lightProbe = lightProbe;   this.xrWebGLBinding = null;   this.estimationStartCallback = estimationStartCallback;   this.frameCallback = this.onXRFrame.bind( this );    const session = renderer.xr.getSession();    // If the XRWebGLBinding class is available then we can also query an   // estimated reflection cube map.   if ( environmentEstimation && 'XRWebGLBinding' in window ) {     // This is the simplest way I know of to initialize a WebGL cubemap in Three.    const cubeRenderTarget = new WebGLCubeRenderTarget( 16 );    xrLight.environment = cubeRenderTarget.texture;     const gl = renderer.getContext();     // Ensure that we have any extensions needed to use the preferred cube map format.    switch ( session.preferredReflectionFormat ) {      case 'srgba8':      gl.getExtension( 'EXT_sRGB' );      break;      case 'rgba16f':      gl.getExtension( 'OES_texture_half_float' );      break;     }     this.xrWebGLBinding = new XRWebGLBinding( session, gl );     this.lightProbe.addEventListener( 'reflectionchange', () => {      this.updateReflection();     } );    }    // Start monitoring the XR animation frame loop to look for lighting   // estimation changes.   session.requestAnimationFrame( this.frameCallback );   }   updateReflection() {    const textureProperties = this.renderer.properties.get( this.xrLight.environment );    if ( textureProperties ) {     const cubeMap = this.xrWebGLBinding.getReflectionCubeMap( this.lightProbe );     if ( cubeMap ) {      textureProperties.__webglTexture = cubeMap;      this.xrLight.environment.needsPMREMUpdate = true;     }    }   }   onXRFrame( time, xrFrame ) {    // If either this obejct or the XREstimatedLight has been destroyed, stop   // running the frame loop.   if ( ! this.xrLight ) {     return;    }    const session = xrFrame.session;   session.requestAnimationFrame( this.frameCallback );    const lightEstimate = xrFrame.getLightEstimate( this.lightProbe );   if ( lightEstimate ) {     // We can copy the estimate's spherical harmonics array directly into the light probe.    this.xrLight.lightProbe.sh.fromArray( lightEstimate.sphericalHarmonicsCoefficients );    this.xrLight.lightProbe.intensity = 1.0;     // For the directional light we have to normalize the color and set the scalar as the    // intensity, since WebXR can return color values that exceed 1.0.    const intensityScalar = Math.max( 1.0,     Math.max( lightEstimate.primaryLightIntensity.x,      Math.max( lightEstimate.primaryLightIntensity.y,       lightEstimate.primaryLightIntensity.z ) ) );     this.xrLight.directionalLight.color.setRGB(     lightEstimate.primaryLightIntensity.x / intensityScalar,     lightEstimate.primaryLightIntensity.y / intensityScalar,     lightEstimate.primaryLightIntensity.z / intensityScalar );    this.xrLight.directionalLight.intensity = intensityScalar;    this.xrLight.directionalLight.position.copy( lightEstimate.primaryLightDirection );     if ( this.estimationStartCallback ) {      this.estimationStartCallback();     this.estimationStartCallback = null;     }    }   }   dispose() {    this.xrLight = null;   this.renderer = null;   this.lightProbe = null;   this.xrWebGLBinding = null;   }  }  export class XREstimatedLight extends Group {   constructor( renderer, environmentEstimation = true ) {    super();    this.lightProbe = new LightProbe();   this.lightProbe.intensity = 0;   this.add( this.lightProbe );    this.directionalLight = new DirectionalLight();   this.directionalLight.intensity = 0;   this.add( this.directionalLight );    // Will be set to a cube map in the SessionLightProbe if environment estimation is   // available and requested.   this.environment = null;    let sessionLightProbe = null;   let estimationStarted = false;   renderer.xr.addEventListener( 'sessionstart', () => {     const session = renderer.xr.getSession();     if ( 'requestLightProbe' in session ) {      session.requestLightProbe( {       reflectionFormat: session.preferredReflectionFormat      } ).then( ( probe ) => {       sessionLightProbe = new SessionLightProbe( this, renderer, probe, environmentEstimation, () => {        estimationStarted = true;        // Fired to indicate that the estimated lighting values are now being updated.       this.dispatchEvent( { type: 'estimationstart' } );       } );      } );     }    } );    renderer.xr.addEventListener( 'sessionend', () => {     if ( sessionLightProbe ) {      sessionLightProbe.dispose();     sessionLightProbe = null;     }     if ( estimationStarted ) {      // Fired to indicate that the estimated lighting values are no longer being updated.     this.dispatchEvent( { type: 'estimationend' } );     }    } );    // Done inline to provide access to sessionLightProbe.   this.dispose = () => {     if ( sessionLightProbe ) {      sessionLightProbe.dispose();     sessionLightProbe = null;     }     this.remove( this.lightProbe );    this.lightProbe = null;     this.remove( this.directionalLight );    this.directionalLight = null;     this.environment = null;    };   }  } 
^..^ FILENAME ^..^
addons|webxr|XRHandMeshModel.js
^..^ CONTENTS ^..^
import { GLTFLoader } from '../loaders/GLTFLoader.js';  const DEFAULT_HAND_PROFILE_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/';  class XRHandMeshModel {   constructor( handModel, controller, path, handedness, loader = null, onLoad = null ) {    this.controller = controller;   this.handModel = handModel;    this.bones = [];    if ( loader === null ) {     loader = new GLTFLoader();    loader.setPath( path || DEFAULT_HAND_PROFILE_PATH );    }    loader.load( ||handedness}.glb|, gltf => {     const object = gltf.scene.children[ 0 ];    this.handModel.add( object );     const mesh = object.getObjectByProperty( 'type', 'SkinnedMesh' );    mesh.frustumCulled = false;    mesh.castShadow = true;    mesh.receiveShadow = true;     const joints = [     'wrist',     'thumb-metacarpal',     'thumb-phalanx-proximal',     'thumb-phalanx-distal',     'thumb-tip',     'index-finger-metacarpal',     'index-finger-phalanx-proximal',     'index-finger-phalanx-intermediate',     'index-finger-phalanx-distal',     'index-finger-tip',     'middle-finger-metacarpal',     'middle-finger-phalanx-proximal',     'middle-finger-phalanx-intermediate',     'middle-finger-phalanx-distal',     'middle-finger-tip',     'ring-finger-metacarpal',     'ring-finger-phalanx-proximal',     'ring-finger-phalanx-intermediate',     'ring-finger-phalanx-distal',     'ring-finger-tip',     'pinky-finger-metacarpal',     'pinky-finger-phalanx-proximal',     'pinky-finger-phalanx-intermediate',     'pinky-finger-phalanx-distal',     'pinky-finger-tip',    ];     joints.forEach( jointName => {      const bone = object.getObjectByName( jointName );      if ( bone !== undefined ) {       bone.jointName = jointName;      } else {       console.warn( |Couldn't find |jointName} in |handedness} hand mesh| );      }      this.bones.push( bone );     } );     if ( onLoad ) onLoad( object );    } );   }   updateMesh() {    // XR Joints   const XRJoints = this.controller.joints;    for ( let i = 0; i < this.bones.length; i ++ ) {     const bone = this.bones[ i ];     if ( bone ) {      const XRJoint = XRJoints[ bone.jointName ];      if ( XRJoint.visible ) {       const position = XRJoint.position;       bone.position.copy( position );      bone.quaternion.copy( XRJoint.quaternion );      // bone.scale.setScalar( XRJoint.jointRadius || defaultRadius );      }     }    }   }  }  export { XRHandMeshModel }; 
^..^ FILENAME ^..^
addons|webxr|XRHandModelFactory.js
^..^ CONTENTS ^..^
import {  Object3D } from 'three';  import {  XRHandPrimitiveModel } from './XRHandPrimitiveModel.js';  import {  XRHandMeshModel } from './XRHandMeshModel.js';  class XRHandModel extends Object3D {   constructor( controller ) {    super();    this.controller = controller;   this.motionController = null;   this.envMap = null;    this.mesh = null;   }   updateMatrixWorld( force ) {    super.updateMatrixWorld( force );    if ( this.motionController ) {     this.motionController.updateMesh();    }   }  }  class XRHandModelFactory {   constructor( gltfLoader = null, onLoad = null ) {    this.gltfLoader = gltfLoader;   this.path = null;   this.onLoad = onLoad;   }   setPath( path ) {    this.path = path;    return this;   }   createHandModel( controller, profile ) {    const handModel = new XRHandModel( controller );    controller.addEventListener( 'connected', ( event ) => {     const xrInputSource = event.data;     if ( xrInputSource.hand && ! handModel.motionController ) {      handModel.xrInputSource = xrInputSource;      // @todo Detect profile if not provided     if ( profile === undefined || profile === 'spheres' ) {       handModel.motionController = new XRHandPrimitiveModel( handModel, controller, this.path, xrInputSource.handedness, { primitive: 'sphere' } );      } else if ( profile === 'boxes' ) {       handModel.motionController = new XRHandPrimitiveModel( handModel, controller, this.path, xrInputSource.handedness, { primitive: 'box' } );      } else if ( profile === 'mesh' ) {       handModel.motionController = new XRHandMeshModel( handModel, controller, this.path, xrInputSource.handedness, this.gltfLoader, this.onLoad );      }     }     controller.visible = true;    } );    controller.addEventListener( 'disconnected', () => {     controller.visible = false;    // handModel.motionController = null;    // handModel.remove( scene );    // scene = null;    } );    return handModel;   }  }  export { XRHandModelFactory }; 
^..^ FILENAME ^..^
addons|webxr|XRHandPrimitiveModel.js
^..^ CONTENTS ^..^
import {  DynamicDrawUsage,  SphereGeometry,  BoxGeometry,  MeshStandardMaterial,  InstancedMesh,  Matrix4,  Vector3 } from 'three';  const _matrix = new Matrix4(); const _vector = new Vector3();  class XRHandPrimitiveModel {   constructor( handModel, controller, path, handedness, options ) {    this.controller = controller;   this.handModel = handModel;   this.envMap = null;    let geometry;    if ( ! options || ! options.primitive || options.primitive === 'sphere' ) {     geometry = new SphereGeometry( 1, 10, 10 );    } else if ( options.primitive === 'box' ) {     geometry = new BoxGeometry( 1, 1, 1 );    }    const material = new MeshStandardMaterial();    this.handMesh = new InstancedMesh( geometry, material, 30 );   this.handMesh.frustumCulled = false;   this.handMesh.instanceMatrix.setUsage( DynamicDrawUsage ); // will be updated every frame   this.handMesh.castShadow = true;   this.handMesh.receiveShadow = true;   this.handModel.add( this.handMesh );    this.joints = [    'wrist',    'thumb-metacarpal',    'thumb-phalanx-proximal',    'thumb-phalanx-distal',    'thumb-tip',    'index-finger-metacarpal',    'index-finger-phalanx-proximal',    'index-finger-phalanx-intermediate',    'index-finger-phalanx-distal',    'index-finger-tip',    'middle-finger-metacarpal',    'middle-finger-phalanx-proximal',    'middle-finger-phalanx-intermediate',    'middle-finger-phalanx-distal',    'middle-finger-tip',    'ring-finger-metacarpal',    'ring-finger-phalanx-proximal',    'ring-finger-phalanx-intermediate',    'ring-finger-phalanx-distal',    'ring-finger-tip',    'pinky-finger-metacarpal',    'pinky-finger-phalanx-proximal',    'pinky-finger-phalanx-intermediate',    'pinky-finger-phalanx-distal',    'pinky-finger-tip'   ];   }   updateMesh() {    const defaultRadius = 0.008;   const joints = this.controller.joints;    let count = 0;    for ( let i = 0; i < this.joints.length; i ++ ) {     const joint = joints[ this.joints[ i ] ];     if ( joint.visible ) {      _vector.setScalar( joint.jointRadius || defaultRadius );     _matrix.compose( joint.position, joint.quaternion, _vector );     this.handMesh.setMatrixAt( i, _matrix );      count ++;     }    }    this.handMesh.count = count;   this.handMesh.instanceMatrix.needsUpdate = true;   }  }  export { XRHandPrimitiveModel }; 
^..^ FILENAME ^..^
addons|webxr|XRPlanes.js
^..^ CONTENTS ^..^
import {  BoxGeometry,  Matrix4,  Mesh,  MeshBasicMaterial,  Object3D } from 'three';  class XRPlanes extends Object3D {   constructor( renderer ) {    super();    const matrix = new Matrix4();    const currentPlanes = new Map();    const xr = renderer.xr;    xr.addEventListener( 'planesdetected', event => {     const frame = event.data;    const planes = frame.detectedPlanes;     const referenceSpace = xr.getReferenceSpace();     let planeschanged = false;     for ( const [ plane, mesh ] of currentPlanes ) {      if ( planes.has( plane ) === false ) {       mesh.geometry.dispose();      mesh.material.dispose();      this.remove( mesh );       currentPlanes.delete( plane );       planeschanged = true;      }     }     for ( const plane of planes ) {      if ( currentPlanes.has( plane ) === false ) {       const pose = frame.getPose( plane.planeSpace, referenceSpace );      matrix.fromArray( pose.transform.matrix );       const polygon = plane.polygon;       let minX = Number.MAX_SAFE_INTEGER;      let maxX = Number.MIN_SAFE_INTEGER;      let minZ = Number.MAX_SAFE_INTEGER;      let maxZ = Number.MIN_SAFE_INTEGER;       for ( const point of polygon ) {        minX = Math.min( minX, point.x );       maxX = Math.max( maxX, point.x );       minZ = Math.min( minZ, point.z );       maxZ = Math.max( maxZ, point.z );       }       const width = maxX - minX;      const height = maxZ - minZ;       const geometry = new BoxGeometry( width, 0.01, height );      const material = new MeshBasicMaterial( { color: 0xffffff * Math.random() } );       const mesh = new Mesh( geometry, material );      mesh.position.setFromMatrixPosition( matrix );      mesh.quaternion.setFromRotationMatrix( matrix );      this.add( mesh );       currentPlanes.set( plane, mesh );       planeschanged = true;      }     }     if ( planeschanged ) {      this.dispatchEvent( { type: 'planeschanged' } );     }    } );   }  }  export { XRPlanes }; 
`; 
